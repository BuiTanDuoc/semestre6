T-SQL
Flow Control:
-------------
BEGIN...END
	BEGIN
		{sql_statement | statement_block}
	END

BREAK
	Stop a WHILE loop.

CONTINUE
	Restart a WHILE loop.

GOTO label
	Alter the  flow of execution to a label.
	Note: 
	definig the label:
	label :

IF...ELSE
	IF boolean expression
		{sql_statement | statement_block}
	[
	ELSE
		{sql_statement | statement_block}
	]

RETURN 
	Exits uncondicionally from a query or procedure
	RETURN [ integer expression ]

TRY...CATCH
	BEGIN TRY 
		{sql_statement | statement_block}
	END TRY
	BEGIN CATCH
		{sql_statement | statement_block}
	END CATCH
	;

WAITFOR
	Block the execution of a batch, stored procedure or transaction  until:
		- specified time or a time interval is reached
		- specified statement modifies or returns at least one row
	WAITFOR 
	{
		DELAY 'time_to_pass' 
		| TIME 'time_to_execute' 
		| [ ( receive_statement ) | ( get_conversation_group_statement ) ] 
		[ , TIMEOUT timeout ]
	}

WHILE
	WHILE Boolean_expression 
     { sql_statement | statement_block | BREAK | CONTINUE }

	 
BATCHES
-------------
The following rules apply to using batches:
    CREATE DEFAULT, CREATE FUNCTION, CREATE PROCEDURE, CREATE RULE, CREATE SCHEMA, CREATE TRIGGER, and CREATE VIEW statements cannot be combined with other statements in a batch. The CREATE statement must start the batch. All other statements that follow in that batch will be interpreted as part of the definition of the first CREATE statement.
    A table cannot be changed and then the new columns referenced in the same batch.
    If an EXECUTE statement is the first statement in a batch, the EXECUTE keyword is not required. The EXECUTE keyword is required if the EXECUTE statement is not the first statement in the batch.
-----------

Reference

/*...*/ (Comment) (Transact-SQL)
-- (Comment) (Transact-SQL)
CASE (Transact-SQL)
	Evaluates a list of conditions and returns one of multiple possible result expressions.
	The CASE expression has two formats:
		The simple CASE expression compares an expression to a set of simple expressions to determine the result.
		The searched CASE expression evaluates a set of Boolean expressions to determine the result.
	Both formats support an optional ELSE argument.
	Simple CASE expression: 
	CASE input_expression 
		 WHEN when_expression THEN result_expression [ ...n ] 
		 [ ELSE else_result_expression ] 
	END 
	Searched CASE expression:
	CASE
		 WHEN Boolean_expression THEN result_expression [ ...n ] 
		 [ ELSE else_result_expression ] 
	END

DECLARE @local_variable (Transact-SQL)
	Variables are declared in the body of a batch or procedure with the DECLARE statement and are assigned values by using either a SET or SELECT statement. Cursor variables can be declared with this statement and used with other cursor-related statements. After declaration, all variables are initialized as NULL, unless a value is provided as part of the declaration.
	DECLARE 
     { 
	{{ @local_variable [AS] data_type } | [ = value ] }
		| { @cursor_variable_name CURSOR }
	} [,...n] 
		| { @table_variable_name [AS] <table_type_definition> | <user-defined table type> } 

	<table_type_definition> ::= 
		 TABLE ( { <column_definition> | <table_constraint> } [ ,... ] 
	   ) 

	<column_definition> ::= 
		 column_name { scalar_data_type | AS computed_column_expression }
		 [ COLLATE collation_name ] 
		 [ [ DEFAULT constant_expression ] | IDENTITY [ (seed ,increment ) ] ] 
		 [ ROWGUIDCOL ] 
		 [ <column_constraint> ] 

	<column_constraint> ::= 
		 { [ NULL | NOT NULL ] 
		 | [ PRIMARY KEY | UNIQUE ] 
		 | CHECK ( logical_expression ) 
		 } 

	<table_constraint> ::= 
		 { { PRIMARY KEY | UNIQUE } ( column_name [ ,... ] ) 
		 | CHECK ( search_condition ) 
		 } 

EXECUTE (Transact-SQL)
	Executes a command string or character string within a Transact-SQL batch, or one of the following modules: system stored procedure, user-defined stored procedure, scalar-valued user-defined function, or extended stored procedure.
	Execute a stored procedure or function
	[ { EXEC | EXECUTE } ]
		{ 
		  [ @return_status = ]
		  { module_name [ ;number ] | @module_name_var } 
			[ [ @parameter = ] { value 
							   | @variable [ OUTPUT ] 
							   | [ DEFAULT ] 
							   }
			]
		  [ ,...n ]
		  [ WITH RECOMPILE ]
		}
	[;]

	Execute a character string
	{ EXEC | EXECUTE } 
		( { @string_variable | [ N ]'tsql_string' } [ + ...n ] )
		[ AS { LOGIN | USER } = ' name ' ]
	[;]

	Execute a pass-through command against a linked server
	{ EXEC | EXECUTE }
		( { @string_variable | [ N ] 'command_string [ ? ]' } [ + ...n ]
			[ { , { value | @variable [ OUTPUT ] } } [ ...n ] ]
		) 
		[ AS { LOGIN | USER } = ' name ' ]
		[ AT linked_server_name ]
	[;]

PRINT (Transact-SQL)
	PRINT msg_str | @local_variable | string_expr
	
RAISERROR (Transact-SQL)
	RAISERROR ( { msg_id | msg_str | @local_variable }
    { ,severity ,state }
    [ ,argument [ ,...n ] ] )
    [ WITH option [ ,...n ] ]
	
	
AVANÇANDO
----------
CURSORES:
ISO Syntax
DECLARE cursor_name [ INSENSITIVE ] [ SCROLL ] CURSOR 
     FOR select_statement 
     [ FOR { READ ONLY | UPDATE [ OF column_name [ ,...n ] ] } ]
;
Transact-SQL Extended Syntax
DECLARE cursor_name CURSOR [ LOCAL | GLOBAL ] 
     [ FORWARD_ONLY | SCROLL ] 
     [ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ] 
     [ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ] 
     [ TYPE_WARNING ] 
     FOR select_statement 
     [ FOR UPDATE [ OF column_name [ ,...n ] ] ]
;


STORED PROCEDURES
CREATE PROCEDURE (Transact-SQL)
Creates a Transact-SQL or common language runtime (CLR) stored procedure in SQL Server 2008 R2. Stored procedures are similar to procedures in other programming languages in that they can:
- Accept input parameters and return multiple values in the form of output parameters to the calling procedure or batch.
- Contain programming statements that perform operations in the database, including calling other procedures.
- Return a status value to a calling procedure or batch to indicate success or failure (and the reason for failure).
Use this statement to create a permanent procedure in the current database or a temporary procedure in the tempdb database.

--Transact-SQL Stored Procedure Syntax
CREATE { PROC | PROCEDURE } [schema_name.] procedure_name [ ; number ] 
    [ { @parameter [ type_schema_name. ] data_type } 
        [ VARYING ] [ = default ] [ OUT | OUTPUT ] [READONLY]
    ] [ ,...n ] 
[ WITH <procedure_option> [ ,...n ] ]
[ FOR REPLICATION ] 
AS { [ BEGIN ] sql_statement [;] [ ...n ] [ END ] }
;

<procedure_option> ::= 
    [ ENCRYPTION ]
    [ RECOMPILE ]
    [ EXECUTE AS Clause ]
	
--CLR Stored Procedure Syntax
CREATE { PROC | PROCEDURE } [schema_name.] procedure_name [ ; number ] 
    [ { @parameter [ type_schema_name. ] data_type } 
        [ = default ] [ OUT | OUTPUT ] [READONLY]
    ] [ ,...n ] 
[ WITH EXECUTE AS Clause ]
AS { EXTERNAL NAME assembly_name.class_name.method_name }
;

CREATE FUNCTION (Transact-SQL)
Creates a user-defined function. This is a saved Transact-SQL or common language runtime (CLR) routine that returns a value. User-defined functions cannot be used to perform actions that modify the database state. User-defined functions, like system functions, can be invoked from a query. Scalar functions can be executed by using an EXECUTE statement like stored procedures.
User-defined functions are modified by using ALTER FUNCTION and dropped by using DROP FUNCTION.
Scalar Functions
CREATE FUNCTION [ schema_name. ] function_name 
( [ { @parameter_name [ AS ][ type_schema_name. ] parameter_data_type 
    [ = default ] } 
    [ ,...n ]
  ]
)
RETURNS return_data_type
    [ WITH <function_option> [ ,...n ] ]
    [ AS ]
    BEGIN 
                function_body 
        RETURN scalar_expression
    END
[ ; ]

Inline Table-valued Functions
CREATE FUNCTION [ schema_name. ] function_name 
( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type 
    [ = default ] } 
    [ ,...n ]
  ]
)
RETURNS TABLE
    [ WITH <function_option> [ ,...n ] ]
    [ AS ]
    RETURN [ ( ] select_stmt [ ) ]
[ ; ]

Multistatement Table-valued Functions
CREATE FUNCTION [ schema_name. ] function_name 
( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type 
    [ = default ] } 
    [ ,...n ]
  ]
)
RETURNS @return_variable TABLE < table_type_definition >
    [ WITH <function_option> [ ,...n ] ]
    [ AS ]
    BEGIN 
                function_body 
        RETURN
    END
[ ; ]

CLR Functions
CREATE FUNCTION [ schema_name. ] function_name 
( { @parameter_name [AS] [ type_schema_name. ] parameter_data_type 
        [ = default ] } 
    [ ,...n ]
)
RETURNS { return_data_type | TABLE <clr_table_type_definition> }
    [ WITH <clr_function_option> [ ,...n ] ]
    [ AS ] EXTERNAL NAME <method_specifier>
[ ; ]

Method Specifier
<method_specifier>::=
    assembly_name.class_name.method_name

Function Options
<function_option>::= 
{
    [ ENCRYPTION ]
  | [ SCHEMABINDING ]
  | [ RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT ]
  | [ EXECUTE_AS_Clause ]
}

<clr_function_option>::=
}
    [ RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT ]
  | [ EXECUTE_AS_Clause ]
}

Table Type Definitions
<table_type_definition>:: = 
( { <column_definition> <column_constraint> 
  | <computed_column_definition> } 
        [ <table_constraint> ] [ ,...n ]
) 

<clr_table_type_definition>::= 
( { column_name data_type } [ ,...n ] )

<column_definition>::=
{
    { column_name data_type }
    [ [ DEFAULT constant_expression ] 
      [ COLLATE collation_name ] | [ ROWGUIDCOL ]
    ]
    | [ IDENTITY [ (seed , increment ) ] ]
    [ <column_constraint> [ ...n ] ] 
}
<column_constraint>::= 
{
    [ NULL | NOT NULL ] 
    { PRIMARY KEY | UNIQUE }
      [ CLUSTERED | NONCLUSTERED ] 
        [ WITH FILLFACTOR = fillfactor 
        | WITH ( < index_option > [ , ...n ] )
      [ ON { filegroup | "default" } ]
  | [ CHECK ( logical_expression ) ] [ ,...n ]
}

<computed_column_definition>::=
column_name AS computed_column_expression 

<table_constraint>::=
{ 
    { PRIMARY KEY | UNIQUE }
      [ CLUSTERED | NONCLUSTERED ] 
            ( column_name [ ASC | DESC ] [ ,...n ] )
        [ WITH FILLFACTOR = fillfactor 
        | WITH ( <index_option> [ , ...n ] )
  | [ CHECK ( logical_expression ) ] [ ,...n ]
}

<index_option>::=
{ 
    PAD_INDEX = { ON | OFF } 
  | FILLFACTOR = fillfactor 
  | IGNORE_DUP_KEY = { ON | OFF }
  | STATISTICS_NORECOMPUTE = { ON | OFF } 
  | ALLOW_ROW_LOCKS = { ON | OFF }
  | ALLOW_PAGE_LOCKS ={ ON | OFF } 
}

CREATE TRIGGER (Transact-SQL)
Creates a DML, DDL, or logon trigger. A trigger is a special kind of stored procedure that automatically executes when an event occurs in the database server. DML triggers execute when a user tries to modify data through a data manipulation language (DML) event. DML events are INSERT, UPDATE, or DELETE statements on a table or view. 
DDL triggers execute in response to a variety of data definition language (DDL) events. These events primarily correspond to Transact-SQL CREATE, ALTER, and DROP statements, and certain system stored procedures that perform DDL-like operations. Logon triggers fire in response to the LOGON event that is raised when a user sessions is being established. Triggers can be created in the SQL Server 2005 Database Engine directly from Transact-SQL statements or from methods of assemblies that are created in the Microsoft .NET Framework common language runtime (CLR) and uploaded to an instance of SQL Server. SQL Server allows for creating multiple triggers for any specific statement. 
Trigger on an INSERT, UPDATE, or DELETE statement to a table or view (DML Trigger)
CREATE TRIGGER [ schema_name . ]trigger_name 
ON { table | view } 
[ WITH <dml_trigger_option> [ ,...n ] ]
{ FOR | AFTER | INSTEAD OF } 
{ [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] } 
[ WITH APPEND ] 
[ NOT FOR REPLICATION ] 
AS { sql_statement  [ ; ] [ ,...n ] | EXTERNAL NAME <method specifier [ ; ] > }

<dml_trigger_option> ::=
    [ ENCRYPTION ]
    [ EXECUTE AS Clause ]

<method_specifier> ::=
    assembly_name.class_name.method_name

Trigger on a CREATE, ALTER, DROP, GRANT, DENY, REVOKE, or UPDATE STATISTICS statement (DDL Trigger)
CREATE TRIGGER trigger_name 
ON { ALL SERVER | DATABASE } 
[ WITH <ddl_trigger_option> [ ,...n ] ]
{ FOR | AFTER } { event_type | event_group } [ ,...n ]
AS { sql_statement  [ ; ] [ ,...n ] | EXTERNAL NAME < method specifier >  [ ; ] }

<ddl_trigger_option> ::=
    [ ENCRYPTION ]
    [ EXECUTE AS Clause ]

<method_specifier> ::=
    assembly_name.class_name.method_name

Trigger on a LOGON event (Logon Trigger)
CREATE TRIGGER trigger_name 
ON ALL SERVER 
[ WITH <logon_trigger_option> [ ,...n ] ]
{ FOR | AFTER } LOGON  
AS { sql_statement  [ ; ] [ ,...n ] | EXTERNAL NAME <method specifier>  [ ; ] }
<logon_trigger_option> ::=
    [ ENCRYPTION ]
    [ EXECUTE AS Clause ]

<method_specifier> ::=
    assembly_name.class_name.method_name
