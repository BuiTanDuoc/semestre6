2.

using System;
public struct Ponto {
public int x, y;
public static void Main() {
Ponto p;
p.x = p.y = 1;
Object o = p;			//Boxing explicito
p = (Point) o;			//unboxing
p.x = 2;
o=p;					//boxing implicito
}
}

3.

using System;
public struct A { public int x; }
public struct C :A { public int y; }
public class B { public int w; }
public class D : B { public int z;}
public class Program{
	public static void Main(){
		A a;
		Object o1 = a;		//boxing
		Object o2 = a;		//boxing
		B b= new D();		
		D d= new B();		
		o1.x = 2;
		( (A) o2 ). x = 4;
		A k = o2;
		((D) b).z=3;
		Console.WriteLine(a);
		Console.WriteLine(k);
		Console.WriteLine(o1);
		Console.WriteLine(o2);
		Console.WriteLine(b);
		Console.WriteLine(d);
	}
}

a) ver ficheiro questao3.cs
b) indicado no ficheiro questao3.cs

4.

a) é necessário fazer override ao método GetHashCode sempre que se faz o mesmo ao método Equals
b) a correcta será a última uma vez que é a única que tem em consideração a possibilidade de estarmos a comparar objectos de classes que se extendem.

5.

a) não se pode usar o operador == para comparar structs
b) a primeira comparação dá true uma vez que são objectos do mesmo tipo e iguais
no caso da 2ª comparação dá false uma vez que as referências para os objectos são diferentes. structs são tipos valor e as referências para estes são diferentes uma vez que estõa em posiçãos diferentes do stack

6.
o método F de B esconde o metodo F de A mas no caso de G como é virtual e B tem override este é redefinido. 
Chamando F com A ou B chama métodos diferentes mas no caso de G, devido à redefinição, chama sempre B.G
