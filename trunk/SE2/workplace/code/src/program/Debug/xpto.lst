
xpto.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .debug_aranges 000016f0  00000000  00000000  00020890  2**3
                  CONTENTS, READONLY, DEBUGGING
  1 .debug_pubnames 000038a3  00000000  00000000  00021f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_info   0005900d  00000000  00000000  00025823  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_abbrev 0000d0d4  00000000  00000000  0007e830  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_line   00012160  00000000  00000000  0008b904  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_frame  00003224  00000000  00000000  0009da64  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_str    00009395  00000000  00000000  000a0c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00010a40  00000000  00000000  000aa01d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_macinfo 000043d7  00000000  00000000  000baa5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .rom_vectors  00000040  00000000  00000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text         000128fc  00000040  00000040  00008040  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .rodata       0000095c  0001293c  0001293c  0001a93c  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .fixed_vectors 00000140  40000400  40000400  000bee40  2**5
                  CONTENTS, READONLY
 13 .data         0000034c  40000540  00013298  00020540  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          000043c8  4000088c  000135e4  0002088c  2**4
                  ALLOC
 15 .ARM.attributes 0000002c  00000000  00000000  000bef80  2**0
                  CONTENTS, READONLY
 16 .debug_ranges 00004d50  00000000  00000000  000befb0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000d2f  00000000  00000000  000c3d00  2**0
                  CONTENTS, READONLY

Disassembly of section .rom_vectors:

00000000 <__exception_handlers>:
        .global __exception_handlers
__exception_handlers:
#ifdef CYGSEM_HAL_ROM_RESET_USES_JUMP
// Assumption:  ROM code has these vectors at the hardware reset address.
// A simple jump removes any address-space dependencies [i.e. safer]
        b       reset_vector                    // 0x00
   0:	ea00000e 	b	40 <__exidx_end>
#else        
        ldr     pc,.reset_vector                // 0x00
#endif        
        ldr     pc,.undefined_instruction       // 0x04
   4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <HAL_ARM_UNDEFINED_VECTOR_ADDR>
        ldr     pc,.software_interrupt          // 0x08 start && software int
   8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <HAL_ARM_SWI_VECTOR_ADDR>
        ldr     pc,.abort_prefetch              // 0x0C
   c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <HAL_ARM_PREFETCH_VECTOR_ADDR>
        ldr     pc,.abort_data                  // 0x10
  10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <HAL_ARM_ABORT_VECTOR_ADDR>
  14:	b4405f62 	.word	0xb4405f62
#ifdef CYGNUM_HAL_ARM_VECTOR_0x14
        .word   CYGNUM_HAL_ARM_VECTOR_0x14
#else
        .word   0                               // unused
#endif
        ldr     pc,.IRQ                         // 0x18
  18:	e59ff018 	ldr	pc, [pc, #24]	; 38 <HAL_ARM_IRQ_VECTOR_ADDR>
        ldr     pc,.FIQ                         // 0x1C
  1c:	e59ff018 	ldr	pc, [pc, #24]	; 3c <HAL_ARM_FIQ_VECTOR_ADDR>

00000020 <vectors>:
  20:	00000040 	.word	0x00000040

00000024 <.undefined_instruction>:
  24:	00000264 	.word	0x00000264

00000028 <.software_interrupt>:
  28:	0288      	.short	0x0288
	...

0000002c <.abort_prefetch>:
  2c:	000002b4 	.word	0x000002b4

00000030 <.abort_data>:
  30:	000002d0 	.word	0x000002d0
  34:	00000000 	.word	0x00000000

00000038 <.IRQ>:
  38:	000003d0 	.word	0x000003d0

0000003c <.FIQ>:
  3c:	00000398 	.word	0x00000398

Disassembly of section .text:

00000040 <reset_vector>:
        .text   
// Startup code which will get the machine into supervisor mode
        .global reset_vector
        .type   reset_vector,function
reset_vector:
        PLATFORM_SETUP1         // Early stage platform initialization
      40:	e59f0568 	ldr	r0, [pc, #1384]	; 5b0 <_eCos_id+0x14>
      44:	e3a020aa 	mov	r2, #170	; 0xaa
      48:	e3a03055 	mov	r3, #85	; 0x55
      4c:	e3a01001 	mov	r1, #1	; 0x1
      50:	e5801080 	str	r1, [r0, #128]
      54:	e3a01023 	mov	r1, #35	; 0x23
      58:	e5801084 	str	r1, [r0, #132]
      5c:	e580208c 	str	r2, [r0, #140]
      60:	e580308c 	str	r3, [r0, #140]
      64:	e5901088 	ldr	r1, [r0, #136]
      68:	e2111b01 	ands	r1, r1, #1024	; 0x400
      6c:	0afffffc 	beq	64 <ARMREG_SIZE+0x14>
      70:	e3a01003 	mov	r1, #3	; 0x3
      74:	e5801080 	str	r1, [r0, #128]
      78:	e580208c 	str	r2, [r0, #140]
      7c:	e580308c 	str	r3, [r0, #140]
      80:	e3a00000 	mov	r0, #0	; 0x0
      84:	e3a01101 	mov	r1, #1073741824	; 0x40000000
      88:	e3a02040 	mov	r2, #64	; 0x40
      8c:	e5b03004 	ldr	r3, [r0, #4]!
      90:	e5a13004 	str	r3, [r1, #4]!
      94:	e1500002 	cmp	r0, r2
      98:	1afffffb 	bne	8c <CPSR_IRQ_DISABLE+0xc>
      9c:	e59f050c 	ldr	r0, [pc, #1292]	; 5b0 <_eCos_id+0x14>
      a0:	e3a01002 	mov	r1, #2	; 0x2
      a4:	e5801040 	str	r1, [r0, #64]
      a8:	e3a01004 	mov	r1, #4	; 0x4
      ac:	e5801004 	str	r1, [r0, #4]
      b0:	e3a01002 	mov	r1, #2	; 0x2
      b4:	e5801000 	str	r1, [r0]
      b8:	e59f04f4 	ldr	r0, [pc, #1268]	; 5b4 <_eCos_id+0x18>
      bc:	e3a01116 	mov	r1, #-2147483643	; 0x80000005
      c0:	e5801000 	str	r1, [r0]
      c4:	e59f04ec 	ldr	r0, [pc, #1260]	; 5b8 <_eCos_id+0x1c>
      c8:	e3a01080 	mov	r1, #128	; 0x80
      cc:	e5801008 	str	r1, [r0, #8]

000000d0 <warm_reset>:
        cmp     r7,#CPSR_SUPERVISOR_MODE
        beq     start
#endif

        // We cannot access any LED registers until after PLATFORM_SETUP1
        LED 7
      d0:	04e0      	.short	0x04e0
      d2:	9f          	.byte	0x9f
      d3:	e5          	.byte	0xe5
      d4:	e3a01080 	.word	0xe3a01080
      d8:	e580100c 	.word	0xe580100c
      dc:	e3a01080 	.word	0xe3a01080
      e0:	e5801004 	.word	0xe5801004

        mov     r0,#0           // move vectors
      e4:	e3a00000 	.word	0xe3a00000
        ldr     r1,=__exception_handlers
      e8:	e59f14cc 	.word	0xe59f14cc
#ifndef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
        // Wait with this if stubs are included (see further down).
        ldr     r2,[r1,#0x04]   // undefined instruction
      ec:	e5912004 	.word	0xe5912004
        str     r2,[r0,#0x04]
      f0:	e5802004 	.word	0xe5802004
        ldr     r2,[r1,#0x24]   
      f4:	e5912024 	.word	0xe5912024
        str     r2,[r0,#0x24]
      f8:	e5802024 	.word	0xe5802024
#endif
        ldr     r2,[r1,#0x08]   // software interrupt
      fc:	e5912008 	.word	0xe5912008
        str     r2,[r0,#0x08]
     100:	e5802008 	.word	0xe5802008

00000104 <start>:
// Real startup code. We jump here from the reset vector to set up the world.
        .globl  start
        .type   start,function
start:  

        LED 5
     104:	e59f04ac 	ldr	r0, [pc, #1196]	; 5b8 <_eCos_id+0x1c>
     108:	e3a01080 	mov	r1, #128	; 0x80
     10c:	e580100c 	str	r1, [r0, #12]
     110:	e3a01080 	mov	r1, #128	; 0x80
     114:	e5801004 	str	r1, [r0, #4]
        ldr     r1,init_done
        str     r1,[r0]
#endif

        // Reset software interrupt pointer
        ldr     r0,=CYGHWR_HAL_VECTOR_TABLE_BASE           // move vectors
     118:	e3a00000 	mov	r0, #0	; 0x0
        ldr     r1,.__exception_handlers
     11c:	e59f1464 	ldr	r1, [pc, #1124]	; 588 <.__exception_handlers>
#if defined(CYG_HAL_STARTUP_RAM) && \
    !defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
        cmp     r7,#CPSR_SUPERVISOR_MODE
        beq     10f
#endif
        ldr     r2,[r1,#HAL_ARM_SWI_VECTOR_ADDR]   // software interrupt
     120:	e5912028 	ldr	r2, [r1, #40]
        str     r2,[r0,#HAL_ARM_SWI_VECTOR_ADDR]
     124:	e5802028 	str	r2, [r0, #40]
10:
        ldr     r2,[r1,#HAL_ARM_IRQ_VECTOR]   // IRQ
     128:	e5912018 	ldr	r2, [r1, #24]
        str     r2,[r0,#HAL_ARM_IRQ_VECTOR]
     12c:	e5802018 	str	r2, [r0, #24]
        ldr     r2,[r1,#HAL_ARM_IRQ_VECTOR_ADDR]
     130:	e5912038 	ldr	r2, [r1, #56]
        str     r2,[r0,#HAL_ARM_IRQ_VECTOR_ADDR]
     134:	e5802038 	str	r2, [r0, #56]
        ldr     r2,[r1,#HAL_ARM_FIQ_VECTOR]   // FIQ
     138:	e591201c 	ldr	r2, [r1, #28]
        str     r2,[r0,#HAL_ARM_FIQ_VECTOR]
     13c:	e580201c 	str	r2, [r0, #28]
        ldr     r2,[r1,#HAL_ARM_FIQ_VECTOR_ADDR]
     140:	e591203c 	ldr	r2, [r1, #60]
        str     r2,[r0,#HAL_ARM_FIQ_VECTOR_ADDR]
     144:	e580203c 	str	r2, [r0, #60]
        ldr     r2,[r1,#HAL_ARM_PREFETCH_VECTOR]   // abort (prefetch)
     148:	e591200c 	ldr	r2, [r1, #12]
        str     r2,[r0,#HAL_ARM_PREFETCH_VECTOR]
     14c:	e580200c 	str	r2, [r0, #12]
        ldr     r2,[r1,#HAL_ARM_PREFETCH_VECTOR_ADDR]   
     150:	e591202c 	ldr	r2, [r1, #44]
        str     r2,[r0,#HAL_ARM_PREFETCH_VECTOR_ADDR]
     154:	e580202c 	str	r2, [r0, #44]
        ldr     r2,[r1,#HAL_ARM_ABORT_VECTOR]   // abort (data)
     158:	e5912010 	ldr	r2, [r1, #16]
        str     r2,[r0,#HAL_ARM_ABORT_VECTOR]
     15c:	e5802010 	str	r2, [r0, #16]
        ldr     r2,[r1,#HAL_ARM_ABORT_VECTOR_ADDR]
     160:	e5912030 	ldr	r2, [r1, #48]
        str     r2,[r0,#HAL_ARM_ABORT_VECTOR_ADDR]
     164:	e5802030 	str	r2, [r0, #48]

        LED 4
     168:	e59f0448 	ldr	r0, [pc, #1096]	; 5b8 <_eCos_id+0x1c>
     16c:	e3a01080 	mov	r1, #128	; 0x80
     170:	e580100c 	str	r1, [r0, #12]
     174:	e3a01000 	mov	r1, #0	; 0x0
     178:	e5801004 	str	r1, [r0, #4]

#if defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
        // Set up reset vector
        ldr     r0,=CYGHWR_HAL_VECTOR_TABLE_BASE
     17c:	e3a00000 	mov	r0, #0	; 0x0
        ldr     r1,.__exception_handlers
     180:	e59f1400 	ldr	r1, [pc, #1024]	; 588 <.__exception_handlers>
# ifndef CYGSEM_HAL_KEEP_RESET_VECTOR
        ldr     r2,[r1,#HAL_ARM_RESET_VECTOR]    // reset vector instruction
     184:	e5912000 	ldr	r2, [r1]
        str     r2,[r0,#HAL_ARM_RESET_VECTOR]
     188:	e5802000 	str	r2, [r0]
        ldr     r2,=warm_reset
        str     r2,[r0,#HAL_ARM_RESET_VECTOR_ADDR]
#  endif
# endif
        // Relocate [copy] data from ROM to RAM
        ldr     r3,.__rom_data_start
     18c:	e59f33dc 	ldr	r3, [pc, #988]	; 570 <.__rom_data_start>
        ldr     r4,.__ram_data_start
     190:	e59f43dc 	ldr	r4, [pc, #988]	; 574 <.__ram_data_start>
        ldr     r5,.__ram_data_end
     194:	e59f53dc 	ldr	r5, [pc, #988]	; 578 <.__ram_data_end>
        cmp     r4,r5           // jump if no data to move
     198:	e1540005 	cmp	r4, r5
        beq     2f
     19c:	0a000005 	beq	1b8 <start+0xb4>
        sub     r3,r3,#4        // loop adjustments
     1a0:	e2433004 	sub	r3, r3, #4	; 0x4
        sub     r4,r4,#4
     1a4:	e2444004 	sub	r4, r4, #4	; 0x4
1:      ldr     r0,[r3,#4]!     // copy info
     1a8:	e5b30004 	ldr	r0, [r3, #4]!
        str     r0,[r4,#4]!
     1ac:	e5a40004 	str	r0, [r4, #4]!
        cmp     r4,r5
     1b0:	e1540005 	cmp	r4, r5
        bne     1b
     1b4:	1afffffb 	bne	1a8 <start+0xa4>
2:
#endif

        // initialize interrupt/exception environments
        ldr     sp,.__startup_stack
     1b8:	e59fd398 	ldr	sp, [pc, #920]	; 558 <.__startup_stack>
        mov     r0,#(CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE|CPSR_IRQ_MODE)
     1bc:	e3a000d2 	mov	r0, #210	; 0xd2
        msr     cpsr,r0
     1c0:	e129f000 	msr	CPSR_fc, r0
        ldr     sp,.__exception_stack
     1c4:	e59fd390 	ldr	sp, [pc, #912]	; 55c <.__exception_stack>
        mov     r0,#(CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE|CPSR_UNDEF_MODE)
     1c8:	e3a000db 	mov	r0, #219	; 0xdb
        msr     cpsr,r0
     1cc:	e129f000 	msr	CPSR_fc, r0
        ldr     sp,.__exception_stack
     1d0:	e59fd384 	ldr	sp, [pc, #900]	; 55c <.__exception_stack>

        // initialize CPSR (machine state register)
        mov     r0,#(CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE|CPSR_SUPERVISOR_MODE)
     1d4:	e3a000d3 	mov	r0, #211	; 0xd3
        msr     cpsr,r0
     1d8:	e129f000 	msr	CPSR_fc, r0

        // Note: some functions in LIBGCC1 will cause a "restore from SPSR"!!
        msr     spsr,r0
     1dc:	e169f000 	msr	SPSR_fc, r0

        // initialize stack
#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
        // use interrupt stack for system initialization since it's bigger 
        // than the "startup" stack in this configuration                                
        ldr     sp,.__interrupt_stack
     1e0:	e59fd3b0 	ldr	sp, [pc, #944]	; 598 <.__interrupt_stack>
#else        
        ldr     sp,.__startup_stack
#endif        

        // clear BSS
        ldr     r1,.__bss_start
     1e4:	e59f1378 	ldr	r1, [pc, #888]	; 564 <.__bss_start>
        ldr     r2,.__bss_end
     1e8:	e59f2378 	ldr	r2, [pc, #888]	; 568 <.__bss_end>
        mov     r0,#0
     1ec:	e3a00000 	mov	r0, #0	; 0x0
        cmp     r1,r2
     1f0:	e1510002 	cmp	r1, r2
        beq     2f
     1f4:	0a000002 	beq	204 <start+0x100>
1:      str     r0,[r1],#4
     1f8:	e4810004 	str	r0, [r1], #4
        cmp     r2,r1
     1fc:	e1520001 	cmp	r2, r1
        bhi     1b
     200:	8afffffc 	bhi	1f8 <start+0xf4>
2:

        // Run kernel + application in THUMB mode
        THUMB_MODE(r1,10)

        LED 3
     204:	e59f03ac 	ldr	r0, [pc, #940]	; 5b8 <_eCos_id+0x1c>
     208:	e3a01080 	mov	r1, #128	; 0x80
     20c:	e580100c 	str	r1, [r0, #12]
     210:	e3a01080 	mov	r1, #128	; 0x80
     214:	e5801004 	str	r1, [r0, #4]
        
        // Call platform specific hardware initialization
        bl      hal_hardware_init
     218:	eb0036bd 	bl	dd14 <hal_hardware_init>
    || defined(CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT)
        .extern hal_ctrlc_isr_init
        bl      hal_ctrlc_isr_init
#endif

        LED 2
     21c:	e59f0394 	ldr	r0, [pc, #916]	; 5b8 <_eCos_id+0x1c>
     220:	e3a01080 	mov	r1, #128	; 0x80
     224:	e580100c 	str	r1, [r0, #12]
     228:	e3a01000 	mov	r1, #0	; 0x0
     22c:	e5801004 	str	r1, [r0, #4]
        
        // Run through static constructors
        bl      cyg_hal_invoke_constructors
     230:	eb0035d5 	bl	d98c <cyg_hal_invoke_constructors>

        LED 1
     234:	e59f037c 	ldr	r0, [pc, #892]	; 5b8 <_eCos_id+0x1c>
     238:	e3a01080 	mov	r1, #128	; 0x80
     23c:	e580100c 	str	r1, [r0, #12]
     240:	e3a01080 	mov	r1, #128	; 0x80
     244:	e5801004 	str	r1, [r0, #4]
        
        // This starts up the eCos kernel
#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
        ldr     r1,=__startup_stack
     248:	e59f1370 	ldr	r1, [pc, #880]	; 5c0 <_eCos_id+0x24>
        mov     sp,r1
     24c:	e1a0d001 	mov	sp, r1
#endif        
        bl      cyg_start
     250:	eb000702 	bl	1e60 <cyg_start>

00000254 <_start_hang>:
_start_hang:
        b       _start_hang
     254:	eafffffe 	.word	0xeafffffe

00000258 <reset_platform>:
        // initialize CPSR (machine state register)
        mov     r0,#(CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE|CPSR_SUPERVISOR_MODE)
        msr     cpsr,r0
        b       warm_reset
#else
        mov     r0,#0
     258:	e3a00000 	mov	r0, #0	; 0x0
        mov     pc,r0           // Jump to reset vector        
     25c:	e1a0f000 	mov	pc, r0

00000260 <init_done>:
     260:	deadb00b 	.word	0xdeadb00b

00000264 <undefined_instruction>:
//             except in case of standalone app. running in user mode
//             (CYGOPT_HAL_ARM_WITH_USER_MODE should have been defined)
//
        .code   32
undefined_instruction:
        ldr     sp,.__undef_exception_stack     // get good stack
     264:	e59fd2f4 	ldr	sp, [pc, #756]	; 560 <.__undef_exception_stack>
        stmfd   sp!,{r0-r5}                     // save some supervisor regs
     268:	e92d003f 	push	{r0, r1, r2, r3, r4, r5}
        mrs     r1,spsr
     26c:	e14f1000 	mrs	r1, SPSR
        tst     r1,#CPSR_THUMB_ENABLE
     270:	e3110020 	tst	r1, #32	; 0x20
        subeq   r0,lr,#4                // PC at time of interrupt (ARM)
     274:	024e0004 	subeq	r0, lr, #4	; 0x4
        subne   r0,lr,#2                // PC at time of interrupt (thumb)
     278:	124e0002 	subne	r0, lr, #2	; 0x2
        mov     r2,#CYGNUM_HAL_EXCEPTION_ILLEGAL_INSTRUCTION
     27c:	e3a02001 	mov	r2, #1	; 0x1
        mov     r3,sp
     280:	e1a0300d 	mov	r3, sp
        b       call_exception_handler
     284:	ea000018 	b	2ec <call_exception_handler>

00000288 <software_interrupt>:

        .code   32
software_interrupt:
        stmfd   sp!,{r8}
     288:	e92d0100 	.word	0xe92d0100
        ldr     r8,.__undef_exception_stack     // get good stack
     28c:	e59f82cc 	.word	0xe59f82cc
        stmfd   r8!,{r0-r5}                     // save some supervisor regs
     290:	e928003f 	.word	0xe928003f
        mov     r3,r8
     294:	e1a03008 	.word	0xe1a03008
        ldmfd   sp!,{r8}
     298:	e8bd0100 	.word	0xe8bd0100
        mrs     r1,spsr
     29c:	e14f1000 	.word	0xe14f1000
        tst     r1,#CPSR_THUMB_ENABLE
     2a0:	e3110020 	.word	0xe3110020
        subeq   r0,lr,#4                // PC at time of SWI (ARM)
     2a4:	024e0004 	.word	0x024e0004
        subne   r0,lr,#2                // PC at time of SWI (thumb)
     2a8:	124e0002 	.word	0x124e0002
        mov     r2,#CYGNUM_HAL_EXCEPTION_INTERRUPT
     2ac:	e3a02002 	.word	0xe3a02002
        b       call_exception_handler
     2b0:	ea00000d 	.word	0xea00000d

000002b4 <abort_prefetch>:

        .code   32
abort_prefetch:
        ldr     sp,.__undef_exception_stack     // get good stack
     2b4:	e59fd2a4 	.word	0xe59fd2a4
        stmfd   sp!,{r0-r5}                     // save some supervisor regs
     2b8:	e92d003f 	.word	0xe92d003f
        sub     r0,lr,#4                        // PC at time of interrupt
     2bc:	e24e0004 	.word	0xe24e0004
        mrs     r1,spsr
     2c0:	e14f1000 	.word	0xe14f1000
        mov     r2,#CYGNUM_HAL_EXCEPTION_CODE_ACCESS
     2c4:	e3a02003 	.word	0xe3a02003
        mov     r3,sp
     2c8:	e1a0300d 	.word	0xe1a0300d
        b       call_exception_handler
     2cc:	ea000006 	.word	0xea000006

000002d0 <abort_data>:

        .code   32
abort_data:
        ldr     sp,.__undef_exception_stack     // get good stack
     2d0:	e59fd288 	.word	0xe59fd288
        stmfd   sp!,{r0-r5}                     // save some supervisor regs
     2d4:	e92d003f 	.word	0xe92d003f
        sub     r0,lr,#4                        // PC at time of interrupt
     2d8:	e24e0004 	.word	0xe24e0004
        mrs     r1,spsr
     2dc:	e14f1000 	.word	0xe14f1000
        mov     r2,#CYGNUM_HAL_EXCEPTION_DATA_ACCESS
     2e0:	e3a02004 	.word	0xe3a02004
        mov     r3,sp
     2e4:	e1a0300d 	.word	0xe1a0300d
        b       call_exception_handler
     2e8:	eaffffff 	.word	0xeaffffff

000002ec <call_exception_handler>:
        // [r3+12]: exception r3
        // [r3+8] : exception r2
        // [r3+4] : exception r1
        // [r3]   : exception r0
        
        mrs     r4,cpsr                 // switch to Supervisor Mode
     2ec:	e10f4000 	.word	0xe10f4000
        bic     r4,r4,#CPSR_MODE_BITS
     2f0:	e3c4401f 	.word	0xe3c4401f
        orr     r4,r4,#CPSR_SUPERVISOR_MODE
     2f4:	e3844013 	.word	0xe3844013
        msr     cpsr,r4
     2f8:	e129f004 	.word	0xe129f004

        mov     r5,sp                   // save original svc sp
     2fc:	e1a0500d 	.word	0xe1a0500d
        mov	r4,lr                   // and original svc lr
     300:	0e          	.byte	0x0e
     301:	40          	.byte	0x40
     302:	e1a0      	.short	0xe1a0
        //
        // r5 holds original svc sp, current sp is stack to use
        // r4 holds original svc lr, which must also be preserved
        //

        stmfd   sp!,{r0-r2,r4,r5}       // push svc_sp, svc_lr, vector, psr, pc
     304:	e92d0037 	.word	0xe92d0037
        sub     sp, sp, #4*7
        bal     2f
1:
#endif
        // switch to pre-exception mode to get banked regs
        mov     r0,sp                   // r0 survives mode switch
     308:	e1a0000d 	.word	0xe1a0000d
        mrs     r2,cpsr                 // Save current psr for return
     30c:	e10f2000 	.word	0xe10f2000
        orr     r1,r1,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
     310:	e38110c0 	.word	0xe38110c0
        bic     r1,r1,#CPSR_THUMB_ENABLE
     314:	e3c11020 	.word	0xe3c11020
        msr     cpsr,r1
     318:	e129f001 	.word	0xe129f001
        stmfd   r0!,{r8-r12,sp,lr}
     31c:	e9207f00 	.word	0xe9207f00
        msr     cpsr,r2                 // back to svc mode
     320:	e129f002 	.word	0xe129f002
        mov     sp,r0                   // update stack pointer
     324:	e1a0d000 	.word	0xe1a0d000
2:
        // now save pre-exception r0-r7 on current stack
        ldmfd   r3,{r0-r5}
     328:	e893003f 	.word	0xe893003f
        stmfd   sp!,{r0-r7}
     32c:	e92d00ff 	.word	0xe92d00ff

        // SP needs fixing if exception occured in SVC mode.
        // The original SVC LR is still in place so that 
        // does not need to be fixed here.
        ldr     r1,[sp,#armreg_cpsr]
     330:	e59d1040 	.word	0xe59d1040
        and     r1,r1,#CPSR_MODE_BITS
     334:	e201101f 	.word	0xe201101f
        cmp     r1,#CPSR_SUPERVISOR_MODE
     338:	e3510013 	.word	0xe3510013
        ldreq   r1,[sp,#armreg_svcsp]
     33c:	059d104c 	.word	0x059d104c
        streq   r1,[sp,#armreg_sp]
     340:	058d1034 	.word	0x058d1034
#else
        THUMB_MODE(r9,10)
#endif

        // call exception handler
        mov     r0,sp
     344:	e1a0000d 	.word	0xe1a0000d
        bl      exception_handler
     348:	eb0035b3 	.word	0xeb0035b3

0000034c <return_from_exception>:
        //
        // Return from exception
        //
return_from_exception:

        ldr     r0,[sp,#armreg_cpsr]
     34c:	e59d0040 	.word	0xe59d0040

        // return to supervisor mode is simple
        and     r1,r0,#CPSR_MODE_BITS
     350:	e200101f 	.word	0xe200101f
        cmp     r1,#CPSR_SUPERVISOR_MODE
     354:	e3510013 	.word	0xe3510013

#ifndef CYGOPT_HAL_ARM_PRESERVE_SVC_SPSR
        msr     spsr,r0
     358:	e169f000 	.word	0xe169f000
        ldmeqfd sp,{r0-r14,pc}^
     35c:	08ddffff 	.word	0x08ddffff
        ldmfd   r2, {r8-r14}^           // restore user mode regs
	nop
        bal     2f
1:
#else
        add     r2, sp, #armreg_r8
     360:	e28d2020 	.word	0xe28d2020
        //
        // return to other non-user modes is a little trickier
        //

        // switch to pre-exception mode and restore r8-r14
        mrs     r1,cpsr
     364:	e10f1000 	.word	0xe10f1000
        orr     r0,r0,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
     368:	e38000c0 	.word	0xe38000c0
        bic     r0,r0,#CPSR_THUMB_ENABLE
     36c:	e3c00020 	.word	0xe3c00020
        msr     cpsr,r0
     370:	e129f000 	.word	0xe129f000
        ldmfd   r2,{r8-r14}
     374:	e8927f00 	.word	0xe8927f00
        msr     cpsr, r1        // back to svc mode
     378:	e129f001 	.word	0xe129f001

2:	
        // move sp,lr and pc for final load
        ldr     r0,[sp,#armreg_svcsp]
     37c:	e59d004c 	.word	0xe59d004c
        str     r0,[sp,#armreg_r8]
     380:	e58d0020 	.word	0xe58d0020
        ldr     r0,[sp,#armreg_svclr]	
     384:	e59d0048 	.word	0xe59d0048
        str     r0,[sp,#armreg_r9]
     388:	e58d0024 	.word	0xe58d0024
        ldr     r0,[sp,#armreg_pc]
     38c:	e59d003c 	.word	0xe59d003c
        str     r0,[sp,#armreg_r10]
     390:	e58d0028 	.word	0xe58d0028

        // restore r0-r7,sp,lr and return from exception
        ldmfd   sp,{r0-r7,sp,lr,pc}^
     394:	e8dde0ff 	.word	0xe8dde0ff

00000398 <FIQ>:
// (spurious interrupt while standalone app. is running in user mode)

        .code   32
FIQ:
        // We can get here from any non-user mode.
        mrs     r8,spsr                 // CPSR at time of interrupt
     398:	e14f8000 	.word	0xe14f8000
        and     r9,r8,#CPSR_MODE_BITS   // isolate pre-interrupt mode
     39c:	e208901f 	.word	0xe208901f
        cmp	r9,#CPSR_IRQ_MODE
     3a0:	e3590012 	.word	0xe3590012
        bne	1f
     3a4:	1a000002 	.word	0x1a000002
        // If FIQ interrupted IRQ mode, just return with FIQ disabled.
        // The common interrupt handling takes care of the rest.
        orr	r8,r8,#CPSR_FIQ_DISABLE
     3a8:	e3888040 	.word	0xe3888040
        msr	spsr,r8
     3ac:	e169f008 	.word	0xe169f008
        subs	pc,lr,#4
     3b0:	e25ef004 	.word	0xe25ef004
    1:
        // If FIQ interrupted other non-user mode, switch to IRQ mode and
        // fall through to IRQ handler.
        ldr     sp,.__exception_stack   // get good stack to save lr and spsr
     3b4:	e59fd1a0 	.word	0xe59fd1a0
        stmdb   sp,{r8,lr}
     3b8:	e90d4100 	.word	0xe90d4100
        mov     r8,#CPSR_IRQ_MODE|CPSR_FIQ_DISABLE|CPSR_IRQ_DISABLE
     3bc:	e3a080d2 	.word	0xe3a080d2
        msr     cpsr,r8			// switch to IRQ mode
     3c0:	e129f008 	.word	0xe129f008
        ldr     sp,.__exception_stack   // get regs saved in FIQ mode
     3c4:	e59fd190 	.word	0xe59fd190
        ldmdb	sp,{sp,lr}
     3c8:	e91d6000 	.word	0xe91d6000
        msr     spsr,sp
     3cc:	e169f00d 	.word	0xe169f00d

000003d0 <IRQ>:
        // now it looks like we got an IRQ instead of an FIQ except that
        // FIQ is disabled so we don't recurse.
IRQ:
        // Note: I use this exception stack while saving the context because
        // the current SP does not seem to be always valid in this CPU mode.
        ldr     sp,.__exception_stack   // get good stack
     3d0:	e59fd184 	.word	0xe59fd184
        stmfd   sp!,{r0-r5}             // save some supervisor regs
     3d4:	e92d003f 	.word	0xe92d003f
        sub     r0,lr,#4                // PC at time of interrupt
     3d8:	e24e0004 	.word	0xe24e0004
        mrs     r1,spsr
     3dc:	e14f1000 	.word	0xe14f1000
        mov     r2,#CYGNUM_HAL_VECTOR_IRQ
     3e0:	e3a02006 	.word	0xe3a02006
        mov     r3,sp
     3e4:	e1a0300d 	.word	0xe1a0300d
	
        mrs     r4,cpsr                 // switch to Supervisor Mode
     3e8:	e10f4000 	.word	0xe10f4000
        bic     r4,r4,#CPSR_MODE_BITS
     3ec:	e3c4401f 	.word	0xe3c4401f
        // mode, the FIQ handling code would transform the FIQ into an 
        // IRQ and call the non-reentrant IRQ handler again. As a result, 
        // for example, the stack pointer would be set to the beginning 
        // of the exception_stack clobbering the registers we have just 
        // saved.
        orr     r4,r4,#CPSR_SUPERVISOR_MODE|CPSR_FIQ_DISABLE
     3f0:	e3844053 	.word	0xe3844053
        msr     cpsr,r4
     3f4:	e129f004 	.word	0xe129f004

        mov     r5,sp                   // save original svc sp
     3f8:	e1a0500d 	.word	0xe1a0500d
	mov	r4,lr			// save original svc lr
     3fc:	e1a0400e 	.word	0xe1a0400e
        stmfd   sp!,{r0-r2,r4,r5}       // push svc_sp, svc_lr, vector, psr, pc
     400:	e92d0037 	.word	0xe92d0037
        sub     sp, sp, #4*7
        bal     2f
1:
#endif
        // switch to pre-exception mode to get banked regs
        mov     r0,sp                   // r0 survives mode switch
     404:	e1a0000d 	.word	0xe1a0000d
        mrs     r2,cpsr                 // Save current psr for return
     408:	e10f2000 	.word	0xe10f2000
        orr     r1,r1,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
     40c:	e38110c0 	.word	0xe38110c0
        bic     r1,r1,#CPSR_THUMB_ENABLE
     410:	e3c11020 	.word	0xe3c11020
        msr     cpsr,r1
     414:	e129f001 	.word	0xe129f001
        stmfd   r0!,{r8-r12,sp,lr}
     418:	e9207f00 	.word	0xe9207f00
        msr     cpsr,r2                 // back to svc mode
     41c:	e129f002 	.word	0xe129f002
        mov     sp,r0                   // update stack pointer
     420:	e1a0d000 	.word	0xe1a0d000
	
2:
        // now save pre-exception r0-r7 on current stack
        ldmfd   r3,{r0-r5}
     424:	e893003f 	.word	0xe893003f
        stmfd   sp!,{r0-r7}
     428:	e92d00ff 	.word	0xe92d00ff

        // sp needs fixing if exception occured in SVC mode.
        ldr     r1,[sp,#armreg_cpsr]
     42c:	e59d1040 	.word	0xe59d1040
        and     r1,r1,#CPSR_MODE_BITS
     430:	e201101f 	.word	0xe201101f
        cmp     r1,#CPSR_SUPERVISOR_MODE
     434:	e3510013 	.word	0xe3510013
        ldreq   r1,[sp,#armreg_svcsp]
     438:	059d104c 	.word	0x059d104c
        streq   r1,[sp,#armreg_sp]
     43c:	058d1034 	.word	0x058d1034

        mov     v6,sp                   // Save pointer to register frame
     440:	e1a0900d 	.word	0xe1a0900d
//      mov     r0,sp
//      bl      _show_frame_in

#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
        // Switch to interrupt stack
        ldr     r2,.irq_level           // current number of nested interrupts
     444:	e59f2148 	.word	0xe59f2148
        ldr     r0,[r2]
     448:	e5920000 	.word	0xe5920000
        add     r1,r0,#1
     44c:	e2801001 	.word	0xe2801001
        str     r1,[r2]                 // if was zero, switch stacks
     450:	e5821000 	.word	0xe5821000
        cmp     r0,#0
     454:	e3500000 	.word	0xe3500000
        moveq   r1,sp                   // save old stack pointer
     458:	01a0100d 	.word	0x01a0100d
        ldreq   sp,.__interrupt_stack
     45c:	059fd134 	.word	0x059fd134
        stmeqfd sp!,{r1}
     460:	092d0002 	.word	0x092d0002
        // The entire CPU state is now stashed on the stack,
        // increment the scheduler lock and handle the interrupt

#ifdef CYGFUN_HAL_COMMON_KERNEL_SUPPORT                 
        .extern cyg_scheduler_sched_lock
        ldr     r3,.cyg_scheduler_sched_lock
     464:	e59f3124 	.word	0xe59f3124
        ldr     r4,[r3]
     468:	e5934000 	.word	0xe5934000
        add     r4,r4,#1
     46c:	e2844001 	.word	0xe2844001
        str     r4,[r3]
     470:	e5834000 	.word	0xe5834000
#endif

        THUMB_MODE(r3,10)

        mov     r0,v6
     474:	e1a00009 	.word	0xe1a00009
        bl      hal_IRQ_handler         // determine interrupt source
     478:	eb0035cb 	.word	0xeb0035cb
        mov     v1,r0                   // returned vector #
     47c:	e1a04000 	.word	0xe1a04000
        bl      cyg_instrument          // call instrument function
#endif

        ARM_MODE(r0,10)

        mov     r0,v1                   // vector #
     480:	e1a00004 	.word	0xe1a00004
       .extern  hal_saved_interrupt_state
        ldr     r2,=hal_saved_interrupt_state
        str     v6,[r2]
#endif

        cmp     r0,#CYGNUM_HAL_INTERRUPT_NONE   // spurious interrupt
     484:	e3700001 	.word	0xe3700001
        bne     10f
     488:	1a000002 	.word	0x1a000002

#ifdef  CYGIMP_HAL_COMMON_INTERRUPTS_IGNORE_SPURIOUS
        // Acknowledge the interrupt
        THUMB_CALL(r1,12,hal_interrupt_acknowledge)
#else
        mov     r0,v6                   // register frame
     48c:	e1a00009 	.word	0xe1a00009
        THUMB_CALL(r1,12,hal_spurious_IRQ)
     490:	eb00353c 	.word	0xeb00353c
#endif // CYGIMP_HAL_COMMON_INTERRUPTS_IGNORE_SPURIOUS
        b       spurious_IRQ
     494:	ea000006 	.word	0xea000006
        
10:     ldr     r1,.hal_interrupt_data
     498:	e59f10e0 	.word	0xe59f10e0
        ldr     r1,[r1,v1,lsl #2]       // handler data
     49c:	e7911104 	.word	0xe7911104
        ldr     r2,.hal_interrupt_handlers
     4a0:	e59f20d4 	.word	0xe59f20d4
        ldr     v3,[r2,v1,lsl #2]       // handler (indexed by vector #)
     4a4:	e7926104 	.word	0xe7926104
        mov     r2,v6                   // register frame (this is necessary
     4a8:	e1a02009 	.word	0xe1a02009
        .pool
        .code   32
15:
IRQ_15A:
#else
        mov     lr,pc                   // invoke handler (call indirect
     4ac:	e1a0e00f 	.word	0xe1a0e00f
        mov     pc,v3                   // thru v3)
     4b0:	e1a0f006 	.word	0xe1a0f006

000004b4 <spurious_IRQ>:

#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
        // If we are returning from the last nested interrupt, move back
        // to the thread stack. interrupt_end() must be called on the
        // thread stack since it potentially causes a context switch.
        ldr     r2,.irq_level
     4b4:	e59f20d8 	.word	0xe59f20d8
        ldr     r3,[r2]
     4b8:	e5923000 	.word	0xe5923000
        subs    r1,r3,#1
     4bc:	e2531001 	.word	0xe2531001
        str     r1,[r2]
     4c0:	e5821000 	.word	0xe5821000
        ldreq   sp,[sp]         // This should be the saved stack pointer
     4c4:	059dd000 	.word	0x059dd000
        // The return value from the handler (in r0) will indicate whether a 
        // DSR is to be posted. Pass this together with a pointer to the
        // interrupt object we have just used to the interrupt tidy up routine.

                              // don't run this for spurious interrupts!
        cmp     v1,#CYGNUM_HAL_INTERRUPT_NONE
     4c8:	e3740001 	.word	0xe3740001
        beq     17f
     4cc:	0a000003 	.word	0x0a000003
        ldr     r1,.hal_interrupt_objects
     4d0:	e59f10ac 	.word	0xe59f10ac
        ldr     r1,[r1,v1,lsl #2]
     4d4:	e7911104 	.word	0xe7911104
        mov     r2,v6           // register frame
     4d8:	e1a02009 	.word	0xe1a02009

        THUMB_MODE(r3,10)

        bl      interrupt_end   // post any bottom layer handler
     4dc:	eb001313 	.word	0xeb001313

//      mov     r0,sp
//      bl      show_frame_out

	// return from IRQ is same as return from exception
	b	return_from_exception
     4e0:	eaffff99 	.word	0xeaffff99

000004e4 <hal_interrupt_stack_call_pending_DSRs>:

#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
// Execute pending DSRs the interrupt stack
// Note: this can only be called from code running on a thread stack
FUNC_START_ARM(hal_interrupt_stack_call_pending_DSRs, r1)
        stmfd   sp!,{r4,r5,lr}
     4e4:	e92d4030 	push	{r4, r5, lr}
        // Disable interrupts
        mrs     r4,cpsr                 // disable IRQ's
     4e8:	e10f4000 	mrs	r4, CPSR
        orr     r2,r4,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
     4ec:	e38420c0 	orr	r2, r4, #192	; 0xc0
        bic     r5,r4,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
     4f0:	e3c450c0 	bic	r5, r4, #192	; 0xc0
        msr     cpsr,r2
     4f4:	e129f002 	msr	CPSR_fc, r2
        // Switch to interrupt stack
        mov     r3,sp                   // save old stack pointer
     4f8:	e1a0300d 	mov	r3, sp
        ldr     sp,.__interrupt_stack
     4fc:	e59fd094 	ldr	sp, [pc, #148]	; 598 <.__interrupt_stack>
        stmfd   sp!,{r3}                // stored at top of interrupt stack
     500:	e92d0008 	push	{r3}
        ldr     r2,.irq_level           // current number of nested interrupts
     504:	e59f2088 	ldr	r2, [pc, #136]	; 594 <.irq_level>
        ldr     r3,[r2]
     508:	e5923000 	ldr	r3, [r2]
        add     r3,r3,#1                // bump nesting level
     50c:	e2833001 	add	r3, r3, #1	; 0x1
        str     r3,[r2]
     510:	e5823000 	str	r3, [r2]
        msr     cpsr,r5                 // enable interrupts
     514:	e129f005 	msr	CPSR_fc, r5

        THUMB_MODE(r1,20)

        bl      cyg_interrupt_call_pending_DSRs
     518:	eb001239 	bl	4e04 <cyg_interrupt_call_pending_DSRs>


        ARM_MODE(r1,22)

        // Disable interrupts
        mrs     r1,cpsr                 // disable IRQ's
     51c:	e10f1000 	mrs	r1, CPSR
        orr     r2,r1,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
     520:	e38120c0 	orr	r2, r1, #192	; 0xc0
        msr     cpsr,r2
     524:	e129f002 	msr	CPSR_fc, r2

        // Move back to the thread stack.
        ldr     r2,.irq_level
     528:	e59f2064 	ldr	r2, [pc, #100]	; 594 <.irq_level>
        ldr     r3,[r2]
     52c:	e5923000 	ldr	r3, [r2]
        sub     r3,r3,#1                // decrement nesting level
     530:	e2433001 	sub	r3, r3, #1	; 0x1
        str     r3,[r2]
     534:	e5823000 	str	r3, [r2]
        ldr     sp,[sp]                 // This should be the saved stack pointer
     538:	e59dd000 	ldr	sp, [sp]
        msr     cpsr,r4                 // restore interrupts to original state
     53c:	e129f004 	msr	CPSR_fc, r4

#ifdef __thumb__
        ldmfd   sp!,{r4,r5,lr}          // return
        bx      lr
#else
        ldmfd   sp!,{r4,r5,pc}          // return
     540:	e8bd8030 	pop	{r4, r5, pc}

00000544 <__gccmain>:
_sp:
        mov     r0,sp
        bx      lr
#else
__gccmain:
        mov     pc,lr   
     544:	e1a0f00e 	.word	0xe1a0f00e

00000548 <_psr>:

_psr:
        mrs     r0,cpsr
     548:	e10f0000 	.word	0xe10f0000
        mov     pc,lr
     54c:	e1a0f00e 	.word	0xe1a0f00e

00000550 <_sp>:

_sp:
        mov     r0,sp
     550:	e1a0000d 	.word	0xe1a0000d
        mov     pc,lr
     554:	e1a0f00e 	.word	0xe1a0f00e

00000558 <.__startup_stack>:
     558:	40001ba0 	.word	0x40001ba0

0000055c <.__exception_stack>:
     55c:	40000910 	.word	0x40000910

00000560 <.__undef_exception_stack>:
     560:	40000990 	.word	0x40000990

00000564 <.__bss_start>:
     564:	4000088c 	.word	0x4000088c

00000568 <.__bss_end>:
     568:	40004c54 	.word	0x40004c54

0000056c <._end>:
     56c:	40004c54 	.word	0x40004c54

00000570 <.__rom_data_start>:
     570:	00013298 	.word	0x00013298

00000574 <.__ram_data_start>:
     574:	40000540 	.word	0x40000540

00000578 <.__ram_data_end>:
     578:	4000088c 	.word	0x4000088c

0000057c <.hal_interrupt_handlers>:
     57c:	40000544 	.word	0x40000544

00000580 <.hal_interrupt_data>:
     580:	400005c4 	.word	0x400005c4

00000584 <.hal_interrupt_objects>:
     584:	40000644 	.word	0x40000644

00000588 <.__exception_handlers>:
     588:	00000000 	.word	0x00000000

0000058c <.init_flag>:
     58c:	40000540 	.word	0x40000540

00000590 <.cyg_scheduler_sched_lock>:
     590:	400007c8 	.word	0x400007c8

00000594 <.irq_level>:
     594:	40001990 	.word	0x40001990

00000598 <.__interrupt_stack>:
     598:	40001990 	.word	0x40001990

0000059c <_eCos_id>:
     59c:	736f4365 	.word	0x736f4365
     5a0:	00203a20 	.word	0x00203a20
     5a4:	206e754a 	.word	0x206e754a
     5a8:	32203331 	.word	0x32203331
     5ac:	00313130 	.word	0x00313130
     5b0:	e01fc000 	.word	0xe01fc000
     5b4:	e002c000 	.word	0xe002c000
     5b8:	e0028000 	.word	0xe0028000
     5bc:	00000000 	.word	0x00000000
     5c0:	40001ba0 	.word	0x40001ba0

000005c4 <main>:
 *
 *  Created on: 13 Jun 2011
 *      Author: masterzdran
 */
#include <stdio.h>
int main(){
     5c4:	e1a0c00d 	mov	ip, sp
     5c8:	e92dd800 	push	{fp, ip, lr, pc}
     5cc:	e24cb004 	sub	fp, ip, #4	; 0x4
	printf("Hello World!\n");
     5d0:	e59f0014 	ldr	r0, [pc, #20]	; 5ec <main+0x28>
     5d4:	eb001c57 	bl	7738 <puts>
	return 0;
     5d8:	e3a03000 	mov	r3, #0	; 0x0
}
     5dc:	e1a00003 	mov	r0, r3
     5e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
     5e4:	e89d6800 	ldm	sp, {fp, sp, lr}
     5e8:	e12fff1e 	bx	lr
     5ec:	0001293c 	.word	0x0001293c

000005f0 <_GLOBAL__I.49000_ioinit.cxx>:
externC void cyg_io_init(void);

class cyg_io_init_class {
public:
    cyg_io_init_class(void) { 
        cyg_io_init();
     5f0:	ea000540 	b	1af8 <cyg_io_init>

000005f4 <serial_select>:
#else

    // With no select support, we simply return true.
    return true;
#endif    
}
     5f4:	e3a00001 	mov	r0, #1	; 0x1
     5f8:	e12fff1e 	bx	lr

000005fc <serial_set_config>:
// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_set_config(cyg_io_handle_t handle, cyg_uint32 key, const void *xbuf, 
                  cyg_uint32 *len)
{
     5fc:	e92d4010 	push	{r4, lr}
    Cyg_ErrNo res = ENOERR;
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
     600:	e5904014 	ldr	r4, [r0, #20]
        break;
#endif

    default:
        // pass down to lower layers
        return (funs->set_config)(chan, key, xbuf, len);
     604:	e1a00004 	mov	r0, r4
     608:	e594c000 	ldr	ip, [r4]
     60c:	e1a0e00f 	mov	lr, pc
     610:	e59cf008 	ldr	pc, [ip, #8]
    }
    return res;
}
     614:	e8bd8010 	pop	{r4, pc}

00000618 <serial_rcv_char>:
#endif

    // If the flow control is not enabled/sufficient and the buffer is
    // already full, just throw new characters away.

    if ( cbuf->nb < cbuf->len ) {
     618:	e5902068 	ldr	r2, [r0, #104]
     61c:	e5903064 	ldr	r3, [r0, #100]
     620:	e1520003 	cmp	r2, r3

// ---------------------------------------------------------------------------

static void
serial_rcv_char(serial_channel *chan, unsigned char c)
{
     624:	e1a0c001 	mov	ip, r1
#endif

    // If the flow control is not enabled/sufficient and the buffer is
    // already full, just throw new characters away.

    if ( cbuf->nb < cbuf->len ) {
     628:	aa00000c 	bge	660 <serial_rcv_char+0x48>
        cbuf->data[cbuf->put++] = c;
     62c:	e590305c 	ldr	r3, [r0, #92]
     630:	e5902058 	ldr	r2, [r0, #88]
     634:	e2831001 	add	r1, r3, #1	; 0x1
     638:	e7c2c003 	strb	ip, [r2, r3]
     63c:	e580105c 	str	r1, [r0, #92]
        if (cbuf->put == cbuf->len) cbuf->put = 0;
     640:	e5902064 	ldr	r2, [r0, #100]
     644:	e590305c 	ldr	r3, [r0, #92]
     648:	e1530002 	cmp	r3, r2
     64c:	03a03000 	moveq	r3, #0	; 0x0
     650:	0580305c 	streq	r3, [r0, #92]
        cbuf->nb++;
     654:	e5903068 	ldr	r3, [r0, #104]
     658:	e2833001 	add	r3, r3, #1	; 0x1
     65c:	e5803068 	str	r3, [r0, #104]
        stat.which = CYGNUM_SERIAL_STATUS_OVERRUNERR;
        serial_indicate_status(chan, &stat);
    }
#endif

    if (cbuf->waiting) {
     660:	e590308c 	ldr	r3, [r0, #140]
     664:	e3530000 	cmp	r3, #0	; 0x0
     668:	012fff1e 	bxeq	lr
            HAL_CLOCK_READ(&_time);
            _stime = (int)cyg_current_time();
            diag_printf("Signal reader - time: %x.%x\n", _stime, _time);
            enable_diag_uart = _enable;
#endif // CYGDBG_DIAG_BUF
        cbuf->waiting = false;
     66c:	e3a03000 	mov	r3, #0	; 0x0
     670:	e580308c 	str	r3, [r0, #140]
        cyg_drv_cond_broadcast(&cbuf->wait);
     674:	e2800070 	add	r0, r0, #112	; 0x70
     678:	ea000b48 	b	33a0 <cyg_cond_broadcast>

0000067c <serial_xmt_char>:
    if ( chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED ) {
        (funs->stop_xmit)(chan);  // Stop transmitting for now
        return;
    }
#endif
    while (cbuf->nb > 0) {
     67c:	e5903028 	ldr	r3, [r0, #40]
     680:	e3530000 	cmp	r3, #0	; 0x0

// ---------------------------------------------------------------------------

static void
serial_xmt_char(serial_channel *chan)
{
     684:	e92d4070 	push	{r4, r5, r6, lr}
     688:	e1a04000 	mov	r4, r0
    cbuf_t *cbuf = &chan->out_cbuf;
    serial_funs *funs = chan->funs;
     68c:	e5905000 	ldr	r5, [r0]
    if ( chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED ) {
        (funs->stop_xmit)(chan);  // Stop transmitting for now
        return;
    }
#endif
    while (cbuf->nb > 0) {
     690:	da000023 	ble	724 <serial_xmt_char+0xa8>
        c = cbuf->data[cbuf->get];
        if ((funs->putc)(chan, c)) {
            cbuf->get++;
            if (cbuf->get == cbuf->len) cbuf->get = 0;
     694:	e3a06000 	mov	r6, #0	; 0x0
     698:	ea00000c 	b	6d0 <serial_xmt_char+0x54>
    }
#endif
    while (cbuf->nb > 0) {
        c = cbuf->data[cbuf->get];
        if ((funs->putc)(chan, c)) {
            cbuf->get++;
     69c:	e5943020 	ldr	r3, [r4, #32]
     6a0:	e2833001 	add	r3, r3, #1	; 0x1
     6a4:	e5843020 	str	r3, [r4, #32]
            if (cbuf->get == cbuf->len) cbuf->get = 0;
     6a8:	e5942024 	ldr	r2, [r4, #36]
     6ac:	e5943020 	ldr	r3, [r4, #32]
     6b0:	e1530002 	cmp	r3, r2
     6b4:	05846020 	streq	r6, [r4, #32]
            cbuf->nb--;
     6b8:	e5943028 	ldr	r3, [r4, #40]
     6bc:	e2433001 	sub	r3, r3, #1	; 0x1
     6c0:	e5843028 	str	r3, [r4, #40]
    if ( chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED ) {
        (funs->stop_xmit)(chan);  // Stop transmitting for now
        return;
    }
#endif
    while (cbuf->nb > 0) {
     6c4:	e5942028 	ldr	r2, [r4, #40]
     6c8:	e3520000 	cmp	r2, #0	; 0x0
     6cc:	da000014 	ble	724 <serial_xmt_char+0xa8>
        c = cbuf->data[cbuf->get];
     6d0:	e5942020 	ldr	r2, [r4, #32]
        if ((funs->putc)(chan, c)) {
     6d4:	e5943018 	ldr	r3, [r4, #24]
     6d8:	e1a00004 	mov	r0, r4
     6dc:	e7d31002 	ldrb	r1, [r3, r2]
     6e0:	e1a0e00f 	mov	lr, pc
     6e4:	e595f000 	ldr	pc, [r5]
     6e8:	e3500000 	cmp	r0, #0	; 0x0
     6ec:	1affffea 	bne	69c <serial_xmt_char+0x20>
            cbuf->get++;
            if (cbuf->get == cbuf->len) cbuf->get = 0;
            cbuf->nb--;
        } else {
            // See if there is now enough room to restart writer
            space = cbuf->len - cbuf->nb;
     6f0:	e5943028 	ldr	r3, [r4, #40]
            if (space >= cbuf->low_water) {
     6f4:	e5942024 	ldr	r2, [r4, #36]
     6f8:	e594102c 	ldr	r1, [r4, #44]
     6fc:	e0632002 	rsb	r2, r3, r2
     700:	e1520001 	cmp	r2, r1
     704:	b8bd8070 	poplt	{r4, r5, r6, pc}
                if (cbuf->waiting) {
     708:	e594304c 	ldr	r3, [r4, #76]
     70c:	e3530000 	cmp	r3, #0	; 0x0
     710:	08bd8070 	popeq	{r4, r5, r6, pc}
                    cbuf->waiting = false;
     714:	e584004c 	str	r0, [r4, #76]
                    cyg_drv_cond_broadcast(&cbuf->wait);
     718:	e2840030 	add	r0, r4, #48	; 0x30
        cyg_drv_cond_broadcast(&cbuf->wait);
    }
#ifdef CYGPKG_IO_SERIAL_SELECT_SUPPORT
    cyg_selwakeup( &cbuf->selinfo );
#endif                    
}
     71c:	e8bd4070 	pop	{r4, r5, r6, lr}
            // See if there is now enough room to restart writer
            space = cbuf->len - cbuf->nb;
            if (space >= cbuf->low_water) {
                if (cbuf->waiting) {
                    cbuf->waiting = false;
                    cyg_drv_cond_broadcast(&cbuf->wait);
     720:	ea000b1e 	b	33a0 <cyg_cond_broadcast>
#endif                    
            }
            return;  // Need to wait for more space
        }
    }
    (funs->stop_xmit)(chan);  // Done with transmit
     724:	e1a00004 	mov	r0, r4
     728:	e1a0e00f 	mov	lr, pc
     72c:	e595f010 	ldr	pc, [r5, #16]

    // must signal waiters, and wake up selecters for the case when
    // this was the last char to be sent and they hadn't been signalled
    // before (e.g. because of flow control)
    if (cbuf->waiting) {
     730:	e594304c 	ldr	r3, [r4, #76]
     734:	e3530000 	cmp	r3, #0	; 0x0
     738:	08bd8070 	popeq	{r4, r5, r6, pc}
        cbuf->waiting = false;
     73c:	e3a03000 	mov	r3, #0	; 0x0
        cyg_drv_cond_broadcast(&cbuf->wait);
     740:	e2840030 	add	r0, r4, #48	; 0x30

    // must signal waiters, and wake up selecters for the case when
    // this was the last char to be sent and they hadn't been signalled
    // before (e.g. because of flow control)
    if (cbuf->waiting) {
        cbuf->waiting = false;
     744:	e584304c 	str	r3, [r4, #76]
        cyg_drv_cond_broadcast(&cbuf->wait);
    }
#ifdef CYGPKG_IO_SERIAL_SELECT_SUPPORT
    cyg_selwakeup( &cbuf->selinfo );
#endif                    
}
     748:	e8bd4070 	pop	{r4, r5, r6, lr}
    // must signal waiters, and wake up selecters for the case when
    // this was the last char to be sent and they hadn't been signalled
    // before (e.g. because of flow control)
    if (cbuf->waiting) {
        cbuf->waiting = false;
        cyg_drv_cond_broadcast(&cbuf->wait);
     74c:	ea000b13 	b	33a0 <cyg_cond_broadcast>

00000750 <serial_init>:

// ---------------------------------------------------------------------------

static void
serial_init(serial_channel *chan)
{
     750:	e92d4030 	push	{r4, r5, lr}
    if (chan->init) return;
     754:	e5902014 	ldr	r2, [r0, #20]
     758:	e3520000 	cmp	r2, #0	; 0x0

// ---------------------------------------------------------------------------

static void
serial_init(serial_channel *chan)
{
     75c:	e24dd004 	sub	sp, sp, #4	; 0x4
     760:	e1a05000 	mov	r5, r0
    if (chan->init) return;
     764:	1a000007 	bne	788 <serial_init+0x38>
    if (chan->out_cbuf.len != 0) {
     768:	e5903024 	ldr	r3, [r0, #36]
     76c:	e3530000 	cmp	r3, #0	; 0x0
     770:	1a000010 	bne	7b8 <serial_init+0x68>
        chan->out_cbuf.low_water = chan->out_cbuf.len / 4;
#ifdef CYGPKG_IO_SERIAL_SELECT_SUPPORT
        cyg_selinit( &chan->out_cbuf.selinfo );
#endif        
    }
    if (chan->in_cbuf.len != 0) {
     774:	e5953064 	ldr	r3, [r5, #100]
     778:	e3530000 	cmp	r3, #0	; 0x0
     77c:	1a000003 	bne	790 <serial_init+0x40>
#if CYGINT_IO_SERIAL_BLOCK_TRANSFER
    chan->in_cbuf.block_mode_xfer_running = false;
    chan->out_cbuf.block_mode_xfer_running = false;
#endif // CYGINT_IO_SERIAL_BLOCK_TRANSFER
#endif // CYGDBG_USE_ASSERTS
    chan->init = true;
     780:	e3a03001 	mov	r3, #1	; 0x1
     784:	e5853014 	str	r3, [r5, #20]
}
     788:	e28dd004 	add	sp, sp, #4	; 0x4
     78c:	e8bd8030 	pop	{r4, r5, pc}
        cbuf_t *cbuf = &chan->in_cbuf;

#ifdef CYGDBG_IO_INIT
        diag_printf("Set input buffer - buf: %p len: %d\n", cbuf->data, cbuf->len);
#endif
        cbuf->waiting = false;
     790:	e3a03000 	mov	r3, #0	; 0x0
            cbuf->high_water = 1;
        if ( cbuf->low_water > cbuf->high_water )
            cbuf->low_water = cbuf->high_water;
# endif
#endif
        cyg_drv_mutex_init(&cbuf->lock);
     794:	e2854078 	add	r4, r5, #120	; 0x78
     798:	e1a00004 	mov	r0, r4

#ifdef CYGDBG_IO_INIT
        diag_printf("Set input buffer - buf: %p len: %d\n", cbuf->data, cbuf->len);
#endif
        cbuf->waiting = false;
        cbuf->abort = false;
     79c:	e5853090 	str	r3, [r5, #144]
        cbuf_t *cbuf = &chan->in_cbuf;

#ifdef CYGDBG_IO_INIT
        diag_printf("Set input buffer - buf: %p len: %d\n", cbuf->data, cbuf->len);
#endif
        cbuf->waiting = false;
     7a0:	e585308c 	str	r3, [r5, #140]
            cbuf->high_water = 1;
        if ( cbuf->low_water > cbuf->high_water )
            cbuf->low_water = cbuf->high_water;
# endif
#endif
        cyg_drv_mutex_init(&cbuf->lock);
     7a4:	eb000b0a 	bl	33d4 <cyg_mutex_init>
        cyg_drv_cond_init(&cbuf->wait, &cbuf->lock);
     7a8:	e1a01004 	mov	r1, r4
     7ac:	e2850070 	add	r0, r5, #112	; 0x70
     7b0:	eb000aff 	bl	33b4 <cyg_cond_init>
     7b4:	eafffff1 	b	780 <serial_init+0x30>
        chan->out_cbuf.abort = false;
#ifdef CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING
        chan->out_cbuf.blocking = true;
#endif
        chan->out_cbuf.pending = 0;
        cyg_drv_mutex_init(&chan->out_cbuf.lock);
     7b8:	e2804038 	add	r4, r0, #56	; 0x38
    if (chan->out_cbuf.len != 0) {
#ifdef CYGDBG_IO_INIT
        diag_printf("Set output buffer - buf: %p len: %d\n", chan->out_cbuf.data, chan->out_cbuf.len);
#endif
        chan->out_cbuf.waiting = false;
        chan->out_cbuf.abort = false;
     7bc:	e5802050 	str	r2, [r0, #80]
    if (chan->init) return;
    if (chan->out_cbuf.len != 0) {
#ifdef CYGDBG_IO_INIT
        diag_printf("Set output buffer - buf: %p len: %d\n", chan->out_cbuf.data, chan->out_cbuf.len);
#endif
        chan->out_cbuf.waiting = false;
     7c0:	e580204c 	str	r2, [r0, #76]
        chan->out_cbuf.abort = false;
#ifdef CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING
        chan->out_cbuf.blocking = true;
#endif
        chan->out_cbuf.pending = 0;
     7c4:	e5802054 	str	r2, [r0, #84]
        cyg_drv_mutex_init(&chan->out_cbuf.lock);
     7c8:	e1a00004 	mov	r0, r4
     7cc:	eb000b00 	bl	33d4 <cyg_mutex_init>
        cyg_drv_cond_init(&chan->out_cbuf.wait, &chan->out_cbuf.lock);
     7d0:	e1a01004 	mov	r1, r4
     7d4:	e2850030 	add	r0, r5, #48	; 0x30
     7d8:	eb000af5 	bl	33b4 <cyg_cond_init>
        chan->out_cbuf.low_water = chan->out_cbuf.len / 4;
     7dc:	e5953024 	ldr	r3, [r5, #36]
     7e0:	e3530000 	cmp	r3, #0	; 0x0
     7e4:	e2832003 	add	r2, r3, #3	; 0x3
     7e8:	b1a03002 	movlt	r3, r2
     7ec:	e1a03143 	asr	r3, r3, #2
     7f0:	e585302c 	str	r3, [r5, #44]
#ifdef CYGPKG_IO_SERIAL_SELECT_SUPPORT
        cyg_selinit( &chan->out_cbuf.selinfo );
#endif        
    }
    if (chan->in_cbuf.len != 0) {
     7f4:	e5953064 	ldr	r3, [r5, #100]
     7f8:	e3530000 	cmp	r3, #0	; 0x0
     7fc:	0affffdf 	beq	780 <serial_init+0x30>
     800:	eaffffe2 	b	790 <serial_init+0x40>

00000804 <serial_get_config>:
// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *xbuf,
                  cyg_uint32 *len)
{
     804:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    Cyg_ErrNo res = ENOERR;
    cbuf_t *out_cbuf = &chan->out_cbuf;
    cbuf_t *in_cbuf = &chan->in_cbuf;
    serial_funs *funs = chan->funs;

    switch (key) {
     808:	e2411c01 	sub	r1, r1, #256	; 0x100
static Cyg_ErrNo 
serial_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *xbuf,
                  cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
     80c:	e5905014 	ldr	r5, [r0, #20]
    Cyg_ErrNo res = ENOERR;
    cbuf_t *out_cbuf = &chan->out_cbuf;
    cbuf_t *in_cbuf = &chan->in_cbuf;
    serial_funs *funs = chan->funs;

    switch (key) {
     810:	e2411001 	sub	r1, r1, #1	; 0x1
// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *xbuf,
                  cyg_uint32 *len)
{
     814:	e1a0c003 	mov	ip, r3
    serial_channel *chan = (serial_channel *)t->priv;
    cyg_serial_info_t *buf = (cyg_serial_info_t *)xbuf;
    Cyg_ErrNo res = ENOERR;
    cbuf_t *out_cbuf = &chan->out_cbuf;
    cbuf_t *in_cbuf = &chan->in_cbuf;
    serial_funs *funs = chan->funs;
     818:	e5956000 	ldr	r6, [r5]

    switch (key) {
     81c:	e3510010 	cmp	r1, #16	; 0x10
     820:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
     824:	ea000010 	b	86c <serial_get_config+0x68>
     828:	000008c8 	.word	0x000008c8
     82c:	000008f0 	.word	0x000008f0
     830:	00000908 	.word	0x00000908
     834:	00000990 	.word	0x00000990
     838:	000009f8 	.word	0x000009f8
     83c:	0000086c 	.word	0x0000086c
     840:	0000086c 	.word	0x0000086c
     844:	0000086c 	.word	0x0000086c
     848:	0000086c 	.word	0x0000086c
     84c:	0000086c 	.word	0x0000086c
     850:	0000086c 	.word	0x0000086c
     854:	0000086c 	.word	0x0000086c
     858:	0000086c 	.word	0x0000086c
     85c:	0000086c 	.word	0x0000086c
     860:	0000086c 	.word	0x0000086c
     864:	0000086c 	.word	0x0000086c
     868:	00000878 	.word	0x00000878
            cyg_drv_cond_broadcast(&out_cbuf->wait);
            out_cbuf->waiting = false;
        }
        cyg_drv_dsr_unlock();
        cyg_drv_mutex_unlock(&out_cbuf->lock);
        break;
     86c:	e3e04015 	mvn	r4, #21	; 0x15

    default:
        res = -EINVAL;
    }
    return res;
}
     870:	e1a00004 	mov	r0, r4
     874:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    case CYG_IO_GET_CONFIG_SERIAL_BUFFER_INFO:
        // return rx/tx buffer sizes and counts
        {
            cyg_serial_buf_info_t *p;
            if (*len < sizeof(cyg_serial_buf_info_t))
     878:	e5933000 	ldr	r3, [r3]
     87c:	e353000f 	cmp	r3, #15	; 0xf
     880:	9afffff9 	bls	86c <serial_get_config+0x68>
                return -EINVAL;
          
            *len = sizeof(cyg_serial_buf_info_t);
     884:	e3a03010 	mov	r3, #16	; 0x10
     888:	e58c3000 	str	r3, [ip]
            p = (cyg_serial_buf_info_t *)xbuf;
            
            p->rx_bufsize = in_cbuf->len;
     88c:	e5953064 	ldr	r3, [r5, #100]
     890:	e5823000 	str	r3, [r2]
            if (p->rx_bufsize)
     894:	e3530000 	cmp	r3, #0	; 0x0
                p->rx_count = in_cbuf->nb;
     898:	15953068 	ldrne	r3, [r5, #104]
            else
                p->rx_count = 0;
     89c:	05823004 	streq	r3, [r2, #4]
            *len = sizeof(cyg_serial_buf_info_t);
            p = (cyg_serial_buf_info_t *)xbuf;
            
            p->rx_bufsize = in_cbuf->len;
            if (p->rx_bufsize)
                p->rx_count = in_cbuf->nb;
     8a0:	15823004 	strne	r3, [r2, #4]
            else
                p->rx_count = 0;
            
            p->tx_bufsize = out_cbuf->len;
     8a4:	e5950024 	ldr	r0, [r5, #36]
     8a8:	e5820008 	str	r0, [r2, #8]
            if (p->tx_bufsize)
     8ac:	e3500000 	cmp	r0, #0	; 0x0
                p->tx_count = out_cbuf->nb;
     8b0:	15953028 	ldrne	r3, [r5, #40]
     8b4:	13a04000 	movne	r4, #0	; 0x0
     8b8:	1582300c 	strne	r3, [r2, #12]
            else
                p->tx_count = 0;
     8bc:	0582000c 	streq	r0, [r2, #12]
     8c0:	01a04000 	moveq	r4, r0
     8c4:	eaffffe9 	b	870 <serial_get_config+0x6c>
    cbuf_t *in_cbuf = &chan->in_cbuf;
    serial_funs *funs = chan->funs;

    switch (key) {
    case CYG_IO_GET_CONFIG_SERIAL_INFO:
        if (*len < sizeof(cyg_serial_info_t)) {
     8c8:	e5933000 	ldr	r3, [r3]
     8cc:	e3530007 	cmp	r3, #7	; 0x7
     8d0:	9affffe5 	bls	86c <serial_get_config+0x68>
            return -EINVAL;
        }
        *buf = chan->config;
     8d4:	e285300c 	add	r3, r5, #12	; 0xc
     8d8:	e8930003 	ldm	r3, {r0, r1}
        *len = sizeof(chan->config);
     8dc:	e3a03008 	mov	r3, #8	; 0x8
    switch (key) {
    case CYG_IO_GET_CONFIG_SERIAL_INFO:
        if (*len < sizeof(cyg_serial_info_t)) {
            return -EINVAL;
        }
        *buf = chan->config;
     8e0:	e8820003 	stm	r2, {r0, r1}
        *len = sizeof(chan->config);
     8e4:	e3a04000 	mov	r4, #0	; 0x0
     8e8:	e58c3000 	str	r3, [ip]
     8ec:	eaffffdf 	b	870 <serial_get_config+0x6c>
        }
      break;
      
    case CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN:
// Wait for any pending output to complete
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
     8f0:	e5953024 	ldr	r3, [r5, #36]
     8f4:	e3530000 	cmp	r3, #0	; 0x0
     8f8:	1a00004a 	bne	a28 <serial_get_config+0x224>
            cyg_drv_cond_broadcast(&out_cbuf->wait);
            out_cbuf->waiting = false;
        }
        cyg_drv_dsr_unlock();
        cyg_drv_mutex_unlock(&out_cbuf->lock);
        break;
     8fc:	e3a04000 	mov	r4, #0	; 0x0

    default:
        res = -EINVAL;
    }
    return res;
}
     900:	e1a00004 	mov	r0, r4
     904:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        }
        break;

    case CYG_IO_GET_CONFIG_SERIAL_OUTPUT_FLUSH:
// Throw away any pending output
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
     908:	e5953024 	ldr	r3, [r5, #36]
     90c:	e3530000 	cmp	r3, #0	; 0x0
     910:	0afffff9 	beq	8fc <serial_get_config+0xf8>
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
     914:	e2854038 	add	r4, r5, #56	; 0x38
     918:	e1a00004 	mov	r0, r4
     91c:	eb000aaa 	bl	33cc <cyg_mutex_lock>
        cyg_drv_dsr_lock();
     920:	eb000a03 	bl	3134 <cyg_scheduler_lock>
        if (out_cbuf->nb > 0) {
     924:	e5953028 	ldr	r3, [r5, #40]
     928:	e3530000 	cmp	r3, #0	; 0x0
     92c:	da000008 	ble	954 <serial_get_config+0x150>
            out_cbuf->get = out_cbuf->put = out_cbuf->nb = 0;  // Empties queue!
     930:	e3a03000 	mov	r3, #0	; 0x0
     934:	e5853028 	str	r3, [r5, #40]
     938:	e5952028 	ldr	r2, [r5, #40]
     93c:	e585201c 	str	r2, [r5, #28]
     940:	e595301c 	ldr	r3, [r5, #28]
            (funs->stop_xmit)(chan);  // Done with transmit
     944:	e1a00005 	mov	r0, r5
// Throw away any pending output
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
        cyg_drv_dsr_lock();
        if (out_cbuf->nb > 0) {
            out_cbuf->get = out_cbuf->put = out_cbuf->nb = 0;  // Empties queue!
     948:	e5853020 	str	r3, [r5, #32]
            (funs->stop_xmit)(chan);  // Done with transmit
     94c:	e1a0e00f 	mov	lr, pc
     950:	e596f010 	ldr	pc, [r6, #16]
        }
        // Pass to the hardware driver in case it wants to flush FIFOs etc.
        (funs->set_config)(chan,
     954:	e3a02000 	mov	r2, #0	; 0x0
     958:	e3a01c01 	mov	r1, #256	; 0x100
     95c:	e1a03002 	mov	r3, r2
     960:	e2811003 	add	r1, r1, #3	; 0x3
     964:	e1a00005 	mov	r0, r5
     968:	e1a0e00f 	mov	lr, pc
     96c:	e596f008 	ldr	pc, [r6, #8]
                           CYG_IO_SET_CONFIG_SERIAL_OUTPUT_FLUSH,
                           NULL, NULL);
        if (out_cbuf->waiting) {
     970:	e595304c 	ldr	r3, [r5, #76]
     974:	e3530000 	cmp	r3, #0	; 0x0
     978:	1a00004d 	bne	ab4 <serial_get_config+0x2b0>
            out_cbuf->abort = true;
            cyg_drv_cond_broadcast(&out_cbuf->wait);
            out_cbuf->waiting = false;
        }
        cyg_drv_dsr_unlock();
     97c:	eb000b3b 	bl	3670 <cyg_scheduler_unlock>
        cyg_drv_mutex_unlock(&out_cbuf->lock);
     980:	e1a00004 	mov	r0, r4
     984:	eb000a8e 	bl	33c4 <cyg_mutex_unlock>
     988:	e3a04000 	mov	r4, #0	; 0x0
     98c:	eaffffb7 	b	870 <serial_get_config+0x6c>
        cyg_drv_mutex_unlock(&out_cbuf->lock);
        break;

    case CYG_IO_GET_CONFIG_SERIAL_INPUT_FLUSH:
        // Flush any buffered input
        if (in_cbuf->len == 0) break;  // Nothing to do if not buffered
     990:	e5953064 	ldr	r3, [r5, #100]
     994:	e3530000 	cmp	r3, #0	; 0x0
     998:	0affffd7 	beq	8fc <serial_get_config+0xf8>
        cyg_drv_mutex_lock(&in_cbuf->lock);  // Stop any further input processing
     99c:	e2857078 	add	r7, r5, #120	; 0x78
     9a0:	e1a00007 	mov	r0, r7
     9a4:	eb000a88 	bl	33cc <cyg_mutex_lock>
        cyg_drv_dsr_lock();
     9a8:	eb0009e1 	bl	3134 <cyg_scheduler_lock>
        if (in_cbuf->waiting) {
     9ac:	e595308c 	ldr	r3, [r5, #140]
     9b0:	e3530000 	cmp	r3, #0	; 0x0
     9b4:	1a000037 	bne	a98 <serial_get_config+0x294>
            in_cbuf->abort = true;
            cyg_drv_cond_broadcast(&in_cbuf->wait);
            in_cbuf->waiting = false;
        }
        in_cbuf->get = in_cbuf->put = in_cbuf->nb = 0;  // Flush buffered input
     9b8:	e3a04000 	mov	r4, #0	; 0x0
     9bc:	e5854068 	str	r4, [r5, #104]
     9c0:	e5953068 	ldr	r3, [r5, #104]
     9c4:	e585305c 	str	r3, [r5, #92]
     9c8:	e595205c 	ldr	r2, [r5, #92]

        // Pass to the hardware driver in case it wants to flush FIFOs etc.
        (funs->set_config)(chan,
     9cc:	e3a01f41 	mov	r1, #260	; 0x104
        if (in_cbuf->waiting) {
            in_cbuf->abort = true;
            cyg_drv_cond_broadcast(&in_cbuf->wait);
            in_cbuf->waiting = false;
        }
        in_cbuf->get = in_cbuf->put = in_cbuf->nb = 0;  // Flush buffered input
     9d0:	e5852060 	str	r2, [r5, #96]

        // Pass to the hardware driver in case it wants to flush FIFOs etc.
        (funs->set_config)(chan,
     9d4:	e1a03004 	mov	r3, r4
     9d8:	e1a02004 	mov	r2, r4
     9dc:	e1a00005 	mov	r0, r5
     9e0:	e1a0e00f 	mov	lr, pc
     9e4:	e596f008 	ldr	pc, [r6, #8]
                           CYG_IO_SET_CONFIG_SERIAL_INPUT_FLUSH,
                           NULL, NULL);
        cyg_drv_dsr_unlock();
     9e8:	eb000b20 	bl	3670 <cyg_scheduler_unlock>
        cyg_drv_mutex_unlock(&in_cbuf->lock);
     9ec:	e1a00007 	mov	r0, r7
     9f0:	eb000a73 	bl	33c4 <cyg_mutex_unlock>
     9f4:	eaffff9d 	b	870 <serial_get_config+0x6c>
        break;

    case CYG_IO_GET_CONFIG_SERIAL_ABORT:
        // Abort any outstanding I/O, including blocked reads
        // Caution - assumed to be called from 'timeout' (i.e. DSR) code
        if (in_cbuf->len != 0) {
     9f8:	e5953064 	ldr	r3, [r5, #100]
     9fc:	e3530000 	cmp	r3, #0	; 0x0
     a00:	1a00001f 	bne	a84 <serial_get_config+0x280>
            in_cbuf->abort = true;
            cyg_drv_cond_broadcast(&in_cbuf->wait);
        }
        if (out_cbuf->len != 0) {
     a04:	e5953024 	ldr	r3, [r5, #36]
     a08:	e3530000 	cmp	r3, #0	; 0x0
     a0c:	0affffba 	beq	8fc <serial_get_config+0xf8>
            out_cbuf->abort = true;
     a10:	e3a03001 	mov	r3, #1	; 0x1
     a14:	e5853050 	str	r3, [r5, #80]
            cyg_drv_cond_broadcast(&out_cbuf->wait);
     a18:	e2850030 	add	r0, r5, #48	; 0x30
     a1c:	eb000a5f 	bl	33a0 <cyg_cond_broadcast>
     a20:	e3a04000 	mov	r4, #0	; 0x0
     a24:	eaffff91 	b	870 <serial_get_config+0x6c>
      break;
      
    case CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN:
// Wait for any pending output to complete
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
     a28:	e2858038 	add	r8, r5, #56	; 0x38
     a2c:	e1a00008 	mov	r0, r8
     a30:	eb000a65 	bl	33cc <cyg_mutex_lock>
        cyg_drv_dsr_lock();
        while (out_cbuf->pending || (out_cbuf->nb > 0)) {
            out_cbuf->waiting = true;
            if(!cyg_drv_cond_wait(&out_cbuf->wait) )
     a34:	e2856030 	add	r6, r5, #48	; 0x30
      
    case CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN:
// Wait for any pending output to complete
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
        cyg_drv_dsr_lock();
     a38:	eb0009bd 	bl	3134 <cyg_scheduler_lock>
        while (out_cbuf->pending || (out_cbuf->nb > 0)) {
            out_cbuf->waiting = true;
            if(!cyg_drv_cond_wait(&out_cbuf->wait) )
     a3c:	e3a04000 	mov	r4, #0	; 0x0
// Wait for any pending output to complete
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
        cyg_drv_dsr_lock();
        while (out_cbuf->pending || (out_cbuf->nb > 0)) {
            out_cbuf->waiting = true;
     a40:	e3a07001 	mov	r7, #1	; 0x1
     a44:	ea000003 	b	a58 <serial_get_config+0x254>
     a48:	e585704c 	str	r7, [r5, #76]
            if(!cyg_drv_cond_wait(&out_cbuf->wait) )
     a4c:	eb000a55 	bl	33a8 <cyg_cond_wait>
     a50:	e3500000 	cmp	r0, #0	; 0x0
     a54:	03e04003 	mvneq	r4, #3	; 0x3
    case CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN:
// Wait for any pending output to complete
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
        cyg_drv_dsr_lock();
        while (out_cbuf->pending || (out_cbuf->nb > 0)) {
     a58:	e5953054 	ldr	r3, [r5, #84]
     a5c:	e3530000 	cmp	r3, #0	; 0x0
            out_cbuf->waiting = true;
            if(!cyg_drv_cond_wait(&out_cbuf->wait) )
     a60:	e1a00006 	mov	r0, r6
    case CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN:
// Wait for any pending output to complete
        if (out_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&out_cbuf->lock);  // Stop any further output processing
        cyg_drv_dsr_lock();
        while (out_cbuf->pending || (out_cbuf->nb > 0)) {
     a64:	1afffff7 	bne	a48 <serial_get_config+0x244>
     a68:	e5953028 	ldr	r3, [r5, #40]
     a6c:	e3530000 	cmp	r3, #0	; 0x0
     a70:	cafffff4 	bgt	a48 <serial_get_config+0x244>
            out_cbuf->waiting = true;
            if(!cyg_drv_cond_wait(&out_cbuf->wait) )
                res = -EINTR;
        }
        cyg_drv_dsr_unlock();
     a74:	eb000afd 	bl	3670 <cyg_scheduler_unlock>
        cyg_drv_mutex_unlock(&out_cbuf->lock);
     a78:	e1a00008 	mov	r0, r8
     a7c:	eb000a50 	bl	33c4 <cyg_mutex_unlock>
     a80:	eaffff7a 	b	870 <serial_get_config+0x6c>

    case CYG_IO_GET_CONFIG_SERIAL_ABORT:
        // Abort any outstanding I/O, including blocked reads
        // Caution - assumed to be called from 'timeout' (i.e. DSR) code
        if (in_cbuf->len != 0) {
            in_cbuf->abort = true;
     a84:	e3a03001 	mov	r3, #1	; 0x1
     a88:	e5853090 	str	r3, [r5, #144]
            cyg_drv_cond_broadcast(&in_cbuf->wait);
     a8c:	e2850070 	add	r0, r5, #112	; 0x70
     a90:	eb000a42 	bl	33a0 <cyg_cond_broadcast>
     a94:	eaffffda 	b	a04 <serial_get_config+0x200>
        // Flush any buffered input
        if (in_cbuf->len == 0) break;  // Nothing to do if not buffered
        cyg_drv_mutex_lock(&in_cbuf->lock);  // Stop any further input processing
        cyg_drv_dsr_lock();
        if (in_cbuf->waiting) {
            in_cbuf->abort = true;
     a98:	e3a03001 	mov	r3, #1	; 0x1
     a9c:	e5853090 	str	r3, [r5, #144]
            cyg_drv_cond_broadcast(&in_cbuf->wait);
     aa0:	e2850070 	add	r0, r5, #112	; 0x70
     aa4:	eb000a3d 	bl	33a0 <cyg_cond_broadcast>
            in_cbuf->waiting = false;
     aa8:	e3a03000 	mov	r3, #0	; 0x0
     aac:	e585308c 	str	r3, [r5, #140]
     ab0:	eaffffc0 	b	9b8 <serial_get_config+0x1b4>
        // Pass to the hardware driver in case it wants to flush FIFOs etc.
        (funs->set_config)(chan,
                           CYG_IO_SET_CONFIG_SERIAL_OUTPUT_FLUSH,
                           NULL, NULL);
        if (out_cbuf->waiting) {
            out_cbuf->abort = true;
     ab4:	e3a03001 	mov	r3, #1	; 0x1
     ab8:	e5853050 	str	r3, [r5, #80]
            cyg_drv_cond_broadcast(&out_cbuf->wait);
     abc:	e2850030 	add	r0, r5, #48	; 0x30
     ac0:	eb000a36 	bl	33a0 <cyg_cond_broadcast>
            out_cbuf->waiting = false;
     ac4:	e3a03000 	mov	r3, #0	; 0x0
     ac8:	e585304c 	str	r3, [r5, #76]
     acc:	eaffffaa 	b	97c <serial_get_config+0x178>

00000ad0 <serial_read>:

// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
     ad0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
     ad4:	e5905014 	ldr	r5, [r0, #20]
    serial_funs *funs = chan->funs;
     ad8:	e1a09005 	mov	r9, r5
     adc:	e499a078 	ldr	sl, [r9], #120

// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
     ae0:	e24dd004 	sub	sp, sp, #4	; 0x4
            int _enable = enable_diag_uart;
            int _time, _stime;
            externC cyg_tick_count_t cyg_current_time(void);
#endif // CYGDBG_DIAG_BUF

    cyg_drv_mutex_lock(&cbuf->lock);
     ae4:	e1a00009 	mov	r0, r9

// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
     ae8:	e1a08001 	mov	r8, r1
     aec:	e1a07002 	mov	r7, r2
            int _enable = enable_diag_uart;
            int _time, _stime;
            externC cyg_tick_count_t cyg_current_time(void);
#endif // CYGDBG_DIAG_BUF

    cyg_drv_mutex_lock(&cbuf->lock);
     af0:	eb000a35 	bl	33cc <cyg_mutex_lock>
    cbuf->abort = false;

    if (cbuf->len == 0) {
     af4:	e5952064 	ldr	r2, [r5, #100]
            int _time, _stime;
            externC cyg_tick_count_t cyg_current_time(void);
#endif // CYGDBG_DIAG_BUF

    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;
     af8:	e3a03000 	mov	r3, #0	; 0x0

    if (cbuf->len == 0) {
     afc:	e3520000 	cmp	r2, #0	; 0x0
            int _time, _stime;
            externC cyg_tick_count_t cyg_current_time(void);
#endif // CYGDBG_DIAG_BUF

    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;
     b00:	e5853090 	str	r3, [r5, #144]
serial_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
    serial_funs *funs = chan->funs;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
     b04:	e1a06008 	mov	r6, r8
#endif // CYGDBG_DIAG_BUF

    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;

    if (cbuf->len == 0) {
     b08:	1a000011 	bne	b54 <serial_read+0x84>
        // Non interrupt driven (i.e. polled) operation
        while (size++ < *len) {
     b0c:	e5973000 	ldr	r3, [r7]
     b10:	e3530000 	cmp	r3, #0	; 0x0
     b14:	0a000008 	beq	b3c <serial_read+0x6c>
     b18:	e1a04002 	mov	r4, r2
            cyg_uint8 c = (funs->getc)(chan);
     b1c:	e1a00005 	mov	r0, r5
     b20:	e1a0e00f 	mov	lr, pc
     b24:	e59af004 	ldr	pc, [sl, #4]
                    *buf++ = c;
            }
            else
                *buf++ = c;
#else
            *buf++ = c;
     b28:	e7c80004 	strb	r0, [r8, r4]
    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;

    if (cbuf->len == 0) {
        // Non interrupt driven (i.e. polled) operation
        while (size++ < *len) {
     b2c:	e5973000 	ldr	r3, [r7]
                    *buf++ = c;
            }
            else
                *buf++ = c;
#else
            *buf++ = c;
     b30:	e2844001 	add	r4, r4, #1	; 0x1
    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;

    if (cbuf->len == 0) {
        // Non interrupt driven (i.e. polled) operation
        while (size++ < *len) {
     b34:	e1530004 	cmp	r3, r4
     b38:	8afffff7 	bhi	b1c <serial_read+0x4c>
                    res = -EINTR;
                    break;
                }
            }
        }
        cyg_drv_dsr_unlock();
     b3c:	e3a04000 	mov	r4, #0	; 0x0
    _stime = (int)cyg_current_time();
    diag_printf("READ done - size: %d, len: %d, time: %x.%x\n", size, *len, _stime, _time);
    enable_diag_uart = _enable;
    cyg_drv_isr_unlock();
#endif // CYGDBG_DIAG_BUF
    cyg_drv_mutex_unlock(&cbuf->lock);
     b40:	e1a00009 	mov	r0, r9
     b44:	eb000a1e 	bl	33c4 <cyg_mutex_unlock>
    return res;
}
     b48:	e1a00004 	mov	r0, r4
     b4c:	e28dd004 	add	sp, sp, #4	; 0x4
     b50:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                HAL_CLOCK_READ(&_time);
                _stime = (int)cyg_current_time();
                diag_printf("READ wait - get: %d, put: %d, time: %x.%x\n", cbuf->get, cbuf->put, _stime, _time);
                enable_diag_uart = _enable;
#endif // CYGDBG_DIAG_BUF
                if( !cyg_drv_cond_wait(&cbuf->wait) )
     b54:	e1a04003 	mov	r4, r3
     b58:	e2858070 	add	r8, r5, #112	; 0x70
#else
            *buf++ = c;
#endif    
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid races
     b5c:	eb000974 	bl	3134 <cyg_scheduler_lock>
                    *len = size;        // characters actually read
                    res = size == 0 ? -EAGAIN : ENOERR;
                    break;
                }
#endif // CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING
                cbuf->waiting = true;
     b60:	e3a0b001 	mov	fp, #1	; 0x1
                if ( (cbuf->nb <= cbuf->low_water) && 
                     (chan->flow_desc.flags & CYG_SERIAL_FLOW_IN_THROTTLED) )
                    restart_rx( chan, false );
#endif
                *buf++ = cbuf->data[cbuf->get];
                if (++cbuf->get == cbuf->len) cbuf->get = 0;
     b64:	e1a0a004 	mov	sl, r4
     b68:	ea00000f 	b	bac <serial_read+0xdc>
#ifdef CYGPKG_IO_SERIAL_FLOW_CONTROL
                if ( (cbuf->nb <= cbuf->low_water) && 
                     (chan->flow_desc.flags & CYG_SERIAL_FLOW_IN_THROTTLED) )
                    restart_rx( chan, false );
#endif
                *buf++ = cbuf->data[cbuf->get];
     b6c:	e5951060 	ldr	r1, [r5, #96]
     b70:	e5953058 	ldr	r3, [r5, #88]
     b74:	e7d32001 	ldrb	r2, [r3, r1]
     b78:	e5c62000 	strb	r2, [r6]
                if (++cbuf->get == cbuf->len) cbuf->get = 0;
     b7c:	e5953060 	ldr	r3, [r5, #96]
     b80:	e2833001 	add	r3, r3, #1	; 0x1
     b84:	e5853060 	str	r3, [r5, #96]
     b88:	e5952064 	ldr	r2, [r5, #100]
     b8c:	e5953060 	ldr	r3, [r5, #96]
     b90:	e1530002 	cmp	r3, r2
     b94:	0585a060 	streq	sl, [r5, #96]
                cbuf->nb--;
     b98:	e5953068 	ldr	r3, [r5, #104]
     b9c:	e2433001 	sub	r3, r3, #1	; 0x1
     ba0:	e5853068 	str	r3, [r5, #104]
#ifdef CYGPKG_IO_SERIAL_FLOW_CONTROL
                if ( (cbuf->nb <= cbuf->low_water) && 
                     (chan->flow_desc.flags & CYG_SERIAL_FLOW_IN_THROTTLED) )
                    restart_rx( chan, false );
#endif
                *buf++ = cbuf->data[cbuf->get];
     ba4:	e2866001 	add	r6, r6, #1	; 0x1
                if (++cbuf->get == cbuf->len) cbuf->get = 0;
                cbuf->nb--;
                size++;
     ba8:	e2844001 	add	r4, r4, #1	; 0x1
            *buf++ = c;
#endif    
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid races
        while (size < *len) {
     bac:	e5973000 	ldr	r3, [r7]
     bb0:	e1540003 	cmp	r4, r3
     bb4:	2a000011 	bcs	c00 <serial_read+0x130>
            if (cbuf->nb > 0) {
     bb8:	e5953068 	ldr	r3, [r5, #104]
     bbc:	e3530000 	cmp	r3, #0	; 0x0
     bc0:	caffffe9 	bgt	b6c <serial_read+0x9c>
                    *len = size;        // characters actually read
                    res = size == 0 ? -EAGAIN : ENOERR;
                    break;
                }
#endif // CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING
                cbuf->waiting = true;
     bc4:	e585b08c 	str	fp, [r5, #140]
                HAL_CLOCK_READ(&_time);
                _stime = (int)cyg_current_time();
                diag_printf("READ wait - get: %d, put: %d, time: %x.%x\n", cbuf->get, cbuf->put, _stime, _time);
                enable_diag_uart = _enable;
#endif // CYGDBG_DIAG_BUF
                if( !cyg_drv_cond_wait(&cbuf->wait) )
     bc8:	e1a00008 	mov	r0, r8
     bcc:	eb0009f5 	bl	33a8 <cyg_cond_wait>
     bd0:	e3500000 	cmp	r0, #0	; 0x0
                    cbuf->abort = true;
     bd4:	0585b090 	streq	fp, [r5, #144]
                HAL_CLOCK_READ(&_time);
                _stime = (int)cyg_current_time();
                diag_printf("READ continue - get: %d, put: %d, time: %x.%x\n", cbuf->get, cbuf->put, _stime, _time);
                enable_diag_uart = _enable;
#endif // CYGDBG_DIAG_BUF
                if (cbuf->abort) {
     bd8:	e5953090 	ldr	r3, [r5, #144]
     bdc:	e3530000 	cmp	r3, #0	; 0x0
     be0:	0afffff1 	beq	bac <serial_read+0xdc>
                    // Give up!
                    *len = size;        // characters actually read
                    cbuf->abort = false;
     be4:	e3a03000 	mov	r3, #0	; 0x0
                diag_printf("READ continue - get: %d, put: %d, time: %x.%x\n", cbuf->get, cbuf->put, _stime, _time);
                enable_diag_uart = _enable;
#endif // CYGDBG_DIAG_BUF
                if (cbuf->abort) {
                    // Give up!
                    *len = size;        // characters actually read
     be8:	e5874000 	str	r4, [r7]
                    cbuf->abort = false;
                    cbuf->waiting = false;
     bec:	e585308c 	str	r3, [r5, #140]
                enable_diag_uart = _enable;
#endif // CYGDBG_DIAG_BUF
                if (cbuf->abort) {
                    // Give up!
                    *len = size;        // characters actually read
                    cbuf->abort = false;
     bf0:	e5853090 	str	r3, [r5, #144]
                    cbuf->waiting = false;
     bf4:	e3e04003 	mvn	r4, #3	; 0x3
                    res = -EINTR;
                    break;
                }
            }
        }
        cyg_drv_dsr_unlock();
     bf8:	eb000a9c 	bl	3670 <cyg_scheduler_unlock>
     bfc:	eaffffcf 	b	b40 <serial_read+0x70>
            *buf++ = c;
#endif    
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid races
        while (size < *len) {
     c00:	e3a04000 	mov	r4, #0	; 0x0
                    res = -EINTR;
                    break;
                }
            }
        }
        cyg_drv_dsr_unlock();
     c04:	eb000a99 	bl	3670 <cyg_scheduler_unlock>
     c08:	eaffffcc 	b	b40 <serial_read+0x70>

00000c0c <serial_write>:

// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
     c0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
     c10:	e5905014 	ldr	r5, [r0, #20]
    serial_funs *funs = chan->funs;
     c14:	e1a09005 	mov	r9, r5
     c18:	e4997038 	ldr	r7, [r9], #56

// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
     c1c:	e24dd004 	sub	sp, sp, #4	; 0x4
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    int next;
    cbuf_t *cbuf = &chan->out_cbuf;
    Cyg_ErrNo res = ENOERR;

    cyg_drv_mutex_lock(&cbuf->lock);
     c20:	e1a00009 	mov	r0, r9
serial_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
    serial_funs *funs = chan->funs;
    cyg_int32 size = *len;
     c24:	e5928000 	ldr	r8, [r2]

// ---------------------------------------------------------------------------

static Cyg_ErrNo 
serial_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
     c28:	e1a0b002 	mov	fp, r2
     c2c:	e1a06001 	mov	r6, r1
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    int next;
    cbuf_t *cbuf = &chan->out_cbuf;
    Cyg_ErrNo res = ENOERR;

    cyg_drv_mutex_lock(&cbuf->lock);
     c30:	eb0009e5 	bl	33cc <cyg_mutex_lock>
    cbuf->abort = false;

    if (cbuf->len == 0) {
     c34:	e5952024 	ldr	r2, [r5, #36]
    int next;
    cbuf_t *cbuf = &chan->out_cbuf;
    Cyg_ErrNo res = ENOERR;

    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;
     c38:	e3a03000 	mov	r3, #0	; 0x0

    if (cbuf->len == 0) {
     c3c:	e3520000 	cmp	r2, #0	; 0x0
    int next;
    cbuf_t *cbuf = &chan->out_cbuf;
    Cyg_ErrNo res = ENOERR;

    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;
     c40:	e5853050 	str	r3, [r5, #80]
serial_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    serial_channel *chan = (serial_channel *)t->priv;
    serial_funs *funs = chan->funs;
    cyg_int32 size = *len;
     c44:	e1a04008 	mov	r4, r8
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
     c48:	e1a0a006 	mov	sl, r6
    Cyg_ErrNo res = ENOERR;

    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;

    if (cbuf->len == 0) {
     c4c:	1a000011 	bne	c98 <serial_write+0x8c>
        // Non interrupt driven (i.e. polled) operation
        while (size-- > 0) {
     c50:	e1580003 	cmp	r8, r3
     c54:	da000009 	ble	c80 <serial_write+0x74>
     c58:	e1a04002 	mov	r4, r2
#ifdef CYGPKG_IO_SERIAL_FLOW_CONTROL
            while ( ( 0 != (chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED) ) ||
                    ((funs->putc)(chan, *buf) == false) ) 
                ;  // Ignore full, keep trying
#else
            while ((funs->putc)(chan, *buf) == false) 
     c5c:	e7d61004 	ldrb	r1, [r6, r4]
     c60:	e1a00005 	mov	r0, r5
     c64:	e1a0e00f 	mov	lr, pc
     c68:	e597f000 	ldr	pc, [r7]
     c6c:	e3500000 	cmp	r0, #0	; 0x0
     c70:	0afffff9 	beq	c5c <serial_write+0x50>
     c74:	e2844001 	add	r4, r4, #1	; 0x1
    cyg_drv_mutex_lock(&cbuf->lock);
    cbuf->abort = false;

    if (cbuf->len == 0) {
        // Non interrupt driven (i.e. polled) operation
        while (size-- > 0) {
     c78:	e1540008 	cmp	r4, r8
     c7c:	1afffff6 	bne	c5c <serial_write+0x50>
        }
#ifdef CYGPKG_IO_SERIAL_FLOW_CONTROL
        if ( 0 == (chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED) )
#endif
            (funs->start_xmit)(chan);  // Start output as necessary
        cyg_drv_dsr_unlock();
     c80:	e3a04000 	mov	r4, #0	; 0x0
    }
    cyg_drv_mutex_unlock(&cbuf->lock);
     c84:	e1a00009 	mov	r0, r9
     c88:	eb0009cd 	bl	33c4 <cyg_mutex_unlock>
    return res;
}
     c8c:	e1a00004 	mov	r0, r4
     c90:	e28dd004 	add	sp, sp, #4	; 0x4
     c94:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                ;  // Ignore full, keep trying
#endif
            buf++;
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid race condition testing pointers
     c98:	eb000925 	bl	3134 <cyg_scheduler_lock>
        while (size > 0) {       
     c9c:	e3580000 	cmp	r8, #0	; 0x0
     ca0:	da000034 	ble	d78 <serial_write+0x16c>
                        res = (*len == 0) ? -EAGAIN : ENOERR;
                        break;
                    }
#endif // CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING
                    cbuf->pending += size;  // Have this much more to send [eventually]
                    if( !cyg_drv_cond_wait(&cbuf->wait) )
     ca4:	e2858030 	add	r8, r5, #48	; 0x30
        cyg_drv_dsr_lock();  // Avoid race condition testing pointers
        while (size > 0) {       
            next = cbuf->put + 1;
            if (next == cbuf->len) next = 0;
            if (cbuf->nb == cbuf->len) {
                cbuf->waiting = true;
     ca8:	e3a06001 	mov	r6, #1	; 0x1
     cac:	ea00000c 	b	ce4 <serial_write+0xd8>
                    cbuf->waiting = false;
                    res = -EINTR;
                    break;
                }
            } else {
                cbuf->data[cbuf->put++] = *buf++;
     cb0:	e595101c 	ldr	r1, [r5, #28]
     cb4:	e4da0001 	ldrb	r0, [sl], #1
     cb8:	e5953018 	ldr	r3, [r5, #24]
     cbc:	e2812001 	add	r2, r1, #1	; 0x1
     cc0:	e7c30001 	strb	r0, [r3, r1]
     cc4:	e585201c 	str	r2, [r5, #28]
                cbuf->put = next;
     cc8:	e585c01c 	str	ip, [r5, #28]
                cbuf->nb++;
     ccc:	e5953028 	ldr	r3, [r5, #40]
     cd0:	e2833001 	add	r3, r3, #1	; 0x1
     cd4:	e5853028 	str	r3, [r5, #40]
                size--;  // Only count if actually sent!
     cd8:	e2444001 	sub	r4, r4, #1	; 0x1
#endif
            buf++;
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid race condition testing pointers
        while (size > 0) {       
     cdc:	e3540000 	cmp	r4, #0	; 0x0
     ce0:	da000024 	ble	d78 <serial_write+0x16c>
            next = cbuf->put + 1;
     ce4:	e595301c 	ldr	r3, [r5, #28]
            if (next == cbuf->len) next = 0;
     ce8:	e5952024 	ldr	r2, [r5, #36]
            buf++;
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid race condition testing pointers
        while (size > 0) {       
            next = cbuf->put + 1;
     cec:	e283c001 	add	ip, r3, #1	; 0x1
            if (next == cbuf->len) next = 0;
            if (cbuf->nb == cbuf->len) {
     cf0:	e5951028 	ldr	r1, [r5, #40]
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid race condition testing pointers
        while (size > 0) {       
            next = cbuf->put + 1;
            if (next == cbuf->len) next = 0;
     cf4:	e152000c 	cmp	r2, ip
     cf8:	03a0c000 	moveq	ip, #0	; 0x0
            if (cbuf->nb == cbuf->len) {
     cfc:	e1520001 	cmp	r2, r1
     d00:	1affffea 	bne	cb0 <serial_write+0xa4>
                cbuf->waiting = true;
     d04:	e585604c 	str	r6, [r5, #76]
                // Buffer full - wait for space
#ifdef CYGPKG_IO_SERIAL_FLOW_CONTROL
                if ( 0 == (chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED) )
#endif
                    (funs->start_xmit)(chan);  // Make sure xmit is running
     d08:	e1a00005 	mov	r0, r5
     d0c:	e1a0e00f 	mov	lr, pc
     d10:	e597f00c 	ldr	pc, [r7, #12]

                // Check flag: 'start_xmit' may have obviated the need
                // to wait :-)
                if (cbuf->waiting) {
     d14:	e595304c 	ldr	r3, [r5, #76]
     d18:	e3530000 	cmp	r3, #0	; 0x0
     d1c:	1a00000a 	bne	d4c <serial_write+0x140>
                    cbuf->pending += size;  // Have this much more to send [eventually]
                    if( !cyg_drv_cond_wait(&cbuf->wait) )
                        cbuf->abort = true;
                    cbuf->pending -= size;
                }
                if (cbuf->abort) {
     d20:	e5953050 	ldr	r3, [r5, #80]
     d24:	e3530000 	cmp	r3, #0	; 0x0
     d28:	0affffeb 	beq	cdc <serial_write+0xd0>
                    // Give up!
                    *len -= size;   // number of characters actually sent
     d2c:	e59b3000 	ldr	r3, [fp]
                    cbuf->abort = false;
     d30:	e3a02000 	mov	r2, #0	; 0x0
                        cbuf->abort = true;
                    cbuf->pending -= size;
                }
                if (cbuf->abort) {
                    // Give up!
                    *len -= size;   // number of characters actually sent
     d34:	e0643003 	rsb	r3, r4, r3
     d38:	e58b3000 	str	r3, [fp]
                    cbuf->abort = false;
                    cbuf->waiting = false;
     d3c:	e3e04003 	mvn	r4, #3	; 0x3
     d40:	e585204c 	str	r2, [r5, #76]
                    cbuf->pending -= size;
                }
                if (cbuf->abort) {
                    // Give up!
                    *len -= size;   // number of characters actually sent
                    cbuf->abort = false;
     d44:	e5852050 	str	r2, [r5, #80]
     d48:	ea00000b 	b	d7c <serial_write+0x170>
                        cbuf->waiting = false;
                        res = (*len == 0) ? -EAGAIN : ENOERR;
                        break;
                    }
#endif // CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING
                    cbuf->pending += size;  // Have this much more to send [eventually]
     d4c:	e5953054 	ldr	r3, [r5, #84]
     d50:	e0843003 	add	r3, r4, r3
     d54:	e5853054 	str	r3, [r5, #84]
                    if( !cyg_drv_cond_wait(&cbuf->wait) )
     d58:	e1a00008 	mov	r0, r8
     d5c:	eb000991 	bl	33a8 <cyg_cond_wait>
     d60:	e3500000 	cmp	r0, #0	; 0x0
                        cbuf->abort = true;
     d64:	05856050 	streq	r6, [r5, #80]
                    cbuf->pending -= size;
     d68:	e5953054 	ldr	r3, [r5, #84]
     d6c:	e0643003 	rsb	r3, r4, r3
     d70:	e5853054 	str	r3, [r5, #84]
     d74:	eaffffe9 	b	d20 <serial_write+0x114>
#endif
            buf++;
        }
    } else {
        cyg_drv_dsr_lock();  // Avoid race condition testing pointers
        while (size > 0) {       
     d78:	e3a04000 	mov	r4, #0	; 0x0
            }
        }
#ifdef CYGPKG_IO_SERIAL_FLOW_CONTROL
        if ( 0 == (chan->flow_desc.flags & CYG_SERIAL_FLOW_OUT_THROTTLED) )
#endif
            (funs->start_xmit)(chan);  // Start output as necessary
     d7c:	e1a00005 	mov	r0, r5
     d80:	e1a0e00f 	mov	lr, pc
     d84:	e597f00c 	ldr	pc, [r7, #12]
        cyg_drv_dsr_unlock();
     d88:	eb000a38 	bl	3670 <cyg_scheduler_unlock>
     d8c:	eaffffbc 	b	c84 <serial_write+0x78>

00000d90 <tty_init>:
#endif

static bool 
tty_init(struct cyg_devtab_entry *tab)
{
    struct tty_private_info *priv = (struct tty_private_info *)tab->priv;
     d90:	e5903014 	ldr	r3, [r0, #20]
#ifdef CYGDBG_IO_INIT
    diag_printf("Init tty channel: %p\n", tab);
#endif
    priv->dev_info.tty_out_flags = CYG_TTY_OUT_FLAGS_DEFAULT;
    priv->dev_info.tty_in_flags = CYG_TTY_IN_FLAGS_DEFAULT;
     d94:	e3a02005 	mov	r2, #5	; 0x5
{
    struct tty_private_info *priv = (struct tty_private_info *)tab->priv;
#ifdef CYGDBG_IO_INIT
    diag_printf("Init tty channel: %p\n", tab);
#endif
    priv->dev_info.tty_out_flags = CYG_TTY_OUT_FLAGS_DEFAULT;
     d98:	e3a00001 	mov	r0, #1	; 0x1
    priv->dev_info.tty_in_flags = CYG_TTY_IN_FLAGS_DEFAULT;
     d9c:	e8830005 	stm	r3, {r0, r2}
    return true;
}
     da0:	e12fff1e 	bx	lr

00000da4 <tty_lookup>:
    cyg_io_handle_t chan = (cyg_io_handle_t)sub_tab;
    struct tty_private_info *priv = (struct tty_private_info *)(*tab)->priv;
#if 0
    cyg_int32 len;
#endif
    priv->dev_handle = chan;
     da4:	e5903000 	ldr	r3, [r0]
     da8:	e5932014 	ldr	r2, [r3, #20]
    // Initialize configuration
    cyg_io_get_config(chan, CYG_SERIAL_GET_CONFIG, 
                      (void *)&priv->dev_info.serial_config, &len);
#endif
    return ENOERR;
}
     dac:	e3a00000 	mov	r0, #0	; 0x0
    cyg_io_handle_t chan = (cyg_io_handle_t)sub_tab;
    struct tty_private_info *priv = (struct tty_private_info *)(*tab)->priv;
#if 0
    cyg_int32 len;
#endif
    priv->dev_handle = chan;
     db0:	e5821008 	str	r1, [r2, #8]
    // Initialize configuration
    cyg_io_get_config(chan, CYG_SERIAL_GET_CONFIG, 
                      (void *)&priv->dev_info.serial_config, &len);
#endif
    return ENOERR;
}
     db4:	e12fff1e 	bx	lr

00000db8 <tty_set_config>:
#if 0
    cyg_int32 current_len;
#endif
    Cyg_ErrNo res = ENOERR;
    // assert(chan)
    switch (key) {
     db8:	e3a0cd0a 	mov	ip, #640	; 0x280
    return res;
}

static Cyg_ErrNo 
tty_set_config(cyg_io_handle_t handle, cyg_uint32 key, const void *buf, cyg_uint32 *len)
{
     dbc:	e92d0030 	push	{r4, r5}
#if 0
    cyg_int32 current_len;
#endif
    Cyg_ErrNo res = ENOERR;
    // assert(chan)
    switch (key) {
     dc0:	e28cc001 	add	ip, ip, #1	; 0x1

static Cyg_ErrNo 
tty_set_config(cyg_io_handle_t handle, cyg_uint32 key, const void *buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
     dc4:	e5904014 	ldr	r4, [r0, #20]
#if 0
    cyg_int32 current_len;
#endif
    Cyg_ErrNo res = ENOERR;
    // assert(chan)
    switch (key) {
     dc8:	e151000c 	cmp	r1, ip
    return res;
}

static Cyg_ErrNo 
tty_set_config(cyg_io_handle_t handle, cyg_uint32 key, const void *buf, cyg_uint32 *len)
{
     dcc:	e1a05002 	mov	r5, r2
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
    cyg_io_handle_t chan = (cyg_io_handle_t)priv->dev_handle;
     dd0:	e5940008 	ldr	r0, [r4, #8]
#if 0
    cyg_int32 current_len;
#endif
    Cyg_ErrNo res = ENOERR;
    // assert(chan)
    switch (key) {
     dd4:	0a000001 	beq	de0 <tty_set_config+0x28>
        break;
    default: // Pass on to serial driver
        res = cyg_io_set_config(chan, key, buf, len);
    }
    return res;
}
     dd8:	e8bd0030 	pop	{r4, r5}
            return -EINVAL;
        }
        priv->dev_info = *(cyg_tty_info_t *)buf;
        break;
    default: // Pass on to serial driver
        res = cyg_io_set_config(chan, key, buf, len);
     ddc:	ea000401 	b	1de8 <cyg_io_set_config>
#endif
    Cyg_ErrNo res = ENOERR;
    // assert(chan)
    switch (key) {
    case CYG_IO_SET_CONFIG_TTY_INFO:
        if (*len != sizeof(cyg_tty_info_t)) {
     de0:	e5933000 	ldr	r3, [r3]
     de4:	e3530008 	cmp	r3, #8	; 0x8
            return -EINVAL;
        }
        priv->dev_info = *(cyg_tty_info_t *)buf;
     de8:	08920003 	ldmeq	r2, {r0, r1}
#endif
    Cyg_ErrNo res = ENOERR;
    // assert(chan)
    switch (key) {
    case CYG_IO_SET_CONFIG_TTY_INFO:
        if (*len != sizeof(cyg_tty_info_t)) {
     dec:	13e00015 	mvnne	r0, #21	; 0x15
            return -EINVAL;
        }
        priv->dev_info = *(cyg_tty_info_t *)buf;
     df0:	08840003 	stmeq	r4, {r0, r1}
     df4:	03a00000 	moveq	r0, #0	; 0x0
        break;
    default: // Pass on to serial driver
        res = cyg_io_set_config(chan, key, buf, len);
    }
    return res;
}
     df8:	e8bd0030 	pop	{r4, r5}
     dfc:	e12fff1e 	bx	lr

00000e00 <tty_get_config>:
    Cyg_ErrNo res = ENOERR;
#if 0
    cyg_int32 current_len;
#endif
    // assert(chan)
    switch (key) {
     e00:	e3a0cc02 	mov	ip, #512	; 0x200
    return cyg_io_select( chan, which, info );
}

static Cyg_ErrNo 
tty_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *buf, cyg_uint32 *len)
{
     e04:	e92d0030 	push	{r4, r5}
    Cyg_ErrNo res = ENOERR;
#if 0
    cyg_int32 current_len;
#endif
    // assert(chan)
    switch (key) {
     e08:	e28cc001 	add	ip, ip, #1	; 0x1

static Cyg_ErrNo 
tty_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
     e0c:	e5904014 	ldr	r4, [r0, #20]
    Cyg_ErrNo res = ENOERR;
#if 0
    cyg_int32 current_len;
#endif
    // assert(chan)
    switch (key) {
     e10:	e151000c 	cmp	r1, ip
    return cyg_io_select( chan, which, info );
}

static Cyg_ErrNo 
tty_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *buf, cyg_uint32 *len)
{
     e14:	e1a05002 	mov	r5, r2
     e18:	e1a0c003 	mov	ip, r3
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
    cyg_io_handle_t chan = (cyg_io_handle_t)priv->dev_handle;
     e1c:	e5940008 	ldr	r0, [r4, #8]
    Cyg_ErrNo res = ENOERR;
#if 0
    cyg_int32 current_len;
#endif
    // assert(chan)
    switch (key) {
     e20:	0a000001 	beq	e2c <tty_get_config+0x2c>
        break;
    default:  // Assume this is a 'serial' driver control
        res = cyg_io_get_config(chan, key, buf, len);
    }
    return res;
}
     e24:	e8bd0030 	pop	{r4, r5}
#endif
        *(cyg_tty_info_t *)buf = priv->dev_info;
        *len = sizeof(cyg_tty_info_t);
        break;
    default:  // Assume this is a 'serial' driver control
        res = cyg_io_get_config(chan, key, buf, len);
     e28:	ea0003de 	b	1da8 <cyg_io_get_config>
    cyg_int32 current_len;
#endif
    // assert(chan)
    switch (key) {
    case CYG_IO_GET_CONFIG_TTY_INFO:
        if (*len < sizeof(cyg_tty_info_t)) {
     e2c:	e5933000 	ldr	r3, [r3]
     e30:	e3530007 	cmp	r3, #7	; 0x7
                                (void *)&priv->dev_info.serial_config, &current_len);
        if (res != ENOERR) {
            return res;
        }
#endif
        *(cyg_tty_info_t *)buf = priv->dev_info;
     e34:	88940003 	ldmhi	r4, {r0, r1}
        *len = sizeof(cyg_tty_info_t);
     e38:	83a03008 	movhi	r3, #8	; 0x8
                                (void *)&priv->dev_info.serial_config, &current_len);
        if (res != ENOERR) {
            return res;
        }
#endif
        *(cyg_tty_info_t *)buf = priv->dev_info;
     e3c:	88820003 	stmhi	r2, {r0, r1}
    cyg_int32 current_len;
#endif
    // assert(chan)
    switch (key) {
    case CYG_IO_GET_CONFIG_TTY_INFO:
        if (*len < sizeof(cyg_tty_info_t)) {
     e40:	93e00015 	mvnls	r0, #21	; 0x15
        if (res != ENOERR) {
            return res;
        }
#endif
        *(cyg_tty_info_t *)buf = priv->dev_info;
        *len = sizeof(cyg_tty_info_t);
     e44:	858c3000 	strhi	r3, [ip]
     e48:	83a00000 	movhi	r0, #0	; 0x0
        break;
    default:  // Assume this is a 'serial' driver control
        res = cyg_io_get_config(chan, key, buf, len);
    }
    return res;
}
     e4c:	e8bd0030 	pop	{r4, r5}
     e50:	e12fff1e 	bx	lr

00000e54 <tty_select>:
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
    cyg_io_handle_t chan = (cyg_io_handle_t)priv->dev_handle;    

    // Just pass it on to next driver level
    return cyg_io_select( chan, which, info );
     e54:	e5903014 	ldr	r3, [r0, #20]
     e58:	e5930008 	ldr	r0, [r3, #8]
     e5c:	ea0003c7 	b	1d80 <cyg_io_select>

00000e60 <tty_read>:
    return res;
}

static Cyg_ErrNo 
tty_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
     e60:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
     e64:	e5905014 	ldr	r5, [r0, #20]
    return res;
}

static Cyg_ErrNo 
tty_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
     e68:	e24dd00c 	sub	sp, sp, #12	; 0xc
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
    cyg_io_handle_t chan = (cyg_io_handle_t)priv->dev_handle;
     e6c:	e5956008 	ldr	r6, [r5, #8]
    return res;
}

static Cyg_ErrNo 
tty_read(cyg_io_handle_t handle, void *_buf, cyg_uint32 *len)
{
     e70:	e1a0b001 	mov	fp, r1
     e74:	e1a07002 	mov	r7, r2
    cyg_io_handle_t chan = (cyg_io_handle_t)priv->dev_handle;
    cyg_uint32 clen;
    cyg_int32 size;
    Cyg_ErrNo res;
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
     e78:	e3a04000 	mov	r4, #0	; 0x0
    // assert(chan)
    size = 0;
    while (size < *len) {
        clen = 1;
        res = cyg_io_read(chan, &c, &clen);
     e7c:	e28d9007 	add	r9, sp, #7	; 0x7
     e80:	e1a0a00d 	mov	sl, sp
    Cyg_ErrNo res;
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    // assert(chan)
    size = 0;
    while (size < *len) {
     e84:	e5973000 	ldr	r3, [r7]
     e88:	e1540003 	cmp	r4, r3
     e8c:	2a00001d 	bcs	f08 <tty_read+0xa8>
        clen = 1;
     e90:	e3a03001 	mov	r3, #1	; 0x1
        res = cyg_io_read(chan, &c, &clen);
     e94:	e1a00006 	mov	r0, r6
     e98:	e1a01009 	mov	r1, r9
     e9c:	e1a0200d 	mov	r2, sp
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    // assert(chan)
    size = 0;
    while (size < *len) {
        clen = 1;
     ea0:	e58d3000 	str	r3, [sp]
        res = cyg_io_read(chan, &c, &clen);
     ea4:	eb000383 	bl	1cb8 <cyg_io_read>
        if (res != ENOERR) {
     ea8:	e2508000 	subs	r8, r0, #0	; 0x0
     eac:	1a00003b 	bne	fa0 <tty_read+0x140>
            *len = size;
            return res;
        }
        buf[size++] = c;
     eb0:	e5dd3007 	ldrb	r3, [sp, #7]
     eb4:	e7cb3004 	strb	r3, [fp, r4]
        if ((priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_BINARY) == 0) {
     eb8:	e5952004 	ldr	r2, [r5, #4]
     ebc:	e3120008 	tst	r2, #8	; 0x8
        res = cyg_io_read(chan, &c, &clen);
        if (res != ENOERR) {
            *len = size;
            return res;
        }
        buf[size++] = c;
     ec0:	e2844001 	add	r4, r4, #1	; 0x1
        if ((priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_BINARY) == 0) {
     ec4:	1affffee 	bne	e84 <tty_read+0x24>
            switch (c) {
     ec8:	e353000a 	cmp	r3, #10	; 0xa
     ecc:	0a000025 	beq	f68 <tty_read+0x108>
     ed0:	8a00000f 	bhi	f14 <tty_read+0xb4>
     ed4:	e3530008 	cmp	r3, #8	; 0x8
     ed8:	0a000011 	beq	f24 <tty_read+0xc4>
                }
                buf[size-1] = c;
                *len = size;
                return ENOERR;
            default:
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
     edc:	e3120004 	tst	r2, #4	; 0x4
     ee0:	0affffe7 	beq	e84 <tty_read+0x24>
                    clen = 1;
     ee4:	e3a03001 	mov	r3, #1	; 0x1
                    cyg_io_write(chan, &c, &clen);
     ee8:	e1a00006 	mov	r0, r6
     eec:	e1a01009 	mov	r1, r9
     ef0:	e1a0200d 	mov	r2, sp
                buf[size-1] = c;
                *len = size;
                return ENOERR;
            default:
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
                    clen = 1;
     ef4:	e58d3000 	str	r3, [sp]
                    cyg_io_write(chan, &c, &clen);
     ef8:	eb00035c 	bl	1c70 <cyg_io_write>
    Cyg_ErrNo res;
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    // assert(chan)
    size = 0;
    while (size < *len) {
     efc:	e5973000 	ldr	r3, [r7]
     f00:	e1540003 	cmp	r4, r3
     f04:	3affffe1 	bcc	e90 <tty_read+0x30>
                }
                break;
            }
        }
    }
    *len = size;
     f08:	e5874000 	str	r4, [r7]
     f0c:	e3a08000 	mov	r8, #0	; 0x0
     f10:	ea000023 	b	fa4 <tty_read+0x144>
            *len = size;
            return res;
        }
        buf[size++] = c;
        if ((priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_BINARY) == 0) {
            switch (c) {
     f14:	e353000d 	cmp	r3, #13	; 0xd
     f18:	0a00000d 	beq	f54 <tty_read+0xf4>
     f1c:	e353007f 	cmp	r3, #127	; 0x7f
     f20:	1affffed 	bne	edc <tty_read+0x7c>
            case '\b':    /* drop through */
            case 0x7f:
                size -= 2;  // erase one character + 'backspace' char
                if (size < 0) {
     f24:	e2544002 	subs	r4, r4, #2	; 0x2
     f28:	43a04000 	movmi	r4, #0	; 0x0
     f2c:	4affffd4 	bmi	e84 <tty_read+0x24>
                    size = 0;
                } else if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
     f30:	e3120004 	tst	r2, #4	; 0x4
     f34:	0affffd2 	beq	e84 <tty_read+0x24>
                    clen = 3;
     f38:	e3a03003 	mov	r3, #3	; 0x3
                    cyg_io_write(chan, "\b \b", &clen);
     f3c:	e1a00006 	mov	r0, r6
     f40:	e59f1090 	ldr	r1, [pc, #144]	; fd8 <tty_read+0x178>
     f44:	e1a0200d 	mov	r2, sp
            case 0x7f:
                size -= 2;  // erase one character + 'backspace' char
                if (size < 0) {
                    size = 0;
                } else if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
                    clen = 3;
     f48:	e58d3000 	str	r3, [sp]
                    cyg_io_write(chan, "\b \b", &clen);
     f4c:	eb000347 	bl	1c70 <cyg_io_write>
     f50:	eaffffcb 	b	e84 <tty_read+0x24>
                }
                break;
            case '\r':
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_CRLF) {
     f54:	e3120002 	tst	r2, #2	; 0x2
     f58:	1affffc9 	bne	e84 <tty_read+0x24>
                    /* Don't do anything because a '\n' will come next */
                    break;
                }
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_CR) {
     f5c:	e3120001 	tst	r2, #1	; 0x1
                    c = '\n';  // Map CR -> LF
     f60:	13a0300a 	movne	r3, #10	; 0xa
     f64:	15cd3007 	strbne	r3, [sp, #7]
                }
                /* drop through */
            case '\n':
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
     f68:	e3120004 	tst	r2, #4	; 0x4
     f6c:	0a000008 	beq	f94 <tty_read+0x134>
                    if (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF) {
     f70:	e5953000 	ldr	r3, [r5]
     f74:	e3130001 	tst	r3, #1	; 0x1
     f78:	1a00000c 	bne	fb0 <tty_read+0x150>
                        clen = 2;
                        cyg_io_write(chan, "\r\n", &clen);
                    } else {
                        clen = 1;
     f7c:	e3a03001 	mov	r3, #1	; 0x1
                        cyg_io_write(chan, &c, &clen);
     f80:	e1a00006 	mov	r0, r6
     f84:	e1a01009 	mov	r1, r9
     f88:	e1a0200d 	mov	r2, sp
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
                    if (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF) {
                        clen = 2;
                        cyg_io_write(chan, "\r\n", &clen);
                    } else {
                        clen = 1;
     f8c:	e58d3000 	str	r3, [sp]
                        cyg_io_write(chan, &c, &clen);
     f90:	eb000336 	bl	1c70 <cyg_io_write>
                    }
                }
                buf[size-1] = c;
     f94:	e5dd2007 	ldrb	r2, [sp, #7]
     f98:	e08b3004 	add	r3, fp, r4
     f9c:	e5432001 	strb	r2, [r3, #-1]
                *len = size;
     fa0:	e5874000 	str	r4, [r7]
            }
        }
    }
    *len = size;
    return ENOERR;
}
     fa4:	e1a00008 	mov	r0, r8
     fa8:	e28dd00c 	add	sp, sp, #12	; 0xc
     fac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                }
                /* drop through */
            case '\n':
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
                    if (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF) {
                        clen = 2;
     fb0:	e3a03002 	mov	r3, #2	; 0x2
                        cyg_io_write(chan, "\r\n", &clen);
     fb4:	e1a0200d 	mov	r2, sp
     fb8:	e1a00006 	mov	r0, r6
     fbc:	e59f1018 	ldr	r1, [pc, #24]	; fdc <tty_read+0x17c>
                }
                /* drop through */
            case '\n':
                if (priv->dev_info.tty_in_flags & CYG_TTY_IN_FLAGS_ECHO) {
                    if (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF) {
                        clen = 2;
     fc0:	e58d3000 	str	r3, [sp]
                        cyg_io_write(chan, "\r\n", &clen);
     fc4:	eb000329 	bl	1c70 <cyg_io_write>
                    } else {
                        clen = 1;
                        cyg_io_write(chan, &c, &clen);
                    }
                }
                buf[size-1] = c;
     fc8:	e5dd2007 	ldrb	r2, [sp, #7]
     fcc:	e08b3004 	add	r3, fp, r4
     fd0:	e5432001 	strb	r2, [r3, #-1]
     fd4:	eafffff1 	b	fa0 <tty_read+0x140>
     fd8:	0001294c 	.word	0x0001294c
     fdc:	00012950 	.word	0x00012950

00000fe0 <tty_write>:

#define BUFSIZE 64

static Cyg_ErrNo 
tty_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
     fe0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
     fe4:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    cyg_uint8 xbuf[BUFSIZE];
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    Cyg_ErrNo res = -EBADF;
    // assert(chan)
    size = 0;
     fe8:	e3a03000 	mov	r3, #0	; 0x0

#define BUFSIZE 64

static Cyg_ErrNo 
tty_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
     fec:	e58d2004 	str	r2, [sp, #4]
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
     ff0:	e5900014 	ldr	r0, [r0, #20]
    cyg_uint8 xbuf[BUFSIZE];
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    Cyg_ErrNo res = -EBADF;
    // assert(chan)
    size = 0;
     ff4:	e1a05003 	mov	r5, r3
     ff8:	e58d3054 	str	r3, [sp, #84]
     ffc:	e59d3004 	ldr	r3, [sp, #4]

static Cyg_ErrNo 
tty_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
    1000:	e58d000c 	str	r0, [sp, #12]

#define BUFSIZE 64

static Cyg_ErrNo 
tty_write(cyg_io_handle_t handle, const void *_buf, cyg_uint32 *len)
{
    1004:	e58d1008 	str	r1, [sp, #8]
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    struct tty_private_info *priv = (struct tty_private_info *)t->priv;
    cyg_io_handle_t chan = (cyg_io_handle_t)priv->dev_handle;
    1008:	e590b008 	ldr	fp, [r0, #8]
    cyg_uint8 xbuf[BUFSIZE];
    cyg_uint8 c;
    cyg_uint8 *buf = (cyg_uint8 *)_buf;
    Cyg_ErrNo res = -EBADF;
    // assert(chan)
    size = 0;
    100c:	e5937000 	ldr	r7, [r3]
    1010:	e1a0a005 	mov	sl, r5
    1014:	e3e08008 	mvn	r8, #8	; 0x8
    bytes_successful = 0;
    actually_written = 0;
    while (bytes_successful++ < *len) {
    1018:	e1550007 	cmp	r5, r7
    101c:	2a00001b 	bcs	1090 <tty_write+0xb0>
        c = *buf++;
    1020:	e59d9008 	ldr	r9, [sp, #8]
    1024:	e7d96005 	ldrb	r6, [r9, r5]
        if ((c == '\n') &&
    1028:	e356000a 	cmp	r6, #10	; 0xa
    102c:	0a00001a 	beq	109c <tty_write+0xbc>
    1030:	e59d4054 	ldr	r4, [sp, #84]
            (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF)) {
            xbuf[size++] = '\r';
        }
        xbuf[size++] = c;
    1034:	e284c001 	add	ip, r4, #1	; 0x1
    1038:	e28d9058 	add	r9, sp, #88	; 0x58
    103c:	e0893004 	add	r3, r9, r4
        // Always leave room for possible CR/LF expansion
        if ((size >= (BUFSIZE-1)) ||
    1040:	e35c003e 	cmp	ip, #62	; 0x3e
            (bytes_successful == *len)) {
            res = cyg_io_write(chan, xbuf, &size);
    1044:	e1a0000b 	mov	r0, fp
    1048:	e28d1014 	add	r1, sp, #20	; 0x14
    104c:	e28d2054 	add	r2, sp, #84	; 0x54
        c = *buf++;
        if ((c == '\n') &&
            (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF)) {
            xbuf[size++] = '\r';
        }
        xbuf[size++] = c;
    1050:	e5436044 	strb	r6, [r3, #-68]
    1054:	e58dc054 	str	ip, [sp, #84]
    Cyg_ErrNo res = -EBADF;
    // assert(chan)
    size = 0;
    bytes_successful = 0;
    actually_written = 0;
    while (bytes_successful++ < *len) {
    1058:	e2855001 	add	r5, r5, #1	; 0x1
            (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF)) {
            xbuf[size++] = '\r';
        }
        xbuf[size++] = c;
        // Always leave room for possible CR/LF expansion
        if ((size >= (BUFSIZE-1)) ||
    105c:	8a000001 	bhi	1068 <tty_write+0x88>
    1060:	e1570005 	cmp	r7, r5
    1064:	1affffeb 	bne	1018 <tty_write+0x38>
            (bytes_successful == *len)) {
            res = cyg_io_write(chan, xbuf, &size);
    1068:	eb000300 	bl	1c70 <cyg_io_write>
            if (res != ENOERR) {
    106c:	e2508000 	subs	r8, r0, #0	; 0x0
    1070:	1a000014 	bne	10c8 <tty_write+0xe8>
                *len = actually_written;
                return res;
            }
            actually_written += size;
    1074:	e59d4054 	ldr	r4, [sp, #84]
            size = 0;
    1078:	e59d3004 	ldr	r3, [sp, #4]
    107c:	e58d8054 	str	r8, [sp, #84]
    1080:	e5937000 	ldr	r7, [r3]
    Cyg_ErrNo res = -EBADF;
    // assert(chan)
    size = 0;
    bytes_successful = 0;
    actually_written = 0;
    while (bytes_successful++ < *len) {
    1084:	e1550007 	cmp	r5, r7
            res = cyg_io_write(chan, xbuf, &size);
            if (res != ENOERR) {
                *len = actually_written;
                return res;
            }
            actually_written += size;
    1088:	e08aa004 	add	sl, sl, r4
    Cyg_ErrNo res = -EBADF;
    // assert(chan)
    size = 0;
    bytes_successful = 0;
    actually_written = 0;
    while (bytes_successful++ < *len) {
    108c:	3affffe3 	bcc	1020 <tty_write+0x40>
            actually_written += size;
            size = 0;
        }
    }
    return res;
}
    1090:	e1a00008 	mov	r0, r8
    1094:	e28dd05c 	add	sp, sp, #92	; 0x5c
    1098:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    size = 0;
    bytes_successful = 0;
    actually_written = 0;
    while (bytes_successful++ < *len) {
        c = *buf++;
        if ((c == '\n') &&
    109c:	e59d200c 	ldr	r2, [sp, #12]
    10a0:	e5923000 	ldr	r3, [r2]
    10a4:	e3130001 	tst	r3, #1	; 0x1
    10a8:	0affffe0 	beq	1030 <tty_write+0x50>
            (priv->dev_info.tty_out_flags & CYG_TTY_OUT_FLAGS_CRLF)) {
            xbuf[size++] = '\r';
    10ac:	e59d4054 	ldr	r4, [sp, #84]
    10b0:	e28d9058 	add	r9, sp, #88	; 0x58
    10b4:	e0893004 	add	r3, r9, r4
    10b8:	e3a0200d 	mov	r2, #13	; 0xd
    10bc:	e5432044 	strb	r2, [r3, #-68]
    10c0:	e2844001 	add	r4, r4, #1	; 0x1
    10c4:	eaffffda 	b	1034 <tty_write+0x54>
        // Always leave room for possible CR/LF expansion
        if ((size >= (BUFSIZE-1)) ||
            (bytes_successful == *len)) {
            res = cyg_io_write(chan, xbuf, &size);
            if (res != ENOERR) {
                *len = actually_written;
    10c8:	e59d2004 	ldr	r2, [sp, #4]
    10cc:	e582a000 	str	sl, [r2]
    10d0:	eaffffee 	b	1090 <tty_write+0xb0>

000010d4 <haldiag_init>:
#ifdef CYGDBG_IO_INIT
    diag_printf("HAL/diag SERIAL init\n");
#endif
    haldiag_config_port(chan);
    return true;
}
    10d4:	e3a00001 	mov	r0, #1	; 0x1
    10d8:	e12fff1e 	bx	lr

000010dc <haldiag_set_config>:
}

static Cyg_ErrNo
haldiag_set_config(serial_channel *chan, cyg_uint32 key, const void *xbuf,
                   cyg_uint32 *len)
{
    10dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    switch (key) {
    10e0:	e3a03d06 	mov	r3, #384	; 0x180
    10e4:	e2833001 	add	r3, r3, #1	; 0x1
    10e8:	e1510003 	cmp	r1, r3
}

static Cyg_ErrNo
haldiag_set_config(serial_channel *chan, cyg_uint32 key, const void *xbuf,
                   cyg_uint32 *len)
{
    10ec:	e24dd004 	sub	sp, sp, #4	; 0x4
    switch (key) {
    10f0:	13e00015 	mvnne	r0, #21	; 0x15
    10f4:	0a000001 	beq	1100 <haldiag_set_config+0x24>
        diag_printf("%s\n", __FUNCTION__);
        return ENOERR;
    default:
        return -EINVAL;
    }
}
    10f8:	e28dd004 	add	sp, sp, #4	; 0x4
    10fc:	e8bd8000 	pop	{pc}
haldiag_set_config(serial_channel *chan, cyg_uint32 key, const void *xbuf,
                   cyg_uint32 *len)
{
    switch (key) {
    case CYG_IO_SET_CONFIG_SERIAL_INFO:
        diag_printf("%s\n", __FUNCTION__);
    1100:	e59f000c 	ldr	r0, [pc, #12]	; 1114 <haldiag_set_config+0x38>
    1104:	e59f100c 	ldr	r1, [pc, #12]	; 1118 <haldiag_set_config+0x3c>
    1108:	eb000755 	bl	2e64 <diag_printf>
    110c:	e3a00000 	mov	r0, #0	; 0x0
    1110:	eafffff8 	b	10f8 <haldiag_set_config+0x1c>
    1114:	00012a68 	.word	0x00012a68
    1118:	00012974 	.word	0x00012974

0000111c <haldiag_getc>:
    return true;
}

static unsigned char 
haldiag_getc(serial_channel *chan)
{
    111c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    1120:	e24dd00c 	sub	sp, sp, #12	; 0xc
    char c;
    HAL_DIAG_READ_CHAR(c);
    1124:	e28d0007 	add	r0, sp, #7	; 0x7
    1128:	eb000135 	bl	1604 <hal_if_diag_read_char>
    return (unsigned char)c;
}
    112c:	e5dd0007 	ldrb	r0, [sp, #7]
    1130:	e28dd00c 	add	sp, sp, #12	; 0xc
    1134:	e8bd8000 	pop	{pc}

00001138 <haldiag_putc>:
}

// Return 'true' if character is sent to device
static bool
haldiag_putc(serial_channel *chan, unsigned char c)
{
    1138:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    HAL_DIAG_WRITE_CHAR(c);
    113c:	e1a00001 	mov	r0, r1
}

// Return 'true' if character is sent to device
static bool
haldiag_putc(serial_channel *chan, unsigned char c)
{
    1140:	e24dd004 	sub	sp, sp, #4	; 0x4
    HAL_DIAG_WRITE_CHAR(c);
    1144:	eb00019f 	bl	17c8 <hal_if_diag_write_char>
    return true;
}
    1148:	e3a00001 	mov	r0, #1	; 0x1
    114c:	e28dd004 	add	sp, sp, #4	; 0x4
    1150:	e8bd8000 	pop	{pc}

00001154 <cyg_iso_c_start>:
    static int initialized=0;

    CYG_REPORT_FUNCNAME( "cyg_iso_c_start" );
    CYG_REPORT_FUNCARGVOID();

    if (initialized++ == 0) {
    1154:	e59f2018 	ldr	r2, [pc, #24]	; 1174 <cyg_iso_c_start+0x20>
    1158:	e5923000 	ldr	r3, [r2]
    115c:	e3530000 	cmp	r3, #0	; 0x0
    1160:	e2833001 	add	r3, r3, #1	; 0x1
    1164:	e5823000 	str	r3, [r2]
    1168:	112fff1e 	bxne	lr
        CYG_TRACE0( true, "Resuming cyg_libc_main_thread" );
        cyg_libc_main_thread.resume();
    116c:	e59f0004 	ldr	r0, [pc, #4]	; 1178 <cyg_iso_c_start+0x24>
    1170:	ea000c05 	b	418c <_ZN10Cyg_Thread6resumeEv>
    1174:	40001bb0 	.word	0x40001bb0
    1178:	400025c8 	.word	0x400025c8

0000117c <_GLOBAL__I.56100_cyg_iso_c_start>:

// define an object that will automatically call cyg_iso_c_start()

class cyg_libc_startup_dummy_constructor_class {
public:
    cyg_libc_startup_dummy_constructor_class() { cyg_iso_c_start(); }
    117c:	eafffff4 	b	1154 <cyg_iso_c_start>

00001180 <nop_service>:
{
    // This is the default service. It always returns false (0), and
    // _does not_ trigger any assertions. Clients must either cope
    // with the service failure or assert.
    return 0;
}
    1180:	e3a00000 	mov	r0, #0	; 0x0
    1184:	e12fff1e 	bx	lr

00001188 <set_debug_comm>:

    CYG_ASSERT(__comm_id >= CYGNUM_CALL_IF_SET_COMM_ID_MANGLER
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    1188:	e3700002 	cmn	r0, #2	; 0x2

static hal_virtual_comm_table_t comm_channels[CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS+1];

static int
set_debug_comm(int __comm_id)
{
    118c:	e92d4070 	push	{r4, r5, r6, lr}

    CYG_ASSERT(__comm_id >= CYGNUM_CALL_IF_SET_COMM_ID_MANGLER
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    1190:	0a000031 	beq	125c <set_debug_comm+0xd4>
    1194:	e3700001 	cmn	r0, #1	; 0x1
    1198:	0a000036 	beq	1278 <set_debug_comm+0xf0>
    119c:	e3700003 	cmn	r0, #3	; 0x3
        __comm_id = 0;
        update = 1;
        break;

    default:
        __comm_id++;                    // skip mangler entry
    11a0:	12805001 	addne	r5, r0, #1	; 0x1
    11a4:	11a04285 	lslne	r4, r5, #5

    CYG_ASSERT(__comm_id >= CYGNUM_CALL_IF_SET_COMM_ID_MANGLER
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    11a8:	0a000018 	beq	1210 <set_debug_comm+0x88>
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    11ac:	e59f60e0 	ldr	r6, [pc, #224]	; 1294 <set_debug_comm+0x10c>
    11b0:	e5960018 	ldr	r0, [r6, #24]
    }

    if (update) {
        // Find the interrupt state of the channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (__chan)
    11b4:	e3500000 	cmp	r0, #0	; 0x0
    11b8:	0a00001a 	beq	1228 <set_debug_comm+0xa0>
            interrupt_state = CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);
    11bc:	e5902014 	ldr	r2, [r0, #20]
    11c0:	e3a01004 	mov	r1, #4	; 0x4
    11c4:	e5900000 	ldr	r0, [r0]
    11c8:	e1a0e00f 	mov	lr, pc
    11cc:	e12fff12 	bx	r2

        __selected_id = __comm_id;
        CYGACC_CALL_IF_DEBUG_PROCS_SET(comm_channels[__comm_id]);
    11d0:	e59f30c0 	ldr	r3, [pc, #192]	; 1298 <set_debug_comm+0x110>
    11d4:	e0833004 	add	r3, r3, r4
    11d8:	e5863018 	str	r3, [r6, #24]
        // Find the interrupt state of the channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (__chan)
            interrupt_state = CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);

        __selected_id = __comm_id;
    11dc:	e59f30b8 	ldr	r3, [pc, #184]	; 129c <set_debug_comm+0x114>
    11e0:	e5962018 	ldr	r2, [r6, #24]
        CYGACC_CALL_IF_DEBUG_PROCS_SET(comm_channels[__comm_id]);

        // Set interrupt state on the new channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (interrupt_state)
    11e4:	e3500000 	cmp	r0, #0	; 0x0
        // Find the interrupt state of the channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (__chan)
            interrupt_state = CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);

        __selected_id = __comm_id;
    11e8:	e5835000 	str	r5, [r3]
    11ec:	e1a00002 	mov	r0, r2
        CYGACC_CALL_IF_DEBUG_PROCS_SET(comm_channels[__comm_id]);

        // Set interrupt state on the new channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (interrupt_state)
    11f0:	0a000012 	beq	1240 <set_debug_comm+0xb8>
            CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_ENABLE);
    11f4:	e5923014 	ldr	r3, [r2, #20]
    11f8:	e3a01005 	mov	r1, #5	; 0x5
    11fc:	e5920000 	ldr	r0, [r2]
    1200:	e1a0e00f 	mov	lr, pc
    1204:	e12fff13 	bx	r3
    1208:	e3a00001 	mov	r0, #1	; 0x1
    120c:	e8bd8070 	pop	{r4, r5, r6, pc}
    1210:	e59f607c 	ldr	r6, [pc, #124]	; 1294 <set_debug_comm+0x10c>
    1214:	e5960018 	ldr	r0, [r6, #24]
        else
            CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);
    1218:	e3a05000 	mov	r5, #0	; 0x0
    }

    if (update) {
        // Find the interrupt state of the channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (__chan)
    121c:	e3500000 	cmp	r0, #0	; 0x0
        // Set interrupt state on the new channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (interrupt_state)
            CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_ENABLE);
        else
            CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);
    1220:	e1a04005 	mov	r4, r5
    }

    if (update) {
        // Find the interrupt state of the channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (__chan)
    1224:	1affffe4 	bne	11bc <set_debug_comm+0x34>
            interrupt_state = CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);

        __selected_id = __comm_id;
        CYGACC_CALL_IF_DEBUG_PROCS_SET(comm_channels[__comm_id]);
    1228:	e59f3068 	ldr	r3, [pc, #104]	; 1298 <set_debug_comm+0x110>
    122c:	e0833004 	add	r3, r3, r4
    1230:	e5863018 	str	r3, [r6, #24]
        // Find the interrupt state of the channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (__chan)
            interrupt_state = CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);

        __selected_id = __comm_id;
    1234:	e59f2060 	ldr	r2, [pc, #96]	; 129c <set_debug_comm+0x114>
    1238:	e5960018 	ldr	r0, [r6, #24]
    123c:	e5825000 	str	r5, [r2]
        // Set interrupt state on the new channel.
        __chan = CYGACC_CALL_IF_DEBUG_PROCS();
        if (interrupt_state)
            CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_ENABLE);
        else
            CYGACC_COMM_IF_CONTROL(*__chan, __COMMCTL_IRQ_DISABLE);
    1240:	e5903014 	ldr	r3, [r0, #20]
    1244:	e3a01004 	mov	r1, #4	; 0x4
    1248:	e5900000 	ldr	r0, [r0]
    124c:	e1a0e00f 	mov	lr, pc
    1250:	e12fff13 	bx	r3
    1254:	e3a00001 	mov	r0, #1	; 0x1
    }

    CYGARC_HAL_RESTORE_GP();
    return res;
}
    1258:	e8bd8070 	pop	{r4, r5, r6, pc}
        else 
            res = __selected_id;
        break;

    case CYGNUM_CALL_IF_SET_COMM_ID_EMPTY:
        CYGACC_CALL_IF_DEBUG_PROCS_SET(0);
    125c:	e59f2030 	ldr	r2, [pc, #48]	; 1294 <set_debug_comm+0x10c>
        __selected_id = __comm_id;
    1260:	e59f1034 	ldr	r1, [pc, #52]	; 129c <set_debug_comm+0x114>
        else 
            res = __selected_id;
        break;

    case CYGNUM_CALL_IF_SET_COMM_ID_EMPTY:
        CYGACC_CALL_IF_DEBUG_PROCS_SET(0);
    1264:	e3a03000 	mov	r3, #0	; 0x0
        __selected_id = __comm_id;
    1268:	e5810000 	str	r0, [r1]
        else 
            res = __selected_id;
        break;

    case CYGNUM_CALL_IF_SET_COMM_ID_EMPTY:
        CYGACC_CALL_IF_DEBUG_PROCS_SET(0);
    126c:	e5823018 	str	r3, [r2, #24]
        __selected_id = __comm_id;
    1270:	e3a00001 	mov	r0, #1	; 0x1
    1274:	e8bd8070 	pop	{r4, r5, r6, pc}
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    case CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT:
        if (__selected_id > 0)
    1278:	e59f301c 	ldr	r3, [pc, #28]	; 129c <set_debug_comm+0x114>
    127c:	e5930000 	ldr	r0, [r3]
    1280:	e3500000 	cmp	r0, #0	; 0x0
            res = __selected_id-1;
    1284:	c2400001 	subgt	r0, r0, #1	; 0x1
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    case CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT:
        if (__selected_id > 0)
    1288:	c8bd8070 	popgt	{r4, r5, r6, pc}
        __comm_id = 0;
        update = 1;
        break;

    default:
        __comm_id++;                    // skip mangler entry
    128c:	03e00002 	mvneq	r0, #2	; 0x2
    1290:	e8bd8070 	pop	{r4, r5, r6, pc}
    1294:	40000430 	.word	0x40000430
    1298:	40001bbc 	.word	0x40001bbc
    129c:	07b8      	.short	0x07b8
    129e:	4000      	.short	0x4000

000012a0 <set_console_comm>:

    CYG_ASSERT(__comm_id >= CYGNUM_CALL_IF_SET_COMM_ID_MANGLER
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    12a0:	e3700002 	cmn	r0, #2	; 0x2
    12a4:	0a000018 	beq	130c <set_console_comm+0x6c>
    12a8:	e3700001 	cmn	r0, #1	; 0x1
    12ac:	0a00000e 	beq	12ec <set_console_comm+0x4c>
    12b0:	e3700003 	cmn	r0, #3	; 0x3
        __comm_id = 0;
        update = 1;
        break;

    default:
        __comm_id++;                    // skip mangler entry
    12b4:	12800001 	addne	r0, r0, #1	; 0x1
    12b8:	11a02280 	lslne	r2, r0, #5

    CYG_ASSERT(__comm_id >= CYGNUM_CALL_IF_SET_COMM_ID_MANGLER
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    12bc:	0a000007 	beq	12e0 <set_console_comm+0x40>
    }
    
    if (update) {
        __selected_id = __comm_id;
    
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(comm_channels[__comm_id]);
    12c0:	e59f3060 	ldr	r3, [pc, #96]	; 1328 <set_console_comm+0x88>
    12c4:	e59f1060 	ldr	r1, [pc, #96]	; 132c <set_console_comm+0x8c>
    12c8:	e0833002 	add	r3, r3, r2
        update = 1;
        break;
    }
    
    if (update) {
        __selected_id = __comm_id;
    12cc:	e59f205c 	ldr	r2, [pc, #92]	; 1330 <set_console_comm+0x90>
    
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(comm_channels[__comm_id]);
    12d0:	e5813014 	str	r3, [r1, #20]
        update = 1;
        break;
    }
    
    if (update) {
        __selected_id = __comm_id;
    12d4:	e5820000 	str	r0, [r2]
    
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(comm_channels[__comm_id]);
    12d8:	e3a00001 	mov	r0, #1	; 0x1
    12dc:	e12fff1e 	bx	lr
        __comm_id = 0;
        update = 1;
        break;

    default:
        __comm_id++;                    // skip mangler entry
    12e0:	e3a00000 	mov	r0, #0	; 0x0
    12e4:	e1a02000 	mov	r2, r0
    12e8:	eafffff4 	b	12c0 <set_console_comm+0x20>
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    case CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT:
        if (__selected_id > 0)
    12ec:	e59f303c 	ldr	r3, [pc, #60]	; 1330 <set_console_comm+0x90>
    12f0:	e5930000 	ldr	r0, [r3]
    12f4:	e3500000 	cmp	r0, #0	; 0x0
            res = __selected_id-1;
    12f8:	c2400001 	subgt	r0, r0, #1	; 0x1
               && __comm_id < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS,
               "Invalid channel");

    switch (__comm_id) {
    case CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT:
        if (__selected_id > 0)
    12fc:	c12fff1e 	bxgt	lr
            res = __selected_id-1;
        else if (__selected_id == 0)
    1300:	112fff1e 	bxne	lr
        __comm_id = 0;
        update = 1;
        break;

    default:
        __comm_id++;                    // skip mangler entry
    1304:	e3e00002 	mvn	r0, #2	; 0x2
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(comm_channels[__comm_id]);
    }

    CYGARC_HAL_RESTORE_GP();
    return res;
}
    1308:	e12fff1e 	bx	lr
        else
            res = __selected_id;
        break;

    case CYGNUM_CALL_IF_SET_COMM_ID_EMPTY:
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(0);
    130c:	e59f2018 	ldr	r2, [pc, #24]	; 132c <set_console_comm+0x8c>
        __selected_id = __comm_id;
    1310:	e59f1018 	ldr	r1, [pc, #24]	; 1330 <set_console_comm+0x90>
        else
            res = __selected_id;
        break;

    case CYGNUM_CALL_IF_SET_COMM_ID_EMPTY:
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(0);
    1314:	e3a03000 	mov	r3, #0	; 0x0
        __selected_id = __comm_id;
    1318:	e5810000 	str	r0, [r1]
        else
            res = __selected_id;
        break;

    case CYGNUM_CALL_IF_SET_COMM_ID_EMPTY:
        CYGACC_CALL_IF_CONSOLE_PROCS_SET(0);
    131c:	e5823014 	str	r3, [r2, #20]
        __selected_id = __comm_id;
    1320:	e3a00001 	mov	r0, #1	; 0x1
    1324:	e12fff1e 	bx	lr
    1328:	40001bbc 	.word	0x40001bbc
    132c:	40000430 	.word	0x40000430
    1330:	400007b4 	.word	0x400007b4

00001334 <cyg_hal_diag_mangler_gdb_getc>:
// This gets called via the virtual vector console comms entry and
// handles O-packetization. The debug comms entries are used for the
// actual device IO.
static cyg_uint8
cyg_hal_diag_mangler_gdb_getc(void* __ch_data)
{
    1334:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    1338:	e59f301c 	ldr	r3, [pc, #28]	; 135c <cyg_hal_diag_mangler_gdb_getc+0x28>
    133c:	e5932018 	ldr	r2, [r3, #24]
    1340:	e24dd004 	sub	sp, sp, #4	; 0x4
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    1344:	e5920000 	ldr	r0, [r2]
    1348:	e5923010 	ldr	r3, [r2, #16]
    134c:	e1a0e00f 	mov	lr, pc
    1350:	e12fff13 	bx	r3
    __ch = CYGACC_COMM_IF_GETC(*__chan);

    CYGARC_HAL_RESTORE_GP();

    return __ch;
}
    1354:	e28dd004 	add	sp, sp, #4	; 0x4
    1358:	e8bd8000 	pop	{pc}
    135c:	40000430 	.word	0x40000430

00001360 <cyg_hal_diag_mangler_gdb_read>:
}

static void
cyg_hal_diag_mangler_gdb_read(void* __ch_data, 
                              cyg_uint8* __buf, cyg_uint32 __len)
{
    1360:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1364:	e2526000 	subs	r6, r2, #0	; 0x0
}

static void
cyg_hal_diag_mangler_gdb_read(void* __ch_data, 
                              cyg_uint8* __buf, cyg_uint32 __len)
{
    1368:	e24dd004 	sub	sp, sp, #4	; 0x4
    136c:	e1a05001 	mov	r5, r1
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1370:	0a00000a 	beq	13a0 <cyg_hal_diag_mangler_gdb_read+0x40>
    1374:	e59f702c 	ldr	r7, [pc, #44]	; 13a8 <cyg_hal_diag_mangler_gdb_read+0x48>
    1378:	e3a04000 	mov	r4, #0	; 0x0
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    137c:	e5973018 	ldr	r3, [r7, #24]
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    1380:	e5930000 	ldr	r0, [r3]
    1384:	e5932010 	ldr	r2, [r3, #16]
    1388:	e1a0e00f 	mov	lr, pc
    138c:	e12fff12 	bx	r2
        *__buf++ = cyg_hal_diag_mangler_gdb_getc(__ch_data);
    1390:	e7c50004 	strb	r0, [r5, r4]
    1394:	e2844001 	add	r4, r4, #1	; 0x1
cyg_hal_diag_mangler_gdb_read(void* __ch_data, 
                              cyg_uint8* __buf, cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1398:	e1540006 	cmp	r4, r6
    139c:	1afffff6 	bne	137c <cyg_hal_diag_mangler_gdb_read+0x1c>
        *__buf++ = cyg_hal_diag_mangler_gdb_getc(__ch_data);

    CYGARC_HAL_RESTORE_GP();
}
    13a0:	e28dd004 	add	sp, sp, #4	; 0x4
    13a4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    13a8:	40000430 	.word	0x40000430

000013ac <cyg_hal_diag_mangler_gdb_init>:
// and diag init code to initialize the COMMS mangler channel table -
// that's all. The callers have to decide whether to actually use this
// channel.
void
cyg_hal_diag_mangler_gdb_init(void)
{
    13ac:	e92d4030 	push	{r4, r5, lr}
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    13b0:	e59f4068 	ldr	r4, [pc, #104]	; 1420 <cyg_hal_diag_mangler_gdb_init+0x74>
    13b4:	e24dd004 	sub	sp, sp, #4	; 0x4
    13b8:	e5943034 	ldr	r3, [r4, #52]
    13bc:	e3e00000 	mvn	r0, #0	; 0x0
    13c0:	e1a0e00f 	mov	lr, pc
    13c4:	e12fff13 	bx	r3
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    13c8:	e5943034 	ldr	r3, [r4, #52]
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    13cc:	e1a05000 	mov	r5, r0
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    13d0:	e3e00002 	mvn	r0, #2	; 0x2
    13d4:	e1a0e00f 	mov	lr, pc
    13d8:	e12fff13 	bx	r3
    13dc:	e5941014 	ldr	r1, [r4, #20]
    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);

    // Initialize mangler procs
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_gdb_write);
    13e0:	e59f303c 	ldr	r3, [pc, #60]	; 1424 <cyg_hal_diag_mangler_gdb_init+0x78>
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_gdb_read);
    13e4:	e59f203c 	ldr	r2, [pc, #60]	; 1428 <cyg_hal_diag_mangler_gdb_init+0x7c>
    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);

    // Initialize mangler procs
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_gdb_write);
    13e8:	e5813004 	str	r3, [r1, #4]
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_gdb_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_diag_mangler_gdb_putc);
    13ec:	e59f3038 	ldr	r3, [pc, #56]	; 142c <cyg_hal_diag_mangler_gdb_init+0x80>

    // Initialize mangler procs
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_gdb_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_gdb_read);
    13f0:	e5812008 	str	r2, [r1, #8]
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_diag_mangler_gdb_putc);
    13f4:	e581300c 	str	r3, [r1, #12]
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_diag_mangler_gdb_getc);
    13f8:	e59f2030 	ldr	r2, [pc, #48]	; 1430 <cyg_hal_diag_mangler_gdb_init+0x84>
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_diag_mangler_gdb_control);
    13fc:	e59f3030 	ldr	r3, [pc, #48]	; 1434 <cyg_hal_diag_mangler_gdb_init+0x88>
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_gdb_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_gdb_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_diag_mangler_gdb_putc);
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_diag_mangler_gdb_getc);
    1400:	e5812010 	str	r2, [r1, #16]
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_diag_mangler_gdb_control);
    1404:	e5813014 	str	r3, [r1, #20]
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    1408:	e1a00005 	mov	r0, r5
    140c:	e5943034 	ldr	r3, [r4, #52]
    1410:	e1a0e00f 	mov	lr, pc
    1414:	e12fff13 	bx	r3
    
    // Restore the original console channel.
    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
}
    1418:	e28dd004 	add	sp, sp, #4	; 0x4
    141c:	e8bd8030 	pop	{r4, r5, pc}
    1420:	40000430 	.word	0x40000430
    1424:	00001a68 	.word	0x00001a68
    1428:	00001360 	.word	0x00001360
    142c:	00001a10 	.word	0x00001a10
    1430:	00001334 	.word	0x00001334
    1434:	000019e4 	.word	0x000019e4

00001438 <cyg_hal_diag_mangler_null_getc>:
// This differs from setting the console channel to the same as the
// debug channel in that console output will go to the debug channel
// even if the debug channel is changed.
static cyg_uint8
cyg_hal_diag_mangler_null_getc(void* __ch_data)
{
    1438:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    143c:	e59f301c 	ldr	r3, [pc, #28]	; 1460 <cyg_hal_diag_mangler_null_getc+0x28>
    1440:	e5932018 	ldr	r2, [r3, #24]
    1444:	e24dd004 	sub	sp, sp, #4	; 0x4
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    1448:	e5920000 	ldr	r0, [r2]
    144c:	e5923010 	ldr	r3, [r2, #16]
    1450:	e1a0e00f 	mov	lr, pc
    1454:	e12fff13 	bx	r3
    __ch = CYGACC_COMM_IF_GETC(*__chan);

    CYGARC_HAL_RESTORE_GP();

    return __ch;
}
    1458:	e28dd004 	add	sp, sp, #4	; 0x4
    145c:	e8bd8000 	pop	{pc}
    1460:	40000430 	.word	0x40000430

00001464 <cyg_hal_diag_mangler_null_putc>:


static void
cyg_hal_diag_mangler_null_putc(void* __ch_data, cyg_uint8 c)
{
    1464:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    1468:	e59f301c 	ldr	r3, [pc, #28]	; 148c <cyg_hal_diag_mangler_null_putc+0x28>
    146c:	e5932018 	ldr	r2, [r3, #24]
    1470:	e24dd004 	sub	sp, sp, #4	; 0x4
#define CYGACC_COMM_IF_READ(_t_, _b_, _l_) \
 __call_COMM_IF_READ(_t_, _b_, _l_)
#define CYGACC_COMM_IF_READ_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_READ]=(CYG_ADDRWORD)(_x_)

__call_voidCOMM1(IF_PUTC, void, __comm_if_putc_t, cyg_uint8)
    1474:	e5920000 	ldr	r0, [r2]
    1478:	e592300c 	ldr	r3, [r2, #12]
    147c:	e1a0e00f 	mov	lr, pc
    1480:	e12fff13 	bx	r3
    CYGARC_HAL_SAVE_GP();

    CYGACC_COMM_IF_PUTC(*__chan, c);

    CYGARC_HAL_RESTORE_GP();
}
    1484:	e28dd004 	add	sp, sp, #4	; 0x4
    1488:	e8bd8000 	pop	{pc}
    148c:	40000430 	.word	0x40000430

00001490 <cyg_hal_diag_mangler_null_write>:

static void
cyg_hal_diag_mangler_null_write(void* __ch_data,
                                const cyg_uint8* __buf, cyg_uint32 __len)
{
    1490:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1494:	e2526000 	subs	r6, r2, #0	; 0x0
}

static void
cyg_hal_diag_mangler_null_write(void* __ch_data,
                                const cyg_uint8* __buf, cyg_uint32 __len)
{
    1498:	e24dd004 	sub	sp, sp, #4	; 0x4
    149c:	e1a05001 	mov	r5, r1
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    14a0:	0a00000a 	beq	14d0 <cyg_hal_diag_mangler_null_write+0x40>
    14a4:	e59f702c 	ldr	r7, [pc, #44]	; 14d8 <cyg_hal_diag_mangler_null_write+0x48>
    14a8:	e3a04000 	mov	r4, #0	; 0x0
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    14ac:	e5973018 	ldr	r3, [r7, #24]
#define CYGACC_COMM_IF_READ(_t_, _b_, _l_) \
 __call_COMM_IF_READ(_t_, _b_, _l_)
#define CYGACC_COMM_IF_READ_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_READ]=(CYG_ADDRWORD)(_x_)

__call_voidCOMM1(IF_PUTC, void, __comm_if_putc_t, cyg_uint8)
    14b0:	e7d51004 	ldrb	r1, [r5, r4]
    14b4:	e5930000 	ldr	r0, [r3]
    14b8:	e2844001 	add	r4, r4, #1	; 0x1
    14bc:	e593200c 	ldr	r2, [r3, #12]
    14c0:	e1a0e00f 	mov	lr, pc
    14c4:	e12fff12 	bx	r2
    14c8:	e1540006 	cmp	r4, r6
    14cc:	1afffff6 	bne	14ac <cyg_hal_diag_mangler_null_write+0x1c>
        cyg_hal_diag_mangler_null_putc(__ch_data, *__buf++);

    CYGARC_HAL_RESTORE_GP();
}
    14d0:	e28dd004 	add	sp, sp, #4	; 0x4
    14d4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    14d8:	40000430 	.word	0x40000430

000014dc <cyg_hal_diag_mangler_null_read>:

static void
cyg_hal_diag_mangler_null_read(void* __ch_data, 
                               cyg_uint8* __buf, cyg_uint32 __len)
{
    14dc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    14e0:	e2526000 	subs	r6, r2, #0	; 0x0
}

static void
cyg_hal_diag_mangler_null_read(void* __ch_data, 
                               cyg_uint8* __buf, cyg_uint32 __len)
{
    14e4:	e24dd004 	sub	sp, sp, #4	; 0x4
    14e8:	e1a05001 	mov	r5, r1
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    14ec:	0a00000a 	beq	151c <cyg_hal_diag_mangler_null_read+0x40>
    14f0:	e59f702c 	ldr	r7, [pc, #44]	; 1524 <cyg_hal_diag_mangler_null_read+0x48>
    14f4:	e3a04000 	mov	r4, #0	; 0x0
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    14f8:	e5973018 	ldr	r3, [r7, #24]
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    14fc:	e5930000 	ldr	r0, [r3]
    1500:	e5932010 	ldr	r2, [r3, #16]
    1504:	e1a0e00f 	mov	lr, pc
    1508:	e12fff12 	bx	r2
        *__buf++ = cyg_hal_diag_mangler_null_getc(__ch_data);
    150c:	e7c50004 	strb	r0, [r5, r4]
    1510:	e2844001 	add	r4, r4, #1	; 0x1
cyg_hal_diag_mangler_null_read(void* __ch_data, 
                               cyg_uint8* __buf, cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1514:	e1540006 	cmp	r4, r6
    1518:	1afffff6 	bne	14f8 <cyg_hal_diag_mangler_null_read+0x1c>
        *__buf++ = cyg_hal_diag_mangler_null_getc(__ch_data);

    CYGARC_HAL_RESTORE_GP();
}
    151c:	e28dd004 	add	sp, sp, #4	; 0x4
    1520:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    1524:	40000430 	.word	0x40000430

00001528 <cyg_hal_diag_mangler_null_control>:

static int
cyg_hal_diag_mangler_null_control(void *__ch_data, 
                                  __comm_control_cmd_t __func, ...)
{
    1528:	e92d000e 	push	{r1, r2, r3}
    // Do nothing (yet).
    return 0;
}
    152c:	e3a00000 	mov	r0, #0	; 0x0
    1530:	e28dd00c 	add	sp, sp, #12	; 0xc
    1534:	e12fff1e 	bx	lr

00001538 <cyg_hal_diag_mangler_null_init>:
// and diag init code to initialize the COMMS mangler channel table -
// that's all. The callers have to decide whether to actually use this
// channel.
void
cyg_hal_diag_mangler_null_init(void)
{
    1538:	e92d4030 	push	{r4, r5, lr}
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    153c:	e59f4068 	ldr	r4, [pc, #104]	; 15ac <cyg_hal_diag_mangler_null_init+0x74>
    1540:	e24dd004 	sub	sp, sp, #4	; 0x4
    1544:	e5943034 	ldr	r3, [r4, #52]
    1548:	e3e00000 	mvn	r0, #0	; 0x0
    154c:	e1a0e00f 	mov	lr, pc
    1550:	e12fff13 	bx	r3
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    1554:	e5943034 	ldr	r3, [r4, #52]
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    1558:	e1a05000 	mov	r5, r0
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    155c:	e3e00002 	mvn	r0, #2	; 0x2
    1560:	e1a0e00f 	mov	lr, pc
    1564:	e12fff13 	bx	r3
    1568:	e5941014 	ldr	r1, [r4, #20]
    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);

    // Initialize mangler procs
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_null_write);
    156c:	e59f303c 	ldr	r3, [pc, #60]	; 15b0 <cyg_hal_diag_mangler_null_init+0x78>
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_null_read);
    1570:	e59f203c 	ldr	r2, [pc, #60]	; 15b4 <cyg_hal_diag_mangler_null_init+0x7c>
    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);

    // Initialize mangler procs
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_null_write);
    1574:	e5813004 	str	r3, [r1, #4]
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_null_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_diag_mangler_null_putc);
    1578:	e59f3038 	ldr	r3, [pc, #56]	; 15b8 <cyg_hal_diag_mangler_null_init+0x80>

    // Initialize mangler procs
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_null_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_null_read);
    157c:	e5812008 	str	r2, [r1, #8]
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_diag_mangler_null_putc);
    1580:	e581300c 	str	r3, [r1, #12]
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_diag_mangler_null_getc);
    1584:	e59f2030 	ldr	r2, [pc, #48]	; 15bc <cyg_hal_diag_mangler_null_init+0x84>
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_diag_mangler_null_control);
    1588:	e59f3030 	ldr	r3, [pc, #48]	; 15c0 <cyg_hal_diag_mangler_null_init+0x88>
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_MANGLER);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_diag_mangler_null_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_diag_mangler_null_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_diag_mangler_null_putc);
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_diag_mangler_null_getc);
    158c:	e5812010 	str	r2, [r1, #16]
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_diag_mangler_null_control);
    1590:	e5813014 	str	r3, [r1, #20]
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    1594:	e1a00005 	mov	r0, r5
    1598:	e5943034 	ldr	r3, [r4, #52]
    159c:	e1a0e00f 	mov	lr, pc
    15a0:	e12fff13 	bx	r3
    
    // Restore the original console channel.
    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
}
    15a4:	e28dd004 	add	sp, sp, #4	; 0x4
    15a8:	e8bd8030 	pop	{r4, r5, pc}
    15ac:	40000430 	.word	0x40000430
    15b0:	00001490 	.word	0x00001490
    15b4:	000014dc 	.word	0x000014dc
    15b8:	00001464 	.word	0x00001464
    15bc:	00001438 	.word	0x00001438
    15c0:	00001528 	.word	0x00001528

000015c4 <hal_if_diag_init>:
//
externC void cyg_hal_plf_comms_init(void);

void
hal_if_diag_init(void)
{
    15c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    // This function may be called from various places and the code
    // should only run once.
    static cyg_uint8 called = 0;
    if (called) return;
    15c8:	e59f202c 	ldr	r2, [pc, #44]	; 15fc <hal_if_diag_init+0x38>
    15cc:	e5d20000 	ldrb	r0, [r2]
    15d0:	e3500000 	cmp	r0, #0	; 0x0
//
externC void cyg_hal_plf_comms_init(void);

void
hal_if_diag_init(void)
{
    15d4:	e24dd004 	sub	sp, sp, #4	; 0x4
    // This function may be called from various places and the code
    // should only run once.
    static cyg_uint8 called = 0;
    if (called) return;
    15d8:	1a000005 	bne	15f4 <hal_if_diag_init+0x30>
    called = 1;
    15dc:	e3a03001 	mov	r3, #1	; 0x1
    15e0:	e5c23000 	strb	r3, [r2]
    15e4:	e59f2014 	ldr	r2, [pc, #20]	; 1600 <hal_if_diag_init+0x3c>
    15e8:	e5923034 	ldr	r3, [r2, #52]
    15ec:	e1a0e00f 	mov	lr, pc
    15f0:	e12fff13 	bx	r3
    CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL);

#endif // CYGDBG_HAL_DIAG_TO_DEBUG_CHAN

#endif // CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
}
    15f4:	e28dd004 	add	sp, sp, #4	; 0x4
    15f8:	e8bd8000 	pop	{pc}
    15fc:	40001bb4 	.word	0x40001bb4
    1600:	40000430 	.word	0x40000430

00001604 <hal_if_diag_read_char>:
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    1604:	e59f2044 	ldr	r2, [pc, #68]	; 1650 <hal_if_diag_read_char+0x4c>
    1608:	e5923014 	ldr	r3, [r2, #20]
void 
hal_if_diag_read_char(char *c)
{
    hal_virtual_comm_table_t* __chan = CYGACC_CALL_IF_CONSOLE_PROCS();
    
    if (__chan)
    160c:	e3530000 	cmp	r3, #0	; 0x0
    }
}

void 
hal_if_diag_read_char(char *c)
{
    1610:	e92d4010 	push	{r4, lr}
    1614:	e1a04000 	mov	r4, r0
    hal_virtual_comm_table_t* __chan = CYGACC_CALL_IF_CONSOLE_PROCS();
    
    if (__chan)
    1618:	0a000005 	beq	1634 <hal_if_diag_read_char+0x30>
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    161c:	e5930000 	ldr	r0, [r3]
    1620:	e5933010 	ldr	r3, [r3, #16]
    1624:	e1a0e00f 	mov	lr, pc
    1628:	e12fff13 	bx	r3
        *c = CYGACC_COMM_IF_GETC(*__chan);
    162c:	e5c40000 	strb	r0, [r4]
    1630:	e8bd8010 	pop	{r4, pc}
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    1634:	e5923018 	ldr	r3, [r2, #24]
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    1638:	e5930000 	ldr	r0, [r3]
    163c:	e5932010 	ldr	r2, [r3, #16]
    1640:	e1a0e00f 	mov	lr, pc
    1644:	e12fff12 	bx	r2
        // This is a bad bad situation - we have no means for diag
        // output; we want to hit a breakpoint to alert the developer
        // or something like that.
        CYG_ASSERT(__chan, "No valid channel set");

        *c = CYGACC_COMM_IF_GETC(*__chan);
    1648:	e5c40000 	strb	r0, [r4]
    164c:	e8bd8010 	pop	{r4, pc}
    1650:	40000430 	.word	0x40000430

00001654 <hal_if_init>:
// For monitor configurations it will initialize the calling interface table,
// for client configurations it will patch the existing table as per
// configuration.
void
hal_if_init(void)
{
    1654:	e92d4010 	push	{r4, lr}
    1658:	e59fc0b0 	ldr	ip, [pc, #176]	; 1710 <hal_if_init+0xbc>
    165c:	e59f40b0 	ldr	r4, [pc, #176]	; 1714 <hal_if_init+0xc0>
    1660:	e3a03000 	mov	r3, #0	; 0x0

        // Initialize tables with the NOP service.
        // This should only be done for service routine entries - data
        // pointers should be NULLed.
        for (i = 0; i < CYGNUM_CALL_IF_TABLE_SIZE; i++)
            hal_virtual_vector_table[i] = (CYG_ADDRWORD) &nop_service;
    1664:	e784c103 	str	ip, [r4, r3, lsl #2]
        int i;

        // Initialize tables with the NOP service.
        // This should only be done for service routine entries - data
        // pointers should be NULLed.
        for (i = 0; i < CYGNUM_CALL_IF_TABLE_SIZE; i++)
    1668:	e2833001 	add	r3, r3, #1	; 0x1
    166c:	e3530040 	cmp	r3, #64	; 0x40
            hal_virtual_vector_table[i] = (CYG_ADDRWORD) &nop_service;
    1670:	e59f009c 	ldr	r0, [pc, #156]	; 1714 <hal_if_init+0xc0>
        int i;

        // Initialize tables with the NOP service.
        // This should only be done for service routine entries - data
        // pointers should be NULLed.
        for (i = 0; i < CYGNUM_CALL_IF_TABLE_SIZE; i++)
    1674:	1afffffa 	bne	1664 <hal_if_init+0x10>
            hal_virtual_vector_table[i] = (CYG_ADDRWORD) &nop_service;
        
        // Version number
        CYGACC_CALL_IF_VERSION_SET(CYGNUM_CALL_IF_TABLE_VERSION_CALL
    1678:	e3a03702 	mov	r3, #524288	; 0x80000
    167c:	e2833017 	add	r3, r3, #23	; 0x17
    1680:	e5803000 	str	r3, [r0]
    }
#endif

    // Miscellaneous services with wrappers in this file.
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
    CYGACC_CALL_IF_RESET_SET(reset);
    1684:	e59f208c 	ldr	r2, [pc, #140]	; 1718 <hal_if_init+0xc4>
#endif
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
    CYGACC_CALL_IF_DELAY_US_SET(delay_us);
    1688:	e59f308c 	ldr	r3, [pc, #140]	; 171c <hal_if_init+0xc8>
    CYGACC_CALL_IF_FLASH_FIS_OP2_SET(flash_fis_op2);
#endif

    // Data entries not currently supported in eCos
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
    CYGACC_CALL_IF_DBG_DATA_SET(0);
    168c:	e3a01000 	mov	r1, #0	; 0x0
    }
#endif

    // Miscellaneous services with wrappers in this file.
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
    CYGACC_CALL_IF_RESET_SET(reset);
    1690:	e5802040 	str	r2, [r0, #64]
#endif
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
    CYGACC_CALL_IF_DELAY_US_SET(delay_us);
    1694:	e5803048 	str	r3, [r0, #72]
    CYGACC_CALL_IF_FLASH_FIS_OP2_SET(flash_fis_op2);
#endif

    // Data entries not currently supported in eCos
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
    CYGACC_CALL_IF_DBG_DATA_SET(0);
    1698:	e580104c 	str	r1, [r0, #76]
#endif

#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_VERSION
    CYGACC_CALL_IF_MONITOR_VERSION_SET(0);
    169c:	e5801038 	str	r1, [r0, #56]
    16a0:	e59f0078 	ldr	r0, [pc, #120]	; 1720 <hal_if_init+0xcc>
    16a4:	e1a0e001 	mov	lr, r1
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
    {
        int i, j;

        // Clear out tables with safe dummy function.
        for (j = 0; j < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS+1; j++)
    16a8:	e3a02000 	mov	r2, #0	; 0x0
    16ac:	e1a0118e 	lsl	r1, lr, #3
            for (i = 0; i < CYGNUM_COMM_IF_TABLE_SIZE; i++)
                comm_channels[j][i] = (CYG_ADDRWORD) &nop_service;
    16b0:	e0813002 	add	r3, r1, r2
    {
        int i, j;

        // Clear out tables with safe dummy function.
        for (j = 0; j < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS+1; j++)
            for (i = 0; i < CYGNUM_COMM_IF_TABLE_SIZE; i++)
    16b4:	e2822001 	add	r2, r2, #1	; 0x1
    16b8:	e3520008 	cmp	r2, #8	; 0x8
                comm_channels[j][i] = (CYG_ADDRWORD) &nop_service;
    16bc:	e780c103 	str	ip, [r0, r3, lsl #2]
    {
        int i, j;

        // Clear out tables with safe dummy function.
        for (j = 0; j < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS+1; j++)
            for (i = 0; i < CYGNUM_COMM_IF_TABLE_SIZE; i++)
    16c0:	1afffffa 	bne	16b0 <hal_if_init+0x5c>
#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
    {
        int i, j;

        // Clear out tables with safe dummy function.
        for (j = 0; j < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS+1; j++)
    16c4:	e28ee001 	add	lr, lr, #1	; 0x1
    16c8:	e35e0002 	cmp	lr, #2	; 0x2
    16cc:	1afffff5 	bne	16a8 <hal_if_init+0x54>
            for (i = 0; i < CYGNUM_COMM_IF_TABLE_SIZE; i++)
                comm_channels[j][i] = (CYG_ADDRWORD) &nop_service;

        // Set accessor functions
        CYGACC_CALL_IF_SET_DEBUG_COMM_SET(set_debug_comm);
    16d0:	e59f304c 	ldr	r3, [pc, #76]	; 1724 <hal_if_init+0xd0>
        CYGACC_CALL_IF_SET_CONSOLE_COMM_SET(set_console_comm);
    16d4:	e59f204c 	ldr	r2, [pc, #76]	; 1728 <hal_if_init+0xd4>

        // Initialize console/debug procs. Note that these _must_
        // be set to empty before the comms init call.
        set_debug_comm(CYGNUM_CALL_IF_SET_COMM_ID_EMPTY);
    16d8:	e3e00001 	mvn	r0, #1	; 0x1
        for (j = 0; j < CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS+1; j++)
            for (i = 0; i < CYGNUM_COMM_IF_TABLE_SIZE; i++)
                comm_channels[j][i] = (CYG_ADDRWORD) &nop_service;

        // Set accessor functions
        CYGACC_CALL_IF_SET_DEBUG_COMM_SET(set_debug_comm);
    16dc:	e5843030 	str	r3, [r4, #48]
        CYGACC_CALL_IF_SET_CONSOLE_COMM_SET(set_console_comm);
    16e0:	e5842034 	str	r2, [r4, #52]

        // Initialize console/debug procs. Note that these _must_
        // be set to empty before the comms init call.
        set_debug_comm(CYGNUM_CALL_IF_SET_COMM_ID_EMPTY);
    16e4:	ebfffea7 	bl	1188 <set_debug_comm>
        set_console_comm(CYGNUM_CALL_IF_SET_COMM_ID_EMPTY);
    16e8:	e3e00001 	mvn	r0, #1	; 0x1
    16ec:	ebfffeeb 	bl	12a0 <set_console_comm>

        // Initialize channels. This used to be done in
        // hal_diag_init() and the stub initHardware() functions, but
        // it makes more sense to have here.
        cyg_hal_plf_comms_init();
    16f0:	eb003195 	bl	dd4c <cyg_hal_plf_comms_init>

        // Always set the debug channel. If stubs are included, it is
        // necessary. If no stubs are included it does not hurt and is
        // likely to be required by the hal_if_diag_init code anyway
        // as it may rely on it if using a mangler.
        set_debug_comm(CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL);
    16f4:	e3a00000 	mov	r0, #0	; 0x0
    16f8:	ebfffea2 	bl	1188 <set_debug_comm>
        // Set console channel to a safe default. hal_if_diag_init
        // will override with console channel or mangler if necessary.
        set_console_comm(CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL);
    16fc:	e3a00000 	mov	r0, #0	; 0x0
    1700:	ebfffee6 	bl	12a0 <set_console_comm>
    }

    // Reset console interrupt flag.
    CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(0);
    1704:	e3a03000 	mov	r3, #0	; 0x0
    1708:	e5843044 	str	r3, [r4, #68]
#if 0 != CYGINT_HAL_PLF_IF_INIT
    // Call platform specific initializations - should only be used
    // to augment what has already been set up, etc.
    plf_if_init();
#endif
}
    170c:	e8bd8010 	pop	{r4, pc}
    1710:	00001180 	.word	0x00001180
    1714:	40000430 	.word	0x40000430
    1718:	000017b4 	.word	0x000017b4
    171c:	0000172c 	.word	0x0000172c
    1720:	40001bbc 	.word	0x40001bbc
    1724:	00001188 	.word	0x00001188
    1728:	000012a0 	.word	0x000012a0

0000172c <delay_us>:

static __call_if_delay_us_t delay_us;

static void
delay_us(cyg_int32 usecs)
{
    172c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
            // multiply+divide to get sufficient accuracy. Note that
            // this test is actually constant, so the compiler will
            // eliminate it and only compile the branch that is
            // selected.
            
            if( usecs > usec_per_period/2 )
    1730:	e3a07d4e 	mov	r7, #4992	; 0x1380

static __call_if_delay_us_t delay_us;

static void
delay_us(cyg_int32 usecs)
{
    1734:	e24dd00c 	sub	sp, sp, #12	; 0xc
            
            // Adjust by elapsed, not slice, since an interrupt may
            // have been stalling us for some time.

            if( CYGNUM_KERNEL_COUNTERS_RTC_PERIOD >= 0x7FFFFFFF/usec_per_period )
                elapsed_usec = elapsed / ticks_per_usec;
    1738:	e59fa070 	ldr	sl, [pc, #112]	; 17b0 <delay_us+0x84>

static __call_if_delay_us_t delay_us;

static void
delay_us(cyg_int32 usecs)
{
    173c:	e1a05000 	mov	r5, r0
            // multiply+divide to get sufficient accuracy. Note that
            // this test is actually constant, so the compiler will
            // eliminate it and only compile the branch that is
            // selected.
            
            if( usecs > usec_per_period/2 )
    1740:	e2877008 	add	r7, r7, #8	; 0x8
    1744:	e28d8004 	add	r8, sp, #4	; 0x4
    1748:	e1a0600d 	mov	r6, sp
    174c:	e1550007 	cmp	r5, r7
                slice = CYGNUM_KERNEL_COUNTERS_RTC_PERIOD/2;
            else if( CYGNUM_KERNEL_COUNTERS_RTC_PERIOD/2 >= 0x7FFFFFFF/usec_per_period )
                slice = usecs * ticks_per_usec;
    1750:	d1a03285 	lslle	r3, r5, #5
    1754:	d0433105 	suble	r3, r3, r5, lsl #2
    1758:	d0833005 	addle	r3, r3, r5
            {
                slice = usecs*CYGNUM_KERNEL_COUNTERS_RTC_PERIOD;
                slice /= usec_per_period;
            }
    
            HAL_CLOCK_READ(&start);
    175c:	e1a00008 	mov	r0, r8
            // multiply+divide to get sufficient accuracy. Note that
            // this test is actually constant, so the compiler will
            // eliminate it and only compile the branch that is
            // selected.
            
            if( usecs > usec_per_period/2 )
    1760:	c3a04912 	movgt	r4, #294912	; 0x48000
                slice = CYGNUM_KERNEL_COUNTERS_RTC_PERIOD/2;
            else if( CYGNUM_KERNEL_COUNTERS_RTC_PERIOD/2 >= 0x7FFFFFFF/usec_per_period )
                slice = usecs * ticks_per_usec;
    1764:	d1a04083 	lslle	r4, r3, #1
            {
                slice = usecs*CYGNUM_KERNEL_COUNTERS_RTC_PERIOD;
                slice /= usec_per_period;
            }
    
            HAL_CLOCK_READ(&start);
    1768:	eb0030e0 	bl	daf0 <hal_clock_read>
            do {
                HAL_CLOCK_READ(&elapsed_hal);
    176c:	e1a0000d 	mov	r0, sp
    1770:	eb0030de 	bl	daf0 <hal_clock_read>
                elapsed = (elapsed_hal - start); // counts up!
    1774:	e89d000c 	ldm	sp, {r2, r3}
                if (elapsed < 0)
    1778:	e0521003 	subs	r1, r2, r3
                    elapsed += CYGNUM_KERNEL_COUNTERS_RTC_PERIOD;
    177c:	42811809 	addmi	r1, r1, #589824	; 0x90000
            } while (elapsed < slice);
    1780:	e1510004 	cmp	r1, r4
    1784:	bafffff8 	blt	176c <delay_us+0x40>
            
            // Adjust by elapsed, not slice, since an interrupt may
            // have been stalling us for some time.

            if( CYGNUM_KERNEL_COUNTERS_RTC_PERIOD >= 0x7FFFFFFF/usec_per_period )
                elapsed_usec = elapsed / ticks_per_usec;
    1788:	e0c2319a 	smull	r3, r2, sl, r1
    178c:	e1a03fc1 	asr	r3, r1, #31
    1790:	e0822001 	add	r2, r2, r1
            // It is possible for elapsed_usec to end up zero in some
            // circumstances and we could end up looping indefinitely.
            // Avoid that by ensuring that we always decrement usec by
            // at least 1 each time.
            
            usecs -= elapsed_usec ? elapsed_usec : 1;
    1794:	e07332c2 	rsbs	r3, r3, r2, asr #5
    1798:	03a03001 	moveq	r3, #1	; 0x1
    179c:	e0635005 	rsb	r5, r3, r5
            
        } while (usecs > 0);
    17a0:	e3550000 	cmp	r5, #0	; 0x0
    17a4:	caffffe8 	bgt	174c <delay_us+0x20>
        for (i = 0; i < 10; i++);
    }
#endif // HAL_DELAY_US
#endif // CYGPKG_KERNEL
    CYGARC_HAL_RESTORE_GP();
}
    17a8:	e28dd00c 	add	sp, sp, #12	; 0xc
    17ac:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    17b0:	8d3dcb09 	.word	0x8d3dcb09

000017b4 <reset>:

static __call_if_reset_t reset;

static void
reset(void)
{
    17b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    17b8:	e24dd004 	sub	sp, sp, #4	; 0x4
    CYGARC_HAL_SAVE_GP();
    // With luck, the platform defines some magic that will cause a hardware
    // reset.
#ifdef HAL_PLATFORM_RESET
    HAL_PLATFORM_RESET();
    17bc:	eb00314a 	bl	dcec <hal_lpc_watchdog_reset>
    17c0:	e3a03000 	mov	r3, #0	; 0x0
    17c4:	e1a0f003 	mov	pc, r3

000017c8 <hal_if_diag_write_char>:
#endif // CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
}

void 
hal_if_diag_write_char(char c)
{
    17c8:	e92d4010 	push	{r4, lr}
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    17cc:	e59f4064 	ldr	r4, [pc, #100]	; 1838 <hal_if_diag_write_char+0x70>
    17d0:	e5943014 	ldr	r3, [r4, #20]
    hal_virtual_comm_table_t* __chan = CYGACC_CALL_IF_CONSOLE_PROCS();

    if (__chan)
    17d4:	e3530000 	cmp	r3, #0	; 0x0
#endif // CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
}

void 
hal_if_diag_write_char(char c)
{
    17d8:	e1a01000 	mov	r1, r0
    hal_virtual_comm_table_t* __chan = CYGACC_CALL_IF_CONSOLE_PROCS();

    if (__chan)
    17dc:	0a00000c 	beq	1814 <hal_if_diag_write_char+0x4c>
#define CYGACC_COMM_IF_READ(_t_, _b_, _l_) \
 __call_COMM_IF_READ(_t_, _b_, _l_)
#define CYGACC_COMM_IF_READ_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_READ]=(CYG_ADDRWORD)(_x_)

__call_voidCOMM1(IF_PUTC, void, __comm_if_putc_t, cyg_uint8)
    17e0:	e5930000 	ldr	r0, [r3]
    17e4:	e593300c 	ldr	r3, [r3, #12]
    17e8:	e1a0e00f 	mov	lr, pc
    17ec:	e12fff13 	bx	r3
#define CYGACC_CALL_IF_MONITOR_VERSION_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_MONITOR_VERSION]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG() \
 CYGACC_DATA_VV(__call_if_console_interrupt_flag_t, CYGNUM_CALL_IF_CONSOLE_INTERRUPT_FLAG)
__data_VV(CYGNUM_CALL_IF_CONSOLE_INTERRUPT_FLAG, __call_if_console_interrupt_flag_t)
    17f0:	e5943044 	ldr	r3, [r4, #68]

        CYGACC_COMM_IF_PUTC(*__chan, c);
    }

    // Check interrupt flag
    if (CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG()) {
    17f4:	e3530000 	cmp	r3, #0	; 0x0
    17f8:	08bd8010 	popeq	{r4, pc}
        CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(0);
    17fc:	e3a02000 	mov	r2, #0	; 0x0
    1800:	e59f3030 	ldr	r3, [pc, #48]	; 1838 <hal_if_diag_write_char+0x70>
        cyg_hal_user_break(0);
    1804:	e1a00002 	mov	r0, r2
        CYGACC_COMM_IF_PUTC(*__chan, c);
    }

    // Check interrupt flag
    if (CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG()) {
        CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(0);
    1808:	e5832044 	str	r2, [r3, #68]
        cyg_hal_user_break(0);
    }
}
    180c:	e8bd4010 	pop	{r4, lr}
    }

    // Check interrupt flag
    if (CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG()) {
        CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(0);
        cyg_hal_user_break(0);
    1810:	ea0000b5 	b	1aec <cyg_hal_user_break>
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    1814:	e5943018 	ldr	r3, [r4, #24]
#define CYGACC_COMM_IF_READ(_t_, _b_, _l_) \
 __call_COMM_IF_READ(_t_, _b_, _l_)
#define CYGACC_COMM_IF_READ_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_READ]=(CYG_ADDRWORD)(_x_)

__call_voidCOMM1(IF_PUTC, void, __comm_if_putc_t, cyg_uint8)
    1818:	e5930000 	ldr	r0, [r3]
    181c:	e593200c 	ldr	r2, [r3, #12]
    1820:	e1a0e00f 	mov	lr, pc
    1824:	e12fff12 	bx	r2
#define CYGACC_CALL_IF_MONITOR_VERSION_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_MONITOR_VERSION]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG() \
 CYGACC_DATA_VV(__call_if_console_interrupt_flag_t, CYGNUM_CALL_IF_CONSOLE_INTERRUPT_FLAG)
__data_VV(CYGNUM_CALL_IF_CONSOLE_INTERRUPT_FLAG, __call_if_console_interrupt_flag_t)
    1828:	e5943044 	ldr	r3, [r4, #68]

        CYGACC_COMM_IF_PUTC(*__chan, c);
    }

    // Check interrupt flag
    if (CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG()) {
    182c:	e3530000 	cmp	r3, #0	; 0x0
    1830:	08bd8010 	popeq	{r4, pc}
    1834:	eafffff0 	b	17fc <hal_if_diag_write_char+0x34>
    1838:	40000430 	.word	0x40000430

0000183c <cyg_hal_diag_mangler_gdb_flush>:
static char __mangler_line[100];
static int  __mangler_pos = 0;

static void
cyg_hal_diag_mangler_gdb_flush(void* __ch_data)
{
    183c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int tries = CYGNUM_HAL_DEBUG_GDB_PROTOCOL_RETRIES;
#endif


    // Nothing to do if mangler buffer is empty.
    if (__mangler_pos == 0)
    1840:	e59f918c 	ldr	r9, [pc, #396]	; 19d4 <cyg_hal_diag_mangler_gdb_flush+0x198>
    1844:	e5993000 	ldr	r3, [r9]
#define CYGACC_CALL_IF_CONSOLE_PROCS_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_PROCS]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DEBUG_PROCS() \
 CYGACC_DATA_VV(__call_if_debug_procs_t, CYGNUM_CALL_IF_DEBUG_PROCS)
__data_VV(CYGNUM_CALL_IF_DEBUG_PROCS, __call_if_debug_procs_t)
    1848:	e59f2188 	ldr	r2, [pc, #392]	; 19d8 <cyg_hal_diag_mangler_gdb_flush+0x19c>
    184c:	e3530000 	cmp	r3, #0	; 0x0
static char __mangler_line[100];
static int  __mangler_pos = 0;

static void
cyg_hal_diag_mangler_gdb_flush(void* __ch_data)
{
    1850:	e24dd014 	sub	sp, sp, #20	; 0x14
    1854:	e5927018 	ldr	r7, [r2, #24]
    int tries = CYGNUM_HAL_DEBUG_GDB_PROTOCOL_RETRIES;
#endif


    // Nothing to do if mangler buffer is empty.
    if (__mangler_pos == 0)
    1858:	0a000057 	beq	19bc <cyg_hal_diag_mangler_gdb_flush+0x180>
    // while we are in the middle of sending a packet. The serial
    // receive interrupt will be seen when we re-enable interrupts
    // later.
#if defined(CYG_HAL_STARTUP_ROM) \
    || !defined(CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION)
    HAL_DISABLE_INTERRUPTS(old);
    185c:	e10f3000 	mrs	r3, CPSR
    1860:	e10f4000 	mrs	r4, CPSR
    1864:	e38440c0 	orr	r4, r4, #192	; 0xc0
    1868:	e129f004 	msr	CPSR_fc, r4
    186c:	e59fa168 	ldr	sl, [pc, #360]	; 19dc <cyg_hal_diag_mangler_gdb_flush+0x1a0>
    1870:	e58d3004 	str	r3, [sp, #4]
    1874:	e59fb164 	ldr	fp, [pc, #356]	; 19e0 <cyg_hal_diag_mangler_gdb_flush+0x1a4>
#define CYGACC_COMM_IF_READ(_t_, _b_, _l_) \
 __call_COMM_IF_READ(_t_, _b_, _l_)
#define CYGACC_COMM_IF_READ_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_READ]=(CYG_ADDRWORD)(_x_)

__call_voidCOMM1(IF_PUTC, void, __comm_if_putc_t, cyg_uint8)
    1878:	e5970000 	ldr	r0, [r7]
    187c:	e3a01024 	mov	r1, #36	; 0x24
    1880:	e597300c 	ldr	r3, [r7, #12]
    1884:	e1a0e00f 	mov	lr, pc
    1888:	e12fff13 	bx	r3
	int i;
        
	CYGACC_COMM_IF_PUTC(*__chan, '$');
	CYGACC_COMM_IF_PUTC(*__chan, 'O');
	csum += 'O';
	for( i = 0; i < __mangler_pos; i++ )
    188c:	e5970000 	ldr	r0, [r7]
    1890:	e3a0104f 	mov	r1, #79	; 0x4f
    1894:	e597200c 	ldr	r2, [r7, #12]
    1898:	e1a0e00f 	mov	lr, pc
    189c:	e12fff12 	bx	r2
    18a0:	e5993000 	ldr	r3, [r9]
    18a4:	e3530000 	cmp	r3, #0	; 0x0
    18a8:	d3a05004 	movle	r5, #4	; 0x4
    18ac:	d3a0400f 	movle	r4, #15	; 0xf
    18b0:	da000019 	ble	191c <cyg_hal_diag_mangler_gdb_flush+0xe0>
    18b4:	e3a0804f 	mov	r8, #79	; 0x4f
    18b8:	e3a06000 	mov	r6, #0	; 0x0
        {
	    char ch = __mangler_line[i];
    18bc:	e7db3006 	ldrb	r3, [fp, r6]
	    char h = hex[(ch>>4)&0xF];
    18c0:	e7da5223 	ldrb	r5, [sl, r3, lsr #4]
	    char l = hex[ch&0xF];
    18c4:	e203300f 	and	r3, r3, #15	; 0xf
    18c8:	e7da4003 	ldrb	r4, [sl, r3]
    18cc:	e5970000 	ldr	r0, [r7]
    18d0:	e1a01005 	mov	r1, r5
    18d4:	e597200c 	ldr	r2, [r7, #12]
    18d8:	e1a0e00f 	mov	lr, pc
    18dc:	e12fff12 	bx	r2
	    CYGACC_COMM_IF_PUTC(*__chan, h);
	    CYGACC_COMM_IF_PUTC(*__chan, l);
	    csum += h;
    18e0:	e5970000 	ldr	r0, [r7]
    18e4:	e1a01004 	mov	r1, r4
    18e8:	e597300c 	ldr	r3, [r7, #12]
    18ec:	e1a0e00f 	mov	lr, pc
    18f0:	e12fff13 	bx	r3
    18f4:	e0844005 	add	r4, r4, r5
	int i;
        
	CYGACC_COMM_IF_PUTC(*__chan, '$');
	CYGACC_COMM_IF_PUTC(*__chan, 'O');
	csum += 'O';
	for( i = 0; i < __mangler_pos; i++ )
    18f8:	e5993000 	ldr	r3, [r9]
	    char ch = __mangler_line[i];
	    char h = hex[(ch>>4)&0xF];
	    char l = hex[ch&0xF];
	    CYGACC_COMM_IF_PUTC(*__chan, h);
	    CYGACC_COMM_IF_PUTC(*__chan, l);
	    csum += h;
    18fc:	e20440ff 	and	r4, r4, #255	; 0xff
	int i;
        
	CYGACC_COMM_IF_PUTC(*__chan, '$');
	CYGACC_COMM_IF_PUTC(*__chan, 'O');
	csum += 'O';
	for( i = 0; i < __mangler_pos; i++ )
    1900:	e2866001 	add	r6, r6, #1	; 0x1
	    char h = hex[(ch>>4)&0xF];
	    char l = hex[ch&0xF];
	    CYGACC_COMM_IF_PUTC(*__chan, h);
	    CYGACC_COMM_IF_PUTC(*__chan, l);
	    csum += h;
	    csum += l;
    1904:	e0844008 	add	r4, r4, r8
	int i;
        
	CYGACC_COMM_IF_PUTC(*__chan, '$');
	CYGACC_COMM_IF_PUTC(*__chan, 'O');
	csum += 'O';
	for( i = 0; i < __mangler_pos; i++ )
    1908:	e1530006 	cmp	r3, r6
	    char h = hex[(ch>>4)&0xF];
	    char l = hex[ch&0xF];
	    CYGACC_COMM_IF_PUTC(*__chan, h);
	    CYGACC_COMM_IF_PUTC(*__chan, l);
	    csum += h;
	    csum += l;
    190c:	e20480ff 	and	r8, r4, #255	; 0xff
	int i;
        
	CYGACC_COMM_IF_PUTC(*__chan, '$');
	CYGACC_COMM_IF_PUTC(*__chan, 'O');
	csum += 'O';
	for( i = 0; i < __mangler_pos; i++ )
    1910:	caffffe9 	bgt	18bc <cyg_hal_diag_mangler_gdb_flush+0x80>
    1914:	e1a05228 	lsr	r5, r8, #4
    1918:	e204400f 	and	r4, r4, #15	; 0xf
    191c:	e5970000 	ldr	r0, [r7]
    1920:	e3a01023 	mov	r1, #35	; 0x23
    1924:	e597300c 	ldr	r3, [r7, #12]
    1928:	e1a0e00f 	mov	lr, pc
    192c:	e12fff13 	bx	r3
	if (CYGACC_COMM_IF_GETC_TIMEOUT(*__chan, &c1) == 0) {
	    c1 = '-';
	    if (tries && (--tries == 0)) c1 = '+';
	}
#else
	c1 = CYGACC_COMM_IF_GETC(*__chan);
    1930:	e5970000 	ldr	r0, [r7]
    1934:	e7da1005 	ldrb	r1, [sl, r5]
    1938:	e597300c 	ldr	r3, [r7, #12]
    193c:	e1a0e00f 	mov	lr, pc
    1940:	e12fff13 	bx	r3
    1944:	e5970000 	ldr	r0, [r7]
    1948:	e7da1004 	ldrb	r1, [sl, r4]
    194c:	e597300c 	ldr	r3, [r7, #12]
    1950:	e1a0e00f 	mov	lr, pc
    1954:	e12fff13 	bx	r3
    1958:	ea000006 	b	1978 <cyg_hal_diag_mangler_gdb_flush+0x13c>
    195c:	e5cd300f 	strb	r3, [sp, #15]
#endif

	if( c1 == '+' ) break;

	if( cyg_hal_is_break( &c1 , 1 ) ) {
    1960:	eb00004f 	bl	1aa4 <cyg_hal_is_break>
    1964:	e3500000 	cmp	r0, #0	; 0x0
    1968:	1a000015 	bne	19c4 <cyg_hal_diag_mangler_gdb_flush+0x188>
	    // Caller's responsibility to react on this.
	    CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(1);
	    break;
	}
	if( c1 != '-' ) goto nak;
    196c:	e5dd300f 	ldrb	r3, [sp, #15]
    1970:	e353002d 	cmp	r3, #45	; 0x2d
    1974:	0affffbf 	beq	1878 <cyg_hal_diag_mangler_gdb_flush+0x3c>
#define CYGACC_COMM_IF_PUTC(_t_, _c_) \
 __call_COMM_IF_PUTC(_t_,_c_)
#define CYGACC_COMM_IF_PUTC_SET(_t_, _x_) \
 (_t_)[CYGNUM_COMM_IF_PUTC]=(CYG_ADDRWORD)(_x_)

__call_COMM0(IF_GETC, cyg_uint8, __comm_if_getc_t)
    1978:	e5970000 	ldr	r0, [r7]
    197c:	e5973010 	ldr	r3, [r7, #16]
    1980:	e1a0e00f 	mov	lr, pc
    1984:	e12fff13 	bx	r3
    1988:	e1a03000 	mov	r3, r0
	}
#else
	c1 = CYGACC_COMM_IF_GETC(*__chan);
#endif

	if( c1 == '+' ) break;
    198c:	e353002b 	cmp	r3, #43	; 0x2b

	if( cyg_hal_is_break( &c1 , 1 ) ) {
    1990:	e3a01001 	mov	r1, #1	; 0x1
    1994:	e28d000f 	add	r0, sp, #15	; 0xf
	}
#else
	c1 = CYGACC_COMM_IF_GETC(*__chan);
#endif

	if( c1 == '+' ) break;
    1998:	1affffef 	bne	195c <cyg_hal_diag_mangler_gdb_flush+0x120>
	    break;
	}
	if( c1 != '-' ) goto nak;
    }

    __mangler_pos = 0;
    199c:	e3a02000 	mov	r2, #0	; 0x0
    19a0:	e5892000 	str	r2, [r9]
    // And re-enable interrupts
#if defined(CYG_HAL_STARTUP_ROM) \
    || !defined(CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION)
    HAL_RESTORE_INTERRUPTS(old);
    19a4:	e59d2004 	ldr	r2, [sp, #4]
    19a8:	e10f3000 	mrs	r3, CPSR
    19ac:	e20240c0 	and	r4, r2, #192	; 0xc0
    19b0:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    19b4:	e1833004 	orr	r3, r3, r4
    19b8:	e129f003 	msr	CPSR_fc, r3
#else
    CYG_HAL_GDB_LEAVE_CRITICAL_IO_REGION(old);
#endif
}
    19bc:	e28dd014 	add	sp, sp, #20	; 0x14
    19c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if( c1 == '+' ) break;

	if( cyg_hal_is_break( &c1 , 1 ) ) {
	    // Caller's responsibility to react on this.
	    CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(1);
    19c4:	e59f200c 	ldr	r2, [pc, #12]	; 19d8 <cyg_hal_diag_mangler_gdb_flush+0x19c>
    19c8:	e3a03001 	mov	r3, #1	; 0x1
    19cc:	e5823044 	str	r3, [r2, #68]
    19d0:	eafffff1 	b	199c <cyg_hal_diag_mangler_gdb_flush+0x160>
    19d4:	40001bb8 	.word	0x40001bb8
    19d8:	40000430 	.word	0x40000430
    19dc:	00012988 	.word	0x00012988
    19e0:	40001bfc 	.word	0x40001bfc

000019e4 <cyg_hal_diag_mangler_gdb_control>:
}

static int
cyg_hal_diag_mangler_gdb_control(void *__ch_data, 
                                 __comm_control_cmd_t __func, ...)
{
    19e4:	e92d000e 	push	{r1, r2, r3}
    19e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    19ec:	e5dd3004 	ldrb	r3, [sp, #4]
    CYGARC_HAL_SAVE_GP();

    if (__func == __COMMCTL_FLUSH_OUTPUT)
    19f0:	e3530008 	cmp	r3, #8	; 0x8
    19f4:	0a000003 	beq	1a08 <cyg_hal_diag_mangler_gdb_control+0x24>
	cyg_hal_diag_mangler_gdb_flush(__ch_data);

    CYGARC_HAL_RESTORE_GP();
    return 0;
}
    19f8:	e3a00000 	mov	r0, #0	; 0x0
    19fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
    1a00:	e28dd00c 	add	sp, sp, #12	; 0xc
    1a04:	e12fff1e 	bx	lr
                                 __comm_control_cmd_t __func, ...)
{
    CYGARC_HAL_SAVE_GP();

    if (__func == __COMMCTL_FLUSH_OUTPUT)
	cyg_hal_diag_mangler_gdb_flush(__ch_data);
    1a08:	ebffff8b 	bl	183c <cyg_hal_diag_mangler_gdb_flush>
    1a0c:	eafffff9 	b	19f8 <cyg_hal_diag_mangler_gdb_control+0x14>

00001a10 <cyg_hal_diag_mangler_gdb_putc>:

static void
cyg_hal_diag_mangler_gdb_putc(void* __ch_data, cyg_uint8 c)
{
    // No need to send CRs
    if( c == '\r' ) return;
    1a10:	e351000d 	cmp	r1, #13	; 0xd
#endif
}

static void
cyg_hal_diag_mangler_gdb_putc(void* __ch_data, cyg_uint8 c)
{
    1a14:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    1a18:	e1a0c001 	mov	ip, r1
    1a1c:	e1a04000 	mov	r4, r0
    // No need to send CRs
    if( c == '\r' ) return;
    1a20:	0a000009 	beq	1a4c <cyg_hal_diag_mangler_gdb_putc+0x3c>

    CYGARC_HAL_SAVE_GP();

    __mangler_line[__mangler_pos++] = c;
    1a24:	e59f1034 	ldr	r1, [pc, #52]	; 1a60 <cyg_hal_diag_mangler_gdb_putc+0x50>
    1a28:	e5912000 	ldr	r2, [r1]
    1a2c:	e59f3030 	ldr	r3, [pc, #48]	; 1a64 <cyg_hal_diag_mangler_gdb_putc+0x54>
    1a30:	e2820001 	add	r0, r2, #1	; 0x1

    if( c == '\n' || __mangler_pos == sizeof(__mangler_line) )
    1a34:	e35c000a 	cmp	ip, #10	; 0xa
    // No need to send CRs
    if( c == '\r' ) return;

    CYGARC_HAL_SAVE_GP();

    __mangler_line[__mangler_pos++] = c;
    1a38:	e7c3c002 	strb	ip, [r3, r2]
    1a3c:	e5810000 	str	r0, [r1]

    if( c == '\n' || __mangler_pos == sizeof(__mangler_line) )
    1a40:	0a000003 	beq	1a54 <cyg_hal_diag_mangler_gdb_putc+0x44>
    1a44:	e3500064 	cmp	r0, #100	; 0x64
    1a48:	0a000001 	beq	1a54 <cyg_hal_diag_mangler_gdb_putc+0x44>
	cyg_hal_diag_mangler_gdb_flush(__ch_data);

    CYGARC_HAL_RESTORE_GP();
}
    1a4c:	e8bd0010 	pop	{r4}
    1a50:	e12fff1e 	bx	lr
    CYGARC_HAL_SAVE_GP();

    __mangler_line[__mangler_pos++] = c;

    if( c == '\n' || __mangler_pos == sizeof(__mangler_line) )
	cyg_hal_diag_mangler_gdb_flush(__ch_data);
    1a54:	e1a00004 	mov	r0, r4

    CYGARC_HAL_RESTORE_GP();
}
    1a58:	e8bd0010 	pop	{r4}
    CYGARC_HAL_SAVE_GP();

    __mangler_line[__mangler_pos++] = c;

    if( c == '\n' || __mangler_pos == sizeof(__mangler_line) )
	cyg_hal_diag_mangler_gdb_flush(__ch_data);
    1a5c:	eaffff76 	b	183c <cyg_hal_diag_mangler_gdb_flush>
    1a60:	40001bb8 	.word	0x40001bb8
    1a64:	40001bfc 	.word	0x40001bfc

00001a68 <cyg_hal_diag_mangler_gdb_write>:
}

static void
cyg_hal_diag_mangler_gdb_write(void* __ch_data,
                               const cyg_uint8* __buf, cyg_uint32 __len)
{
    1a68:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1a6c:	e2527000 	subs	r7, r2, #0	; 0x0
}

static void
cyg_hal_diag_mangler_gdb_write(void* __ch_data,
                               const cyg_uint8* __buf, cyg_uint32 __len)
{
    1a70:	e24dd004 	sub	sp, sp, #4	; 0x4
    1a74:	e1a06000 	mov	r6, r0
    1a78:	e1a05001 	mov	r5, r1
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1a7c:	0a000006 	beq	1a9c <cyg_hal_diag_mangler_gdb_write+0x34>
    1a80:	e3a04000 	mov	r4, #0	; 0x0
        cyg_hal_diag_mangler_gdb_putc(__ch_data, *__buf++);
    1a84:	e7d51004 	ldrb	r1, [r5, r4]
    1a88:	e1a00006 	mov	r0, r6
    1a8c:	e2844001 	add	r4, r4, #1	; 0x1
    1a90:	ebffffde 	bl	1a10 <cyg_hal_diag_mangler_gdb_putc>
cyg_hal_diag_mangler_gdb_write(void* __ch_data,
                               const cyg_uint8* __buf, cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    1a94:	e1540007 	cmp	r4, r7
    1a98:	1afffff9 	bne	1a84 <cyg_hal_diag_mangler_gdb_write+0x1c>
        cyg_hal_diag_mangler_gdb_putc(__ch_data, *__buf++);

    CYGARC_HAL_RESTORE_GP();
}
    1a9c:	e28dd004 	add	sp, sp, #4	; 0x4
    1aa0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

00001aa4 <cyg_hal_is_break>:
// program break. These are usually called from interrupt routines.

cyg_bool
cyg_hal_is_break(char *buf, int size)
{
    while( size )
    1aa4:	e3510000 	cmp	r1, #0	; 0x0
    1aa8:	0a00000d 	beq	1ae4 <cyg_hal_is_break+0x40>
        if( buf[--size] == 0x03 ) return true;
    1aac:	e2412001 	sub	r2, r1, #1	; 0x1
    1ab0:	e7d03002 	ldrb	r3, [r0, r2]
    1ab4:	e3530003 	cmp	r3, #3	; 0x3
    1ab8:	10800001 	addne	r0, r0, r1
    1abc:	0a000006 	beq	1adc <cyg_hal_is_break+0x38>
// program break. These are usually called from interrupt routines.

cyg_bool
cyg_hal_is_break(char *buf, int size)
{
    while( size )
    1ac0:	e3520000 	cmp	r2, #0	; 0x0
        if( buf[--size] == 0x03 ) return true;
    1ac4:	e2422001 	sub	r2, r2, #1	; 0x1
// program break. These are usually called from interrupt routines.

cyg_bool
cyg_hal_is_break(char *buf, int size)
{
    while( size )
    1ac8:	0a000005 	beq	1ae4 <cyg_hal_is_break+0x40>
        if( buf[--size] == 0x03 ) return true;
    1acc:	e5503002 	ldrb	r3, [r0, #-2]
    1ad0:	e3530003 	cmp	r3, #3	; 0x3
    1ad4:	e2400001 	sub	r0, r0, #1	; 0x1
    1ad8:	1afffff8 	bne	1ac0 <cyg_hal_is_break+0x1c>
// program break. These are usually called from interrupt routines.

cyg_bool
cyg_hal_is_break(char *buf, int size)
{
    while( size )
    1adc:	e3a00001 	mov	r0, #1	; 0x1
    1ae0:	e12fff1e 	bx	lr
    1ae4:	e3a00000 	mov	r0, #0	; 0x0
        if( buf[--size] == 0x03 ) return true;

    return false;
}
    1ae8:	e12fff1e 	bx	lr

00001aec <cyg_hal_user_break>:
// used. Yes, it's ugly.
int _cyg_hal_compiler_dummy;

void 
cyg_hal_user_break( CYG_ADDRWORD *regs )
{
    1aec:	e7ffdefe 	.word	0xe7ffdefe
#else

    HAL_BREAKPOINT(breakinst);

#endif
}
    1af0:	e12fff1e 	bx	lr

00001af4 <hal_default_isr>:
        result = HAL_CTRLC_ISR( vector, data );
        if( 0 != result ) return result;
    }
#endif

    result = hal_arch_default_isr (vector, data);
    1af4:	ea002fb4 	b	d9cc <hal_arch_default_isr>

00001af8 <cyg_io_init>:
// "init" entry points.  
//

void
cyg_io_init(void)
{
    1af8:	e92d4070 	push	{r4, r5, r6, lr}
    static int _init = false;
    cyg_devtab_entry_t *t;
    if (_init) return;
    1afc:	e59f605c 	ldr	r6, [pc, #92]	; 1b60 <cyg_io_init+0x68>
    1b00:	e5963000 	ldr	r3, [r6]
    1b04:	e3530000 	cmp	r3, #0	; 0x0
    1b08:	18bd8070 	popne	{r4, r5, r6, pc}
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
    1b0c:	e59f0050 	ldr	r0, [pc, #80]	; 1b64 <cyg_io_init+0x6c>
    1b10:	e59f5050 	ldr	r5, [pc, #80]	; 1b68 <cyg_io_init+0x70>
    1b14:	e1500005 	cmp	r0, r5
    1b18:	0a00000d 	beq	1b54 <cyg_io_init+0x5c>
    1b1c:	e1a04000 	mov	r4, r0
#ifdef CYGDBG_IO_INIT
        diag_printf("Init device '%s'\n", t->name);
#endif
        if (t->init(t)) {
    1b20:	e1a00004 	mov	r0, r4
    1b24:	e1a0e00f 	mov	lr, pc
    1b28:	e594f00c 	ldr	pc, [r4, #12]
    1b2c:	e3500000 	cmp	r0, #0	; 0x0
            t->status |= CYG_DEVTAB_STATUS_AVAIL;
    1b30:	15943018 	ldrne	r3, [r4, #24]
        } else {
            // What to do if device init fails?
            // Device not [currently] available
            t->status &= ~CYG_DEVTAB_STATUS_AVAIL;  
    1b34:	05943018 	ldreq	r3, [r4, #24]
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
#ifdef CYGDBG_IO_INIT
        diag_printf("Init device '%s'\n", t->name);
#endif
        if (t->init(t)) {
            t->status |= CYG_DEVTAB_STATUS_AVAIL;
    1b38:	13833001 	orrne	r3, r3, #1	; 0x1
        } else {
            // What to do if device init fails?
            // Device not [currently] available
            t->status &= ~CYG_DEVTAB_STATUS_AVAIL;  
    1b3c:	03c33001 	biceq	r3, r3, #1	; 0x1
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
#ifdef CYGDBG_IO_INIT
        diag_printf("Init device '%s'\n", t->name);
#endif
        if (t->init(t)) {
            t->status |= CYG_DEVTAB_STATUS_AVAIL;
    1b40:	15843018 	strne	r3, [r4, #24]
        } else {
            // What to do if device init fails?
            // Device not [currently] available
            t->status &= ~CYG_DEVTAB_STATUS_AVAIL;  
    1b44:	05843018 	streq	r3, [r4, #24]
cyg_io_init(void)
{
    static int _init = false;
    cyg_devtab_entry_t *t;
    if (_init) return;
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
    1b48:	e284401c 	add	r4, r4, #28	; 0x1c
    1b4c:	e1540005 	cmp	r4, r5
    1b50:	1afffff2 	bne	1b20 <cyg_io_init+0x28>
            // What to do if device init fails?
            // Device not [currently] available
            t->status &= ~CYG_DEVTAB_STATUS_AVAIL;  
        }
    }
    _init = true;
    1b54:	e3a03001 	mov	r3, #1	; 0x1
    1b58:	e5863000 	str	r3, [r6]
    1b5c:	e8bd8070 	pop	{r4, r5, r6, pc}
    1b60:	40001c60 	.word	0x40001c60
    1b64:	4000081c 	.word	0x4000081c
    1b68:	40000854 	.word	0x40000854

00001b6c <cyg_io_lookup>:
// initializations.
//

Cyg_ErrNo
cyg_io_lookup(const char *name, cyg_io_handle_t *handle)
{
    1b6c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        cyg_io_handle_t h;
    } stunion;
    cyg_devtab_entry_t *t;
    Cyg_ErrNo res;
    const char *name_ptr;
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
    1b70:	e59f30f0 	ldr	r3, [pc, #240]	; 1c68 <cyg_io_lookup+0xfc>
    1b74:	e59f70f0 	ldr	r7, [pc, #240]	; 1c6c <cyg_io_lookup+0x100>
    1b78:	e1530007 	cmp	r3, r7
// initializations.
//

Cyg_ErrNo
cyg_io_lookup(const char *name, cyg_io_handle_t *handle)
{
    1b7c:	e24dd008 	sub	sp, sp, #8	; 0x8
    1b80:	e1a04000 	mov	r4, r0
    1b84:	e1a08001 	mov	r8, r1
        cyg_io_handle_t h;
    } stunion;
    cyg_devtab_entry_t *t;
    Cyg_ErrNo res;
    const char *name_ptr;
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
    1b88:	0a00002a 	beq	1c38 <cyg_io_lookup+0xcc>
    1b8c:	e58d3000 	str	r3, [sp]
    1b90:	e1a05003 	mov	r5, r3
        if (cyg_io_compare(name, t->name, &name_ptr)) {
    1b94:	e595c000 	ldr	ip, [r5]
    1b98:	e3a03000 	mov	r3, #0	; 0x0
//    n2 ends in '/' and matches n1 up to the terminating '/'
// 'ptr' will get a pointer to the residual string.
static bool
cyg_io_compare(const char *n1, const char *n2, const char **ptr)
{
    while (*n1 && *n2) {
    1b9c:	e7d41003 	ldrb	r1, [r4, r3]
    1ba0:	e3510000 	cmp	r1, #0	; 0x0
        if (*n1++ != *n2++) {
    1ba4:	e08c0003 	add	r0, ip, r3
    1ba8:	e0846003 	add	r6, r4, r3
//    n2 ends in '/' and matches n1 up to the terminating '/'
// 'ptr' will get a pointer to the residual string.
static bool
cyg_io_compare(const char *n1, const char *n2, const char **ptr)
{
    while (*n1 && *n2) {
    1bac:	0a000029 	beq	1c58 <cyg_io_lookup+0xec>
    1bb0:	e7dc2003 	ldrb	r2, [ip, r3]
    1bb4:	e3520000 	cmp	r2, #0	; 0x0
    } stunion;
    cyg_devtab_entry_t *t;
    Cyg_ErrNo res;
    const char *name_ptr;
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
        if (cyg_io_compare(name, t->name, &name_ptr)) {
    1bb8:	e2833001 	add	r3, r3, #1	; 0x1
//    n2 ends in '/' and matches n1 up to the terminating '/'
// 'ptr' will get a pointer to the residual string.
static bool
cyg_io_compare(const char *n1, const char *n2, const char **ptr)
{
    while (*n1 && *n2) {
    1bbc:	0a000006 	beq	1bdc <cyg_io_lookup+0x70>
        if (*n1++ != *n2++) {
    1bc0:	e1510002 	cmp	r1, r2
    1bc4:	0afffff4 	beq	1b9c <cyg_io_lookup+0x30>
        cyg_io_handle_t h;
    } stunion;
    cyg_devtab_entry_t *t;
    Cyg_ErrNo res;
    const char *name_ptr;
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
    1bc8:	e285501c 	add	r5, r5, #28	; 0x1c
    1bcc:	e1550007 	cmp	r5, r7
    1bd0:	0a000018 	beq	1c38 <cyg_io_lookup+0xcc>
    1bd4:	e58d5000 	str	r5, [sp]
    1bd8:	eaffffed 	b	1b94 <cyg_io_lookup+0x28>
            return false;
        }
    }
    if (*n1) {
        // See if the devtab name is is a substring
        if (*(n2-1) == '/') {
    1bdc:	e5503001 	ldrb	r3, [r0, #-1]
    1be0:	e353002f 	cmp	r3, #47	; 0x2f
    1be4:	1afffff7 	bne	1bc8 <cyg_io_lookup+0x5c>
    Cyg_ErrNo res;
    const char *name_ptr;
    for (t = &__DEVTAB__[0]; t != &__DEVTAB_END__; t++) {
        if (cyg_io_compare(name, t->name, &name_ptr)) {
            // FUTURE: Check 'avail'/'online' here
            if (t->dep_name) {
    1be8:	e5950004 	ldr	r0, [r5, #4]
    1bec:	e3500000 	cmp	r0, #0	; 0x0
    1bf0:	0a000016 	beq	1c50 <cyg_io_lookup+0xe4>
                res = cyg_io_lookup(t->dep_name, &stunion.h);
    1bf4:	e28d1004 	add	r1, sp, #4	; 0x4
    1bf8:	ebffffdb 	bl	1b6c <cyg_io_lookup>
                if (res != ENOERR) {
    1bfc:	e3500000 	cmp	r0, #0	; 0x0
    1c00:	1a00000a 	bne	1c30 <cyg_io_lookup+0xc4>
                    return res;
                }
            } else {
                stunion.st = NULL;
            }
            if (t->lookup) {
    1c04:	e59d3000 	ldr	r3, [sp]
    1c08:	e593c010 	ldr	ip, [r3, #16]
    1c0c:	e35c0000 	cmp	ip, #0	; 0x0
    1c10:	0a00000b 	beq	1c44 <cyg_io_lookup+0xd8>
                // This indirection + the name pointer allows the lookup routine
                // to return a different 'devtab' handle.  This will provide for
                // 'pluggable' devices, file names, etc.
                res = (t->lookup)(&t, stunion.st, name_ptr);
    1c14:	e1a02006 	mov	r2, r6
    1c18:	e1a0000d 	mov	r0, sp
    1c1c:	e59d1004 	ldr	r1, [sp, #4]
    1c20:	e1a0e00f 	mov	lr, pc
    1c24:	e12fff1c 	bx	ip
                if (res != ENOERR) {
    1c28:	e3500000 	cmp	r0, #0	; 0x0
    1c2c:	0a000003 	beq	1c40 <cyg_io_lookup+0xd4>
            *handle = (cyg_io_handle_t)t;
            return ENOERR;
        }
    }
    return -ENOENT;  // Not found
}
    1c30:	e28dd008 	add	sp, sp, #8	; 0x8
    1c34:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                if (res != ENOERR) {
                    return res;
                }
            }
            *handle = (cyg_io_handle_t)t;
            return ENOERR;
    1c38:	e3e00001 	mvn	r0, #1	; 0x1
    1c3c:	eafffffb 	b	1c30 <cyg_io_lookup+0xc4>
    1c40:	e59d3000 	ldr	r3, [sp]
                res = (t->lookup)(&t, stunion.st, name_ptr);
                if (res != ENOERR) {
                    return res;
                }
            }
            *handle = (cyg_io_handle_t)t;
    1c44:	e5883000 	str	r3, [r8]
    1c48:	e3a00000 	mov	r0, #0	; 0x0
    1c4c:	eafffff7 	b	1c30 <cyg_io_lookup+0xc4>
                res = cyg_io_lookup(t->dep_name, &stunion.h);
                if (res != ENOERR) {
                    return res;
                }
            } else {
                stunion.st = NULL;
    1c50:	e58d0004 	str	r0, [sp, #4]
    1c54:	eaffffea 	b	1c04 <cyg_io_lookup+0x98>
        if (*(n2-1) == '/') {
            *ptr = n1;
            return true;
        }
    }
    if (*n1 || *n2) {
    1c58:	e5d03000 	ldrb	r3, [r0]
    1c5c:	e3530000 	cmp	r3, #0	; 0x0
    1c60:	0affffe0 	beq	1be8 <cyg_io_lookup+0x7c>
    1c64:	eaffffd7 	b	1bc8 <cyg_io_lookup+0x5c>
    1c68:	4000081c 	.word	0x4000081c
    1c6c:	40000854 	.word	0x40000854

00001c70 <cyg_io_write>:
Cyg_ErrNo 
cyg_io_write(cyg_io_handle_t handle, const void *buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->write) {
    1c70:	e5903008 	ldr	r3, [r0, #8]
// 'write' data to a device.
//

Cyg_ErrNo 
cyg_io_write(cyg_io_handle_t handle, const void *buf, cyg_uint32 *len)
{
    1c74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->write) {
    1c78:	e5933000 	ldr	r3, [r3]
    1c7c:	e3530000 	cmp	r3, #0	; 0x0
// 'write' data to a device.
//

Cyg_ErrNo 
cyg_io_write(cyg_io_handle_t handle, const void *buf, cyg_uint32 *len)
{
    1c80:	e1a0c000 	mov	ip, r0
    1c84:	e24dd004 	sub	sp, sp, #4	; 0x4
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->write) {
    1c88:	03e000c9 	mvneq	r0, #201	; 0xc9
    1c8c:	0a000007 	beq	1cb0 <cyg_io_write+0x40>
        return -EDEVNOSUPP;
    }
    // Special check.  If length is zero, this just verifies that the 
    // 'write' method exists for the given device.
    if (NULL != len && 0 == *len) {
    1c90:	e3520000 	cmp	r2, #0	; 0x0
    1c94:	0a000002 	beq	1ca4 <cyg_io_write+0x34>
    1c98:	e5920000 	ldr	r0, [r2]
    1c9c:	e3500000 	cmp	r0, #0	; 0x0
    1ca0:	0a000002 	beq	1cb0 <cyg_io_write+0x40>
        return ENOERR;
    }
    return t->handlers->write(handle, buf, len);
    1ca4:	e1a0000c 	mov	r0, ip
    1ca8:	e1a0e00f 	mov	lr, pc
    1cac:	e12fff13 	bx	r3
}
    1cb0:	e28dd004 	add	sp, sp, #4	; 0x4
    1cb4:	e8bd8000 	pop	{pc}

00001cb8 <cyg_io_read>:
Cyg_ErrNo 
cyg_io_read(cyg_io_handle_t handle, void *buf, cyg_uint32 *len)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->read) {
    1cb8:	e5903008 	ldr	r3, [r0, #8]
// 'read' data from a device.
//

Cyg_ErrNo 
cyg_io_read(cyg_io_handle_t handle, void *buf, cyg_uint32 *len)
{
    1cbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->read) {
    1cc0:	e5933004 	ldr	r3, [r3, #4]
    1cc4:	e3530000 	cmp	r3, #0	; 0x0
// 'read' data from a device.
//

Cyg_ErrNo 
cyg_io_read(cyg_io_handle_t handle, void *buf, cyg_uint32 *len)
{
    1cc8:	e1a0c000 	mov	ip, r0
    1ccc:	e24dd004 	sub	sp, sp, #4	; 0x4
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->read) {
    1cd0:	03e000c9 	mvneq	r0, #201	; 0xc9
    1cd4:	0a000007 	beq	1cf8 <cyg_io_read+0x40>
        return -EDEVNOSUPP;
    }
    // Special check.  If length is zero, this just verifies that the 
    // 'read' method exists for the given device.
    if (NULL != len && 0 == *len) {
    1cd8:	e3520000 	cmp	r2, #0	; 0x0
    1cdc:	0a000002 	beq	1cec <cyg_io_read+0x34>
    1ce0:	e5920000 	ldr	r0, [r2]
    1ce4:	e3500000 	cmp	r0, #0	; 0x0
    1ce8:	0a000002 	beq	1cf8 <cyg_io_read+0x40>
        return ENOERR;
    }
    return t->handlers->read(handle, buf, len);
    1cec:	e1a0000c 	mov	r0, ip
    1cf0:	e1a0e00f 	mov	lr, pc
    1cf4:	e12fff13 	bx	r3
}
    1cf8:	e28dd004 	add	sp, sp, #4	; 0x4
    1cfc:	e8bd8000 	pop	{pc}

00001d00 <cyg_io_bwrite>:
// 'write' blocks to a device. The len and the position are in terms
// of blocks, not bytes like the cyg_io_write.
//
Cyg_ErrNo 
cyg_io_bwrite(cyg_io_handle_t handle, const void *buf, cyg_uint32 *len, cyg_uint32 pos)
{
    1d00:	e1a0c000 	mov	ip, r0
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->bwrite) {
    1d04:	e5900008 	ldr	r0, [r0, #8]
// 'write' blocks to a device. The len and the position are in terms
// of blocks, not bytes like the cyg_io_write.
//
Cyg_ErrNo 
cyg_io_bwrite(cyg_io_handle_t handle, const void *buf, cyg_uint32 *len, cyg_uint32 pos)
{
    1d08:	e92d4010 	push	{r4, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->bwrite) {
    1d0c:	e5904008 	ldr	r4, [r0, #8]
    1d10:	e3540000 	cmp	r4, #0	; 0x0
    1d14:	03e000c9 	mvneq	r0, #201	; 0xc9
    1d18:	08bd8010 	popeq	{r4, pc}
        return -EDEVNOSUPP;
    }
    // Special check.  If length is zero, this just verifies that the 
    // 'bwrite' method exists for the given device.
    if (NULL != len && 0 == *len) {
    1d1c:	e3520000 	cmp	r2, #0	; 0x0
    1d20:	0a000002 	beq	1d30 <cyg_io_bwrite+0x30>
    1d24:	e5920000 	ldr	r0, [r2]
    1d28:	e3500000 	cmp	r0, #0	; 0x0
    1d2c:	08bd8010 	popeq	{r4, pc}
        return ENOERR;
    }
    return t->handlers->bwrite(handle, buf, len, pos);
    1d30:	e1a0000c 	mov	r0, ip
    1d34:	e1a0e00f 	mov	lr, pc
    1d38:	e12fff14 	bx	r4
}
    1d3c:	e8bd8010 	pop	{r4, pc}

00001d40 <cyg_io_bread>:
// 'read' blocks from a device. The len and the position are in terms of
// blocks, not bytes like the cyg_io_read.
//
Cyg_ErrNo 
cyg_io_bread(cyg_io_handle_t handle, void *buf, cyg_uint32 *len, cyg_uint32 pos)
{
    1d40:	e1a0c000 	mov	ip, r0
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->bread) {
    1d44:	e5900008 	ldr	r0, [r0, #8]
// 'read' blocks from a device. The len and the position are in terms of
// blocks, not bytes like the cyg_io_read.
//
Cyg_ErrNo 
cyg_io_bread(cyg_io_handle_t handle, void *buf, cyg_uint32 *len, cyg_uint32 pos)
{
    1d48:	e92d4010 	push	{r4, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->bread) {
    1d4c:	e590400c 	ldr	r4, [r0, #12]
    1d50:	e3540000 	cmp	r4, #0	; 0x0
    1d54:	03e000c9 	mvneq	r0, #201	; 0xc9
    1d58:	08bd8010 	popeq	{r4, pc}
        return -EDEVNOSUPP;
    }
    // Special check.  If length is zero, this just verifies that the 
    // 'bread' method exists for the given device.
    if (NULL != len && 0 == *len) {
    1d5c:	e3520000 	cmp	r2, #0	; 0x0
    1d60:	0a000002 	beq	1d70 <cyg_io_bread+0x30>
    1d64:	e5920000 	ldr	r0, [r2]
    1d68:	e3500000 	cmp	r0, #0	; 0x0
    1d6c:	08bd8010 	popeq	{r4, pc}
        return ENOERR;
    }
    return t->handlers->bread(handle, buf, len, pos);
    1d70:	e1a0000c 	mov	r0, ip
    1d74:	e1a0e00f 	mov	lr, pc
    1d78:	e12fff14 	bx	r4
}
    1d7c:	e8bd8010 	pop	{r4, pc}

00001d80 <cyg_io_select>:
cyg_bool
cyg_io_select(cyg_io_handle_t handle, cyg_uint32 which, CYG_ADDRWORD info)
{
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->select) {
    1d80:	e5903008 	ldr	r3, [r0, #8]
// Check device for available input or space for output
//

cyg_bool
cyg_io_select(cyg_io_handle_t handle, cyg_uint32 which, CYG_ADDRWORD info)
{
    1d84:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->select) {
    1d88:	e5933010 	ldr	r3, [r3, #16]
    1d8c:	e3530000 	cmp	r3, #0	; 0x0
// Check device for available input or space for output
//

cyg_bool
cyg_io_select(cyg_io_handle_t handle, cyg_uint32 which, CYG_ADDRWORD info)
{
    1d90:	e24dd004 	sub	sp, sp, #4	; 0x4
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->select) {
    1d94:	03e000c9 	mvneq	r0, #201	; 0xc9
        return -EDEVNOSUPP;
    }

    return t->handlers->select( handle, which, info );
    1d98:	11a0e00f 	movne	lr, pc
    1d9c:	112fff13 	bxne	r3
}
    1da0:	e28dd004 	add	sp, sp, #4	; 0x4
    1da4:	e8bd8000 	pop	{pc}

00001da8 <cyg_io_get_config>:
// Get the configuration of a device.
//

Cyg_ErrNo 
cyg_io_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *buf, cyg_uint32 *len)
{
    1da8:	e1a0c000 	mov	ip, r0
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->get_config) {
    1dac:	e5900008 	ldr	r0, [r0, #8]
// Get the configuration of a device.
//

Cyg_ErrNo 
cyg_io_get_config(cyg_io_handle_t handle, cyg_uint32 key, void *buf, cyg_uint32 *len)
{
    1db0:	e92d4010 	push	{r4, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->get_config) {
    1db4:	e5904014 	ldr	r4, [r0, #20]
    1db8:	e3540000 	cmp	r4, #0	; 0x0
    1dbc:	03e000c9 	mvneq	r0, #201	; 0xc9
    1dc0:	08bd8010 	popeq	{r4, pc}
        return -EDEVNOSUPP;
    }
    // Special check.  If length is zero, this just verifies that the 
    // 'get_config' method exists for the given device.
    if (NULL != len && 0 == *len) {
    1dc4:	e3530000 	cmp	r3, #0	; 0x0
    1dc8:	0a000002 	beq	1dd8 <cyg_io_get_config+0x30>
    1dcc:	e5930000 	ldr	r0, [r3]
    1dd0:	e3500000 	cmp	r0, #0	; 0x0
    1dd4:	08bd8010 	popeq	{r4, pc}
        return ENOERR;
    }
    return t->handlers->get_config(handle, key, buf, len);
    1dd8:	e1a0000c 	mov	r0, ip
    1ddc:	e1a0e00f 	mov	lr, pc
    1de0:	e12fff14 	bx	r4
}
    1de4:	e8bd8010 	pop	{r4, pc}

00001de8 <cyg_io_set_config>:
// Change the configuration of a device.
//

Cyg_ErrNo 
cyg_io_set_config(cyg_io_handle_t handle, cyg_uint32 key, const void *buf, cyg_uint32 *len)
{
    1de8:	e1a0c000 	mov	ip, r0
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->set_config) {
    1dec:	e5900008 	ldr	r0, [r0, #8]
// Change the configuration of a device.
//

Cyg_ErrNo 
cyg_io_set_config(cyg_io_handle_t handle, cyg_uint32 key, const void *buf, cyg_uint32 *len)
{
    1df0:	e92d4010 	push	{r4, lr}
    cyg_devtab_entry_t *t = (cyg_devtab_entry_t *)handle;
    // Validate request
    if (!t->handlers->set_config) {
    1df4:	e5904018 	ldr	r4, [r0, #24]
    1df8:	e3540000 	cmp	r4, #0	; 0x0
    1dfc:	03e000c9 	mvneq	r0, #201	; 0xc9
    1e00:	08bd8010 	popeq	{r4, pc}
        return -EDEVNOSUPP;
    }
    // Special check.  If length is zero, this just verifies that the 
    // 'set_config' method exists for the given device.
    if (NULL != len && 0 == *len) {
    1e04:	e3530000 	cmp	r3, #0	; 0x0
    1e08:	0a000002 	beq	1e18 <cyg_io_set_config+0x30>
    1e0c:	e5930000 	ldr	r0, [r3]
    1e10:	e3500000 	cmp	r0, #0	; 0x0
    1e14:	08bd8010 	popeq	{r4, pc}
        return ENOERR;
    }
    return t->handlers->set_config(handle, key, buf, len);
    1e18:	e1a0000c 	mov	r0, ip
    1e1c:	e1a0e00f 	mov	lr, pc
    1e20:	e12fff14 	bx	r4
}
    1e24:	e8bd8010 	pop	{r4, pc}

00001e28 <cyg_devio_cwrite>:
// Default functions for devio tables

Cyg_ErrNo cyg_devio_cwrite(cyg_io_handle_t handle, const void *buf, cyg_uint32 *len)
{
    return -EDEVNOSUPP;
}
    1e28:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e2c:	e12fff1e 	bx	lr

00001e30 <cyg_devio_cread>:

Cyg_ErrNo cyg_devio_cread(cyg_io_handle_t handle, void *buf, cyg_uint32 *len)
{
    return -EDEVNOSUPP;
}
    1e30:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e34:	e12fff1e 	bx	lr

00001e38 <cyg_devio_bwrite>:

Cyg_ErrNo cyg_devio_bwrite(cyg_io_handle_t handle, const void *buf,
                        cyg_uint32 *len, cyg_uint32 pos)
{
    return -EDEVNOSUPP;
}
    1e38:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e3c:	e12fff1e 	bx	lr

00001e40 <cyg_devio_bread>:

Cyg_ErrNo cyg_devio_bread(cyg_io_handle_t handle, void *buf,
                       cyg_uint32 *len, cyg_uint32 pos)
{
    return -EDEVNOSUPP;
}
    1e40:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e44:	e12fff1e 	bx	lr

00001e48 <cyg_devio_select>:
{
    CYG_UNUSED_PARAM(cyg_io_handle_t, handle);
    CYG_UNUSED_PARAM(cyg_uint32, which);
    CYG_UNUSED_PARAM(CYG_ADDRWORD, info);
    return -EDEVNOSUPP;
}
    1e48:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e4c:	e12fff1e 	bx	lr

00001e50 <cyg_devio_get_config>:
    CYG_UNUSED_PARAM(cyg_io_handle_t, handle);
    CYG_UNUSED_PARAM(cyg_uint32, key);
    CYG_UNUSED_PARAM(void*, buf);
    CYG_UNUSED_PARAM(cyg_uint32*, len);
    return -EDEVNOSUPP;
}
    1e50:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e54:	e12fff1e 	bx	lr

00001e58 <cyg_devio_set_config>:
    CYG_UNUSED_PARAM(cyg_io_handle_t, handle);
    CYG_UNUSED_PARAM(cyg_uint32, key);
    CYG_UNUSED_PARAM(void*, buf);
    CYG_UNUSED_PARAM(cyg_uint32*, len);
    return -EDEVNOSUPP;
}
    1e58:	e3e000c9 	mvn	r0, #201	; 0xc9
    1e5c:	e12fff1e 	bx	lr

00001e60 <cyg_start>:


// FUNCTIONS

void
cyg_start( void )
    1e60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    1e64:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARGVOID();

    cyg_prestart();
    1e68:	eb000002 	bl	1e78 <cyg_prestart>

    cyg_package_start();
    1e6c:	eb000002 	bl	1e7c <cyg_package_start>

    cyg_user_start();
    1e70:	eb000002 	bl	1e80 <cyg_user_start>

#ifdef CYGPKG_KERNEL
    Cyg_Scheduler::start();
    1e74:	eb000ee7 	bl	5a18 <_ZN13Cyg_Scheduler5startEv>

00001e78 <cyg_prestart>:
    CYG_TRACE0( true, "This is the system default cyg_prestart()" );

    CYG_EMPTY_STATEMENT; // don't let it complain about doing nothing

    CYG_REPORT_RETURN();
} // cyg_prestart()
    1e78:	e12fff1e 	bx	lr

00001e7c <cyg_package_start>:
#endif

    CYG_EMPTY_STATEMENT; // don't let it complain about doing nothing

    CYG_REPORT_RETURN();
} // cyg_package_start()
    1e7c:	e12fff1e 	bx	lr

00001e80 <cyg_user_start>:
    CYG_TRACE0( true, "This is the system default cyg_user_start()" );

    CYG_EMPTY_STATEMENT; // don't let it complain about doing nothing

    CYG_REPORT_RETURN();
} // cyg_user_start()
    1e80:	e12fff1e 	bx	lr

00001e84 <diag_init>:
/*----------------------------------------------------------------------*/
/* Initialize. Call to pull in diag initializing constructor            */

externC void diag_init(void)
{
}
    1e84:	e12fff1e 	bx	lr

00001e88 <diag_init_putc>:
static void (*_putc)(char c, void **param) = _diag_write_char;

void
diag_init_putc(void (*putc)(char c, void **param))
{
    _putc = putc;
    1e88:	e59f3004 	ldr	r3, [pc, #4]	; 1e94 <diag_init_putc+0xc>
    1e8c:	e5830000 	str	r0, [r3]
}
    1e90:	e12fff1e 	bx	lr
    1e94:	400007bc 	.word	0x400007bc

00001e98 <_ZL4_cvtyPclS_>:
}

/*----------------------------------------------------------------------*/

static int
_cvt(unsigned long long val, char *buf, long radix, char *digits)
    1e98:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    1e9c:	e1a05001 	mov	r5, r1
    1ea0:	e24dd050 	sub	sp, sp, #80	; 0x50
{
    char temp[80];
    char *cp = temp;
    int length = 0;

    if (val == 0) {
    1ea4:	e1901005 	orrs	r1, r0, r5
}

/*----------------------------------------------------------------------*/

static int
_cvt(unsigned long long val, char *buf, long radix, char *digits)
    1ea8:	e1a04000 	mov	r4, r0
    1eac:	e1a0a002 	mov	sl, r2
    1eb0:	e59d9070 	ldr	r9, [sp, #112]
        while (val) {
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
    1eb4:	11a07003 	movne	r7, r3
    1eb8:	11a08fc7 	asrne	r8, r7, #31
    1ebc:	128d6001 	addne	r6, sp, #1	; 0x1
{
    char temp[80];
    char *cp = temp;
    int length = 0;

    if (val == 0) {
    1ec0:	1a000011 	bne	1f0c <_ZL4_cvtyPclS_+0x74>
        /* Special case */
        *cp++ = '0';
    1ec4:	e3a03030 	mov	r3, #48	; 0x30
    1ec8:	e5cd3000 	strb	r3, [sp]
    1ecc:	e28dc001 	add	ip, sp, #1	; 0x1
    1ed0:	e1a0000d 	mov	r0, sp
    1ed4:	e1a0100c 	mov	r1, ip
    1ed8:	e3a02000 	mov	r2, #0	; 0x0
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
        *buf++ = *--cp;
    1edc:	e5713001 	ldrb	r3, [r1, #-1]!
        while (val) {
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
    1ee0:	e1500001 	cmp	r0, r1
        *buf++ = *--cp;
    1ee4:	e7ca3002 	strb	r3, [sl, r2]
        length++;
    1ee8:	e2822001 	add	r2, r2, #1	; 0x1
        while (val) {
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
    1eec:	1afffffa 	bne	1edc <_ZL4_cvtyPclS_+0x44>
}

/*----------------------------------------------------------------------*/

static int
_cvt(unsigned long long val, char *buf, long radix, char *digits)
    1ef0:	e060300c 	rsb	r3, r0, ip
    1ef4:	e08aa003 	add	sl, sl, r3
    1ef8:	e060000c 	rsb	r0, r0, ip
    }
    while (cp != temp) {
        *buf++ = *--cp;
        length++;
    }
    *buf = '\0';
    1efc:	e3a03000 	mov	r3, #0	; 0x0
    1f00:	e5ca3000 	strb	r3, [sl]
    return (length);
}
    1f04:	e28dd050 	add	sp, sp, #80	; 0x50
    1f08:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
    1f0c:	e1a00004 	mov	r0, r4
    1f10:	e1a01005 	mov	r1, r5
    1f14:	e1a02007 	mov	r2, r7
    1f18:	e1a03008 	mov	r3, r8
    1f1c:	eb003fc1 	bl	11e28 <__aeabi_uldivmod>
    1f20:	e7d9c002 	ldrb	ip, [r9, r2]
            val /= radix;
    1f24:	e1a00004 	mov	r0, r4
    1f28:	e1a01005 	mov	r1, r5
    1f2c:	e1a03008 	mov	r3, r8
    1f30:	e1a02007 	mov	r2, r7
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
    1f34:	e546c001 	strb	ip, [r6, #-1]
            val /= radix;
    1f38:	eb003fba 	bl	11e28 <__aeabi_uldivmod>

    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
    1f3c:	e1903001 	orrs	r3, r0, r1
            *cp++ = digits[val % radix];
    1f40:	e1a0c006 	mov	ip, r6
            val /= radix;
    1f44:	e1a04000 	mov	r4, r0
    1f48:	e1a05001 	mov	r5, r1
    1f4c:	e2866001 	add	r6, r6, #1	; 0x1

    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
    1f50:	1affffed 	bne	1f0c <_ZL4_cvtyPclS_+0x74>
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
    1f54:	e15c000d 	cmp	ip, sp
    1f58:	e1a0000d 	mov	r0, sp
    1f5c:	01a00003 	moveq	r0, r3
    1f60:	1affffdb 	bne	1ed4 <_ZL4_cvtyPclS_+0x3c>
    1f64:	eaffffe4 	b	1efc <_ZL4_cvtyPclS_+0x64>

00001f68 <_ZL6_sputccPPv>:
static void 
_sputc(char c, void **param)
{
    struct _sputc_info *info = (struct _sputc_info *)param;

    if (info->len < info->max) {
    1f68:	e5912008 	ldr	r2, [r1, #8]
    1f6c:	e5913004 	ldr	r3, [r1, #4]
    1f70:	e1520003 	cmp	r2, r3
    char *ptr;
    int max, len;
};

static void 
_sputc(char c, void **param)
    1f74:	e1a0c001 	mov	ip, r1
{
    struct _sputc_info *info = (struct _sputc_info *)param;

    if (info->len < info->max) {
    1f78:	a12fff1e 	bxge	lr
        *(info->ptr)++ = c;
    1f7c:	e5911000 	ldr	r1, [r1]
    1f80:	e1a03001 	mov	r3, r1
    1f84:	e4c30001 	strb	r0, [r3], #1
        *(info->ptr) = '\0';
    1f88:	e3a02000 	mov	r2, #0	; 0x0
_sputc(char c, void **param)
{
    struct _sputc_info *info = (struct _sputc_info *)param;

    if (info->len < info->max) {
        *(info->ptr)++ = c;
    1f8c:	e58c3000 	str	r3, [ip]
        *(info->ptr) = '\0';
    1f90:	e5c12001 	strb	r2, [r1, #1]
        info->len++;
    1f94:	e59c3008 	ldr	r3, [ip, #8]
    1f98:	e2833001 	add	r3, r3, #1	; 0x1
    1f9c:	e58c3008 	str	r3, [ip, #8]
    1fa0:	e12fff1e 	bx	lr

00001fa4 <diag_vdump_buf_with_offset>:

void
diag_vdump_buf_with_offset(__printf_fun *pf,
                           cyg_uint8     *p, 
                           CYG_ADDRWORD   s, 
                           cyg_uint8     *base)
    1fa4:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
{
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
    1fa8:	e1510002 	cmp	r1, r2

void
diag_vdump_buf_with_offset(__printf_fun *pf,
                           cyg_uint8     *p, 
                           CYG_ADDRWORD   s, 
                           cyg_uint8     *base)
    1fac:	e1a06002 	mov	r6, r2
{
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    1fb0:	30616002 	rsbcc	r6, r1, r2
    }
    while ((int)s > 0) {
    1fb4:	e3560000 	cmp	r6, #0	; 0x0

void
diag_vdump_buf_with_offset(__printf_fun *pf,
                           cyg_uint8     *p, 
                           CYG_ADDRWORD   s, 
                           cyg_uint8     *base)
    1fb8:	e24dd004 	sub	sp, sp, #4	; 0x4
    1fbc:	e1a07001 	mov	r7, r1
    1fc0:	e1a05000 	mov	r5, r0
    1fc4:	e1a0a003 	mov	sl, r3
{
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    1fc8:	da00003d 	ble	20c4 <diag_vdump_buf_with_offset+0x120>
        if (base) {
    1fcc:	e35a0000 	cmp	sl, #0	; 0x0
{
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    1fd0:	e0638001 	rsb	r8, r3, r1
        if (base) {
    1fd4:	0a00002a 	beq	2084 <diag_vdump_buf_with_offset+0xe0>
            (*pf)("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
    1fd8:	e1a01008 	mov	r1, r8
    1fdc:	e59f00e8 	ldr	r0, [pc, #232]	; 20cc <diag_vdump_buf_with_offset+0x128>
    1fe0:	e1a0e00f 	mov	lr, pc
    1fe4:	e12fff15 	bx	r5
        } else {
            (*pf)("%08X: ", p);
    1fe8:	e3a04000 	mov	r4, #0	; 0x0
        }
        for (i = 0;  i < 16;  i++) {
            if (i < (int)s) {
    1fec:	e1560004 	cmp	r6, r4
                (*pf)("%02X ", p[i] & 0xFF);
    1ff0:	e59f00d8 	ldr	r0, [pc, #216]	; 20d0 <diag_vdump_buf_with_offset+0x12c>
            (*pf)("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            (*pf)("%08X: ", p);
        }
        for (i = 0;  i < 16;  i++) {
            if (i < (int)s) {
    1ff4:	da000027 	ble	2098 <diag_vdump_buf_with_offset+0xf4>
                (*pf)("%02X ", p[i] & 0xFF);
    1ff8:	e7d71004 	ldrb	r1, [r7, r4]
    1ffc:	e1a0e00f 	mov	lr, pc
    2000:	e12fff15 	bx	r5
            } else {
                (*pf)("   ");
            }
	    if (i == 7) (*pf)(" ");
    2004:	e3540007 	cmp	r4, #7	; 0x7
        if (base) {
            (*pf)("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            (*pf)("%08X: ", p);
        }
        for (i = 0;  i < 16;  i++) {
    2008:	e2844001 	add	r4, r4, #1	; 0x1
            if (i < (int)s) {
                (*pf)("%02X ", p[i] & 0xFF);
            } else {
                (*pf)("   ");
            }
	    if (i == 7) (*pf)(" ");
    200c:	0a000027 	beq	20b0 <diag_vdump_buf_with_offset+0x10c>
        if (base) {
            (*pf)("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            (*pf)("%08X: ", p);
        }
        for (i = 0;  i < 16;  i++) {
    2010:	e354000f 	cmp	r4, #15	; 0xf
    2014:	dafffff4 	ble	1fec <diag_vdump_buf_with_offset+0x48>
            } else {
                (*pf)("   ");
            }
	    if (i == 7) (*pf)(" ");
        }
        (*pf)(" |");
    2018:	e59f00b4 	ldr	r0, [pc, #180]	; 20d4 <diag_vdump_buf_with_offset+0x130>
    201c:	e1a0e00f 	mov	lr, pc
    2020:	e12fff15 	bx	r5
    2024:	e3a04000 	mov	r4, #0	; 0x0
        for (i = 0;  i < 16;  i++) {
            if (i < (int)s) {
    2028:	e1560004 	cmp	r6, r4
    202c:	d3a01020 	movle	r1, #32	; 0x20
    2030:	da000003 	ble	2044 <diag_vdump_buf_with_offset+0xa0>
                c = p[i] & 0xFF;
    2034:	e7d71004 	ldrb	r1, [r7, r4]
                if ((c < 0x20) || (c >= 0x7F)) c = '.';
    2038:	e2413020 	sub	r3, r1, #32	; 0x20
    203c:	e353005e 	cmp	r3, #94	; 0x5e
    2040:	83a0102e 	movhi	r1, #46	; 0x2e
                (*pf)("   ");
            }
	    if (i == 7) (*pf)(" ");
        }
        (*pf)(" |");
        for (i = 0;  i < 16;  i++) {
    2044:	e2844001 	add	r4, r4, #1	; 0x1
                c = p[i] & 0xFF;
                if ((c < 0x20) || (c >= 0x7F)) c = '.';
            } else {
                c = ' ';
            }
            (*pf)("%c", c);
    2048:	e59f0088 	ldr	r0, [pc, #136]	; 20d8 <diag_vdump_buf_with_offset+0x134>
    204c:	e1a0e00f 	mov	lr, pc
    2050:	e12fff15 	bx	r5
                (*pf)("   ");
            }
	    if (i == 7) (*pf)(" ");
        }
        (*pf)(" |");
        for (i = 0;  i < 16;  i++) {
    2054:	e3540010 	cmp	r4, #16	; 0x10
    2058:	1afffff2 	bne	2028 <diag_vdump_buf_with_offset+0x84>
                c = ' ';
            }
            (*pf)("%c", c);
        }
        (*pf)("|\n");
        s -= 16;
    205c:	e2466010 	sub	r6, r6, #16	; 0x10
            } else {
                c = ' ';
            }
            (*pf)("%c", c);
        }
        (*pf)("|\n");
    2060:	e59f0074 	ldr	r0, [pc, #116]	; 20dc <diag_vdump_buf_with_offset+0x138>
    2064:	e1a0e00f 	mov	lr, pc
    2068:	e12fff15 	bx	r5
{
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    206c:	e3560000 	cmp	r6, #0	; 0x0
                c = ' ';
            }
            (*pf)("%c", c);
        }
        (*pf)("|\n");
        s -= 16;
    2070:	e2888010 	add	r8, r8, #16	; 0x10
{
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2074:	da000012 	ble	20c4 <diag_vdump_buf_with_offset+0x120>
        if (base) {
    2078:	e35a0000 	cmp	sl, #0	; 0x0
            }
            (*pf)("%c", c);
        }
        (*pf)("|\n");
        s -= 16;
        p += 16;
    207c:	e2877010 	add	r7, r7, #16	; 0x10
    int i, c;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
        if (base) {
    2080:	1affffd4 	bne	1fd8 <diag_vdump_buf_with_offset+0x34>
            (*pf)("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            (*pf)("%08X: ", p);
    2084:	e1a01007 	mov	r1, r7
    2088:	e59f003c 	ldr	r0, [pc, #60]	; 20cc <diag_vdump_buf_with_offset+0x128>
    208c:	e1a0e00f 	mov	lr, pc
    2090:	e12fff15 	bx	r5
    2094:	eaffffd3 	b	1fe8 <diag_vdump_buf_with_offset+0x44>
        }
        for (i = 0;  i < 16;  i++) {
            if (i < (int)s) {
                (*pf)("%02X ", p[i] & 0xFF);
            } else {
                (*pf)("   ");
    2098:	e59f0040 	ldr	r0, [pc, #64]	; 20e0 <diag_vdump_buf_with_offset+0x13c>
    209c:	e1a0e00f 	mov	lr, pc
    20a0:	e12fff15 	bx	r5
            }
	    if (i == 7) (*pf)(" ");
    20a4:	e3540007 	cmp	r4, #7	; 0x7
        if (base) {
            (*pf)("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            (*pf)("%08X: ", p);
        }
        for (i = 0;  i < 16;  i++) {
    20a8:	e2844001 	add	r4, r4, #1	; 0x1
            if (i < (int)s) {
                (*pf)("%02X ", p[i] & 0xFF);
            } else {
                (*pf)("   ");
            }
	    if (i == 7) (*pf)(" ");
    20ac:	1affffd7 	bne	2010 <diag_vdump_buf_with_offset+0x6c>
    20b0:	e59f002c 	ldr	r0, [pc, #44]	; 20e4 <diag_vdump_buf_with_offset+0x140>
    20b4:	e1a0e00f 	mov	lr, pc
    20b8:	e12fff15 	bx	r5
    20bc:	e3a04008 	mov	r4, #8	; 0x8
    20c0:	eaffffc9 	b	1fec <diag_vdump_buf_with_offset+0x48>
        }
        (*pf)("|\n");
        s -= 16;
        p += 16;
    }
}
    20c4:	e28dd004 	add	sp, sp, #4	; 0x4
    20c8:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    20cc:	0001299c 	.word	0x0001299c
    20d0:	000129a4 	.word	0x000129a4
    20d4:	000129b0 	.word	0x000129b0
    20d8:	000129b4 	.word	0x000129b4
    20dc:	000129b8 	.word	0x000129b8
    20e0:	000129ac 	.word	0x000129ac
    20e4:	00012a4c 	.word	0x00012a4c

000020e8 <diag_dump_buf_with_offset>:

void
diag_dump_buf_with_offset(cyg_uint8     *p, 
                          CYG_ADDRWORD   s, 
                          cyg_uint8     *base)
    20e8:	e1a0c001 	mov	ip, r1
{
    diag_vdump_buf_with_offset(diag_printf, p, s, base);
    20ec:	e1a01000 	mov	r1, r0
    20f0:	e59f0008 	ldr	r0, [pc, #8]	; 2100 <diag_dump_buf_with_offset+0x18>
}

void
diag_dump_buf_with_offset(cyg_uint8     *p, 
                          CYG_ADDRWORD   s, 
                          cyg_uint8     *base)
    20f4:	e1a03002 	mov	r3, r2
{
    diag_vdump_buf_with_offset(diag_printf, p, s, base);
    20f8:	e1a0200c 	mov	r2, ip
    20fc:	eaffffa8 	b	1fa4 <diag_vdump_buf_with_offset>
    2100:	00002e64 	.word	0x00002e64

00002104 <diag_dump_buf>:
}

void
diag_dump_buf(void *p, CYG_ADDRWORD s)
{
   diag_dump_buf_with_offset((cyg_uint8 *)p, s, 0);
    2104:	e3a02000 	mov	r2, #0	; 0x0
    2108:	eafffff6 	b	20e8 <diag_dump_buf_with_offset>

0000210c <_GLOBAL__I.10100_diag_write_char>:
    );

class Cyg_dummy_diag_init_class {
public:
    Cyg_dummy_diag_init_class() {
        HAL_DIAG_INIT();
    210c:	eafffd2c 	b	15c4 <hal_if_diag_init>

00002110 <diag_write_char>:

externC void diag_write_char(char c)
{    
    /* Translate LF into CRLF */
    
    if( c == '\n' )
    2110:	e350000a 	cmp	r0, #10	; 0xa
                                      CYGBLD_ATTRIB_INIT_AFTER(CYG_INIT_HAL);

/*----------------------------------------------------------------------*/
/* Write single char to output                                          */

externC void diag_write_char(char c)
    2114:	e92d4010 	push	{r4, lr}
    2118:	e1a04000 	mov	r4, r0
{    
    /* Translate LF into CRLF */
    
    if( c == '\n' )
    211c:	0a000002 	beq	212c <diag_write_char+0x1c>
    {
        HAL_DIAG_WRITE_CHAR('\r');        
    }

    HAL_DIAG_WRITE_CHAR(c);
    2120:	e1a00004 	mov	r0, r4
}
    2124:	e8bd4010 	pop	{r4, lr}
    if( c == '\n' )
    {
        HAL_DIAG_WRITE_CHAR('\r');        
    }

    HAL_DIAG_WRITE_CHAR(c);
    2128:	eafffda6 	b	17c8 <hal_if_diag_write_char>
{    
    /* Translate LF into CRLF */
    
    if( c == '\n' )
    {
        HAL_DIAG_WRITE_CHAR('\r');        
    212c:	e3a0000d 	mov	r0, #13	; 0xd
    2130:	ebfffda4 	bl	17c8 <hal_if_diag_write_char>
    2134:	eafffff9 	b	2120 <diag_write_char+0x10>

00002138 <_ZL16_diag_write_charcPPv>:

// Default wrapper function used by diag_printf
static void
_diag_write_char(char c, void **param)
{
    diag_write_char(c);
    2138:	eafffff4 	b	2110 <diag_write_char>

0000213c <diag_write_long_num>:
    cyg_uint64  n,              /* number to write              */
    cyg_ucount8 base,           /* radix to write to            */
    cyg_ucount8 sign,           /* sign, '-' if -ve, '+' if +ve */
    cyg_bool    pfzero,         /* prefix with zero ?           */
    cyg_ucount8 width           /* min width of number          */
    )
    213c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2140:	e24dd02c 	sub	sp, sp, #44	; 0x2c
{
    char buf[32];
    cyg_count8 bpos;
    char bufinit = pfzero?'0':' ';
    2144:	e59dc050 	ldr	ip, [sp, #80]
    char *digits = (char *)"0123456789ABCDEF";
    2148:	e59fb104 	ldr	fp, [pc, #260]	; 2254 <diag_write_long_num+0x118>
    cyg_ucount8 width           /* min width of number          */
    )
{
    char buf[32];
    cyg_count8 bpos;
    char bufinit = pfzero?'0':' ';
    214c:	e35c0000 	cmp	ip, #0	; 0x0
    cyg_uint64  n,              /* number to write              */
    cyg_ucount8 base,           /* radix to write to            */
    cyg_ucount8 sign,           /* sign, '-' if -ve, '+' if +ve */
    cyg_bool    pfzero,         /* prefix with zero ?           */
    cyg_ucount8 width           /* min width of number          */
    )
    2150:	e58d3004 	str	r3, [sp, #4]
{
    char buf[32];
    cyg_count8 bpos;
    char bufinit = pfzero?'0':' ';
    2154:	13a09030 	movne	r9, #48	; 0x30
    2158:	03a09020 	moveq	r9, #32	; 0x20
    cyg_uint64  n,              /* number to write              */
    cyg_ucount8 base,           /* radix to write to            */
    cyg_ucount8 sign,           /* sign, '-' if -ve, '+' if +ve */
    cyg_bool    pfzero,         /* prefix with zero ?           */
    cyg_ucount8 width           /* min width of number          */
    )
    215c:	e1a04000 	mov	r4, r0
    2160:	e1a05001 	mov	r5, r1
{
    char buf[32];
    cyg_count8 bpos;
    char bufinit = pfzero?'0':' ';
    char *digits = (char *)"0123456789ABCDEF";
    2164:	e3a03000 	mov	r3, #0	; 0x0
    2168:	e28da008 	add	sl, sp, #8	; 0x8

    /* init buffer to padding char: space or zero */
    for( bpos = 0; bpos < (cyg_count8)sizeof(buf); bpos++ ) buf[bpos] = bufinit;
    216c:	e7ca9003 	strb	r9, [sl, r3]
    2170:	e2833001 	add	r3, r3, #1	; 0x1
    2174:	e3530020 	cmp	r3, #32	; 0x20
    2178:	1afffffb 	bne	216c <diag_write_long_num+0x30>

    /* Set pos to start */
    bpos = 0;

    /* construct digits into buffer in reverse order */
    if( n == 0 ) buf[bpos++] = '0';
    217c:	e1943005 	orrs	r3, r4, r5
    2180:	03a03030 	moveq	r3, #48	; 0x30
    2184:	05cd3008 	strbeq	r3, [sp, #8]
    2188:	03a06001 	moveq	r6, #1	; 0x1
    218c:	0a000013 	beq	21e0 <diag_write_long_num+0xa4>
    2190:	e1a07002 	mov	r7, r2
    2194:	e3a08000 	mov	r8, #0	; 0x0
    2198:	e3a06000 	mov	r6, #0	; 0x0
    else while( n != 0 )
    {
        cyg_ucount8 d = n % base;
        buf[bpos++] = digits[d];
    219c:	e1a00004 	mov	r0, r4
    21a0:	e1a01005 	mov	r1, r5
    21a4:	e1a02007 	mov	r2, r7
    21a8:	e1a03008 	mov	r3, r8
    21ac:	eb003f1d 	bl	11e28 <__aeabi_uldivmod>
    21b0:	e7dbc002 	ldrb	ip, [fp, r2]
        n /= base;
    21b4:	e1a00004 	mov	r0, r4
    21b8:	e1a01005 	mov	r1, r5
    21bc:	e1a03008 	mov	r3, r8
    21c0:	e1a02007 	mov	r2, r7
    /* construct digits into buffer in reverse order */
    if( n == 0 ) buf[bpos++] = '0';
    else while( n != 0 )
    {
        cyg_ucount8 d = n % base;
        buf[bpos++] = digits[d];
    21c4:	e7cac006 	strb	ip, [sl, r6]
        n /= base;
    21c8:	eb003f16 	bl	11e28 <__aeabi_uldivmod>
    /* Set pos to start */
    bpos = 0;

    /* construct digits into buffer in reverse order */
    if( n == 0 ) buf[bpos++] = '0';
    else while( n != 0 )
    21cc:	e1903001 	orrs	r3, r0, r1
    {
        cyg_ucount8 d = n % base;
        buf[bpos++] = digits[d];
        n /= base;
    21d0:	e1a04000 	mov	r4, r0
    21d4:	e1a05001 	mov	r5, r1
    /* construct digits into buffer in reverse order */
    if( n == 0 ) buf[bpos++] = '0';
    else while( n != 0 )
    {
        cyg_ucount8 d = n % base;
        buf[bpos++] = digits[d];
    21d8:	e2866001 	add	r6, r6, #1	; 0x1
    /* Set pos to start */
    bpos = 0;

    /* construct digits into buffer in reverse order */
    if( n == 0 ) buf[bpos++] = '0';
    else while( n != 0 )
    21dc:	1affffee 	bne	219c <diag_write_long_num+0x60>
    21e0:	e59d3054 	ldr	r3, [sp, #84]
    21e4:	e1560003 	cmp	r6, r3
    21e8:	a1a02006 	movge	r2, r6
    21ec:	b1a02003 	movlt	r2, r3

    /* set pos to width if less. */
    if( (cyg_count8)width > bpos ) bpos = width;

    /* set sign if negative. */
    if( sign == '-' )
    21f0:	e59d3004 	ldr	r3, [sp, #4]
    21f4:	e353002d 	cmp	r3, #45	; 0x2d
    {
        if( buf[bpos-1] == bufinit ) bpos--;
        buf[bpos] = sign;
    }
    else bpos--;
    21f8:	12424001 	subne	r4, r2, #1	; 0x1

    /* set pos to width if less. */
    if( (cyg_count8)width > bpos ) bpos = width;

    /* set sign if negative. */
    if( sign == '-' )
    21fc:	0a000009 	beq	2228 <diag_write_long_num+0xec>
        buf[bpos] = sign;
    }
    else bpos--;

    /* Now write it out in correct order. */
    while( bpos >= 0 )
    2200:	e3540000 	cmp	r4, #0	; 0x0
    if( sign == '-' )
    {
        if( buf[bpos-1] == bufinit ) bpos--;
        buf[bpos] = sign;
    }
    else bpos--;
    2204:	a08a5004 	addge	r5, sl, r4

    /* Now write it out in correct order. */
    while( bpos >= 0 )
    2208:	ba000004 	blt	2220 <diag_write_long_num+0xe4>
        diag_write_char(buf[bpos--]);
    220c:	e2444001 	sub	r4, r4, #1	; 0x1
    2210:	e4550001 	ldrb	r0, [r5], #-1
    2214:	ebffffbd 	bl	2110 <diag_write_char>
        buf[bpos] = sign;
    }
    else bpos--;

    /* Now write it out in correct order. */
    while( bpos >= 0 )
    2218:	e3540000 	cmp	r4, #0	; 0x0
    221c:	aafffffa 	bge	220c <diag_write_long_num+0xd0>
        diag_write_char(buf[bpos--]);
}
    2220:	e28dd02c 	add	sp, sp, #44	; 0x2c
    2224:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( (cyg_count8)width > bpos ) bpos = width;

    /* set sign if negative. */
    if( sign == '-' )
    {
        if( buf[bpos-1] == bufinit ) bpos--;
    2228:	e2424001 	sub	r4, r2, #1	; 0x1
    222c:	e28d3028 	add	r3, sp, #40	; 0x28
    2230:	e0831004 	add	r1, r3, r4
    2234:	e5513020 	ldrb	r3, [r1, #-32]
    2238:	e1530009 	cmp	r3, r9
    223c:	128d3028 	addne	r3, sp, #40	; 0x28
    2240:	11a04002 	movne	r4, r2
    2244:	10831004 	addne	r1, r3, r4
        buf[bpos] = sign;
    2248:	e3a0302d 	mov	r3, #45	; 0x2d
    224c:	e5413020 	strb	r3, [r1, #-32]
    2250:	eaffffea 	b	2200 <diag_write_long_num+0xc4>
    2254:	000129bc 	.word	0x000129bc

00002258 <diag_write_num>:
    cyg_uint32  n,              /* number to write              */
    cyg_ucount8 base,           /* radix to write to            */
    cyg_ucount8 sign,           /* sign, '-' if -ve, '+' if +ve */
    cyg_bool    pfzero,         /* prefix with zero ?           */
    cyg_ucount8 width           /* min width of number          */
    )
    2258:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    225c:	e1a0c002 	mov	ip, r2
    2260:	e24dd00c 	sub	sp, sp, #12	; 0xc
{
    diag_write_long_num((long long)n, base, sign, pfzero, width);
    2264:	e58d3000 	str	r3, [sp]
    2268:	e1a0300c 	mov	r3, ip
    226c:	e59dc010 	ldr	ip, [sp, #16]
    2270:	e1a02001 	mov	r2, r1
    2274:	e3a01000 	mov	r1, #0	; 0x0
    2278:	e58dc004 	str	ip, [sp, #4]
    227c:	ebffffae 	bl	213c <diag_write_long_num>
}
    2280:	e28dd00c 	add	sp, sp, #12	; 0xc
    2284:	e8bd8000 	pop	{pc}

00002288 <diag_write_hex>:
}

/*----------------------------------------------------------------------*/
/* Write hexadecimal value                                              */

externC void diag_write_hex( cyg_uint32 n)
    2288:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
{
    diag_write_num( n, 16, '+', false, 0);
    228c:	e3a0c000 	mov	ip, #0	; 0x0
}

/*----------------------------------------------------------------------*/
/* Write hexadecimal value                                              */

externC void diag_write_hex( cyg_uint32 n)
    2290:	e24dd00c 	sub	sp, sp, #12	; 0xc
{
    diag_write_num( n, 16, '+', false, 0);
    2294:	e1a0300c 	mov	r3, ip
    2298:	e3a01010 	mov	r1, #16	; 0x10
    229c:	e3a0202b 	mov	r2, #43	; 0x2b
    22a0:	e58dc000 	str	ip, [sp]
    22a4:	ebffffeb 	bl	2258 <diag_write_num>
}    
    22a8:	e28dd00c 	add	sp, sp, #12	; 0xc
    22ac:	e8bd8000 	pop	{pc}

000022b0 <diag_write_dec>:
}

/*----------------------------------------------------------------------*/
/* Write decimal value                                                  */

externC void diag_write_dec( cyg_int32 n)
    22b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
{
    cyg_ucount8 sign;

    if( n < 0 ) n = -n, sign = '-';
    22b4:	e3500000 	cmp	r0, #0	; 0x0
    else sign = '+';
    
    diag_write_num( n, 10, sign, false, 0);
    22b8:	e3a0c000 	mov	ip, #0	; 0x0
}

/*----------------------------------------------------------------------*/
/* Write decimal value                                                  */

externC void diag_write_dec( cyg_int32 n)
    22bc:	e24dd00c 	sub	sp, sp, #12	; 0xc
{
    cyg_ucount8 sign;

    if( n < 0 ) n = -n, sign = '-';
    22c0:	a3a0202b 	movge	r2, #43	; 0x2b
    22c4:	b2600000 	rsblt	r0, r0, #0	; 0x0
    22c8:	b3a0202d 	movlt	r2, #45	; 0x2d
    else sign = '+';
    
    diag_write_num( n, 10, sign, false, 0);
    22cc:	e1a0300c 	mov	r3, ip
    22d0:	e3a0100a 	mov	r1, #10	; 0xa
    22d4:	e58dc000 	str	ip, [sp]
    22d8:	ebffffde 	bl	2258 <diag_write_num>
}
    22dc:	e28dd00c 	add	sp, sp, #12	; 0xc
    22e0:	e8bd8000 	pop	{pc}

000022e4 <diag_write_string>:
}

/*----------------------------------------------------------------------*/
/* Write zero terminated string                                         */
  
externC void diag_write_string(const char *psz)
    22e4:	e92d4010 	push	{r4, lr}
    22e8:	e1a03000 	mov	r3, r0
{
    while( *psz ) diag_write_char( *psz++ );
    22ec:	e5d00000 	ldrb	r0, [r0]
    22f0:	e3500000 	cmp	r0, #0	; 0x0
    22f4:	08bd8010 	popeq	{r4, pc}
    22f8:	e1a04003 	mov	r4, r3
    22fc:	ebffff83 	bl	2110 <diag_write_char>
    2300:	e5f40001 	ldrb	r0, [r4, #1]!
    2304:	e3500000 	cmp	r0, #0	; 0x0
    2308:	1afffffb 	bne	22fc <diag_write_string+0x18>
    230c:	e8bd8010 	pop	{r4, pc}

00002310 <_ZL8_vprintfPFvcPPvES0_PKcS_>:
}

#define is_digit(c) ((c >= '0') && (c <= '9'))

static int
_vprintf(void (*putc)(char c, void **param), void **param, const char *fmt, va_list ap)
    2310:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
static cyg_bool diag_check_string( const char *str )
{
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    2314:	e3520000 	cmp	r2, #0	; 0x0
}

#define is_digit(c) ((c >= '0') && (c <= '9'))

static int
_vprintf(void (*putc)(char c, void **param), void **param, const char *fmt, va_list ap)
    2318:	e24dd084 	sub	sp, sp, #132	; 0x84
static cyg_bool diag_check_string( const char *str )
{
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    231c:	e58d2018 	str	r2, [sp, #24]
    
    for( s = str ; result && *s ; s++ )
    2320:	13a02b02 	movne	r2, #2048	; 0x800
}

#define is_digit(c) ((c >= '0') && (c <= '9'))

static int
_vprintf(void (*putc)(char c, void **param), void **param, const char *fmt, va_list ap)
    2324:	e58d3014 	str	r3, [sp, #20]
    2328:	e58d0020 	str	r0, [sp, #32]
    232c:	e58d101c 	str	r1, [sp, #28]
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    2330:	12822002 	addne	r2, r2, #2	; 0x2
static cyg_bool diag_check_string( const char *str )
{
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    2334:	13a03000 	movne	r3, #0	; 0x0
    2338:	0a00000f 	beq	237c <_ZL8_vprintfPFvcPPvES0_PKcS_+0x6c>
    
    for( s = str ; result && *s ; s++ )
    233c:	e59d1018 	ldr	r1, [sp, #24]
    2340:	e7d10003 	ldrb	r0, [r1, r3]
    2344:	e3500000 	cmp	r0, #0	; 0x0
        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    2348:	e2833001 	add	r3, r3, #1	; 0x1
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    234c:	0a000027 	beq	23f0 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xe0>

        /* We only really support CR, NL, tab and backspace at present.
	 * If we want to use other special chars, this test will
         * have to be expanded.  */

        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
    2350:	e350000d 	cmp	r0, #13	; 0xd
    2354:	1350000a 	cmpne	r0, #10	; 0xa
    2358:	0a00001d 	beq	23d4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xc4>
    235c:	e3500009 	cmp	r0, #9	; 0x9
    2360:	13500008 	cmpne	r0, #8	; 0x8
    2364:	0a00001a 	beq	23d4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xc4>
    2368:	e350001b 	cmp	r0, #27	; 0x1b
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    236c:	e2401020 	sub	r1, r0, #32	; 0x20

        /* We only really support CR, NL, tab and backspace at present.
	 * If we want to use other special chars, this test will
         * have to be expanded.  */

        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
    2370:	0a000017 	beq	23d4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xc4>
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    2374:	e351005e 	cmp	r1, #94	; 0x5e
    2378:	9a000015 	bls	23d4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xc4>
        i, islong, islonglong;
    long long val = 0;
    int res = 0, length = 0;

    if (!diag_check_string(fmt)) {
        diag_write_string("<Bad format string: ");
    237c:	e59f0aa0 	ldr	r0, [pc, #2720]	; 2e24 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb14>
    2380:	ebffffd7 	bl	22e4 <diag_write_string>
        diag_write_hex((cyg_uint32)fmt);
    2384:	e59d0018 	ldr	r0, [sp, #24]
    2388:	ebffffbe 	bl	2288 <diag_write_hex>
        diag_write_string(" :");
    238c:	e59f0a94 	ldr	r0, [pc, #2708]	; 2e28 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb18>
    2390:	ebffffd3 	bl	22e4 <diag_write_string>
    2394:	e3a04000 	mov	r4, #0	; 0x0
        for( i = 0; i < 8; i++ ) {
            diag_write_char(' ');
    2398:	e3a00020 	mov	r0, #32	; 0x20
    239c:	ebffff5b 	bl	2110 <diag_write_char>
            val = va_arg(ap, unsigned long);
            diag_write_hex(val);
    23a0:	e59d3014 	ldr	r3, [sp, #20]
    23a4:	e7930004 	ldr	r0, [r3, r4]
    23a8:	e2844004 	add	r4, r4, #4	; 0x4
    23ac:	ebffffb5 	bl	2288 <diag_write_hex>

    if (!diag_check_string(fmt)) {
        diag_write_string("<Bad format string: ");
        diag_write_hex((cyg_uint32)fmt);
        diag_write_string(" :");
        for( i = 0; i < 8; i++ ) {
    23b0:	e3540020 	cmp	r4, #32	; 0x20
    23b4:	1afffff7 	bne	2398 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x88>
            diag_write_char(' ');
            val = va_arg(ap, unsigned long);
            diag_write_hex(val);
        }
        diag_write_string(">\n");
    23b8:	e59f0a6c 	ldr	r0, [pc, #2668]	; 2e2c <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb1c>
    23bc:	e3a09000 	mov	r9, #0	; 0x0
    23c0:	ebffffc7 	bl	22e4 <diag_write_string>
    23c4:	e58d9034 	str	r9, [sp, #52]
            (*putc)(c, param);
            res++;
        }
    }
    return (res);
}
    23c8:	e59d0034 	ldr	r0, [sp, #52]
    23cc:	e28dd084 	add	sp, sp, #132	; 0x84
    23d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    23d4:	e1530002 	cmp	r3, r2
    23d8:	0affffe7 	beq	237c <_ZL8_vprintfPFvcPPvES0_PKcS_+0x6c>
    23dc:	e59d1018 	ldr	r1, [sp, #24]
    23e0:	e7d10003 	ldrb	r0, [r1, r3]
    23e4:	e3500000 	cmp	r0, #0	; 0x0
        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    23e8:	e2833001 	add	r3, r3, #1	; 0x1
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    23ec:	1affffd7 	bne	2350 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x40>
            diag_write_hex(val);
        }
        diag_write_string(">\n");
        return 0;
    }
    while ((c = *fmt++) != '\0') {
    23f0:	e3a02b02 	mov	r2, #2048	; 0x800
    23f4:	e2822002 	add	r2, r2, #2	; 0x2
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    23f8:	e58d0034 	str	r0, [sp, #52]
            diag_write_hex(val);
        }
        diag_write_string(">\n");
        return 0;
    }
    while ((c = *fmt++) != '\0') {
    23fc:	e58d2010 	str	r2, [sp, #16]
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    2400:	e3a07000 	mov	r7, #0	; 0x0
    2404:	e3a08000 	mov	r8, #0	; 0x0
    2408:	e1a0b000 	mov	fp, r0
            diag_write_hex(val);
        }
        diag_write_string(">\n");
        return 0;
    }
    while ((c = *fmt++) != '\0') {
    240c:	e59d1018 	ldr	r1, [sp, #24]
    2410:	e5d10000 	ldrb	r0, [r1]
    2414:	e3500000 	cmp	r0, #0	; 0x0
    2418:	0affffea 	beq	23c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb8>
    241c:	e59da018 	ldr	sl, [sp, #24]
        if (c == '%') {
    2420:	e3500025 	cmp	r0, #37	; 0x25
            diag_write_hex(val);
        }
        diag_write_string(">\n");
        return 0;
    }
    while ((c = *fmt++) != '\0') {
    2424:	e28aa001 	add	sl, sl, #1	; 0x1
    2428:	e58da018 	str	sl, [sp, #24]
        if (c == '%') {
    242c:	1a0001b1 	bne	2af8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x7e8>
            c = *fmt++;
    2430:	e1a0000a 	mov	r0, sl
    2434:	e4d01001 	ldrb	r1, [r0], #1
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
    2438:	e351002d 	cmp	r1, #45	; 0x2d
                c = *fmt++;
    243c:	059d3018 	ldreq	r3, [sp, #24]
    }
    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
    2440:	13a02000 	movne	r2, #0	; 0x0
                c = *fmt++;
    2444:	05d31001 	ldrbeq	r1, [r3, #1]
    2448:	03a09001 	moveq	r9, #1	; 0x1
    }
    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
    244c:	158d2030 	strne	r2, [sp, #48]
                c = *fmt++;
    2450:	058d9030 	streq	r9, [sp, #48]
    2454:	02800001 	addeq	r0, r0, #1	; 0x1
                pad_on_right++;
            }
            if (c == '0') {
    2458:	e3510030 	cmp	r1, #48	; 0x30
                zero_fill = true;
                c = *fmt++;
    245c:	04d01001 	ldrbeq	r1, [r0], #1
    2460:	03a02001 	moveq	r2, #1	; 0x1
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
    2464:	13a0a000 	movne	sl, #0	; 0x0
                zero_fill = true;
                c = *fmt++;
            } else {
                zero_fill = false;
            }
            while (is_digit(c)) {
    2468:	e2413030 	sub	r3, r1, #48	; 0x30
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
                zero_fill = true;
                c = *fmt++;
    246c:	058d2028 	streq	r2, [sp, #40]
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
    2470:	158da028 	strne	sl, [sp, #40]
                zero_fill = true;
                c = *fmt++;
            } else {
                zero_fill = false;
            }
            while (is_digit(c)) {
    2474:	e3530009 	cmp	r3, #9	; 0x9
    2478:	83a02000 	movhi	r2, #0	; 0x0
    247c:	858d0018 	strhi	r0, [sp, #24]
    2480:	81a04001 	movhi	r4, r1
    2484:	858d200c 	strhi	r2, [sp, #12]
    2488:	8a00000c 	bhi	24c0 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x1b0>
    248c:	e3a02000 	mov	r2, #0	; 0x0
                left_prec = (left_prec * 10) + (c - '0');
    2490:	e1a03182 	lsl	r3, r2, #3
    2494:	e1a02082 	lsl	r2, r2, #1
    2498:	e0822003 	add	r2, r2, r3
    249c:	e0822001 	add	r2, r2, r1
                c = *fmt++;
    24a0:	e4d01001 	ldrb	r1, [r0], #1
                zero_fill = true;
                c = *fmt++;
            } else {
                zero_fill = false;
            }
            while (is_digit(c)) {
    24a4:	e2413030 	sub	r3, r1, #48	; 0x30
    24a8:	e3530009 	cmp	r3, #9	; 0x9
                left_prec = (left_prec * 10) + (c - '0');
    24ac:	e2422030 	sub	r2, r2, #48	; 0x30
                zero_fill = true;
                c = *fmt++;
            } else {
                zero_fill = false;
            }
            while (is_digit(c)) {
    24b0:	9afffff6 	bls	2490 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x180>
    24b4:	e58d0018 	str	r0, [sp, #24]
    24b8:	e58d200c 	str	r2, [sp, #12]
    24bc:	e1a04001 	mov	r4, r1
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
    24c0:	e351002e 	cmp	r1, #46	; 0x2e
    24c4:	0a000208 	beq	2cec <_ZL8_vprintfPFvcPPvES0_PKcS_+0x9dc>
                }
            } else {
                right_prec = left_prec;
            }
            sign = '\0';
            if (c == 'l') {
    24c8:	e354006c 	cmp	r4, #108	; 0x6c
    24cc:	13a0c000 	movne	ip, #0	; 0x0
    24d0:	11a0100c 	movne	r1, ip
    24d4:	0a000218 	beq	2d3c <_ZL8_vprintfPFvcPPvES0_PKcS_+0xa2c>
                    // long long qualifier
                    c = *fmt++;
                    islonglong = 1;
                }
            }
            if (c == 'z') {
    24d8:	e354007a 	cmp	r4, #122	; 0x7a
                c = *fmt++;
    24dc:	059d3018 	ldreq	r3, [sp, #24]
    24e0:	04d34001 	ldrbeq	r4, [r3], #1
    24e4:	058d3018 	streq	r3, [sp, #24]
		islong = sizeof(size_t) == sizeof(long);
            }
            // Fetch value [numeric descriptors only]
            switch (c) {
    24e8:	e2443042 	sub	r3, r4, #66	; 0x42
                    c = *fmt++;
                    islonglong = 1;
                }
            }
            if (c == 'z') {
                c = *fmt++;
    24ec:	03a0c001 	moveq	ip, #1	; 0x1
		islong = sizeof(size_t) == sizeof(long);
            }
            // Fetch value [numeric descriptors only]
            switch (c) {
    24f0:	e3530036 	cmp	r3, #54	; 0x36
    24f4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    24f8:	ea0000a0 	b	2780 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x470>
    24fc:	000025dc 	.word	0x000025dc
    2500:	00002780 	.word	0x00002780
    2504:	000025dc 	.word	0x000025dc
    2508:	00002780 	.word	0x00002780
    250c:	00002780 	.word	0x00002780
    2510:	00002780 	.word	0x00002780
    2514:	00002780 	.word	0x00002780
    2518:	00002780 	.word	0x00002780
    251c:	00002780 	.word	0x00002780
    2520:	00002780 	.word	0x00002780
    2524:	00002780 	.word	0x00002780
    2528:	00002780 	.word	0x00002780
    252c:	00002780 	.word	0x00002780
    2530:	00002780 	.word	0x00002780
    2534:	00002780 	.word	0x00002780
    2538:	00002780 	.word	0x00002780
    253c:	00002780 	.word	0x00002780
    2540:	00002780 	.word	0x00002780
    2544:	00002780 	.word	0x00002780
    2548:	000025dc 	.word	0x000025dc
    254c:	00002780 	.word	0x00002780
    2550:	00002780 	.word	0x00002780
    2554:	000025dc 	.word	0x000025dc
    2558:	00002780 	.word	0x00002780
    255c:	00002780 	.word	0x00002780
    2560:	00002780 	.word	0x00002780
    2564:	00002780 	.word	0x00002780
    2568:	00002780 	.word	0x00002780
    256c:	00002780 	.word	0x00002780
    2570:	00002780 	.word	0x00002780
    2574:	00002780 	.word	0x00002780
    2578:	00002780 	.word	0x00002780
    257c:	000025dc 	.word	0x000025dc
    2580:	00002780 	.word	0x00002780
    2584:	000025dc 	.word	0x000025dc
    2588:	00002780 	.word	0x00002780
    258c:	00002780 	.word	0x00002780
    2590:	00002780 	.word	0x00002780
    2594:	00002780 	.word	0x00002780
    2598:	00002780 	.word	0x00002780
    259c:	00002780 	.word	0x00002780
    25a0:	00002780 	.word	0x00002780
    25a4:	00002780 	.word	0x00002780
    25a8:	00002780 	.word	0x00002780
    25ac:	00002780 	.word	0x00002780
    25b0:	00002780 	.word	0x00002780
    25b4:	000025d8 	.word	0x000025d8
    25b8:	00002780 	.word	0x00002780
    25bc:	00002780 	.word	0x00002780
    25c0:	00002780 	.word	0x00002780
    25c4:	00002780 	.word	0x00002780
    25c8:	000025dc 	.word	0x000025dc
    25cc:	00002780 	.word	0x00002780
    25d0:	00002780 	.word	0x00002780
    25d4:	000025dc 	.word	0x000025dc
    25d8:	e3a0c001 	mov	ip, #1	; 0x1
            case 'X':
            case 'u':
            case 'U':
            case 'b':
            case 'B':
                if (islonglong) {
    25dc:	e3510000 	cmp	r1, #0	; 0x0
    25e0:	0a0001b5 	beq	2cbc <_ZL8_vprintfPFvcPPvES0_PKcS_+0x9ac>
                    val = va_arg(ap, long long);
    25e4:	e59da014 	ldr	sl, [sp, #20]
    25e8:	e28a3007 	add	r3, sl, #7	; 0x7
    25ec:	e3c33007 	bic	r3, r3, #7	; 0x7
    25f0:	e8930180 	ldm	r3, {r7, r8}
    25f4:	e2833008 	add	r3, r3, #8	; 0x8
	        } else if (islong) {
                    val = (long long)va_arg(ap, long);
		} else{
                    val = (long long)va_arg(ap, int);
                }
                if ((c == 'd') || (c == 'D')) {
    25f8:	e3540044 	cmp	r4, #68	; 0x44
    25fc:	13540064 	cmpne	r4, #100	; 0x64
    2600:	13a00000 	movne	r0, #0	; 0x0
    2604:	03a00001 	moveq	r0, #1	; 0x1
    2608:	1a0001a0 	bne	2c90 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x980>
                    if (val < 0) {
    260c:	e3580000 	cmp	r8, #0	; 0x0
    2610:	ba0001de 	blt	2d90 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xa80>
                } else {
                    // Mask to unsigned, sized quantity
                    if (islong) {
                        val &= ((long long)1 << (sizeof(long) * 8)) - 1;
                    } else if (!islonglong) { // no need to mask longlong
                        val &= ((long long)1 << (sizeof(int) * 8)) - 1;
    2614:	e3a00000 	mov	r0, #0	; 0x0
    2618:	e58d3014 	str	r3, [sp, #20]
    261c:	e58d0024 	str	r0, [sp, #36]
                break;
            default:
                break;
            }
            // Process output
            switch (c) {
    2620:	e2443025 	sub	r3, r4, #37	; 0x25
    2624:	e3530053 	cmp	r3, #83	; 0x53
    2628:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    262c:	ea000056 	b	278c <_ZL8_vprintfPFvcPPvES0_PKcS_+0x47c>
    2630:	00002af4 	.word	0x00002af4
    2634:	0000278c 	.word	0x0000278c
    2638:	0000278c 	.word	0x0000278c
    263c:	0000278c 	.word	0x0000278c
    2640:	0000278c 	.word	0x0000278c
    2644:	0000278c 	.word	0x0000278c
    2648:	0000278c 	.word	0x0000278c
    264c:	0000278c 	.word	0x0000278c
    2650:	0000278c 	.word	0x0000278c
    2654:	0000278c 	.word	0x0000278c
    2658:	0000278c 	.word	0x0000278c
    265c:	0000278c 	.word	0x0000278c
    2660:	0000278c 	.word	0x0000278c
    2664:	0000278c 	.word	0x0000278c
    2668:	0000278c 	.word	0x0000278c
    266c:	0000278c 	.word	0x0000278c
    2670:	0000278c 	.word	0x0000278c
    2674:	0000278c 	.word	0x0000278c
    2678:	0000278c 	.word	0x0000278c
    267c:	0000278c 	.word	0x0000278c
    2680:	0000278c 	.word	0x0000278c
    2684:	0000278c 	.word	0x0000278c
    2688:	0000278c 	.word	0x0000278c
    268c:	0000278c 	.word	0x0000278c
    2690:	0000278c 	.word	0x0000278c
    2694:	0000278c 	.word	0x0000278c
    2698:	0000278c 	.word	0x0000278c
    269c:	0000278c 	.word	0x0000278c
    26a0:	0000278c 	.word	0x0000278c
    26a4:	00002a70 	.word	0x00002a70
    26a8:	00002a38 	.word	0x00002a38
    26ac:	00002b24 	.word	0x00002b24
    26b0:	0000278c 	.word	0x0000278c
    26b4:	0000278c 	.word	0x0000278c
    26b8:	0000278c 	.word	0x0000278c
    26bc:	0000278c 	.word	0x0000278c
    26c0:	0000278c 	.word	0x0000278c
    26c4:	0000278c 	.word	0x0000278c
    26c8:	0000278c 	.word	0x0000278c
    26cc:	0000278c 	.word	0x0000278c
    26d0:	0000278c 	.word	0x0000278c
    26d4:	0000278c 	.word	0x0000278c
    26d8:	0000278c 	.word	0x0000278c
    26dc:	0000278c 	.word	0x0000278c
    26e0:	0000278c 	.word	0x0000278c
    26e4:	0000278c 	.word	0x0000278c
    26e8:	00002994 	.word	0x00002994
    26ec:	0000278c 	.word	0x0000278c
    26f0:	00002b24 	.word	0x00002b24
    26f4:	0000278c 	.word	0x0000278c
    26f8:	0000278c 	.word	0x0000278c
    26fc:	00002b24 	.word	0x00002b24
    2700:	0000278c 	.word	0x0000278c
    2704:	0000278c 	.word	0x0000278c
    2708:	0000278c 	.word	0x0000278c
    270c:	0000278c 	.word	0x0000278c
    2710:	0000278c 	.word	0x0000278c
    2714:	0000278c 	.word	0x0000278c
    2718:	0000278c 	.word	0x0000278c
    271c:	0000278c 	.word	0x0000278c
    2720:	0000278c 	.word	0x0000278c
    2724:	00002a70 	.word	0x00002a70
    2728:	00002a38 	.word	0x00002a38
    272c:	00002b24 	.word	0x00002b24
    2730:	0000278c 	.word	0x0000278c
    2734:	0000278c 	.word	0x0000278c
    2738:	0000278c 	.word	0x0000278c
    273c:	0000278c 	.word	0x0000278c
    2740:	0000278c 	.word	0x0000278c
    2744:	0000278c 	.word	0x0000278c
    2748:	0000278c 	.word	0x0000278c
    274c:	0000278c 	.word	0x0000278c
    2750:	0000278c 	.word	0x0000278c
    2754:	0000278c 	.word	0x0000278c
    2758:	0000278c 	.word	0x0000278c
    275c:	000027d8 	.word	0x000027d8
    2760:	0000278c 	.word	0x0000278c
    2764:	0000278c 	.word	0x0000278c
    2768:	00002994 	.word	0x00002994
    276c:	0000278c 	.word	0x0000278c
    2770:	00002b24 	.word	0x00002b24
    2774:	0000278c 	.word	0x0000278c
    2778:	0000278c 	.word	0x0000278c
    277c:	00002b24 	.word	0x00002b24
            if (c == 'z') {
                c = *fmt++;
		islong = sizeof(size_t) == sizeof(long);
            }
            // Fetch value [numeric descriptors only]
            switch (c) {
    2780:	e3a09000 	mov	r9, #0	; 0x0
    2784:	e58d9024 	str	r9, [sp, #36]
    2788:	eaffffa4 	b	2620 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x310>
            case '%':
                (*putc)('%', param);
                res++;
                continue;
            default:
                (*putc)('%', param);
    278c:	e59da020 	ldr	sl, [sp, #32]
    2790:	e3a00025 	mov	r0, #37	; 0x25
    2794:	e59d101c 	ldr	r1, [sp, #28]
    2798:	e1a0e00f 	mov	lr, pc
    279c:	e12fff1a 	bx	sl
                (*putc)(c, param);
    27a0:	e1a00004 	mov	r0, r4
    27a4:	e59d101c 	ldr	r1, [sp, #28]
    27a8:	e1a0e00f 	mov	lr, pc
    27ac:	e12fff1a 	bx	sl
                res += 2;
    27b0:	e59d0034 	ldr	r0, [sp, #52]
    27b4:	e59d1014 	ldr	r1, [sp, #20]
    27b8:	e2800002 	add	r0, r0, #2	; 0x2
    27bc:	e58d0034 	str	r0, [sp, #52]
    27c0:	e58d1038 	str	r1, [sp, #56]
    27c4:	e1a0a00b 	mov	sl, fp
                    res++;
                }
            }
        } else {
            (*putc)(c, param);
            res++;
    27c8:	e59d0038 	ldr	r0, [sp, #56]
    27cc:	e1a0b00a 	mov	fp, sl
    27d0:	e58d0014 	str	r0, [sp, #20]
    27d4:	eaffff0c 	b	240c <_ZL8_vprintfPFvcPPvES0_PKcS_+0xfc>
                break;
            }
            // Process output
            switch (c) {
            case 'p':  // Pointer
                (*putc)('0', param);
    27d8:	e3a00030 	mov	r0, #48	; 0x30
    27dc:	e28d101c 	add	r1, sp, #28	; 0x1c
    27e0:	e8910006 	ldm	r1, {r1, r2}
    27e4:	e1a0e00f 	mov	lr, pc
    27e8:	e12fff12 	bx	r2
                (*putc)('x', param);
    27ec:	e3a00078 	mov	r0, #120	; 0x78
    27f0:	e28d101c 	add	r1, sp, #28	; 0x1c
    27f4:	e891000a 	ldm	r1, {r1, r3}
    27f8:	e1a0e00f 	mov	lr, pc
    27fc:	e12fff13 	bx	r3
                zero_fill = true;
                left_prec = sizeof(unsigned long)*2;
                res += 2;  // Account for "0x" leadin
    2800:	e59d9034 	ldr	r9, [sp, #52]
    2804:	e3a0a008 	mov	sl, #8	; 0x8
    2808:	e2899002 	add	r9, r9, #2	; 0x2
    280c:	e3a00001 	mov	r0, #1	; 0x1
    2810:	e58d9034 	str	r9, [sp, #52]
    2814:	e58da00c 	str	sl, [sp, #12]
    2818:	e58d0028 	str	r0, [sp, #40]
                case 'U':
                    length = _cvt(val, buf, 10, (char *)"0123456789");
                    break;
                case 'p':
                case 'x':
                    length = _cvt(val, buf, 16, (char *)"0123456789abcdef");
    281c:	e59fc60c 	ldr	ip, [pc, #1548]	; 2e30 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb20>
    2820:	e3a03010 	mov	r3, #16	; 0x10
    2824:	e1a00007 	mov	r0, r7
    2828:	e1a01008 	mov	r1, r8
    282c:	e28d2040 	add	r2, sp, #64	; 0x40
    2830:	e58dc000 	str	ip, [sp]
    2834:	ebfffd97 	bl	1e98 <_ZL4_cvtyPclS_>
    2838:	e59d300c 	ldr	r3, [sp, #12]
    283c:	e59d9014 	ldr	r9, [sp, #20]
    2840:	e0603003 	rsb	r3, r0, r3
    2844:	e58d300c 	str	r3, [sp, #12]
    2848:	e58d9038 	str	r9, [sp, #56]
    284c:	e1a0b000 	mov	fp, r0
    2850:	e28d9040 	add	r9, sp, #64	; 0x40
                (*putc)(c, param);
                res += 2;
                continue;
            }
            pad = left_prec - length;
            if (sign != '\0') {
    2854:	e59da024 	ldr	sl, [sp, #36]
    2858:	e35a0000 	cmp	sl, #0	; 0x0
                pad--;
    285c:	159d100c 	ldrne	r1, [sp, #12]
                (*putc)(c, param);
                res += 2;
                continue;
            }
            pad = left_prec - length;
            if (sign != '\0') {
    2860:	059d000c 	ldreq	r0, [sp, #12]
                pad--;
            }
            if (zero_fill) {
    2864:	e59d2028 	ldr	r2, [sp, #40]
                res += 2;
                continue;
            }
            pad = left_prec - length;
            if (sign != '\0') {
                pad--;
    2868:	12411001 	subne	r1, r1, #1	; 0x1
                (*putc)(c, param);
                res += 2;
                continue;
            }
            pad = left_prec - length;
            if (sign != '\0') {
    286c:	058d002c 	streq	r0, [sp, #44]
                pad--;
    2870:	158d102c 	strne	r1, [sp, #44]
            }
            if (zero_fill) {
    2874:	e3520000 	cmp	r2, #0	; 0x0
    2878:	03a0a020 	moveq	sl, #32	; 0x20
    287c:	0a000003 	beq	2890 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x580>
                c = '0';
                if (sign != '\0') {
    2880:	e59d3024 	ldr	r3, [sp, #36]
    2884:	e3530000 	cmp	r3, #0	; 0x0
    2888:	03a0a030 	moveq	sl, #48	; 0x30
    288c:	1a000145 	bne	2da8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xa98>
                    sign = '\0';
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
    2890:	e59d2030 	ldr	r2, [sp, #48]
    2894:	e3520000 	cmp	r2, #0	; 0x0
    2898:	159d302c 	ldrne	r3, [sp, #44]
    289c:	158d303c 	strne	r3, [sp, #60]
    28a0:	1a000013 	bne	28f4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x5e4>
                while (pad-- > 0) {
    28a4:	e59d002c 	ldr	r0, [sp, #44]
    28a8:	e2401001 	sub	r1, r0, #1	; 0x1
    28ac:	e3500000 	cmp	r0, #0	; 0x0
    28b0:	e58d103c 	str	r1, [sp, #60]
    28b4:	da00000e 	ble	28f4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x5e4>
    28b8:	e1a04000 	mov	r4, r0
                    (*putc)(c, param);
    28bc:	e2444001 	sub	r4, r4, #1	; 0x1
    28c0:	e1a0000a 	mov	r0, sl
    28c4:	e28d101c 	add	r1, sp, #28	; 0x1c
    28c8:	e8910006 	ldm	r1, {r1, r2}
    28cc:	e1a0e00f 	mov	lr, pc
    28d0:	e12fff12 	bx	r2
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
                while (pad-- > 0) {
    28d4:	e3540000 	cmp	r4, #0	; 0x0
    28d8:	cafffff7 	bgt	28bc <_ZL8_vprintfPFvcPPvES0_PKcS_+0x5ac>
    28dc:	e59d3034 	ldr	r3, [sp, #52]
    28e0:	e59da02c 	ldr	sl, [sp, #44]
    28e4:	e3e00000 	mvn	r0, #0	; 0x0
    28e8:	e083300a 	add	r3, r3, sl
    28ec:	e58d3034 	str	r3, [sp, #52]
    28f0:	e58d003c 	str	r0, [sp, #60]
                    (*putc)(c, param);
                    res++;
                }
            }
            if (sign != '\0') {
    28f4:	e59d1024 	ldr	r1, [sp, #36]
    28f8:	e3510000 	cmp	r1, #0	; 0x0
    28fc:	1a00011a 	bne	2d6c <_ZL8_vprintfPFvcPPvES0_PKcS_+0xa5c>
                (*putc)(sign, param);
                res++;
            }
            while (length-- > 0) {
    2900:	e35b0000 	cmp	fp, #0	; 0x0
    2904:	e24ba001 	sub	sl, fp, #1	; 0x1
    2908:	da00000d 	ble	2944 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x634>
    290c:	e3a04000 	mov	r4, #0	; 0x0
                c = *cp++;
                (*putc)(c, param);
    2910:	e7d90004 	ldrb	r0, [r9, r4]
    2914:	e59d101c 	ldr	r1, [sp, #28]
    2918:	e2844001 	add	r4, r4, #1	; 0x1
    291c:	e59da020 	ldr	sl, [sp, #32]
    2920:	e1a0e00f 	mov	lr, pc
    2924:	e12fff1a 	bx	sl
}

#define is_digit(c) ((c >= '0') && (c <= '9'))

static int
_vprintf(void (*putc)(char c, void **param), void **param, const char *fmt, va_list ap)
    2928:	e064300b 	rsb	r3, r4, fp
            }
            if (sign != '\0') {
                (*putc)(sign, param);
                res++;
            }
            while (length-- > 0) {
    292c:	e3530000 	cmp	r3, #0	; 0x0
    2930:	cafffff6 	bgt	2910 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x600>
    2934:	e59d0034 	ldr	r0, [sp, #52]
    2938:	e080000b 	add	r0, r0, fp
    293c:	e58d0034 	str	r0, [sp, #52]
    2940:	e3e0a000 	mvn	sl, #0	; 0x0
                c = *cp++;
                (*putc)(c, param);
                res++;
            }
            if (pad_on_right) {
    2944:	e59d1030 	ldr	r1, [sp, #48]
    2948:	e3510000 	cmp	r1, #0	; 0x0
    294c:	0affff9d 	beq	27c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x4b8>
                while (pad-- > 0) {
    2950:	e59d203c 	ldr	r2, [sp, #60]
    2954:	e3520000 	cmp	r2, #0	; 0x0
    2958:	daffff9a 	ble	27c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x4b8>
    295c:	e1a04002 	mov	r4, r2
                    (*putc)(' ', param);
    2960:	e2444001 	sub	r4, r4, #1	; 0x1
    2964:	e3a00020 	mov	r0, #32	; 0x20
    2968:	e28d101c 	add	r1, sp, #28	; 0x1c
    296c:	e891000a 	ldm	r1, {r1, r3}
    2970:	e1a0e00f 	mov	lr, pc
    2974:	e12fff13 	bx	r3
                c = *cp++;
                (*putc)(c, param);
                res++;
            }
            if (pad_on_right) {
                while (pad-- > 0) {
    2978:	e3540000 	cmp	r4, #0	; 0x0
    297c:	cafffff7 	bgt	2960 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x650>
    2980:	e59d9034 	ldr	r9, [sp, #52]
    2984:	e59d003c 	ldr	r0, [sp, #60]
    2988:	e0899000 	add	r9, r9, r0
    298c:	e58d9034 	str	r9, [sp, #52]
    2990:	eaffff8c 	b	27c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x4b8>
                }
                cp = buf;
                break;
            case 's':
            case 'S':
                cp = va_arg(ap, char *);
    2994:	e59d1014 	ldr	r1, [sp, #20]
    2998:	e5919000 	ldr	r9, [r1]
    299c:	e2812004 	add	r2, r1, #4	; 0x4
                if (cp == NULL) 
    29a0:	e3590000 	cmp	r9, #0	; 0x0
                }
                cp = buf;
                break;
            case 's':
            case 'S':
                cp = va_arg(ap, char *);
    29a4:	e58d2038 	str	r2, [sp, #56]
                if (cp == NULL) 
                    cp = (char *)"<null>";
    29a8:	059f9484 	ldreq	r9, [pc, #1156]	; 2e34 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb24>
                cp = buf;
                break;
            case 's':
            case 'S':
                cp = va_arg(ap, char *);
                if (cp == NULL) 
    29ac:	13a02000 	movne	r2, #0	; 0x0
    29b0:	0a000013 	beq	2a04 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x6f4>
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    29b4:	e7d93002 	ldrb	r3, [r9, r2]
    29b8:	e3530000 	cmp	r3, #0	; 0x0
        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    29bc:	e2822001 	add	r2, r2, #1	; 0x1
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    29c0:	0a00000f 	beq	2a04 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x6f4>

        /* We only really support CR, NL, tab and backspace at present.
	 * If we want to use other special chars, this test will
         * have to be expanded.  */

        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
    29c4:	e353000d 	cmp	r3, #13	; 0xd
    29c8:	1353000a 	cmpne	r3, #10	; 0xa
    29cc:	0a0000ab 	beq	2c80 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x970>
    29d0:	e3530009 	cmp	r3, #9	; 0x9
    29d4:	13530008 	cmpne	r3, #8	; 0x8
    29d8:	0a0000a8 	beq	2c80 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x970>
    29dc:	e353001b 	cmp	r3, #27	; 0x1b
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    29e0:	e2431020 	sub	r1, r3, #32	; 0x20

        /* We only really support CR, NL, tab and backspace at present.
	 * If we want to use other special chars, this test will
         * have to be expanded.  */

        if( c == '\n' || c == '\r' || c == '\b' || c == '\t' || c == '\033' )
    29e4:	0a0000a5 	beq	2c80 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x970>
            continue;

        /* Check for printable chars. This assumes ASCII */
        
        if( c < ' ' || c > '~' )
    29e8:	e351005e 	cmp	r1, #94	; 0x5e
    29ec:	9a0000a3 	bls	2c80 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x970>
            case 'S':
                cp = va_arg(ap, char *);
                if (cp == NULL) 
                    cp = (char *)"<null>";
                else if (!diag_check_string(cp)) {
                    diag_write_string("<Not a string: 0x");
    29f0:	e59f0440 	ldr	r0, [pc, #1088]	; 2e38 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb28>
    29f4:	ebfffe3a 	bl	22e4 <diag_write_string>
                    diag_write_hex((cyg_uint32)cp);
    29f8:	e1a00009 	mov	r0, r9
    29fc:	ebfffe21 	bl	2288 <diag_write_hex>
                    cp = (char *)">";
    2a00:	e59f9434 	ldr	r9, [pc, #1076]	; 2e3c <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb2c>
                }
                length = 0;
                while (cp[length] != '\0') length++;
    2a04:	e5d90000 	ldrb	r0, [r9]
    2a08:	e3500000 	cmp	r0, #0	; 0x0
    2a0c:	01a0b000 	moveq	fp, r0
    2a10:	0affff8f 	beq	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
    2a14:	e3a0b000 	mov	fp, #0	; 0x0
    2a18:	e28bb001 	add	fp, fp, #1	; 0x1
    2a1c:	e7d9300b 	ldrb	r3, [r9, fp]
    2a20:	e3530000 	cmp	r3, #0	; 0x0
    2a24:	1afffffb 	bne	2a18 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x708>
    2a28:	e59da00c 	ldr	sl, [sp, #12]
    2a2c:	e06ba00a 	rsb	sl, fp, sl
    2a30:	e58da00c 	str	sl, [sp, #12]
    2a34:	eaffff86 	b	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
                (*putc)(c, param);
    2a38:	e59d1014 	ldr	r1, [sp, #20]
    2a3c:	e59d2020 	ldr	r2, [sp, #32]
    2a40:	e5d10000 	ldrb	r0, [r1]
    2a44:	e59d101c 	ldr	r1, [sp, #28]
    2a48:	e1a0e00f 	mov	lr, pc
    2a4c:	e12fff12 	bx	r2
                res++;
    2a50:	e59d3034 	ldr	r3, [sp, #52]
                length = 0;
                while (cp[length] != '\0') length++;
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
    2a54:	e59d9014 	ldr	r9, [sp, #20]
                (*putc)(c, param);
                res++;
    2a58:	e2833001 	add	r3, r3, #1	; 0x1
                length = 0;
                while (cp[length] != '\0') length++;
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
    2a5c:	e2899004 	add	r9, r9, #4	; 0x4
                (*putc)(c, param);
                res++;
    2a60:	e58d3034 	str	r3, [sp, #52]
    2a64:	e1a0a00b 	mov	sl, fp
                length = 0;
                while (cp[length] != '\0') length++;
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
    2a68:	e58d9038 	str	r9, [sp, #56]
    2a6c:	eaffff55 	b	27c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x4b8>
                res++;
                continue;
            case 'b':
            case 'B':
                length = left_prec;
                if (left_prec == 0) {
    2a70:	e3520000 	cmp	r2, #0	; 0x0
    2a74:	1a0000d7 	bne	2dd8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xac8>
                    if (islonglong)
    2a78:	e3510000 	cmp	r1, #0	; 0x0
    2a7c:	13a0003f 	movne	r0, #63	; 0x3f
    2a80:	03a0001f 	moveq	r0, #31	; 0x1f
    2a84:	13a0b040 	movne	fp, #64	; 0x40
    2a88:	03a0b020 	moveq	fp, #32	; 0x20
            diag_write_hex(val);
        }
        diag_write_string(">\n");
        return 0;
    }
    while ((c = *fmt++) != '\0') {
    2a8c:	e3a01000 	mov	r1, #0	; 0x0
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
                    buf[i] = ((val & ((long long)1<<i)) ? '1' : '.');
    2a90:	e1a05137 	lsr	r5, r7, r1
    2a94:	e2613020 	rsb	r3, r1, #32	; 0x20
    2a98:	e1855318 	orr	r5, r5, r8, lsl r3
    2a9c:	e2512020 	subs	r2, r1, #32	; 0x20
    2aa0:	51a05258 	asrpl	r5, r8, r2
    2aa4:	e1a06158 	asr	r6, r8, r1
    2aa8:	e3a0a000 	mov	sl, #0	; 0x0
    2aac:	e3a09001 	mov	r9, #1	; 0x1
    2ab0:	e0053009 	and	r3, r5, r9
    2ab4:	e006400a 	and	r4, r6, sl
    2ab8:	e193a004 	orrs	sl, r3, r4
    2abc:	13a02031 	movne	r2, #49	; 0x31
    2ac0:	03a0202e 	moveq	r2, #46	; 0x2e
    2ac4:	e28d3040 	add	r3, sp, #64	; 0x40
    2ac8:	e7c32001 	strb	r2, [r3, r1]
                    else if (islong)
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
    2acc:	e2811001 	add	r1, r1, #1	; 0x1
    2ad0:	e1510000 	cmp	r1, r0
    2ad4:	baffffed 	blt	2a90 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x780>
    2ad8:	e59d900c 	ldr	r9, [sp, #12]
    2adc:	e59da014 	ldr	sl, [sp, #20]
    2ae0:	e06b9009 	rsb	r9, fp, r9
    2ae4:	e58d900c 	str	r9, [sp, #12]
    2ae8:	e58da038 	str	sl, [sp, #56]
    2aec:	e28d9040 	add	r9, sp, #64	; 0x40
    2af0:	eaffff57 	b	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
                    buf[i] = ((val & ((long long)1<<i)) ? '1' : '.');
                }
                cp = buf;
                break;
            case '%':
                (*putc)('%', param);
    2af4:	e3a00025 	mov	r0, #37	; 0x25
                    (*putc)(' ', param);
                    res++;
                }
            }
        } else {
            (*putc)(c, param);
    2af8:	e28d101c 	add	r1, sp, #28	; 0x1c
    2afc:	e8910006 	ldm	r1, {r1, r2}
    2b00:	e1a0e00f 	mov	lr, pc
    2b04:	e12fff12 	bx	r2
            res++;
    2b08:	e59d3034 	ldr	r3, [sp, #52]
    2b0c:	e59d9014 	ldr	r9, [sp, #20]
    2b10:	e2833001 	add	r3, r3, #1	; 0x1
    2b14:	e58d3034 	str	r3, [sp, #52]
    2b18:	e58d9038 	str	r9, [sp, #56]
    2b1c:	e1a0a00b 	mov	sl, fp
    2b20:	eaffff28 	b	27c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x4b8>
            case 'D':
            case 'u':
            case 'U':
            case 'x':
            case 'X':
                switch (c) {
    2b24:	e2443044 	sub	r3, r4, #68	; 0x44
    2b28:	e3530034 	cmp	r3, #52	; 0x34
    2b2c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    2b30:	ea0000b4 	b	2e08 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xaf8>
    2b34:	00002c44 	.word	0x00002c44
    2b38:	00002e08 	.word	0x00002e08
    2b3c:	00002e08 	.word	0x00002e08
    2b40:	00002e08 	.word	0x00002e08
    2b44:	00002e08 	.word	0x00002e08
    2b48:	00002e08 	.word	0x00002e08
    2b4c:	00002e08 	.word	0x00002e08
    2b50:	00002e08 	.word	0x00002e08
    2b54:	00002e08 	.word	0x00002e08
    2b58:	00002e08 	.word	0x00002e08
    2b5c:	00002e08 	.word	0x00002e08
    2b60:	00002e08 	.word	0x00002e08
    2b64:	00002e08 	.word	0x00002e08
    2b68:	00002e08 	.word	0x00002e08
    2b6c:	00002e08 	.word	0x00002e08
    2b70:	00002e08 	.word	0x00002e08
    2b74:	00002e08 	.word	0x00002e08
    2b78:	00002c44 	.word	0x00002c44
    2b7c:	00002e08 	.word	0x00002e08
    2b80:	00002e08 	.word	0x00002e08
    2b84:	00002c08 	.word	0x00002c08
    2b88:	00002e08 	.word	0x00002e08
    2b8c:	00002e08 	.word	0x00002e08
    2b90:	00002e08 	.word	0x00002e08
    2b94:	00002e08 	.word	0x00002e08
    2b98:	00002e08 	.word	0x00002e08
    2b9c:	00002e08 	.word	0x00002e08
    2ba0:	00002e08 	.word	0x00002e08
    2ba4:	00002e08 	.word	0x00002e08
    2ba8:	00002e08 	.word	0x00002e08
    2bac:	00002e08 	.word	0x00002e08
    2bb0:	00002e08 	.word	0x00002e08
    2bb4:	00002c44 	.word	0x00002c44
    2bb8:	00002e08 	.word	0x00002e08
    2bbc:	00002e08 	.word	0x00002e08
    2bc0:	00002e08 	.word	0x00002e08
    2bc4:	00002e08 	.word	0x00002e08
    2bc8:	00002e08 	.word	0x00002e08
    2bcc:	00002e08 	.word	0x00002e08
    2bd0:	00002e08 	.word	0x00002e08
    2bd4:	00002e08 	.word	0x00002e08
    2bd8:	00002e08 	.word	0x00002e08
    2bdc:	00002e08 	.word	0x00002e08
    2be0:	00002e08 	.word	0x00002e08
    2be4:	0000281c 	.word	0x0000281c
    2be8:	00002e08 	.word	0x00002e08
    2bec:	00002e08 	.word	0x00002e08
    2bf0:	00002e08 	.word	0x00002e08
    2bf4:	00002e08 	.word	0x00002e08
    2bf8:	00002c44 	.word	0x00002c44
    2bfc:	00002e08 	.word	0x00002e08
    2c00:	00002e08 	.word	0x00002e08
    2c04:	0000281c 	.word	0x0000281c
                case 'p':
                case 'x':
                    length = _cvt(val, buf, 16, (char *)"0123456789abcdef");
                    break;
                case 'X':
                    length = _cvt(val, buf, 16, (char *)"0123456789ABCDEF");
    2c08:	e59fc230 	ldr	ip, [pc, #560]	; 2e40 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb30>
    2c0c:	e1a00007 	mov	r0, r7
    2c10:	e1a01008 	mov	r1, r8
    2c14:	e28d2040 	add	r2, sp, #64	; 0x40
    2c18:	e3a03010 	mov	r3, #16	; 0x10
    2c1c:	e58dc000 	str	ip, [sp]
    2c20:	ebfffc9c 	bl	1e98 <_ZL4_cvtyPclS_>
    2c24:	e59da00c 	ldr	sl, [sp, #12]
    2c28:	e1a0b000 	mov	fp, r0
    2c2c:	e060a00a 	rsb	sl, r0, sl
    2c30:	e59d0014 	ldr	r0, [sp, #20]
    2c34:	e58da00c 	str	sl, [sp, #12]
    2c38:	e58d0038 	str	r0, [sp, #56]
    2c3c:	e28d9040 	add	r9, sp, #64	; 0x40
    2c40:	eaffff03 	b	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
                switch (c) {
                case 'd':
                case 'D':
                case 'u':
                case 'U':
                    length = _cvt(val, buf, 10, (char *)"0123456789");
    2c44:	e59fc1f8 	ldr	ip, [pc, #504]	; 2e44 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xb34>
    2c48:	e1a01008 	mov	r1, r8
    2c4c:	e28d2040 	add	r2, sp, #64	; 0x40
    2c50:	e1a00007 	mov	r0, r7
    2c54:	e3a0300a 	mov	r3, #10	; 0xa
    2c58:	e58dc000 	str	ip, [sp]
    2c5c:	ebfffc8d 	bl	1e98 <_ZL4_cvtyPclS_>
    2c60:	e59d100c 	ldr	r1, [sp, #12]
    2c64:	e59d2014 	ldr	r2, [sp, #20]
    2c68:	e0601001 	rsb	r1, r0, r1
    2c6c:	e1a0b000 	mov	fp, r0
    2c70:	e58d100c 	str	r1, [sp, #12]
    2c74:	e58d2038 	str	r2, [sp, #56]
    2c78:	e28d9040 	add	r9, sp, #64	; 0x40
    2c7c:	eafffef4 	b	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
    cyg_bool result = true;
    const char *s;

    if( str == NULL ) return false;
    
    for( s = str ; result && *s ; s++ )
    2c80:	e59d3010 	ldr	r3, [sp, #16]
    2c84:	e1520003 	cmp	r2, r3
    2c88:	1affff49 	bne	29b4 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x6a4>
    2c8c:	eaffff57 	b	29f0 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x6e0>
                        sign = '-';
                        val = -val;
                    }
                } else {
                    // Mask to unsigned, sized quantity
                    if (islong) {
    2c90:	e35c0000 	cmp	ip, #0	; 0x0
                        val &= ((long long)1 << (sizeof(long) * 8)) - 1;
    2c94:	13a08000 	movne	r8, #0	; 0x0
    2c98:	158d3014 	strne	r3, [sp, #20]
    2c9c:	158d0024 	strne	r0, [sp, #36]
                        sign = '-';
                        val = -val;
                    }
                } else {
                    // Mask to unsigned, sized quantity
                    if (islong) {
    2ca0:	1afffe5e 	bne	2620 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x310>
                        val &= ((long long)1 << (sizeof(long) * 8)) - 1;
                    } else if (!islonglong) { // no need to mask longlong
    2ca4:	e3510000 	cmp	r1, #0	; 0x0
                        val &= ((long long)1 << (sizeof(int) * 8)) - 1;
    2ca8:	03a08000 	moveq	r8, #0	; 0x0
    2cac:	058d3014 	streq	r3, [sp, #20]
    2cb0:	058d1024 	streq	r1, [sp, #36]
                    }
                } else {
                    // Mask to unsigned, sized quantity
                    if (islong) {
                        val &= ((long long)1 << (sizeof(long) * 8)) - 1;
                    } else if (!islonglong) { // no need to mask longlong
    2cb4:	0afffe59 	beq	2620 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x310>
    2cb8:	eafffe55 	b	2614 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x304>
            case 'U':
            case 'b':
            case 'B':
                if (islonglong) {
                    val = va_arg(ap, long long);
	        } else if (islong) {
    2cbc:	e35c0000 	cmp	ip, #0	; 0x0
                    val = (long long)va_arg(ap, long);
    2cc0:	159d0014 	ldrne	r0, [sp, #20]
		} else{
                    val = (long long)va_arg(ap, int);
    2cc4:	059d9014 	ldreq	r9, [sp, #20]
            case 'b':
            case 'B':
                if (islonglong) {
                    val = va_arg(ap, long long);
	        } else if (islong) {
                    val = (long long)va_arg(ap, long);
    2cc8:	15903000 	ldrne	r3, [r0]
		} else{
                    val = (long long)va_arg(ap, int);
    2ccc:	05993000 	ldreq	r3, [r9]
            case 'b':
            case 'B':
                if (islonglong) {
                    val = va_arg(ap, long long);
	        } else if (islong) {
                    val = (long long)va_arg(ap, long);
    2cd0:	11a07003 	movne	r7, r3
    2cd4:	11a08fc7 	asrne	r8, r7, #31
		} else{
                    val = (long long)va_arg(ap, int);
    2cd8:	01a07003 	moveq	r7, r3
    2cdc:	01a08fc7 	asreq	r8, r7, #31
            case 'b':
            case 'B':
                if (islonglong) {
                    val = va_arg(ap, long long);
	        } else if (islong) {
                    val = (long long)va_arg(ap, long);
    2ce0:	12803004 	addne	r3, r0, #4	; 0x4
		} else{
                    val = (long long)va_arg(ap, int);
    2ce4:	02893004 	addeq	r3, r9, #4	; 0x4
    2ce8:	eafffe42 	b	25f8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x2e8>
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
    2cec:	e1a03000 	mov	r3, r0
    2cf0:	e4d34001 	ldrb	r4, [r3], #1
                zero_fill++;
    2cf4:	e59d9028 	ldr	r9, [sp, #40]
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
    2cf8:	e58d3018 	str	r3, [sp, #24]
                zero_fill++;
                while (is_digit(c)) {
    2cfc:	e2443030 	sub	r3, r4, #48	; 0x30
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
                zero_fill++;
    2d00:	e2899001 	add	r9, r9, #1	; 0x1
                while (is_digit(c)) {
    2d04:	e3530009 	cmp	r3, #9	; 0x9
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
                zero_fill++;
    2d08:	e58d9028 	str	r9, [sp, #40]
                while (is_digit(c)) {
    2d0c:	8afffded 	bhi	24c8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x1b8>
    2d10:	e2801002 	add	r1, r0, #2	; 0x2
                    right_prec = (right_prec * 10) + (c - '0');
                    c = *fmt++;
    2d14:	e5514001 	ldrb	r4, [r1, #-1]
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
                zero_fill++;
                while (is_digit(c)) {
    2d18:	e2443030 	sub	r3, r4, #48	; 0x30
    2d1c:	e3530009 	cmp	r3, #9	; 0x9
                    right_prec = (right_prec * 10) + (c - '0');
                    c = *fmt++;
    2d20:	e58d1018 	str	r1, [sp, #24]
    2d24:	e2811001 	add	r1, r1, #1	; 0x1
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
                zero_fill++;
                while (is_digit(c)) {
    2d28:	9afffff9 	bls	2d14 <_ZL8_vprintfPFvcPPvES0_PKcS_+0xa04>
                }
            } else {
                right_prec = left_prec;
            }
            sign = '\0';
            if (c == 'l') {
    2d2c:	e354006c 	cmp	r4, #108	; 0x6c
    2d30:	13a0c000 	movne	ip, #0	; 0x0
    2d34:	11a0100c 	movne	r1, ip
    2d38:	1afffde6 	bne	24d8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x1c8>
                // 'long' qualifier
                c = *fmt++;
    2d3c:	e59da018 	ldr	sl, [sp, #24]
    2d40:	e4da4001 	ldrb	r4, [sl], #1
    2d44:	e58da018 	str	sl, [sp, #24]
		islong = 1;
                if (c == 'l') {
    2d48:	e354006c 	cmp	r4, #108	; 0x6c
                    // long long qualifier
                    c = *fmt++;
    2d4c:	059d0018 	ldreq	r0, [sp, #24]
    2d50:	04d04001 	ldrbeq	r4, [r0], #1
    2d54:	03a0c001 	moveq	ip, #1	; 0x1
            sign = '\0';
            if (c == 'l') {
                // 'long' qualifier
                c = *fmt++;
		islong = 1;
                if (c == 'l') {
    2d58:	13a0c001 	movne	ip, #1	; 0x1
    2d5c:	13a01000 	movne	r1, #0	; 0x0
                    // long long qualifier
                    c = *fmt++;
    2d60:	058d0018 	streq	r0, [sp, #24]
    2d64:	01a0100c 	moveq	r1, ip
    2d68:	eafffdda 	b	24d8 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x1c8>
                    (*putc)(c, param);
                    res++;
                }
            }
            if (sign != '\0') {
                (*putc)(sign, param);
    2d6c:	e1a00001 	mov	r0, r1
    2d70:	e28d101c 	add	r1, sp, #28	; 0x1c
    2d74:	e8910006 	ldm	r1, {r1, r2}
    2d78:	e1a0e00f 	mov	lr, pc
    2d7c:	e12fff12 	bx	r2
                res++;
    2d80:	e59d3034 	ldr	r3, [sp, #52]
    2d84:	e2833001 	add	r3, r3, #1	; 0x1
    2d88:	e58d3034 	str	r3, [sp, #52]
    2d8c:	eafffedb 	b	2900 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x5f0>
                    val = (long long)va_arg(ap, int);
                }
                if ((c == 'd') || (c == 'D')) {
                    if (val < 0) {
                        sign = '-';
                        val = -val;
    2d90:	e3a0a02d 	mov	sl, #45	; 0x2d
    2d94:	e2777000 	rsbs	r7, r7, #0	; 0x0
    2d98:	e2e88000 	rsc	r8, r8, #0	; 0x0
    2d9c:	e58d3014 	str	r3, [sp, #20]
    2da0:	e58da024 	str	sl, [sp, #36]
    2da4:	eafffe1d 	b	2620 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x310>
                pad--;
            }
            if (zero_fill) {
                c = '0';
                if (sign != '\0') {
                    (*putc)(sign, param);
    2da8:	e59d0024 	ldr	r0, [sp, #36]
    2dac:	e28d101c 	add	r1, sp, #28	; 0x1c
    2db0:	e8910402 	ldm	r1, {r1, sl}
    2db4:	e1a0e00f 	mov	lr, pc
    2db8:	e12fff1a 	bx	sl
                    res++;
    2dbc:	e59d0034 	ldr	r0, [sp, #52]
    2dc0:	e3a01000 	mov	r1, #0	; 0x0
    2dc4:	e2800001 	add	r0, r0, #1	; 0x1
    2dc8:	e58d0034 	str	r0, [sp, #52]
    2dcc:	e3a0a030 	mov	sl, #48	; 0x30
    2dd0:	e58d1024 	str	r1, [sp, #36]
    2dd4:	eafffead 	b	2890 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x580>
                    else if (islong)
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
    2dd8:	e59da00c 	ldr	sl, [sp, #12]
    2ddc:	e24a0001 	sub	r0, sl, #1	; 0x1
    2de0:	e3500000 	cmp	r0, #0	; 0x0
    2de4:	c1a0b00a 	movgt	fp, sl
    2de8:	caffff27 	bgt	2a8c <_ZL8_vprintfPFvcPPvES0_PKcS_+0x77c>
    2dec:	e59d0014 	ldr	r0, [sp, #20]
    2df0:	e3a01000 	mov	r1, #0	; 0x0
    2df4:	e59db00c 	ldr	fp, [sp, #12]
    2df8:	e58d0038 	str	r0, [sp, #56]
    2dfc:	e28d9040 	add	r9, sp, #64	; 0x40
    2e00:	e58d100c 	str	r1, [sp, #12]
    2e04:	eafffe92 	b	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
                continue;
            default:
                (*putc)('%', param);
                (*putc)(c, param);
                res += 2;
                continue;
    2e08:	e59d200c 	ldr	r2, [sp, #12]
    2e0c:	e59d3014 	ldr	r3, [sp, #20]
    2e10:	e06b2002 	rsb	r2, fp, r2
    2e14:	e58d200c 	str	r2, [sp, #12]
    2e18:	e58d3038 	str	r3, [sp, #56]
    2e1c:	e28d9040 	add	r9, sp, #64	; 0x40
    2e20:	eafffe8b 	b	2854 <_ZL8_vprintfPFvcPPvES0_PKcS_+0x544>
    2e24:	000129d0 	.word	0x000129d0
    2e28:	000129e8 	.word	0x000129e8
    2e2c:	000129ec 	.word	0x000129ec
    2e30:	000129fc 	.word	0x000129fc
    2e34:	00012a10 	.word	0x00012a10
    2e38:	00012a18 	.word	0x00012a18
    2e3c:	00012a2c 	.word	0x00012a2c
    2e40:	000129bc 	.word	0x000129bc
    2e44:	000129f0 	.word	0x000129f0

00002e48 <diag_vprintf>:
    va_end(ap);
    return (ret);
}

int
diag_vprintf(const char *fmt, va_list ap)
    2e48:	e1a03001 	mov	r3, r1
{
    int ret;

    ret = _vprintf(_putc, (void **)0, fmt, ap);
    2e4c:	e59f100c 	ldr	r1, [pc, #12]	; 2e60 <diag_vprintf+0x18>
    va_end(ap);
    return (ret);
}

int
diag_vprintf(const char *fmt, va_list ap)
    2e50:	e1a02000 	mov	r2, r0
{
    int ret;

    ret = _vprintf(_putc, (void **)0, fmt, ap);
    2e54:	e5910000 	ldr	r0, [r1]
    2e58:	e3a01000 	mov	r1, #0	; 0x0
    2e5c:	eafffd2b 	b	2310 <_ZL8_vprintfPFvcPPvES0_PKcS_>
    2e60:	400007bc 	.word	0x400007bc

00002e64 <diag_printf>:
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    return (info.len);
}

int
diag_printf(const char *fmt, ...)
    2e64:	e92d000f 	push	{r0, r1, r2, r3}
    2e68:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
    ret = _vprintf(_putc, (void **)0, fmt, ap);
    2e6c:	e59f3024 	ldr	r3, [pc, #36]	; 2e98 <diag_printf+0x34>
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    return (info.len);
}

int
diag_printf(const char *fmt, ...)
    2e70:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
    ret = _vprintf(_putc, (void **)0, fmt, ap);
    2e74:	e5930000 	ldr	r0, [r3]
    2e78:	e3a01000 	mov	r1, #0	; 0x0
    2e7c:	e59d2008 	ldr	r2, [sp, #8]
    2e80:	e28d300c 	add	r3, sp, #12	; 0xc
    2e84:	ebfffd21 	bl	2310 <_ZL8_vprintfPFvcPPvES0_PKcS_>
    va_end(ap);
    return (ret);
}
    2e88:	e28dd004 	add	sp, sp, #4	; 0x4
    2e8c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
    2e90:	e28dd010 	add	sp, sp, #16	; 0x10
    2e94:	e12fff1e 	bx	lr
    2e98:	400007bc 	.word	0x400007bc

00002e9c <diag_dump_buf_with_offset_16bit>:
}

void
diag_dump_buf_with_offset_16bit(cyg_uint16   *p, 
				CYG_ADDRWORD  s, 
				cyg_uint16   *base)
    2e9c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
    2ea0:	e1500001 	cmp	r0, r1
}

void
diag_dump_buf_with_offset_16bit(cyg_uint16   *p, 
				CYG_ADDRWORD  s, 
				cyg_uint16   *base)
    2ea4:	e1a07001 	mov	r7, r1
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    2ea8:	30607001 	rsbcc	r7, r0, r1
    }
    while ((int)s > 0) {
    2eac:	e3570000 	cmp	r7, #0	; 0x0
}

void
diag_dump_buf_with_offset_16bit(cyg_uint16   *p, 
				CYG_ADDRWORD  s, 
				cyg_uint16   *base)
    2eb0:	e24dd004 	sub	sp, sp, #4	; 0x4
    2eb4:	e1a06000 	mov	r6, r0
    2eb8:	e1a0a002 	mov	sl, r2
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2ebc:	da000029 	ble	2f68 <diag_dump_buf_with_offset_16bit+0xcc>
        if (base) {
    2ec0:	e35a0000 	cmp	sl, #0	; 0x0
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2ec4:	e0628000 	rsb	r8, r2, r0
        if (base) {
    2ec8:	0a00001e 	beq	2f48 <diag_dump_buf_with_offset_16bit+0xac>
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
    2ecc:	e1a01008 	mov	r1, r8
    2ed0:	e59f0098 	ldr	r0, [pc, #152]	; 2f70 <diag_dump_buf_with_offset_16bit+0xd4>
    2ed4:	ebffffe2 	bl	2e64 <diag_printf>
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
    2ed8:	e1a050c7 	asr	r5, r7, #1
    2edc:	e3a04000 	mov	r4, #0	; 0x0
    2ee0:	ea000006 	b	2f00 <diag_dump_buf_with_offset_16bit+0x64>
        }
        for (i = 0;  i < 8;  i++) {
            if (i < (int)s/2) {
	      diag_printf("%04X ", p[i] );
    2ee4:	e19610b3 	ldrh	r1, [r6, r3]
    2ee8:	ebffffdd 	bl	2e64 <diag_printf>
	      if (i == 3) diag_printf(" ");
    2eec:	e3540003 	cmp	r4, #3	; 0x3
    2ef0:	0a000018 	beq	2f58 <diag_dump_buf_with_offset_16bit+0xbc>
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 8;  i++) {
    2ef4:	e2844001 	add	r4, r4, #1	; 0x1
    2ef8:	e3540007 	cmp	r4, #7	; 0x7
    2efc:	ca000008 	bgt	2f24 <diag_dump_buf_with_offset_16bit+0x88>
            if (i < (int)s/2) {
    2f00:	e1550004 	cmp	r5, r4
	      diag_printf("%04X ", p[i] );
    2f04:	e1a03084 	lsl	r3, r4, #1
    2f08:	e59f0064 	ldr	r0, [pc, #100]	; 2f74 <diag_dump_buf_with_offset_16bit+0xd8>
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 8;  i++) {
            if (i < (int)s/2) {
    2f0c:	cafffff4 	bgt	2ee4 <diag_dump_buf_with_offset_16bit+0x48>
	      diag_printf("%04X ", p[i] );
	      if (i == 3) diag_printf(" ");
            } else {
	      diag_printf("     ");
    2f10:	e59f0060 	ldr	r0, [pc, #96]	; 2f78 <diag_dump_buf_with_offset_16bit+0xdc>
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 8;  i++) {
    2f14:	e2844001 	add	r4, r4, #1	; 0x1
            if (i < (int)s/2) {
	      diag_printf("%04X ", p[i] );
	      if (i == 3) diag_printf(" ");
            } else {
	      diag_printf("     ");
    2f18:	ebffffd1 	bl	2e64 <diag_printf>
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 8;  i++) {
    2f1c:	e3540007 	cmp	r4, #7	; 0x7
    2f20:	dafffff6 	ble	2f00 <diag_dump_buf_with_offset_16bit+0x64>
            } else {
	      diag_printf("     ");
            }
        }
        diag_printf("\n");
        s -= 16;
    2f24:	e2477010 	sub	r7, r7, #16	; 0x10
	      if (i == 3) diag_printf(" ");
            } else {
	      diag_printf("     ");
            }
        }
        diag_printf("\n");
    2f28:	e59f004c 	ldr	r0, [pc, #76]	; 2f7c <diag_dump_buf_with_offset_16bit+0xe0>
    2f2c:	ebffffcc 	bl	2e64 <diag_printf>
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2f30:	e3570000 	cmp	r7, #0	; 0x0
            } else {
	      diag_printf("     ");
            }
        }
        diag_printf("\n");
        s -= 16;
    2f34:	e2888010 	add	r8, r8, #16	; 0x10
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2f38:	da00000a 	ble	2f68 <diag_dump_buf_with_offset_16bit+0xcc>
        if (base) {
    2f3c:	e35a0000 	cmp	sl, #0	; 0x0
	      diag_printf("     ");
            }
        }
        diag_printf("\n");
        s -= 16;
        p += 8;
    2f40:	e2866010 	add	r6, r6, #16	; 0x10
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
        if (base) {
    2f44:	1affffe0 	bne	2ecc <diag_dump_buf_with_offset_16bit+0x30>
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
    2f48:	e1a01006 	mov	r1, r6
    2f4c:	e59f001c 	ldr	r0, [pc, #28]	; 2f70 <diag_dump_buf_with_offset_16bit+0xd4>
    2f50:	ebffffc3 	bl	2e64 <diag_printf>
    2f54:	eaffffdf 	b	2ed8 <diag_dump_buf_with_offset_16bit+0x3c>
        }
        for (i = 0;  i < 8;  i++) {
            if (i < (int)s/2) {
	      diag_printf("%04X ", p[i] );
	      if (i == 3) diag_printf(" ");
    2f58:	e59f0020 	ldr	r0, [pc, #32]	; 2f80 <diag_dump_buf_with_offset_16bit+0xe4>
    2f5c:	ebffffc0 	bl	2e64 <diag_printf>
    2f60:	e2844001 	add	r4, r4, #1	; 0x1
    2f64:	eaffffe5 	b	2f00 <diag_dump_buf_with_offset_16bit+0x64>
        }
        diag_printf("\n");
        s -= 16;
        p += 8;
    }
}
    2f68:	e28dd004 	add	sp, sp, #4	; 0x4
    2f6c:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    2f70:	0001299c 	.word	0x0001299c
    2f74:	00012a30 	.word	0x00012a30
    2f78:	00012a48 	.word	0x00012a48
    2f7c:	00012a38 	.word	0x00012a38
    2f80:	00012a4c 	.word	0x00012a4c

00002f84 <diag_dump_buf_16bit>:

externC void
diag_dump_buf_16bit(void *p, CYG_ADDRWORD s)
{
   diag_dump_buf_with_offset_16bit((cyg_uint16 *)p, s, 0);
    2f84:	e3a02000 	mov	r2, #0	; 0x0
    2f88:	eaffffc3 	b	2e9c <diag_dump_buf_with_offset_16bit>

00002f8c <diag_dump_buf_with_offset_32bit>:
}

void
diag_dump_buf_with_offset_32bit(cyg_uint32   *p, 
				CYG_ADDRWORD  s, 
				cyg_uint32   *base)
    2f8c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
    2f90:	e1500001 	cmp	r0, r1
}

void
diag_dump_buf_with_offset_32bit(cyg_uint32   *p, 
				CYG_ADDRWORD  s, 
				cyg_uint32   *base)
    2f94:	e1a07001 	mov	r7, r1
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    2f98:	30607001 	rsbcc	r7, r0, r1
    }
    while ((int)s > 0) {
    2f9c:	e3570000 	cmp	r7, #0	; 0x0
}

void
diag_dump_buf_with_offset_32bit(cyg_uint32   *p, 
				CYG_ADDRWORD  s, 
				cyg_uint32   *base)
    2fa0:	e24dd004 	sub	sp, sp, #4	; 0x4
    2fa4:	e1a06000 	mov	r6, r0
    2fa8:	e1a0a002 	mov	sl, r2
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2fac:	da000022 	ble	303c <diag_dump_buf_with_offset_32bit+0xb0>
        if (base) {
    2fb0:	e35a0000 	cmp	sl, #0	; 0x0
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    2fb4:	e0628000 	rsb	r8, r2, r0
        if (base) {
    2fb8:	0a00001b 	beq	302c <diag_dump_buf_with_offset_32bit+0xa0>
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
    2fbc:	e1a01008 	mov	r1, r8
    2fc0:	e59f007c 	ldr	r0, [pc, #124]	; 3044 <diag_dump_buf_with_offset_32bit+0xb8>
    2fc4:	ebffffa6 	bl	2e64 <diag_printf>
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
    2fc8:	e1a05147 	asr	r5, r7, #2
    2fcc:	e3a04000 	mov	r4, #0	; 0x0
    2fd0:	ea000004 	b	2fe8 <diag_dump_buf_with_offset_32bit+0x5c>
        }
        for (i = 0;  i < 4;  i++) {
            if (i < (int)s/4) {
                diag_printf("%08X ", p[i] );
    2fd4:	e7961104 	ldr	r1, [r6, r4, lsl #2]
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 4;  i++) {
    2fd8:	e2844001 	add	r4, r4, #1	; 0x1
            if (i < (int)s/4) {
                diag_printf("%08X ", p[i] );
    2fdc:	ebffffa0 	bl	2e64 <diag_printf>
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 4;  i++) {
    2fe0:	e3540004 	cmp	r4, #4	; 0x4
    2fe4:	0a000007 	beq	3008 <diag_dump_buf_with_offset_32bit+0x7c>
            if (i < (int)s/4) {
    2fe8:	e1550004 	cmp	r5, r4
                diag_printf("%08X ", p[i] );
    2fec:	e59f0054 	ldr	r0, [pc, #84]	; 3048 <diag_dump_buf_with_offset_32bit+0xbc>
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 4;  i++) {
            if (i < (int)s/4) {
    2ff0:	cafffff7 	bgt	2fd4 <diag_dump_buf_with_offset_32bit+0x48>
                diag_printf("%08X ", p[i] );
            } else {
                diag_printf("         ");
    2ff4:	e59f0050 	ldr	r0, [pc, #80]	; 304c <diag_dump_buf_with_offset_32bit+0xc0>
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 4;  i++) {
    2ff8:	e2844001 	add	r4, r4, #1	; 0x1
            if (i < (int)s/4) {
                diag_printf("%08X ", p[i] );
            } else {
                diag_printf("         ");
    2ffc:	ebffff98 	bl	2e64 <diag_printf>
        if (base) {
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
        }
        for (i = 0;  i < 4;  i++) {
    3000:	e3540004 	cmp	r4, #4	; 0x4
    3004:	1afffff7 	bne	2fe8 <diag_dump_buf_with_offset_32bit+0x5c>
            } else {
                diag_printf("         ");
            }
        }
        diag_printf("\n");
        s -= 16;
    3008:	e2477010 	sub	r7, r7, #16	; 0x10
                diag_printf("%08X ", p[i] );
            } else {
                diag_printf("         ");
            }
        }
        diag_printf("\n");
    300c:	e59f003c 	ldr	r0, [pc, #60]	; 3050 <diag_dump_buf_with_offset_32bit+0xc4>
    3010:	ebffff93 	bl	2e64 <diag_printf>
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    3014:	e3570000 	cmp	r7, #0	; 0x0
            } else {
                diag_printf("         ");
            }
        }
        diag_printf("\n");
        s -= 16;
    3018:	e2888010 	add	r8, r8, #16	; 0x10
{
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
    301c:	da000006 	ble	303c <diag_dump_buf_with_offset_32bit+0xb0>
        if (base) {
    3020:	e35a0000 	cmp	sl, #0	; 0x0
                diag_printf("         ");
            }
        }
        diag_printf("\n");
        s -= 16;
        p += 4;
    3024:	e2866010 	add	r6, r6, #16	; 0x10
    int i;
    if ((CYG_ADDRWORD)s > (CYG_ADDRWORD)p) {
        s = (CYG_ADDRWORD)s - (CYG_ADDRWORD)p;
    }
    while ((int)s > 0) {
        if (base) {
    3028:	1affffe3 	bne	2fbc <diag_dump_buf_with_offset_32bit+0x30>
            diag_printf("%08X: ", (CYG_ADDRWORD)p - (CYG_ADDRWORD)base);
        } else {
            diag_printf("%08X: ", (CYG_ADDRWORD)p);
    302c:	e1a01006 	mov	r1, r6
    3030:	e59f000c 	ldr	r0, [pc, #12]	; 3044 <diag_dump_buf_with_offset_32bit+0xb8>
    3034:	ebffff8a 	bl	2e64 <diag_printf>
    3038:	eaffffe2 	b	2fc8 <diag_dump_buf_with_offset_32bit+0x3c>
        }
        diag_printf("\n");
        s -= 16;
        p += 4;
    }
}
    303c:	e28dd004 	add	sp, sp, #4	; 0x4
    3040:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    3044:	0001299c 	.word	0x0001299c
    3048:	00012a3c 	.word	0x00012a3c
    304c:	00012a44 	.word	0x00012a44
    3050:	00012a38 	.word	0x00012a38

00003054 <diag_dump_buf_32bit>:

externC void
diag_dump_buf_32bit(void *p, CYG_ADDRWORD s)
{
   diag_dump_buf_with_offset_32bit((cyg_uint32 *)p, s, 0);
    3054:	e3a02000 	mov	r2, #0	; 0x0
    3058:	eaffffcb 	b	2f8c <diag_dump_buf_with_offset_32bit>

0000305c <diag_vsprintf>:
    va_end(ap);
    return (info.len);
}

int 
diag_vsprintf(char *buf, const char *fmt, va_list ap)
    305c:	e92d4010 	push	{r4, lr}
    3060:	e24dd010 	sub	sp, sp, #16	; 0x10
    3064:	e1a03002 	mov	r3, r2
{
    int ret;
    struct _sputc_info info;

    info.ptr = buf;
    3068:	e58d0004 	str	r0, [sp, #4]
    info.max = 1024;  // Unlimited
    info.len = 0;
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    306c:	e1a02001 	mov	r2, r1
{
    int ret;
    struct _sputc_info info;

    info.ptr = buf;
    info.max = 1024;  // Unlimited
    3070:	e3a0cb01 	mov	ip, #1024	; 0x400
    info.len = 0;
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    3074:	e28d1004 	add	r1, sp, #4	; 0x4
    int ret;
    struct _sputc_info info;

    info.ptr = buf;
    info.max = 1024;  // Unlimited
    info.len = 0;
    3078:	e3a04000 	mov	r4, #0	; 0x0
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    307c:	e59f0014 	ldr	r0, [pc, #20]	; 3098 <diag_vsprintf+0x3c>
{
    int ret;
    struct _sputc_info info;

    info.ptr = buf;
    info.max = 1024;  // Unlimited
    3080:	e58dc008 	str	ip, [sp, #8]
    info.len = 0;
    3084:	e58d400c 	str	r4, [sp, #12]
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    3088:	ebfffca0 	bl	2310 <_ZL8_vprintfPFvcPPvES0_PKcS_>
    return (info.len);
}
    308c:	e59d000c 	ldr	r0, [sp, #12]
    3090:	e28dd010 	add	sp, sp, #16	; 0x10
    3094:	e8bd8010 	pop	{r4, pc}
    3098:	00001f68 	.word	0x00001f68

0000309c <diag_snprintf>:
    va_end(ap);
    return (info.len);
}

int
diag_snprintf(char *buf, size_t len, const char *fmt, ...)
    309c:	e92d000c 	push	{r2, r3}
    30a0:	e92d4010 	push	{r4, lr}
    30a4:	e24dd010 	sub	sp, sp, #16	; 0x10
    int ret;
    va_list ap;
    struct _sputc_info info;

    va_start(ap, fmt);
    info.ptr = buf;
    30a8:	e58d0004 	str	r0, [sp, #4]
    info.len = 0;
    info.max = len-1;
    30ac:	e2414001 	sub	r4, r1, #1	; 0x1
    va_list ap;
    struct _sputc_info info;

    va_start(ap, fmt);
    info.ptr = buf;
    info.len = 0;
    30b0:	e3a0c000 	mov	ip, #0	; 0x0
    info.max = len-1;
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    30b4:	e28d1004 	add	r1, sp, #4	; 0x4
    30b8:	e59d2018 	ldr	r2, [sp, #24]
    30bc:	e28d301c 	add	r3, sp, #28	; 0x1c
    30c0:	e59f001c 	ldr	r0, [pc, #28]	; 30e4 <diag_snprintf+0x48>
    va_list ap;
    struct _sputc_info info;

    va_start(ap, fmt);
    info.ptr = buf;
    info.len = 0;
    30c4:	e58dc00c 	str	ip, [sp, #12]
    info.max = len-1;
    30c8:	e58d4008 	str	r4, [sp, #8]
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    30cc:	ebfffc8f 	bl	2310 <_ZL8_vprintfPFvcPPvES0_PKcS_>
    va_end(ap);
    return (info.len);
}
    30d0:	e59d000c 	ldr	r0, [sp, #12]
    30d4:	e28dd010 	add	sp, sp, #16	; 0x10
    30d8:	e8bd4010 	pop	{r4, lr}
    30dc:	e28dd008 	add	sp, sp, #8	; 0x8
    30e0:	e12fff1e 	bx	lr
    30e4:	00001f68 	.word	0x00001f68

000030e8 <diag_sprintf>:
        info->len++;
    }
}

int
diag_sprintf(char *buf, const char *fmt, ...)
    30e8:	e92d000e 	push	{r1, r2, r3}
    30ec:	e92d4010 	push	{r4, lr}
    30f0:	e24dd014 	sub	sp, sp, #20	; 0x14
    int ret;
    va_list ap;
    struct _sputc_info info;

    va_start(ap, fmt);
    info.ptr = buf;
    30f4:	e58d0004 	str	r0, [sp, #4]
    info.max = 1024;  // Unlimited
    30f8:	e3a0cb01 	mov	ip, #1024	; 0x400
    info.len = 0;
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    30fc:	e28d1004 	add	r1, sp, #4	; 0x4
    3100:	e59d201c 	ldr	r2, [sp, #28]
    3104:	e28d3020 	add	r3, sp, #32	; 0x20
    struct _sputc_info info;

    va_start(ap, fmt);
    info.ptr = buf;
    info.max = 1024;  // Unlimited
    info.len = 0;
    3108:	e3a04000 	mov	r4, #0	; 0x0
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    310c:	e59f001c 	ldr	r0, [pc, #28]	; 3130 <diag_sprintf+0x48>
    va_list ap;
    struct _sputc_info info;

    va_start(ap, fmt);
    info.ptr = buf;
    info.max = 1024;  // Unlimited
    3110:	e58dc008 	str	ip, [sp, #8]
    info.len = 0;
    3114:	e58d400c 	str	r4, [sp, #12]
    ret = _vprintf(_sputc, (void **)&info, fmt, ap);
    3118:	ebfffc7c 	bl	2310 <_ZL8_vprintfPFvcPPvES0_PKcS_>
    va_end(ap);
    return (info.len);
}
    311c:	e59d000c 	ldr	r0, [sp, #12]
    3120:	e28dd014 	add	sp, sp, #20	; 0x14
    3124:	e8bd4010 	pop	{r4, lr}
    3128:	e28dd00c 	add	sp, sp, #12	; 0xc
    312c:	e12fff1e 	bx	lr
    3130:	00001f68 	.word	0x00001f68

00003134 <cyg_scheduler_lock>:
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3134:	e59f200c 	ldr	r2, [pc, #12]	; 3148 <cyg_scheduler_lock+0x14>
    3138:	e5923000 	ldr	r3, [r2]
    313c:	e2833001 	add	r3, r3, #1	; 0x1
    3140:	e5823000 	str	r3, [r2]
{
    Cyg_Scheduler::lock();
    // get_sched_lock() is unsigned, see below "cyg_ucount32 lock"
    CYG_ASSERT( (0xff000000 & (Cyg_Scheduler::get_sched_lock())) == 0,
                "Scheduler overlocked" );
}
    3144:	e12fff1e 	bx	lr
    3148:	400007c8 	.word	0x400007c8

0000314c <cyg_scheduler_read_lock>:
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    314c:	e59f3004 	ldr	r3, [pc, #4]	; 3158 <cyg_scheduler_read_lock+0xc>
    3150:	e5930000 	ldr	r0, [r3]
/* Read the scheduler lock value. */
externC cyg_ucount32 cyg_scheduler_read_lock(void) __THROW
{
    cyg_ucount32 slock = Cyg_Scheduler::get_sched_lock();
    return slock;
}
    3154:	e12fff1e 	bx	lr
    3158:	400007c8 	.word	0x400007c8

0000315c <cyg_thread_self>:
// -------------------------------------------------------------------------
// Simple inline accessor functions

inline Cyg_Thread *Cyg_Scheduler_Base::get_current_thread()
{
    return current_thread[CYG_KERNEL_CPU_THIS()];
    315c:	e59f3004 	ldr	r3, [pc, #4]	; 3168 <cyg_thread_self+0xc>
    3160:	e5930000 	ldr	r0, [r3]
}

externC cyg_handle_t cyg_thread_self() __THROW
{
    return (cyg_handle_t)Cyg_Thread::self();
}
    3164:	e12fff1e 	bx	lr
    3168:	40002538 	.word	0x40002538

0000316c <cyg_thread_get_id>:

externC cyg_uint16 cyg_thread_get_id( cyg_handle_t thread) __THROW
{
    return ((Cyg_Thread *)thread)->get_unique_id();
}
    316c:	e1d004bc 	ldrh	r0, [r0, #76]
    3170:	e12fff1e 	bx	lr

00003174 <cyg_thread_idle_thread>:
// idle thread is not really a plain CygThread; danger.
externC cyg_handle_t cyg_thread_idle_thread() __THROW
{
    extern Cyg_Thread idle_thread;
    return (cyg_handle_t)&idle_thread;
}
    3174:	e59f0000 	ldr	r0, [pc, #0]	; 317c <cyg_thread_idle_thread+0x8>
    3178:	e12fff1e 	bx	lr
    317c:	40001c70 	.word	0x40001c70

00003180 <cyg_thread_get_priority>:
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_SIMPLE

    // If we have an inherited priority, return our original
    // priority rather than the current one.
    
    if( priority_inherited ) return original_priority;
    3180:	e5903038 	ldr	r3, [r0, #56]
    3184:	e3530000 	cmp	r3, #0	; 0x0
    3188:	15900034 	ldrne	r0, [r0, #52]

#endif

    return priority;
    318c:	05900024 	ldreq	r0, [r0, #36]
#ifdef CYGIMP_THREAD_PRIORITY
    return ((Cyg_Thread *)thread)->get_priority();
#else
    return 0;
#endif
}
    3190:	e12fff1e 	bx	lr

00003194 <cyg_thread_get_current_priority>:
#ifdef CYGIMP_THREAD_PRIORITY
    return ((Cyg_Thread *)thread)->get_current_priority();
#else
    return 0;
#endif
}
    3194:	e5900024 	ldr	r0, [r0, #36]
    3198:	e12fff1e 	bx	lr

0000319c <cyg_thread_deadline_wait>:
    cyg_tick_count_t    run_time,               /* worst case execution time */
    cyg_tick_count_t    deadline                /* absolute deadline         */
) __THROW
{
    CYG_ASSERT(0,"Not implemented");
} 
    319c:	e12fff1e 	bx	lr

000031a0 <cyg_thread_get_stack_base>:

/* Stack information */
externC cyg_addrword_t cyg_thread_get_stack_base(cyg_handle_t thread) __THROW
{
    return ((Cyg_Thread *)thread)->get_stack_base();
}
    31a0:	e5900000 	ldr	r0, [r0]
    31a4:	e12fff1e 	bx	lr

000031a8 <cyg_thread_get_stack_size>:

externC cyg_uint32 cyg_thread_get_stack_size(cyg_handle_t thread) __THROW
{
    return ((Cyg_Thread *)thread)->get_stack_size();
}
    31a8:	e5900004 	ldr	r0, [r0, #4]
    31ac:	e12fff1e 	bx	lr

000031b0 <cyg_thread_get_data>:
    31b0:	e59f2014 	ldr	r2, [pc, #20]	; 31cc <cyg_thread_get_data+0x1c>
    31b4:	e2800020 	add	r0, r0, #32	; 0x20
    31b8:	e5923000 	ldr	r3, [r2]
    31bc:	e1a00100 	lsl	r0, r0, #2
    31c0:	e0833000 	add	r3, r3, r0
}

externC CYG_ADDRWORD cyg_thread_get_data(cyg_ucount32 index) __THROW
{
    return Cyg_Thread::get_data(index);
}
    31c4:	e5930004 	ldr	r0, [r3, #4]
    31c8:	e12fff1e 	bx	lr
    31cc:	40002538 	.word	0x40002538

000031d0 <cyg_thread_get_data_ptr>:
    31d0:	e59f2014 	ldr	r2, [pc, #20]	; 31ec <cyg_thread_get_data_ptr+0x1c>
    31d4:	e2800020 	add	r0, r0, #32	; 0x20
    31d8:	e5923000 	ldr	r3, [r2]
    31dc:	e1a00100 	lsl	r0, r0, #2
    31e0:	e0833000 	add	r3, r3, r0

externC CYG_ADDRWORD *cyg_thread_get_data_ptr(cyg_ucount32 index) __THROW
{
    return Cyg_Thread::get_data_ptr(index);
}
    31e4:	e2830004 	add	r0, r3, #4	; 0x4
    31e8:	e12fff1e 	bx	lr
    31ec:	40002538 	.word	0x40002538

000031f0 <cyg_thread_set_data>:
    31f0:	e59f2014 	ldr	r2, [pc, #20]	; 320c <cyg_thread_set_data+0x1c>
    CYG_ASSERT( index < CYGNUM_KERNEL_THREADS_DATA_MAX,
                "Per thread data index out of bounds");
    CYG_ASSERT( (thread_data_map & (1<<index)) == 0,
                "Unallocated index used");

    thread_data[index] = data;
    31f4:	e2800020 	add	r0, r0, #32	; 0x20
    31f8:	e5923000 	ldr	r3, [r2]
    31fc:	e1a00100 	lsl	r0, r0, #2
    3200:	e0833000 	add	r3, r3, r0
    3204:	e5831004 	str	r1, [r3, #4]

externC void cyg_thread_set_data(cyg_ucount32 index, CYG_ADDRWORD 
data) __THROW
{
    Cyg_Thread::self()->set_data(index, data);
}
    3208:	e12fff1e 	bx	lr
    320c:	40002538 	.word	0x40002538

00003210 <cyg_interrupt_set_cpu>:
) __THROW
{
#ifdef CYGPKG_KERNEL_SMP_SUPPORT    
    Cyg_Interrupt::set_cpu( vector, cpu );
#endif    
}
    3210:	e12fff1e 	bx	lr

00003214 <cyg_interrupt_get_cpu>:
    return Cyg_Interrupt::get_cpu( vector );
#else
    return CYG_KERNEL_CPU_THIS();
#endif    
    
}
    3214:	e3a00000 	mov	r0, #0	; 0x0
    3218:	e12fff1e 	bx	lr

0000321c <cyg_counter_current_value>:
{
    ((Cyg_Counter *)counter)->~Cyg_Counter();
}

/* Return current value of counter                                           */
externC cyg_tick_count_t cyg_counter_current_value(cyg_handle_t counter) __THROW
    321c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
// Counter class inlines

// Return current value of counter
inline cyg_tick_count Cyg_Counter::current_value()
{
    return counter;
    3220:	e2803008 	add	r3, r0, #8	; 0x8
    3224:	e8930018 	ldm	r3, {r3, r4}
{
    return ((Cyg_Counter *)counter)->current_value();
}
    3228:	e1a01004 	mov	r1, r4
    322c:	e1a00003 	mov	r0, r3
    3230:	e8bd0010 	pop	{r4}
    3234:	e12fff1e 	bx	lr

00003238 <cyg_counter_set_value>:
}

// Set the counter's current value
inline void Cyg_Counter::set_value( cyg_tick_count new_value)
{
    counter = new_value;
    3238:	e5802008 	str	r2, [r0, #8]
    323c:	e580300c 	str	r3, [r0, #12]
    cyg_handle_t        counter,
    cyg_tick_count_t new_value
) __THROW
{
    ((Cyg_Counter *)counter)->set_value( new_value );
}
    3240:	e12fff1e 	bx	lr

00003244 <cyg_clock_to_counter>:
    cyg_handle_t        clock,
    cyg_handle_t        *counter
) __THROW
{
    CYG_CHECK_DATA_PTR( counter, "Bad counter handle pointer" );
    *counter = (cyg_handle_t)(Cyg_Counter *)clock;
    3244:	e5810000 	str	r0, [r1]
}
    3248:	e12fff1e 	bx	lr

0000324c <cyg_clock_set_resolution>:

externC void cyg_clock_set_resolution(
    cyg_handle_t        clock,
    cyg_resolution_t    resolution      /* New resolution                    */
) __THROW
    324c:	e24dd008 	sub	sp, sp, #8	; 0x8
    3250:	e88d0006 	stm	sp, {r1, r2}
// Set new resolution
inline void Cyg_Clock::set_resolution(                
        Cyg_Clock::cyg_resolution new_resolution
        )
{
    resolution = new_resolution;
    3254:	e5801014 	str	r1, [r0, #20]
    3258:	e5802018 	str	r2, [r0, #24]

    res.dividend = resolution.dividend;
    res.divisor  = resolution.divisor;

    ((Cyg_Clock *)clock)->set_resolution( res );
}
    325c:	e28dd008 	add	sp, sp, #8	; 0x8
    3260:	e12fff1e 	bx	lr

00003264 <cyg_clock_get_resolution>:
    Cyg_Clock::cyg_resolution res =
        ((Cyg_Clock *)clock)->get_resolution();    

    cyg_resolution_t resolution;

    resolution.dividend = res.dividend;
    3264:	e591c014 	ldr	ip, [r1, #20]
// Clock class inlines

// Return current resolution
inline Cyg_Clock::cyg_resolution Cyg_Clock::get_resolution()
{
    return resolution;
    3268:	e5912018 	ldr	r2, [r1, #24]
    326c:	e580c000 	str	ip, [r0]
    resolution.divisor  = res.divisor;
    3270:	e5802004 	str	r2, [r0, #4]

    return resolution;
}
    3274:	e12fff1e 	bx	lr

00003278 <cyg_real_time_clock>:

#ifdef CYGVAR_KERNEL_COUNTERS_CLOCK
externC cyg_handle_t cyg_real_time_clock(void) __THROW
    3278:	e59f3004 	ldr	r3, [pc, #4]	; 3284 <cyg_real_time_clock+0xc>
{
    return (cyg_handle_t)Cyg_Clock::real_time_clock;
}
    327c:	e5930000 	ldr	r0, [r3]
    3280:	e12fff1e 	bx	lr
    3284:	400046bc 	.word	0x400046bc

00003288 <cyg_current_time>:

externC cyg_tick_count_t cyg_current_time(void) __THROW
{
    return Cyg_Clock::real_time_clock->current_value();
    3288:	e59f301c 	ldr	r3, [pc, #28]	; 32ac <cyg_current_time+0x24>
    328c:	e5932000 	ldr	r2, [r3]
externC cyg_handle_t cyg_real_time_clock(void) __THROW
{
    return (cyg_handle_t)Cyg_Clock::real_time_clock;
}

externC cyg_tick_count_t cyg_current_time(void) __THROW
    3290:	e92d0030 	push	{r4, r5}
// Counter class inlines

// Return current value of counter
inline cyg_tick_count Cyg_Counter::current_value()
{
    return counter;
    3294:	e2824008 	add	r4, r2, #8	; 0x8
    3298:	e8940030 	ldm	r4, {r4, r5}
{
    return Cyg_Clock::real_time_clock->current_value();
}
    329c:	e1a01005 	mov	r1, r5
    32a0:	e1a00004 	mov	r0, r4
    32a4:	e8bd0030 	pop	{r4, r5}
    32a8:	e12fff1e 	bx	lr
    32ac:	400046bc 	.word	0x400046bc

000032b0 <cyg_mbox_peek>:
}

externC cyg_count32 cyg_mbox_peek(cyg_handle_t mbox) __THROW
{
    return ((Cyg_Mbox *)mbox)->peek();
}
    32b0:	e5900004 	ldr	r0, [r0, #4]
    32b4:	e12fff1e 	bx	lr

000032b8 <cyg_mbox_waiting_to_get>:

externC cyg_bool_t cyg_mbox_waiting_to_get(cyg_handle_t mbox) __THROW
    32b8:	e5900008 	ldr	r0, [r0, #8]
{
    return ((Cyg_Mbox *)mbox)->waiting_to_get();
}
    32bc:	e2500000 	subs	r0, r0, #0	; 0x0
    32c0:	13a00001 	movne	r0, #1	; 0x1
    32c4:	e12fff1e 	bx	lr

000032c8 <cyg_mbox_waiting_to_put>:

externC cyg_bool_t cyg_mbox_waiting_to_put(cyg_handle_t mbox) __THROW
    32c8:	e590000c 	ldr	r0, [r0, #12]
{
    return ((Cyg_Mbox *)mbox)->waiting_to_put();
}
    32cc:	e2500000 	subs	r0, r0, #0	; 0x0
    32d0:	13a00001 	movne	r0, #1	; 0x1
    32d4:	e12fff1e 	bx	lr

000032d8 <cyg_flag_peek>:
}

cyg_flag_value_t cyg_flag_peek( cyg_flag_t *flag ) __THROW
{
    return ((Cyg_Flag *)flag)->peek();
}
    32d8:	e5900000 	ldr	r0, [r0]
    32dc:	e12fff1e 	bx	lr

000032e0 <cyg_flag_waiting>:

cyg_bool_t cyg_flag_waiting( cyg_flag_t *flag ) __THROW
    32e0:	e5900004 	ldr	r0, [r0, #4]
{
    return ((Cyg_Flag *)flag)->waiting();
}
    32e4:	e2500000 	subs	r0, r0, #0	; 0x0
    32e8:	13a00001 	movne	r0, #1	; 0x1
    32ec:	e12fff1e 	bx	lr

000032f0 <cyg_spinlock_init>:
    volatile cyg_uint32 lock;

public:

    // Constructor, initialize the lock to clear
    Cyg_SpinLock() { lock = 0; };
    32f0:	e3a03000 	mov	r3, #0	; 0x0

    // Create the spinlock in cleared state
    Cyg_SpinLock *t = new((void *)lock) Cyg_SpinLock();

    // If the lock is to start locked, then lock it now.
    if( locked )
    32f4:	e3510000 	cmp	r1, #0	; 0x0
    32f8:	e5803000 	str	r3, [r0]
    
    // Spin on the lock. In this case we just set it to 1 and proceed.
    void spin()
    {
        CYG_ASSERT( lock == 0, "spinlock already claimed!");
        lock = 1;
    32fc:	12833001 	addne	r3, r3, #1	; 0x1
    3300:	15803000 	strne	r3, [r0]
    3304:	e12fff1e 	bx	lr

00003308 <cyg_spinlock_destroy>:
}

externC void cyg_spinlock_destroy( cyg_spinlock_t *lock ) __THROW
{
    ((Cyg_SpinLock *)lock)->~Cyg_SpinLock();
}
    3308:	e12fff1e 	bx	lr

0000330c <cyg_spinlock_spin>:
    330c:	e3a03001 	mov	r3, #1	; 0x1
    3310:	e5803000 	str	r3, [r0]

externC void cyg_spinlock_spin( cyg_spinlock_t *lock ) __THROW
{
    ((Cyg_SpinLock *)lock)->spin();
}
    3314:	e12fff1e 	bx	lr

00003318 <cyg_spinlock_clear>:

    // Clear the lock. Again, just set the value.
    void clear()
    {
        CYG_ASSERT( lock != 0, "spinlock already cleared!");
        lock = 0;
    3318:	e3a03000 	mov	r3, #0	; 0x0
    331c:	e5803000 	str	r3, [r0]

externC void cyg_spinlock_clear( cyg_spinlock_t *lock ) __THROW
{
    ((Cyg_SpinLock *)lock)->clear();
}
    3320:	e12fff1e 	bx	lr

00003324 <cyg_spinlock_try>:
    };

    // Try to claim the lock. Return true if successful, false if not.
    cyg_bool trylock()
    {
        if( lock ) return false;
    3324:	e5903000 	ldr	r3, [r0]
    3328:	e3530000 	cmp	r3, #0	; 0x0
        else { lock = 1; return true; }
    332c:	03a03001 	moveq	r3, #1	; 0x1
    3330:	05803000 	streq	r3, [r0]
    };

    // Try to claim the lock. Return true if successful, false if not.
    cyg_bool trylock()
    {
        if( lock ) return false;
    3334:	13a00000 	movne	r0, #0	; 0x0
        else { lock = 1; return true; }
    3338:	01a00003 	moveq	r0, r3

externC cyg_bool_t cyg_spinlock_try( cyg_spinlock_t *lock ) __THROW
{
    return ((Cyg_SpinLock *)lock)->trylock();
}
    333c:	e12fff1e 	bx	lr

00003340 <cyg_spinlock_test>:
    };

    // Test the current value of the lock
    cyg_bool test() { return lock; };
    3340:	e5900000 	ldr	r0, [r0]

externC cyg_bool_t cyg_spinlock_test( cyg_spinlock_t *lock ) __THROW
{
    return ((Cyg_SpinLock *)lock)->test();
}
    3344:	e12fff1e 	bx	lr

00003348 <cyg_spinlock_spin_intsave>:

externC void cyg_spinlock_spin_intsave( cyg_spinlock_t *lock,
                                cyg_addrword_t *istate ) __THROW
    3348:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    // Claim the spinlock, but also mask this CPU's interrupts while
    // we have it.
    void spin_intsave(CYG_INTERRUPT_STATE *state)
    {
        CYG_INTERRUPT_STATE s;
        HAL_DISABLE_INTERRUPTS(s);
    334c:	e10f3000 	mrs	r3, CPSR
    3350:	e10f4000 	mrs	r4, CPSR
    3354:	e38440c0 	orr	r4, r4, #192	; 0xc0
    3358:	e129f004 	msr	CPSR_fc, r4
    
    // Spin on the lock. In this case we just set it to 1 and proceed.
    void spin()
    {
        CYG_ASSERT( lock == 0, "spinlock already claimed!");
        lock = 1;
    335c:	e3a02001 	mov	r2, #1	; 0x1
    // we have it.
    void spin_intsave(CYG_INTERRUPT_STATE *state)
    {
        CYG_INTERRUPT_STATE s;
        HAL_DISABLE_INTERRUPTS(s);
        *state = s;
    3360:	e5813000 	str	r3, [r1]
    
    // Spin on the lock. In this case we just set it to 1 and proceed.
    void spin()
    {
        CYG_ASSERT( lock == 0, "spinlock already claimed!");
        lock = 1;
    3364:	e5802000 	str	r2, [r0]
{
    ((Cyg_SpinLock *)lock)->spin_intsave((CYG_INTERRUPT_STATE *)istate);
}
    3368:	e8bd0010 	pop	{r4}
    336c:	e12fff1e 	bx	lr

00003370 <cyg_spinlock_clear_intsave>:

    // Clear the lock. Again, just set the value.
    void clear()
    {
        CYG_ASSERT( lock != 0, "spinlock already cleared!");
        lock = 0;
    3370:	e3a02000 	mov	r2, #0	; 0x0
    
externC void cyg_spinlock_clear_intsave( cyg_spinlock_t *lock,
                                 cyg_addrword_t istate ) __THROW
    3374:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    3378:	e5802000 	str	r2, [r0]
    // Clear the lock, and restore the interrupt state saved in
    // spin_intsave().
    void clear_intsave(CYG_INTERRUPT_STATE state)
    {
        clear();
        HAL_RESTORE_INTERRUPTS(state);
    337c:	e10f3000 	mrs	r3, CPSR
    3380:	e20140c0 	and	r4, r1, #192	; 0xc0
    3384:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    3388:	e1833004 	orr	r3, r3, r4
    338c:	e129f003 	msr	CPSR_fc, r3
{
    ((Cyg_SpinLock *)lock)->clear_intsave((CYG_INTERRUPT_STATE)istate);
}
    3390:	e8bd0010 	pop	{r4}
    3394:	e12fff1e 	bx	lr

00003398 <cyg_cond_timed_wait>:
    
#ifdef CYGMFN_KERNEL_SYNCH_CONDVAR_TIMED_WAIT

    // Wait until a signal or timeout expiry
    inline cyg_bool wait( cyg_tick_count timeout )
    { return wait_inner( mutex, timeout ); }
    3398:	e5901000 	ldr	r1, [r0]
    339c:	ea001022 	b	742c <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy>

000033a0 <cyg_cond_broadcast>:
    ((Cyg_Condition_Variable *)cond)->signal();
}

externC void cyg_cond_broadcast( cyg_cond_t *cond ) __THROW
{
    ((Cyg_Condition_Variable *)cond)->broadcast();
    33a0:	ea000f95 	b	71fc <_ZN22Cyg_Condition_Variable9broadcastEv>

000033a4 <cyg_cond_signal>:
    return ((Cyg_Condition_Variable *)cond)->wait();
}

externC void cyg_cond_signal( cyg_cond_t *cond ) __THROW
{
    ((Cyg_Condition_Variable *)cond)->signal();
    33a4:	ea000fb1 	b	7270 <_ZN22Cyg_Condition_Variable6signalEv>

000033a8 <cyg_cond_wait>:
    void     signal();                  // Set cond true, wake one thread

    void     broadcast();               // Set cond true, wake all threads

    // Wait for condition to be true
    inline cyg_bool wait() { return wait_inner( mutex ); }
    33a8:	e5901000 	ldr	r1, [r0]
    33ac:	ea001060 	b	7534 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex>

000033b0 <cyg_cond_destroy>:
    t=t;
}

externC void cyg_cond_destroy( cyg_cond_t *cond ) __THROW
{
    ((Cyg_Condition_Variable *)cond)->~Cyg_Condition_Variable();
    33b0:	ea000ed7 	b	6f14 <_ZN22Cyg_Condition_VariableD1Ev>

000033b4 <cyg_cond_init>:
) __THROW
{
    CYG_ASSERT_SIZES( cyg_cond_t, Cyg_Condition_Variable );
    
    Cyg_Condition_Variable *t = new((void *)cond) Cyg_Condition_Variable(
        *(Cyg_Mutex *)mutex);
    33b4:	ea000ebb 	b	6ea8 <_ZN22Cyg_Condition_VariableC1ER9Cyg_Mutex>

000033b8 <cyg_mutex_set_protocol>:
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DYNAMIC
externC void cyg_mutex_set_protocol( 
    cyg_mutex_t *mutex,
    enum cyg_mutex_protocol protocol ) __THROW
{
    ((Cyg_Mutex *)mutex)->set_protocol((Cyg_Mutex::cyg_protcol)protocol);
    33b8:	ea000f6f 	b	717c <_ZN9Cyg_Mutex12set_protocolENS_11cyg_protcolE>

000033bc <cyg_mutex_set_ceiling>:
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
externC void cyg_mutex_set_ceiling( 
    cyg_mutex_t *mutex, 
    cyg_priority_t priority ) __THROW
{
    ((Cyg_Mutex *)mutex)->set_ceiling(priority);
    33bc:	ea000f7e 	b	71bc <_ZN9Cyg_Mutex11set_ceilingEi>

000033c0 <cyg_mutex_release>:
    ((Cyg_Mutex *)mutex)->unlock();
}

externC void cyg_mutex_release( cyg_mutex_t *mutex ) __THROW
{
    ((Cyg_Mutex *)mutex)->release();
    33c0:	ea000fc2 	b	72d0 <_ZN9Cyg_Mutex7releaseEv>

000033c4 <cyg_mutex_unlock>:
    return ((Cyg_Mutex *)mutex)->trylock();
}

externC void cyg_mutex_unlock( cyg_mutex_t *mutex ) __THROW
{
    ((Cyg_Mutex *)mutex)->unlock();
    33c4:	ea000fda 	b	7334 <_ZN9Cyg_Mutex6unlockEv>

000033c8 <cyg_mutex_trylock>:
    return ((Cyg_Mutex *)mutex)->lock();
}

externC cyg_bool_t cyg_mutex_trylock( cyg_mutex_t *mutex ) __THROW
{
    return ((Cyg_Mutex *)mutex)->trylock();
    33c8:	ea000f42 	b	70d8 <_ZN9Cyg_Mutex7trylockEv>

000033cc <cyg_mutex_lock>:
    ((Cyg_Mutex *)mutex)->~Cyg_Mutex();
}

externC cyg_bool_t cyg_mutex_lock( cyg_mutex_t *mutex ) __THROW
{
    return ((Cyg_Mutex *)mutex)->lock();
    33cc:	ea000ee0 	b	6f54 <_ZN9Cyg_Mutex4lockEv>

000033d0 <cyg_mutex_destroy>:
    m=m;
}

externC void cyg_mutex_destroy( cyg_mutex_t *mutex ) __THROW
{
    ((Cyg_Mutex *)mutex)->~Cyg_Mutex();
    33d0:	ea000e9f 	b	6e54 <_ZN9Cyg_MutexD1Ev>

000033d4 <cyg_mutex_init>:
    cyg_mutex_t        *mutex          /* Mutex to init                      */
) __THROW
{
    CYG_ASSERT_SIZES( cyg_mutex_t, Cyg_Mutex );
    
    Cyg_Mutex *m = new((void *)mutex) Cyg_Mutex;
    33d4:	ea000e77 	b	6db8 <_ZN9Cyg_MutexC1Ev>

000033d8 <cyg_flag_poll>:

cyg_flag_value_t cyg_flag_poll( cyg_flag_t         *flag,
                                cyg_flag_value_t    pattern, 
                                cyg_flag_mode_t     mode ) __THROW
{
    if ( 0 == pattern || 0 != (mode & ~3) )
    33d8:	e3510000 	cmp	r1, #0	; 0x0
    33dc:	0a000001 	beq	33e8 <cyg_flag_poll+0x10>
    33e0:	e31200fc 	tst	r2, #252	; 0xfc
    33e4:	0a000001 	beq	33f0 <cyg_flag_poll+0x18>
        return 0;
    return ((Cyg_Flag *)flag)->poll( pattern, mode );

}
    33e8:	e3a00000 	mov	r0, #0	; 0x0
    33ec:	e12fff1e 	bx	lr
                                cyg_flag_value_t    pattern, 
                                cyg_flag_mode_t     mode ) __THROW
{
    if ( 0 == pattern || 0 != (mode & ~3) )
        return 0;
    return ((Cyg_Flag *)flag)->poll( pattern, mode );
    33f0:	ea000b04 	b	6008 <_ZN8Cyg_Flag4pollEjh>

000033f4 <cyg_flag_timed_wait>:

#ifdef CYGFUN_KERNEL_THREADS_TIMER
cyg_flag_value_t cyg_flag_timed_wait( cyg_flag_t        *flag,
                                      cyg_flag_value_t   pattern, 
                                      cyg_flag_mode_t    mode,
                                      cyg_tick_count_t   abstime ) __THROW
    33f4:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
{
    if ( 0 == pattern || 0 != (mode & ~3) )
    33f8:	e3510000 	cmp	r1, #0	; 0x0

#ifdef CYGFUN_KERNEL_THREADS_TIMER
cyg_flag_value_t cyg_flag_timed_wait( cyg_flag_t        *flag,
                                      cyg_flag_value_t   pattern, 
                                      cyg_flag_mode_t    mode,
                                      cyg_tick_count_t   abstime ) __THROW
    33fc:	e99d0018 	ldmib	sp, {r3, r4}
{
    if ( 0 == pattern || 0 != (mode & ~3) )
    3400:	0a000001 	beq	340c <cyg_flag_timed_wait+0x18>
    3404:	e31200fc 	tst	r2, #252	; 0xfc
    3408:	0a000002 	beq	3418 <cyg_flag_timed_wait+0x24>
        return 0;
    return ((Cyg_Flag *)flag)->wait( pattern, mode, abstime );

}
    340c:	e3a00000 	mov	r0, #0	; 0x0
    3410:	e8bd0010 	pop	{r4}
    3414:	e12fff1e 	bx	lr
    3418:	e8bd0010 	pop	{r4}
                                      cyg_flag_mode_t    mode,
                                      cyg_tick_count_t   abstime ) __THROW
{
    if ( 0 == pattern || 0 != (mode & ~3) )
        return 0;
    return ((Cyg_Flag *)flag)->wait( pattern, mode, abstime );
    341c:	ea000bec 	b	63d4 <_ZN8Cyg_Flag4waitEjhy>

00003420 <cyg_flag_wait>:

cyg_flag_value_t cyg_flag_wait( cyg_flag_t        *flag,
                                cyg_flag_value_t   pattern, 
                                cyg_flag_mode_t    mode ) __THROW
{
    if ( 0 == pattern || 0 != (mode & ~3) )
    3420:	e3510000 	cmp	r1, #0	; 0x0
    3424:	0a000001 	beq	3430 <cyg_flag_wait+0x10>
    3428:	e31200fc 	tst	r2, #252	; 0xfc
    342c:	0a000001 	beq	3438 <cyg_flag_wait+0x18>
        return 0;
    return ((Cyg_Flag *)flag)->wait( pattern, mode );

}
    3430:	e3a00000 	mov	r0, #0	; 0x0
    3434:	e12fff1e 	bx	lr
                                cyg_flag_value_t   pattern, 
                                cyg_flag_mode_t    mode ) __THROW
{
    if ( 0 == pattern || 0 != (mode & ~3) )
        return 0;
    return ((Cyg_Flag *)flag)->wait( pattern, mode );
    3438:	ea000ba1 	b	62c4 <_ZN8Cyg_Flag4waitEjh>

0000343c <cyg_flag_maskbits>:
    ((Cyg_Flag *)flag)->setbits( value ); 
}

void cyg_flag_maskbits( cyg_flag_t *flag, cyg_flag_value_t value) __THROW
{
    ((Cyg_Flag *)flag)->maskbits( value ); 
    343c:	ea000b18 	b	60a4 <_ZN8Cyg_Flag8maskbitsEj>

00003440 <cyg_flag_setbits>:
    ((Cyg_Flag *)flag)->~Cyg_Flag();
}

void cyg_flag_setbits( cyg_flag_t *flag, cyg_flag_value_t value) __THROW
{
    ((Cyg_Flag *)flag)->setbits( value ); 
    3440:	ea000b29 	b	60ec <_ZN8Cyg_Flag7setbitsEj>

00003444 <cyg_flag_destroy>:
    t=t;
}

void cyg_flag_destroy( cyg_flag_t *flag ) __THROW
{
    ((Cyg_Flag *)flag)->~Cyg_Flag();
    3444:	ea000b71 	b	6210 <_ZN8Cyg_FlagD1Ev>

00003448 <cyg_flag_init>:
        ( Cyg_Flag::AND == CYG_FLAG_WAITMODE_AND ) &&
        ( Cyg_Flag::OR  == CYG_FLAG_WAITMODE_OR  ) &&
        ( Cyg_Flag::CLR == CYG_FLAG_WAITMODE_CLR ),
        "CYG_FLAG_WAITMODE_xxx definition != C++ Cyg_Flag::xxx" );
    
    Cyg_Flag *t = new((void *)flag) Cyg_Flag();
    3448:	e3a01000 	mov	r1, #0	; 0x0
    344c:	ea000abd 	b	5f48 <_ZN8Cyg_FlagC1Ej>

00003450 <cyg_semaphore_peek>:
externC void cyg_semaphore_post( cyg_sem_t *sem ) __THROW
{
    ((Cyg_Counting_Semaphore *)sem)->post();
}

externC void cyg_semaphore_peek( cyg_sem_t *sem, cyg_count32 *val ) __THROW
    3450:	e92d4010 	push	{r4, lr}
    3454:	e1a04001 	mov	r4, r1
{
    CYG_CHECK_DATA_PTR( val, "Bad val parameter" );

    *val = ((Cyg_Counting_Semaphore *)sem)->peek();
    3458:	eb0009f4 	bl	5c30 <_ZNK22Cyg_Counting_Semaphore4peekEv>
    345c:	e5840000 	str	r0, [r4]
}
    3460:	e8bd8010 	pop	{r4, pc}

00003464 <cyg_semaphore_post>:
    return ((Cyg_Counting_Semaphore *)sem)->trywait();
}

externC void cyg_semaphore_post( cyg_sem_t *sem ) __THROW
{
    ((Cyg_Counting_Semaphore *)sem)->post();
    3464:	ea000a83 	b	5e78 <_ZN22Cyg_Counting_Semaphore4postEv>

00003468 <cyg_semaphore_trywait>:
#endif


externC int cyg_semaphore_trywait( cyg_sem_t *sem ) __THROW
{
    return ((Cyg_Counting_Semaphore *)sem)->trywait();
    3468:	ea000a9d 	b	5ee4 <_ZN22Cyg_Counting_Semaphore7trywaitEv>

0000346c <cyg_semaphore_timed_wait>:
externC cyg_bool_t cyg_semaphore_timed_wait(
    cyg_sem_t          *sem,
    cyg_tick_count_t   abstime
    ) __THROW
{
    return ((Cyg_Counting_Semaphore *)sem)->wait(abstime);
    346c:	ea000a2a 	b	5d1c <_ZN22Cyg_Counting_Semaphore4waitEy>

00003470 <cyg_semaphore_wait>:
    ((Cyg_Counting_Semaphore *)sem)->~Cyg_Counting_Semaphore();
}

externC cyg_bool_t cyg_semaphore_wait( cyg_sem_t *sem ) __THROW
{
    return ((Cyg_Counting_Semaphore *)sem)->wait();
    3470:	ea0009f0 	b	5c38 <_ZN22Cyg_Counting_Semaphore4waitEv>

00003474 <cyg_semaphore_destroy>:
    t=t;
}

externC void cyg_semaphore_destroy( cyg_sem_t *sem ) __THROW
{
    ((Cyg_Counting_Semaphore *)sem)->~Cyg_Counting_Semaphore();
    3474:	ea0009dd 	b	5bf0 <_ZN22Cyg_Counting_SemaphoreD1Ev>

00003478 <cyg_semaphore_init>:
    cyg_count32         val              /* Initial semaphore value          */
) __THROW
{
    CYG_ASSERT_SIZES( cyg_sem_t, Cyg_Counting_Semaphore );
    
    Cyg_Counting_Semaphore *t = new((void *)sem) Cyg_Counting_Semaphore(val);
    3478:	ea0009c9 	b	5ba4 <_ZN22Cyg_Counting_SemaphoreC1Ei>

0000347c <cyg_mbox_tryput>:
#endif
#endif

externC cyg_bool_t cyg_mbox_tryput(cyg_handle_t mbox, void *item) __THROW
{
    return ((Cyg_Mbox *)mbox)->tryput(item);
    347c:	ea000cf4 	b	6854 <_ZN8Cyg_Mbox6tryputEPv>

00003480 <cyg_mbox_timed_put>:
    cyg_handle_t mbox,
    void *item,
    cyg_tick_count_t abstime
    ) __THROW
{
    return ((Cyg_Mbox *)mbox)->put(item, abstime);
    3480:	ea000d6a 	b	6a30 <_ZN8Cyg_Mbox3putEPvy>

00003484 <cyg_mbox_put>:
}

#ifdef CYGMFN_KERNEL_SYNCH_MBOXT_PUT_CAN_WAIT
externC cyg_bool_t cyg_mbox_put(cyg_handle_t mbox, void *item) __THROW
{
    return ((Cyg_Mbox *)mbox)->put(item);
    3484:	ea000d1f 	b	6908 <_ZN8Cyg_Mbox3putEPv>

00003488 <cyg_mbox_peek_item>:
    return ((Cyg_Mbox *)mbox)->tryget();
}

externC void *cyg_mbox_peek_item(cyg_handle_t mbox) __THROW
{
    return ((Cyg_Mbox *)mbox)->peek_item();
    3488:	ea000c73 	b	665c <_ZN8Cyg_Mbox9peek_itemEv>

0000348c <cyg_mbox_tryget>:
}
#endif

externC void *cyg_mbox_tryget(cyg_handle_t mbox) __THROW
{
    return ((Cyg_Mbox *)mbox)->tryget();
    348c:	ea000dc6 	b	6bac <_ZN8Cyg_Mbox6trygetEv>

00003490 <cyg_mbox_timed_get>:
void *cyg_mbox_timed_get(
    cyg_handle_t mbox,
    cyg_tick_count_t abstime
    ) __THROW
{
    return ((Cyg_Mbox *)mbox)->get(abstime);
    3490:	ea000c8d 	b	66cc <_ZN8Cyg_Mbox3getEy>

00003494 <cyg_mbox_get>:
    ((Cyg_Mbox *)mbox)->~Cyg_Mbox();
}

externC void *cyg_mbox_get(cyg_handle_t mbox) __THROW
{
    return ((Cyg_Mbox *)mbox)->get();
    3494:	ea000df3 	b	6c68 <_ZN8Cyg_Mbox3getEv>

00003498 <cyg_mbox_delete>:
    *handle = (cyg_handle_t)mbox;
}

externC void cyg_mbox_delete(cyg_handle_t mbox) __THROW
{
    ((Cyg_Mbox *)mbox)->~Cyg_Mbox();
    3498:	ea000c50 	b	65e0 <_ZN8Cyg_MboxD1Ev>

0000349c <cyg_mbox_create>:
/* Mail boxes                                                                */

externC void cyg_mbox_create(
    cyg_handle_t        *handle,
    cyg_mbox            *mbox
) __THROW
    349c:	e92d4030 	push	{r4, r5, lr}
    34a0:	e1a04001 	mov	r4, r1
    34a4:	e1a05000 	mov	r5, r0
    34a8:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    CYG_ASSERT_SIZES( cyg_mbox, Cyg_Mbox );
    
    Cyg_Mbox *t = new((void *)mbox) Cyg_Mbox();
    34ac:	e1a00001 	mov	r0, r1
    34b0:	eb000c25 	bl	654c <_ZN8Cyg_MboxC1Ev>
    t=t;

    CYG_CHECK_DATA_PTR( handle, "Bad handle pointer" );
    *handle = (cyg_handle_t)mbox;
    34b4:	e5854000 	str	r4, [r5]
}
    34b8:	e28dd004 	add	sp, sp, #4	; 0x4
    34bc:	e8bd8030 	pop	{r4, r5, pc}

000034c0 <cyg_alarm_disable>:
    ((Cyg_Alarm *)alarm)->enable();
}

externC void cyg_alarm_disable( cyg_handle_t alarm ) __THROW
{
    ((Cyg_Alarm *)alarm)->disable();
    34c0:	ea002f21 	b	f14c <_ZN9Cyg_Alarm7disableEv>

000034c4 <cyg_alarm_enable>:
        (cyg_tick_count*)interval);
}

externC void cyg_alarm_enable( cyg_handle_t alarm ) __THROW
{
    ((Cyg_Alarm *)alarm)->enable();
    34c4:	ea002f4f 	b	f208 <_ZN9Cyg_Alarm6enableEv>

000034c8 <cyg_alarm_get_times>:
    cyg_tick_count_t    *interval       /* Current interval                  */
) __THROW
{
    ((Cyg_Alarm *)alarm)->get_times(
        (cyg_tick_count*)trigger,
        (cyg_tick_count*)interval);
    34c8:	ea002f09 	b	f0f4 <_ZN9Cyg_Alarm9get_timesEPyS0_>

000034cc <cyg_alarm_initialize>:
    cyg_tick_count_t    interval        /* Relative retrigger interval       */
) __THROW
{
    ((Cyg_Alarm *)alarm)->initialize(
        (cyg_tick_count)trigger,
        (cyg_tick_count)interval);
    34cc:	ea002e87 	b	eef0 <_ZN9Cyg_Alarm10initializeEyy>

000034d0 <cyg_alarm_delete>:
}

/* Disable alarm, detach from counter and invalidate handles                 */
externC void cyg_alarm_delete( cyg_handle_t alarm) __THROW
{
    ((Cyg_Alarm *)alarm)->~Cyg_Alarm();
    34d0:	ea002f30 	b	f198 <_ZN9Cyg_AlarmD1Ev>

000034d4 <cyg_alarm_create>:
    cyg_handle_t        counter,        /* Attached to this counter          */
    cyg_alarm_t         *alarmfn,       /* Call-back function                */
    cyg_addrword_t      data,           /* Call-back data                    */
    cyg_handle_t        *handle,        /* Returned alarm object             */
    cyg_alarm           *alarm          /* put alarm here                    */
) __THROW
    34d4:	e92d4030 	push	{r4, r5, lr}
    34d8:	e24dd004 	sub	sp, sp, #4	; 0x4
    34dc:	e59d5010 	ldr	r5, [sp, #16]
    34e0:	e1a0c001 	mov	ip, r1
    34e4:	e1a0e002 	mov	lr, r2
    34e8:	e1a04003 	mov	r4, r3

    Cyg_Alarm *t = new((void *)alarm) Cyg_Alarm (
        (Cyg_Counter *)counter,
        (cyg_alarm_fn *)alarmfn,
        (CYG_ADDRWORD)data
    );
    34ec:	e1a01000 	mov	r1, r0
    34f0:	e1a0200c 	mov	r2, ip
    34f4:	e1a0300e 	mov	r3, lr
    34f8:	e1a00005 	mov	r0, r5
    34fc:	eb002d7f 	bl	eb00 <_ZN9Cyg_AlarmC1EP11Cyg_CounterPFvPS_jEj>
    t=t;

    CYG_CHECK_DATA_PTR( handle, "Bad handle pointer" );
    *handle = (cyg_handle_t)alarm;
    3500:	e5845000 	str	r5, [r4]
}
    3504:	e28dd004 	add	sp, sp, #4	; 0x4
    3508:	e8bd8030 	pop	{r4, r5, pc}

0000350c <cyg_clock_delete>:
    *handle = (cyg_handle_t)clock;
}

externC void cyg_clock_delete(cyg_handle_t clock) __THROW
{
    ((Cyg_Clock *)clock)->~Cyg_Clock();
    350c:	ea002ae4 	b	e0a4 <_ZN9Cyg_ClockD1Ev>

00003510 <cyg_clock_create>:
/* Create a clock object                */
externC void cyg_clock_create(
    cyg_resolution_t    resolution,     /* Initial resolution                */
    cyg_handle_t        *handle,        /* Returned clock handle             */
    cyg_clock           *clock          /* put clock here                    */
) __THROW
    3510:	e92d4030 	push	{r4, r5, lr}
    3514:	e24dd014 	sub	sp, sp, #20	; 0x14
{
    CYG_ASSERT_SIZES( cyg_clock, Cyg_Clock );

    Cyg_Clock::cyg_resolution res;

    res.dividend = resolution.dividend;
    3518:	e58d0008 	str	r0, [sp, #8]
    res.divisor  = resolution.divisor;
    351c:	e58d100c 	str	r1, [sp, #12]
/* Create a clock object                */
externC void cyg_clock_create(
    cyg_resolution_t    resolution,     /* Initial resolution                */
    cyg_handle_t        *handle,        /* Returned clock handle             */
    cyg_clock           *clock          /* put clock here                    */
) __THROW
    3520:	e1a04003 	mov	r4, r3
    Cyg_Clock::cyg_resolution res;

    res.dividend = resolution.dividend;
    res.divisor  = resolution.divisor;

    Cyg_Clock *t = new((void *)clock) Cyg_Clock ( res );
    3524:	e28d3008 	add	r3, sp, #8	; 0x8
/* Create a clock object                */
externC void cyg_clock_create(
    cyg_resolution_t    resolution,     /* Initial resolution                */
    cyg_handle_t        *handle,        /* Returned clock handle             */
    cyg_clock           *clock          /* put clock here                    */
) __THROW
    3528:	e88d0003 	stm	sp, {r0, r1}
    352c:	e1a05002 	mov	r5, r2
    Cyg_Clock::cyg_resolution res;

    res.dividend = resolution.dividend;
    res.divisor  = resolution.divisor;

    Cyg_Clock *t = new((void *)clock) Cyg_Clock ( res );
    3530:	e1a00004 	mov	r0, r4
    3534:	e8930006 	ldm	r3, {r1, r2}
    3538:	eb002ab7 	bl	e01c <_ZN9Cyg_ClockC1ENS_14cyg_resolutionE>
    t=t;

    CYG_CHECK_DATA_PTR( handle, "Bad handle pointer" );
    *handle = (cyg_handle_t)clock;
    353c:	e5854000 	str	r4, [r5]
}
    3540:	e28dd014 	add	sp, sp, #20	; 0x14
    3544:	e8bd8030 	pop	{r4, r5, pc}

00003548 <cyg_counter_multi_tick>:
}

/* Advance counter by multiple ticks                                         */
externC void cyg_counter_multi_tick(cyg_handle_t counter, cyg_tick_count_t ticks) __THROW
{
    ((Cyg_Counter *)counter)->tick(ticks); 
    3548:	e1a01002 	mov	r1, r2
    354c:	ea002e86 	b	ef6c <_ZN11Cyg_Counter4tickEj>

00003550 <cyg_counter_tick>:
}

/* Advance counter by one tick                                               */
externC void cyg_counter_tick(cyg_handle_t counter) __THROW
{
    ((Cyg_Counter *)counter)->tick(); 
    3550:	e3a01001 	mov	r1, #1	; 0x1
    3554:	ea002e84 	b	ef6c <_ZN11Cyg_Counter4tickEj>

00003558 <cyg_counter_delete>:
    *handle = (cyg_handle_t)counter;
}

externC void cyg_counter_delete(cyg_handle_t counter) __THROW
{
    ((Cyg_Counter *)counter)->~Cyg_Counter();
    3558:	ea002a6f 	b	df1c <_ZN11Cyg_CounterD1Ev>

0000355c <cyg_counter_create>:
/* Counters, Clocks and Alarms                                               */

externC void cyg_counter_create(
    cyg_handle_t        *handle,        /* returned counter handle           */
    cyg_counter         *counter        /* put counter here                  */
) __THROW
    355c:	e92d4030 	push	{r4, r5, lr}
    3560:	e1a04001 	mov	r4, r1
    3564:	e1a05000 	mov	r5, r0
    3568:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    CYG_ASSERT_SIZES( cyg_counter, Cyg_Counter );

    Cyg_Counter *t = new((void *)counter) Cyg_Counter ();
    356c:	e3a01001 	mov	r1, #1	; 0x1
    3570:	e1a00004 	mov	r0, r4
    3574:	eb002a4e 	bl	deb4 <_ZN11Cyg_CounterC1Ej>
    t=t;

    CYG_CHECK_DATA_PTR( handle, "Bad handle pointer" );
    *handle = (cyg_handle_t)counter;
    3578:	e5854000 	str	r4, [r5]
}
    357c:	e28dd004 	add	sp, sp, #4	; 0x4
    3580:	e8bd8030 	pop	{r4, r5, pc}

00003584 <cyg_interrupt_configure>:
    cyg_vector_t        vector,         /* vector to configure               */
    cyg_bool_t          level,          /* level or edge triggered           */
    cyg_bool_t          up              /* rising/faling edge, high/low level*/
) __THROW
{
    Cyg_Interrupt::configure_interrupt( (cyg_vector)vector, level, up );
    3584:	ea0006b2 	b	5054 <_ZN13Cyg_Interrupt19configure_interruptEjii>

00003588 <cyg_interrupt_acknowledge>:
    Cyg_Interrupt::unmask_interrupt_intunsafe( (cyg_vector)vector);
}

externC void cyg_interrupt_acknowledge(cyg_vector_t vector) __THROW
{
    Cyg_Interrupt::acknowledge_interrupt( (cyg_vector)vector);
    3588:	ea0006b2 	b	5058 <_ZN13Cyg_Interrupt21acknowledge_interruptEj>

0000358c <cyg_interrupt_unmask_intunsafe>:
    Cyg_Interrupt::unmask_interrupt( (cyg_vector)vector);
}

externC void cyg_interrupt_unmask_intunsafe(cyg_vector_t vector) __THROW
{
    Cyg_Interrupt::unmask_interrupt_intunsafe( (cyg_vector)vector);
    358c:	ea0006b2 	b	505c <_ZN13Cyg_Interrupt26unmask_interrupt_intunsafeEj>

00003590 <cyg_interrupt_unmask>:
    Cyg_Interrupt::mask_interrupt_intunsafe( (cyg_vector)vector);
}

externC void cyg_interrupt_unmask(cyg_vector_t vector) __THROW
{
    Cyg_Interrupt::unmask_interrupt( (cyg_vector)vector);
    3590:	ea0006b2 	b	5060 <_ZN13Cyg_Interrupt16unmask_interruptEj>

00003594 <cyg_interrupt_mask_intunsafe>:
    Cyg_Interrupt::mask_interrupt( (cyg_vector)vector);
}

externC void cyg_interrupt_mask_intunsafe(cyg_vector_t vector) __THROW
{
    Cyg_Interrupt::mask_interrupt_intunsafe( (cyg_vector)vector);
    3594:	ea0006bf 	b	5098 <_ZN13Cyg_Interrupt24mask_interrupt_intunsafeEj>

00003598 <cyg_interrupt_mask>:
}

/* Interrupt controller access                                               */
externC void cyg_interrupt_mask(cyg_vector_t vector) __THROW
{
    Cyg_Interrupt::mask_interrupt( (cyg_vector)vector);
    3598:	ea0006bf 	b	509c <_ZN13Cyg_Interrupt14mask_interruptEj>

0000359c <cyg_interrupt_enable>:
    Cyg_Interrupt::disable_interrupts();
}

externC void cyg_interrupt_enable() __THROW
{
    Cyg_Interrupt::enable_interrupts();
    359c:	ea000690 	b	4fe4 <_ZN13Cyg_Interrupt17enable_interruptsEv>

000035a0 <cyg_interrupt_disable>:
}

/* CPU level interrupt mask                                                  */
externC void cyg_interrupt_disable() __THROW
{
    Cyg_Interrupt::disable_interrupts();
    35a0:	ea000679 	b	4f8c <_ZN13Cyg_Interrupt18disable_interruptsEv>

000035a4 <cyg_interrupt_set_vsr>:
externC void cyg_interrupt_set_vsr(
    cyg_vector_t        vector,         /* vector to set                     */
    cyg_VSR_t           *vsr            /* vsr to set                        */
) __THROW
{
    Cyg_Interrupt::set_vsr( (cyg_vector)vector, (cyg_VSR *)vsr);
    35a4:	e3a02000 	mov	r2, #0	; 0x0
    35a8:	ea000663 	b	4f3c <_ZN13Cyg_Interrupt7set_vsrEjPFvvEPS1_>

000035ac <cyg_interrupt_get_vsr>:
externC void cyg_interrupt_get_vsr(
    cyg_vector_t        vector,         /* vector to get                     */
    cyg_VSR_t           **vsr           /* vsr got                           */
) __THROW
{
    Cyg_Interrupt::get_vsr( (cyg_vector)vector, (cyg_VSR **)vsr);
    35ac:	ea00065d 	b	4f28 <_ZN13Cyg_Interrupt7get_vsrEjPPFvvE>

000035b0 <cyg_interrupt_detach>:
    ((Cyg_Interrupt *)interrupt)->attach();
}

void cyg_interrupt_detach( cyg_handle_t interrupt ) __THROW
{
    ((Cyg_Interrupt *)interrupt)->detach();
    35b0:	ea000648 	b	4ed8 <_ZN13Cyg_Interrupt6detachEv>

000035b4 <cyg_interrupt_attach>:
    ((Cyg_Interrupt *)interrupt)->~Cyg_Interrupt();
}

void cyg_interrupt_attach( cyg_handle_t interrupt ) __THROW
{
    ((Cyg_Interrupt *)interrupt)->attach();
    35b4:	ea0006c6 	b	50d4 <_ZN13Cyg_Interrupt6attachEv>

000035b8 <cyg_interrupt_delete>:
    *handle = (cyg_handle_t)intr;
}

externC void cyg_interrupt_delete( cyg_handle_t interrupt) __THROW
{
    ((Cyg_Interrupt *)interrupt)->~Cyg_Interrupt();
    35b8:	ea0005da 	b	4d28 <_ZN13Cyg_InterruptD1Ev>

000035bc <cyg_interrupt_create>:
    cyg_addrword_t      data,           /* Data pointer                      */
    cyg_ISR_t           *isr,           /* Interrupt Service Routine         */
    cyg_DSR_t           *dsr,           /* Deferred Service Routine          */
    cyg_handle_t        *handle,        /* returned handle                   */
    cyg_interrupt       *intr           /* put interrupt here                */
) __THROW
    35bc:	e92d4010 	push	{r4, lr}
    35c0:	e24dd008 	sub	sp, sp, #8	; 0x8
    35c4:	e59d4018 	ldr	r4, [sp, #24]
    35c8:	e1a0c001 	mov	ip, r1
    35cc:	e1a0e002 	mov	lr, r2
    Cyg_Interrupt *t = new((void *)intr) Cyg_Interrupt (
        (cyg_vector)vector,
        (cyg_priority)priority,
        (CYG_ADDRWORD)data,
        (cyg_ISR *)isr,
        (cyg_DSR *)dsr );
    35d0:	e1a0200c 	mov	r2, ip
    35d4:	e59dc010 	ldr	ip, [sp, #16]
    35d8:	e58d3000 	str	r3, [sp]
    35dc:	e1a01000 	mov	r1, r0
    35e0:	e1a0300e 	mov	r3, lr
    35e4:	e1a00004 	mov	r0, r4
    35e8:	e58dc004 	str	ip, [sp, #4]
    35ec:	eb0005ad 	bl	4ca8 <_ZN13Cyg_InterruptC1EjijPFjjjEPFvjjjE>
    t=t;

    CYG_CHECK_DATA_PTR( handle, "Bad handle pointer" );
    *handle = (cyg_handle_t)intr;
    35f0:	e59d3014 	ldr	r3, [sp, #20]
    35f4:	e5834000 	str	r4, [r3]
}
    35f8:	e28dd008 	add	sp, sp, #8	; 0x8
    35fc:	e8bd8010 	pop	{r4, pc}

00003600 <cyg_exception_call_handler>:
    cyg_addrword_t              error_code
) __THROW
{
    Cyg_Thread *t = (Cyg_Thread *)thread;

    t->deliver_exception( exception_number, error_code );
    3600:	ea000111 	b	3a4c <_ZN10Cyg_Thread17deliver_exceptionEij>

00003604 <cyg_exception_clear_handler>:
    3604:	e59f300c 	ldr	r3, [pc, #12]	; 3618 <cyg_exception_clear_handler+0x14>
}

/* Clear exception handler to default                                        */
externC void cyg_exception_clear_handler(
    cyg_code_t                  exception_number
) __THROW
    3608:	e1a01000 	mov	r1, r0
    360c:	e5933000 	ldr	r3, [r3]
    cyg_code                exception_number        // exception number
    )
{
    self()->exception_control.deregister_exception(
        exception_number
        );
    3610:	e59f0004 	ldr	r0, [pc, #4]	; 361c <cyg_exception_clear_handler+0x18>
    3614:	ea000579 	b	4c00 <_ZN21Cyg_Exception_Control20deregister_exceptionEi>
    3618:	40002538 	.word	0x40002538
    361c:	40002518 	.word	0x40002518

00003620 <cyg_exception_set_handler>:
    cyg_code_t                  exception_number,
    cyg_exception_handler_t     *new_handler,
    cyg_addrword_t              new_data,
    cyg_exception_handler_t     **old_handler,
    cyg_addrword_t              *old_data
) __THROW
    3620:	e92d4010 	push	{r4, lr}
    3624:	e1a0c001 	mov	ip, r1
    3628:	e24dd008 	sub	sp, sp, #8	; 0x8
    362c:	e1a0e002 	mov	lr, r2
        exception_number,
        handler,
        data,
        old_handler,
        old_data
        );
    3630:	e58d3000 	str	r3, [sp]
    3634:	e1a0200c 	mov	r2, ip
    3638:	e59d4010 	ldr	r4, [sp, #16]
    363c:	e59fc01c 	ldr	ip, [pc, #28]	; 3660 <cyg_exception_set_handler+0x40>
    3640:	e1a01000 	mov	r1, r0
    3644:	e1a0300e 	mov	r3, lr
    3648:	e59f0014 	ldr	r0, [pc, #20]	; 3664 <cyg_exception_set_handler+0x44>
    364c:	e59cc000 	ldr	ip, [ip]
    3650:	e58d4004 	str	r4, [sp, #4]
    3654:	eb00055b 	bl	4bc8 <_ZN21Cyg_Exception_Control18register_exceptionEiPFvjijEjPS1_Pj>
        (cyg_exception_handler *)new_handler,
        (CYG_ADDRWORD)new_data,
        (cyg_exception_handler **)old_handler,
        (CYG_ADDRWORD *)old_data
        );
}
    3658:	e28dd008 	add	sp, sp, #8	; 0x8
    365c:	e8bd8010 	pop	{r4, pc}
    3660:	40002538 	.word	0x40002538
    3664:	40002518 	.word	0x40002518

00003668 <cyg_thread_free_data_index>:
    return index;
}

externC void cyg_thread_free_data_index(cyg_ucount32 index) __THROW
{
    Cyg_Thread::free_data_index(index);
    3668:	ea000124 	b	3b00 <_ZN10Cyg_Thread15free_data_indexEi>

0000366c <cyg_thread_new_data_index>:

#ifdef CYGVAR_KERNEL_THREADS_DATA

externC cyg_ucount32 cyg_thread_new_data_index() __THROW
{
    Cyg_Thread::cyg_data_index index = Cyg_Thread::new_data_index();
    366c:	ea0004e8 	b	4a14 <_ZN10Cyg_Thread14new_data_indexEv>

00003670 <cyg_scheduler_unlock>:
    CYG_ASSERT( (0xff000000 & (Cyg_Scheduler::get_sched_lock())) == 0,
                "Scheduler overlocked" );
}

/* Unlock the scheduler. */
externC void cyg_scheduler_unlock(void) __THROW
    3670:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3674:	e59f2030 	ldr	r2, [pc, #48]	; 36ac <cyg_scheduler_unlock+0x3c>
    3678:	e5923000 	ldr	r3, [r2]
{
    cyg_ucount32 slock = Cyg_Scheduler::get_sched_lock();
    CYG_ASSERT( 0 < slock, "Scheduler not locked" );
    // And program defensively too:
    if ( 0 < slock )
    367c:	e3530000 	cmp	r3, #0	; 0x0
    CYG_ASSERT( (0xff000000 & (Cyg_Scheduler::get_sched_lock())) == 0,
                "Scheduler overlocked" );
}

/* Unlock the scheduler. */
externC void cyg_scheduler_unlock(void) __THROW
    3680:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    cyg_ucount32 slock = Cyg_Scheduler::get_sched_lock();
    CYG_ASSERT( 0 < slock, "Scheduler not locked" );
    // And program defensively too:
    if ( 0 < slock )
    3684:	1a000001 	bne	3690 <cyg_scheduler_unlock+0x20>
        Cyg_Scheduler::unlock();
}
    3688:	e28dd004 	add	sp, sp, #4	; 0x4
    368c:	e8bd8000 	pop	{pc}
    3690:	e5923000 	ldr	r3, [r2]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    3694:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3698:	15820000 	strne	r0, [r2]
    369c:	0a000000 	beq	36a4 <cyg_scheduler_unlock+0x34>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    36a0:	eafffff8 	b	3688 <cyg_scheduler_unlock+0x18>
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    36a4:	eb0008dc 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    36a8:	eafffff6 	b	3688 <cyg_scheduler_unlock+0x18>
    36ac:	400007c8 	.word	0x400007c8

000036b0 <cyg_thread_delay>:
    36b0:	e59f3010 	ldr	r3, [pc, #16]	; 36c8 <cyg_thread_delay+0x18>
    36b4:	e593c000 	ldr	ip, [r3]
) __THROW
{
    CYG_ASSERT(0,"Not implemented");
} 

externC void cyg_thread_delay(cyg_tick_count_t delay) __THROW
    36b8:	e1a02000 	mov	r2, r0
    36bc:	e1a03001 	mov	r3, r1
{
    Cyg_Thread::self()->delay(delay);
    36c0:	e1a0000c 	mov	r0, ip
    36c4:	ea0001f0 	b	3e8c <_ZN10Cyg_Thread5delayEy>
    36c8:	40002538 	.word	0x40002538

000036cc <cyg_thread_set_priority>:
/* Priority manipulation */
externC void cyg_thread_set_priority(
    cyg_handle_t thread, cyg_priority_t priority ) __THROW
{
#ifdef CYGIMP_THREAD_PRIORITY
    ((Cyg_Thread *)thread)->set_priority(priority);
    36cc:	ea00030c 	b	4304 <_ZN10Cyg_Thread12set_priorityEi>

000036d0 <cyg_thread_yield>:
    36d0:	e59f3008 	ldr	r3, [pc, #8]	; 36e0 <cyg_thread_yield+0x10>
    36d4:	e5930000 	ldr	r0, [r3]

// -------------------------------------------------------------------------

inline void Cyg_Thread::yield()
{
    self()->Cyg_SchedThread::yield();
    36d8:	e280001c 	add	r0, r0, #28	; 0x1c
    36dc:	ea000821 	b	5768 <_ZN30Cyg_SchedThread_Implementation5yieldEv>
    36e0:	40002538 	.word	0x40002538

000036e4 <cyg_thread_release>:
    ((Cyg_Thread *)thread)->kill();
}

externC void cyg_thread_release( cyg_handle_t thread) __THROW
{
    ((Cyg_Thread *)thread)->release();    
    36e4:	ea0004e8 	b	4a8c <_ZN10Cyg_Thread7releaseEv>

000036e8 <cyg_thread_kill>:
    th->resume();
}

externC void cyg_thread_kill( cyg_handle_t thread) __THROW
{
    ((Cyg_Thread *)thread)->kill();
    36e8:	ea0003bc 	b	45e0 <_ZN10Cyg_Thread4killEv>

000036ec <cyg_thread_resume>:
    Cyg_Thread *th = (Cyg_Thread *)thread;

    // If we are resuming an exited thread then
    // reinitialize it.
    
    if( th->get_state() == Cyg_Thread::EXITED )
    36ec:	e590303c 	ldr	r3, [r0, #60]
    36f0:	e3530010 	cmp	r3, #16	; 0x10
externC void cyg_thread_suspend(cyg_handle_t thread) __THROW
{
    ((Cyg_Thread *)thread)->suspend();
}

externC void cyg_thread_resume(cyg_handle_t thread) __THROW
    36f4:	e92d4010 	push	{r4, lr}
    36f8:	e1a04000 	mov	r4, r0
    Cyg_Thread *th = (Cyg_Thread *)thread;

    // If we are resuming an exited thread then
    // reinitialize it.
    
    if( th->get_state() == Cyg_Thread::EXITED )
    36fc:	0a000002 	beq	370c <cyg_thread_resume+0x20>
        th->reinitialize();

    th->resume();
    3700:	e1a00004 	mov	r0, r4
}
    3704:	e8bd4010 	pop	{r4, lr}
    // reinitialize it.
    
    if( th->get_state() == Cyg_Thread::EXITED )
        th->reinitialize();

    th->resume();
    3708:	ea00029f 	b	418c <_ZN10Cyg_Thread6resumeEv>

    // If we are resuming an exited thread then
    // reinitialize it.
    
    if( th->get_state() == Cyg_Thread::EXITED )
        th->reinitialize();
    370c:	eb00018a 	bl	3d3c <_ZN10Cyg_Thread12reinitializeEv>
    3710:	eafffffa 	b	3700 <cyg_thread_resume+0x14>

00003714 <cyg_thread_suspend>:
    return true;
}

externC void cyg_thread_suspend(cyg_handle_t thread) __THROW
{
    ((Cyg_Thread *)thread)->suspend();
    3714:	ea0001a1 	b	3da0 <_ZN10Cyg_Thread7suspendEv>

00003718 <cyg_thread_delete>:
}

externC cyg_bool_t cyg_thread_delete( cyg_handle_t thread ) __THROW
{
    Cyg_Thread *th = (Cyg_Thread *)thread;
    if( th->get_state() != Cyg_Thread::EXITED )
    3718:	e590303c 	ldr	r3, [r0, #60]
    371c:	e3530010 	cmp	r3, #16	; 0x10
externC void cyg_thread_exit() __THROW
{
    Cyg_Thread::exit();
}

externC cyg_bool_t cyg_thread_delete( cyg_handle_t thread ) __THROW
    3720:	e92d4010 	push	{r4, lr}
    3724:	e1a04000 	mov	r4, r0
{
    Cyg_Thread *th = (Cyg_Thread *)thread;
    if( th->get_state() != Cyg_Thread::EXITED )
    3728:	1a000003 	bne	373c <cyg_thread_delete+0x24>
        th->kill(); // encourage it to terminate
    if( th->get_state() != Cyg_Thread::EXITED )
        return false; // it didn't run yet, leave it up to the app to fix
    th->~Cyg_Thread();
    372c:	e1a00004 	mov	r0, r4
    3730:	eb000346 	bl	4450 <_ZN10Cyg_ThreadD1Ev>
    3734:	e3a00001 	mov	r0, #1	; 0x1
    return true;
}
    3738:	e8bd8010 	pop	{r4, pc}

externC cyg_bool_t cyg_thread_delete( cyg_handle_t thread ) __THROW
{
    Cyg_Thread *th = (Cyg_Thread *)thread;
    if( th->get_state() != Cyg_Thread::EXITED )
        th->kill(); // encourage it to terminate
    373c:	eb0003a7 	bl	45e0 <_ZN10Cyg_Thread4killEv>
    if( th->get_state() != Cyg_Thread::EXITED )
    3740:	e594303c 	ldr	r3, [r4, #60]
    3744:	e3530010 	cmp	r3, #16	; 0x10
    3748:	13a00000 	movne	r0, #0	; 0x0
    374c:	18bd8010 	popne	{r4, pc}
    3750:	eafffff5 	b	372c <cyg_thread_delete+0x14>

00003754 <cyg_thread_exit>:
    *handle = (cyg_handle_t)thread;
}

externC void cyg_thread_exit() __THROW
{
    Cyg_Thread::exit();
    3754:	ea0000c4 	b	3a6c <_ZN10Cyg_Thread4exitEv>

00003758 <cyg_thread_create>:
    char                *name,                  /* optional thread name      */
    void                *stack_base,            /* stack base, NULL = alloc  */
    cyg_ucount32        stack_size,             /* stack size, 0 = default   */
    cyg_handle_t        *handle,                /* returned thread handle    */
    cyg_thread          *thread                 /* put thread here           */
) __THROW
    3758:	e92d4030 	push	{r4, r5, lr}
    375c:	e24dd014 	sub	sp, sp, #20	; 0x14
    3760:	e59d502c 	ldr	r5, [sp, #44]
    3764:	e1a0c001 	mov	ip, r1
    3768:	e1a0e002 	mov	lr, r2
        (cyg_thread_entry *)entry,
        (CYG_ADDRWORD) entry_data,
        name,
        (CYG_ADDRWORD) stack_base,
        stack_size
        );
    376c:	e59d4024 	ldr	r4, [sp, #36]
    3770:	e1a0200c 	mov	r2, ip
    3774:	e59dc020 	ldr	ip, [sp, #32]
    3778:	e58d3000 	str	r3, [sp]
    377c:	e1a01000 	mov	r1, r0
    3780:	e1a0300e 	mov	r3, lr
    3784:	e1a00005 	mov	r0, r5
    3788:	e58dc004 	str	ip, [sp, #4]
    378c:	e58d4008 	str	r4, [sp, #8]
    3790:	eb000101 	bl	3b9c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj>
    t=t;
    
    CYG_CHECK_DATA_PTR( handle, "Bad handle pointer" );
    *handle = (cyg_handle_t)thread;
    3794:	e59d3028 	ldr	r3, [sp, #40]
    3798:	e5835000 	str	r5, [r3]
}
    379c:	e28dd014 	add	sp, sp, #20	; 0x14
    37a0:	e8bd8030 	pop	{r4, r5, pc}

000037a4 <cyg_scheduler_start>:
/* Scheduler operations */

/* Starts scheduler with created threads.  Never returns. */
externC void cyg_scheduler_start(void) __THROW
{
    Cyg_Scheduler::start();
    37a4:	eb00089b 	bl	5a18 <_ZN13Cyg_Scheduler5startEv>

000037a8 <cyg_thread_get_next>:
/*---------------------------------------------------------------------------*/
/* Thread enumeration and information                                        */

#ifdef CYGVAR_KERNEL_THREADS_LIST

cyg_bool_t cyg_thread_get_next( cyg_handle_t *current, cyg_uint16 *id ) __THROW
    37a8:	e92d4030 	push	{r4, r5, lr}
    37ac:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    37b0:	e59f50c0 	ldr	r5, [pc, #192]	; 3878 <cyg_thread_get_next+0xd0>
    37b4:	e5953000 	ldr	r3, [r5]
    37b8:	e2833001 	add	r3, r3, #1	; 0x1
    37bc:	e5853000 	str	r3, [r5]
    if ( *current != 0 )
        CYG_CHECK_DATA_PTRC( *current );

    Cyg_Scheduler::lock();

    Cyg_Thread *thread = (Cyg_Thread *)*current;
    37c0:	e590c000 	ldr	ip, [r0]
    CYG_ASSERT_ZERO_OR_CLASSC( thread );
    if( *current == 0 )
    37c4:	e35c0000 	cmp	ip, #0	; 0x0
    37c8:	1a00000f 	bne	380c <cyg_thread_get_next+0x64>

#ifdef CYGVAR_KERNEL_THREADS_LIST

inline Cyg_Thread *Cyg_Thread::get_list_head()
{
    return thread_list?thread_list->list_next:0;
    37cc:	e59f30a8 	ldr	r3, [pc, #168]	; 387c <cyg_thread_get_next+0xd4>
    37d0:	e5933000 	ldr	r3, [r3]
    37d4:	e3530000 	cmp	r3, #0	; 0x0
    37d8:	159330a0 	ldrne	r3, [r3, #160]
    {
        thread = Cyg_Thread::get_list_head();
        *current = (cyg_handle_t)thread;
    37dc:	e5803000 	str	r3, [r0]
        *id = thread->get_unique_id();
    37e0:	e1d334bc 	ldrh	r3, [r3, #76]
    37e4:	e1c130b0 	strh	r3, [r1]
    37e8:	e3a04001 	mov	r4, #1	; 0x1
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    37ec:	e5953000 	ldr	r3, [r5]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    37f0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    37f4:	159f307c 	ldrne	r3, [pc, #124]	; 3878 <cyg_thread_get_next+0xd0>
    37f8:	15830000 	strne	r0, [r3]
    37fc:	0a00000f 	beq	3840 <cyg_thread_get_next+0x98>
    }
    
    Cyg_Scheduler::unlock();

    return result;
}
    3800:	e1a00004 	mov	r0, r4
    3804:	e28dd004 	add	sp, sp, #4	; 0x4
    3808:	e8bd8030 	pop	{r4, r5, pc}
    {
        thread = Cyg_Thread::get_list_head();
        *current = (cyg_handle_t)thread;
        *id = thread->get_unique_id();
    }
    else if( (thread->get_unique_id() == *id) &&
    380c:	e1d120b0 	ldrh	r2, [r1]
    3810:	e1dc34bc 	ldrh	r3, [ip, #76]
    3814:	e1520003 	cmp	r2, r3
    3818:	0a00000a 	beq	3848 <cyg_thread_get_next+0xa0>
        *current = (cyg_handle_t)thread;
        *id = thread->get_unique_id();
    }
    else
    {
        *current = 0;
    381c:	e3a03000 	mov	r3, #0	; 0x0
    3820:	e5803000 	str	r3, [r0]
        *id = 0;
    3824:	e1c130b0 	strh	r3, [r1]
    3828:	e1a04003 	mov	r4, r3
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    382c:	e5953000 	ldr	r3, [r5]
    3830:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3834:	159f303c 	ldrne	r3, [pc, #60]	; 3878 <cyg_thread_get_next+0xd0>
    3838:	15830000 	strne	r0, [r3]
    383c:	1affffef 	bne	3800 <cyg_thread_get_next+0x58>
    3840:	eb000875 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3844:	eaffffed 	b	3800 <cyg_thread_get_next+0x58>
}
    
inline Cyg_Thread *Cyg_Thread::get_list_next()
{
    return (this==thread_list)?0:list_next;
    3848:	e59f302c 	ldr	r3, [pc, #44]	; 387c <cyg_thread_get_next+0xd4>
    384c:	e5932000 	ldr	r2, [r3]
    3850:	e15c0002 	cmp	ip, r2
    3854:	0afffff0 	beq	381c <cyg_thread_get_next+0x74>
    3858:	e59c30a0 	ldr	r3, [ip, #160]
    {
        thread = Cyg_Thread::get_list_head();
        *current = (cyg_handle_t)thread;
        *id = thread->get_unique_id();
    }
    else if( (thread->get_unique_id() == *id) &&
    385c:	e3530000 	cmp	r3, #0	; 0x0
    3860:	0affffed 	beq	381c <cyg_thread_get_next+0x74>
             (thread = thread->get_list_next()) != NULL )
    {
        CYG_CHECK_DATA_PTRC( thread );
        CYG_ASSERT_CLASSC( thread );
        *current = (cyg_handle_t)thread;
    3864:	e5803000 	str	r3, [r0]
        *id = thread->get_unique_id();
    3868:	e1d334bc 	ldrh	r3, [r3, #76]
    386c:	e3a04001 	mov	r4, #1	; 0x1
    3870:	e1c130b0 	strh	r3, [r1]
    3874:	eaffffdc 	b	37ec <cyg_thread_get_next+0x44>
    3878:	400007c8 	.word	0x400007c8
    387c:	40001c64 	.word	0x40001c64

00003880 <cyg_thread_get_info>:

#endif

cyg_bool_t cyg_thread_get_info( cyg_handle_t threadh,
                                cyg_uint16 id,
                                cyg_thread_info *info ) __THROW
    3880:	e92d4030 	push	{r4, r5, lr}
    3884:	e1a0c002 	mov	ip, r2
    3888:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    388c:	e59f50b0 	ldr	r5, [pc, #176]	; 3944 <cyg_thread_get_info+0xc4>
    3890:	e5953000 	ldr	r3, [r5]
    3894:	e2833001 	add	r3, r3, #1	; 0x1
    3898:	e5853000 	str	r3, [r5]
    if ( NULL != info )
        CYG_CHECK_DATA_PTRC( info );
    
    Cyg_Scheduler::lock();
    
    if( thread->get_unique_id() == id && info != NULL )
    389c:	e1d044bc 	ldrh	r4, [r0, #76]
    38a0:	e1540001 	cmp	r4, r1
    38a4:	0a000008 	beq	38cc <cyg_thread_get_info+0x4c>
        info->stack_size = thread->get_stack_size();
        
#ifdef CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT
        info->stack_used = thread->measure_stack_usage();
#else
        info->stack_used = 0;
    38a8:	e3a04000 	mov	r4, #0	; 0x0
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    38ac:	e5953000 	ldr	r3, [r5]
    38b0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    38b4:	159f3088 	ldrne	r3, [pc, #136]	; 3944 <cyg_thread_get_info+0xc4>
    38b8:	15830000 	strne	r0, [r3]
    38bc:	0a00001e 	beq	393c <cyg_thread_get_info+0xbc>
    else result = false;
    
    Cyg_Scheduler::unlock();

    return result;
}
    38c0:	e1a00004 	mov	r0, r4
    38c4:	e28dd004 	add	sp, sp, #4	; 0x4
    38c8:	e8bd8030 	pop	{r4, r5, pc}
    if ( NULL != info )
        CYG_CHECK_DATA_PTRC( info );
    
    Cyg_Scheduler::lock();
    
    if( thread->get_unique_id() == id && info != NULL )
    38cc:	e3520000 	cmp	r2, #0	; 0x0
    38d0:	0afffff4 	beq	38a8 <cyg_thread_get_info+0x28>
    {
        CYG_ASSERT_CLASSC( thread );
        info->handle = threadh;
    38d4:	e5820000 	str	r0, [r2]
        info->id = id;
        info->state = thread->get_state();
    38d8:	e590303c 	ldr	r3, [r0, #60]
    38dc:	e5823008 	str	r3, [r2, #8]
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_SIMPLE

    // If we have an inherited priority, return our original
    // priority rather than the current one.
    
    if( priority_inherited ) return original_priority;
    38e0:	e5902038 	ldr	r2, [r0, #56]
#ifdef CYGVAR_KERNEL_THREADS_NAME
        info->name = thread->get_name();
    38e4:	e590309c 	ldr	r3, [r0, #156]
    38e8:	e3520000 	cmp	r2, #0	; 0x0
    38ec:	e58c300c 	str	r3, [ip, #12]

#endif

    return priority;
    38f0:	05903024 	ldreq	r3, [r0, #36]
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_SIMPLE

    // If we have an inherited priority, return our original
    // priority rather than the current one.
    
    if( priority_inherited ) return original_priority;
    38f4:	15902034 	ldrne	r2, [r0, #52]
    38f8:	15903024 	ldrne	r3, [r0, #36]

#endif

    return priority;
    38fc:	01a02003 	moveq	r2, r3
#else
        info->name = NULL;
#endif
        info->set_pri = thread->get_priority();
    3900:	e58c2010 	str	r2, [ip, #16]
        info->cur_pri = thread->get_current_priority();
    3904:	e58c3014 	str	r3, [ip, #20]
        info->stack_base = thread->get_stack_base();
    3908:	e5903000 	ldr	r3, [r0]
    390c:	e58c3018 	str	r3, [ip, #24]
        info->stack_size = thread->get_stack_size();
    3910:	e5902004 	ldr	r2, [r0, #4]
        
#ifdef CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT
        info->stack_used = thread->measure_stack_usage();
#else
        info->stack_used = 0;
    3914:	e3a03000 	mov	r3, #0	; 0x0
    
    if( thread->get_unique_id() == id && info != NULL )
    {
        CYG_ASSERT_CLASSC( thread );
        info->handle = threadh;
        info->id = id;
    3918:	e1cc40b4 	strh	r4, [ip, #4]
        info->stack_size = thread->get_stack_size();
        
#ifdef CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT
        info->stack_used = thread->measure_stack_usage();
#else
        info->stack_used = 0;
    391c:	e58c3020 	str	r3, [ip, #32]
        info->name = NULL;
#endif
        info->set_pri = thread->get_priority();
        info->cur_pri = thread->get_current_priority();
        info->stack_base = thread->get_stack_base();
        info->stack_size = thread->get_stack_size();
    3920:	e58c201c 	str	r2, [ip, #28]
        
#ifdef CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT
        info->stack_used = thread->measure_stack_usage();
#else
        info->stack_used = 0;
    3924:	e3a04001 	mov	r4, #1	; 0x1
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3928:	e5953000 	ldr	r3, [r5]
    392c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3930:	159f300c 	ldrne	r3, [pc, #12]	; 3944 <cyg_thread_get_info+0xc4>
    3934:	15830000 	strne	r0, [r3]
    3938:	1affffe0 	bne	38c0 <cyg_thread_get_info+0x40>
    393c:	eb000836 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3940:	eaffffde 	b	38c0 <cyg_thread_get_info+0x40>
    3944:	400007c8 	.word	0x400007c8

00003948 <cyg_thread_find>:
    Cyg_Scheduler::unlock();

    return result;
}

cyg_handle_t cyg_thread_find( cyg_uint16 id ) __THROW
    3948:	e92d4010 	push	{r4, lr}
    394c:	e1a01000 	mov	r1, r0
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3950:	e59fc08c 	ldr	ip, [pc, #140]	; 39e4 <cyg_thread_find+0x9c>
    3954:	e59c3000 	ldr	r3, [ip]
    3958:	e2833001 	add	r3, r3, #1	; 0x1
    395c:	e58c3000 	str	r3, [ip]

#ifdef CYGVAR_KERNEL_THREADS_LIST

inline Cyg_Thread *Cyg_Thread::get_list_head()
{
    return thread_list?thread_list->list_next:0;
    3960:	e59f3080 	ldr	r3, [pc, #128]	; 39e8 <cyg_thread_find+0xa0>
    3964:	e5932000 	ldr	r2, [r3]
    3968:	e3520000 	cmp	r2, #0	; 0x0
    396c:	0a00000b 	beq	39a0 <cyg_thread_find+0x58>
    3970:	e59200a0 	ldr	r0, [r2, #160]
{
    Cyg_Scheduler::lock();

    Cyg_Thread *thread = Cyg_Thread::get_list_head();

    while( thread != NULL )
    3974:	e3500000 	cmp	r0, #0	; 0x0
    3978:	1a000003 	bne	398c <cyg_thread_find+0x44>
    397c:	ea000007 	b	39a0 <cyg_thread_find+0x58>
}
    
inline Cyg_Thread *Cyg_Thread::get_list_next()
{
    return (this==thread_list)?0:list_next;
    3980:	e59000a0 	ldr	r0, [r0, #160]
    3984:	e3500000 	cmp	r0, #0	; 0x0
    3988:	0a000004 	beq	39a0 <cyg_thread_find+0x58>
    {
        if( thread->get_unique_id() == id )
    398c:	e1d034bc 	ldrh	r3, [r0, #76]
    3990:	e1530001 	cmp	r3, r1
    3994:	0a000009 	beq	39c0 <cyg_thread_find+0x78>
    3998:	e1520000 	cmp	r2, r0
    399c:	1afffff7 	bne	3980 <cyg_thread_find+0x38>
{
    Cyg_Scheduler::lock();

    Cyg_Thread *thread = Cyg_Thread::get_list_head();

    while( thread != NULL )
    39a0:	e3a04000 	mov	r4, #0	; 0x0
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    39a4:	e59c3000 	ldr	r3, [ip]
    39a8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    39ac:	159f3030 	ldrne	r3, [pc, #48]	; 39e4 <cyg_thread_find+0x9c>
    39b0:	15830000 	strne	r0, [r3]
    39b4:	0a000007 	beq	39d8 <cyg_thread_find+0x90>
    }

    Cyg_Scheduler::unlock();
    
    return (cyg_handle_t)thread;
}
    39b8:	e1a00004 	mov	r0, r4
    39bc:	e8bd8010 	pop	{r4, pc}

    Cyg_Thread *thread = Cyg_Thread::get_list_head();

    while( thread != NULL )
    {
        if( thread->get_unique_id() == id )
    39c0:	e1a04000 	mov	r4, r0
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    39c4:	e59c3000 	ldr	r3, [ip]
    39c8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    39cc:	159f3010 	ldrne	r3, [pc, #16]	; 39e4 <cyg_thread_find+0x9c>
    39d0:	15830000 	strne	r0, [r3]
    39d4:	1afffff7 	bne	39b8 <cyg_thread_find+0x70>
    39d8:	eb00080f 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    }

    Cyg_Scheduler::unlock();
    
    return (cyg_handle_t)thread;
}
    39dc:	e1a00004 	mov	r0, r4
    39e0:	e8bd8010 	pop	{r4, pc}
    39e4:	400007c8 	.word	0x400007c8
    39e8:	40001c64 	.word	0x40001c64

000039ec <cyg_scheduler_safe_lock>:
    CYG_ASSERT( (0xff000000 & (Cyg_Scheduler::get_sched_lock())) == 0,
                "Scheduler overlocked" );
}

/* Lock the scheduler, but never more than level=1. */
externC void cyg_scheduler_safe_lock(void) __THROW
    39ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    39f0:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    39f4:	e59f2034 	ldr	r2, [pc, #52]	; 3a30 <cyg_scheduler_safe_lock+0x44>
    39f8:	e5923000 	ldr	r3, [r2]
    39fc:	e2833001 	add	r3, r3, #1	; 0x1
    3a00:	e5823000 	str	r3, [r2]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3a04:	e5923000 	ldr	r3, [r2]
{
    Cyg_Scheduler::lock();
    cyg_ucount32 slock = Cyg_Scheduler::get_sched_lock();
    if (slock > 1)
    3a08:	e3530001 	cmp	r3, #1	; 0x1
    3a0c:	9a000003 	bls	3a20 <cyg_scheduler_safe_lock+0x34>
    3a10:	e5923000 	ldr	r3, [r2]
    3a14:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3a18:	15820000 	strne	r0, [r2]
    3a1c:	0a000001 	beq	3a28 <cyg_scheduler_safe_lock+0x3c>
        Cyg_Scheduler::unlock();
    // get_sched_lock() is unsigned, see below "cyg_ucount32 lock"
    CYG_ASSERT( (0xff000000 & (Cyg_Scheduler::get_sched_lock())) == 0,
                "Scheduler overlocked" );
}
    3a20:	e28dd004 	add	sp, sp, #4	; 0x4
    3a24:	e8bd8000 	pop	{pc}
    3a28:	eb0007fb 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3a2c:	eafffffb 	b	3a20 <cyg_scheduler_safe_lock+0x34>
    3a30:	400007c8 	.word	0x400007c8

00003a34 <_Z16idle_thread_mainj>:

    for(;;)
    {
        idle_thread_loops[CYG_KERNEL_CPU_THIS()]++;

        HAL_IDLE_THREAD_ACTION(idle_thread_loops[CYG_KERNEL_CPU_THIS()]);
    3a34:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    3a38:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    3a3c:	e3a02001 	mov	r2, #1	; 0x1
    3a40:	e58320c0 	str	r2, [r3, #192]
    3a44:	e58320c0 	str	r2, [r3, #192]
    3a48:	eafffffc 	b	3a40 <_Z16idle_thread_mainj+0xc>

00003a4c <_ZN10Cyg_Thread17deliver_exceptionEij>:
    3a4c:	e59f3010 	ldr	r3, [pc, #16]	; 3a64 <_ZN10Cyg_Thread17deliver_exceptionEij+0x18>
    3a50:	e593c000 	ldr	ip, [r3]
Cyg_Thread::deliver_exception(
    cyg_code            exception_number,       // exception being raised
    CYG_ADDRWORD        exception_info          // exception specific info
    )
{
    if( this == Cyg_Scheduler::get_current_thread() )
    3a54:	e15c0000 	cmp	ip, r0
    3a58:	112fff1e 	bxne	lr
    {
        // Delivering to current thread, probably as a result
        // of a real hardware exception. Simply invoke the appropriate
        // handler.

        exception_control.deliver_exception( exception_number, exception_info );
    3a5c:	e59f0004 	ldr	r0, [pc, #4]	; 3a68 <_ZN10Cyg_Thread17deliver_exceptionEij+0x1c>
    3a60:	ea00046b 	b	4c14 <_ZN21Cyg_Exception_Control17deliver_exceptionEij>
    3a64:	40002538 	.word	0x40002538
    3a68:	40002518 	.word	0x40002518

00003a6c <_ZN10Cyg_Thread4exitEv>:
Cyg_Thread::destructors[ CYGNUM_KERNEL_THREADS_DESTRUCTORS ];
#endif
#endif

void
Cyg_Thread::exit()
    3a6c:	e92d4030 	push	{r4, r5, lr}
    3a70:	e59f2050 	ldr	r2, [pc, #80]	; 3ac8 <_ZN10Cyg_Thread4exitEv+0x5c>
    3a74:	e24dd004 	sub	sp, sp, #4	; 0x4
    3a78:	e5924000 	ldr	r4, [r2]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3a7c:	e59f5048 	ldr	r5, [pc, #72]	; 3acc <_ZN10Cyg_Thread4exitEv+0x60>
    3a80:	e5953000 	ldr	r3, [r5]
    3a84:	e2833001 	add	r3, r3, #1	; 0x1
    3a88:	e5853000 	str	r3, [r5]
    3a8c:	e5920000 	ldr	r0, [r2]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    3a90:	e2800050 	add	r0, r0, #80	; 0x50
    3a94:	eb002dac 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    clear_timer();

    // It is possible that we have already been killed by another
    // thread, in which case we do not want to try and take ourself
    // out of the scheduler again.
    if( self->state != EXITED )
    3a98:	e594303c 	ldr	r3, [r4, #60]
    3a9c:	e3530010 	cmp	r3, #16	; 0x10
    3aa0:	0a000004 	beq	3ab8 <_ZN10Cyg_Thread4exitEv+0x4c>
    {
        self->state = EXITED;
    3aa4:	e3a03010 	mov	r3, #16	; 0x10
    3aa8:	e584303c 	str	r3, [r4, #60]

        Cyg_Scheduler::scheduler.rem_thread(self);
    3aac:	e1a01004 	mov	r1, r4
    3ab0:	e59f0018 	ldr	r0, [pc, #24]	; 3ad0 <_ZN10Cyg_Thread4exitEv+0x64>
    3ab4:	eb0005f8 	bl	529c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3ab8:	e5950000 	ldr	r0, [r5]
    }

    Cyg_Scheduler::reschedule();
}
    3abc:	e28dd004 	add	sp, sp, #4	; 0x4
    3ac0:	e8bd4030 	pop	{r4, r5, lr}
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    3ac4:	ea0007d4 	b	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3ac8:	40002538 	.word	0x40002538
    3acc:	400007c8 	.word	0x400007c8
    3ad0:	40002540 	.word	0x40002540

00003ad4 <_ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread>:
// Thread entry point.
// This is inserted as the PC value in all initial thread contexts.
// It does some housekeeping and then calls the real entry point.

void
Cyg_HardwareThread::thread_entry( Cyg_Thread *thread )
    3ad4:	e92d4010 	push	{r4, lr}
{
    CYG_REPORT_FUNCTION();

    // Call the scheduler to do any housekeeping
    Cyg_Scheduler::scheduler.thread_entry( thread );
    3ad8:	e1a01000 	mov	r1, r0
// Thread entry point.
// This is inserted as the PC value in all initial thread contexts.
// It does some housekeeping and then calls the real entry point.

void
Cyg_HardwareThread::thread_entry( Cyg_Thread *thread )
    3adc:	e1a04000 	mov	r4, r0
{
    CYG_REPORT_FUNCTION();

    // Call the scheduler to do any housekeeping
    Cyg_Scheduler::scheduler.thread_entry( thread );
    3ae0:	e59f0014 	ldr	r0, [pc, #20]	; 3afc <_ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread+0x28>
    3ae4:	eb000809 	bl	5b10 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread>
    
    // Call entry point in a loop.
    for(;;)
    {
        thread->entry_point(thread->entry_data);
    3ae8:	e5940014 	ldr	r0, [r4, #20]
    3aec:	e1a0e00f 	mov	lr, pc
    3af0:	e594f010 	ldr	pc, [r4, #16]
        thread->exit();
    3af4:	ebffffdc 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    3af8:	eafffffa 	b	3ae8 <_ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread+0x14>
    3afc:	40002540 	.word	0x40002540

00003b00 <_ZN10Cyg_Thread15free_data_indexEi>:
    Cyg_Scheduler::unlock();

    return index;
}

void Cyg_Thread::free_data_index( Cyg_Thread::cyg_data_index index )
    3b00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    3b04:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3b08:	e59fc03c 	ldr	ip, [pc, #60]	; 3b4c <_ZN10Cyg_Thread15free_data_indexEi+0x4c>
    3b0c:	e59c3000 	ldr	r3, [ip]
    3b10:	e2833001 	add	r3, r3, #1	; 0x1
    3b14:	e58c3000 	str	r3, [ip]
{
    Cyg_Scheduler::lock();

    thread_data_map |= (1<<index);
    3b18:	e59f1030 	ldr	r1, [pc, #48]	; 3b50 <_ZN10Cyg_Thread15free_data_indexEi+0x50>
    3b1c:	e5913000 	ldr	r3, [r1]
    3b20:	e3a02001 	mov	r2, #1	; 0x1
    3b24:	e1833012 	orr	r3, r3, r2, lsl r0
    3b28:	e5813000 	str	r3, [r1]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3b2c:	e59c3000 	ldr	r3, [ip]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    3b30:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3b34:	158c0000 	strne	r0, [ip]
    3b38:	0a000001 	beq	3b44 <_ZN10Cyg_Thread15free_data_indexEi+0x44>
    
    Cyg_Scheduler::unlock();    
}
    3b3c:	e28dd004 	add	sp, sp, #4	; 0x4
    3b40:	e8bd8000 	pop	{pc}
    3b44:	eb0007b4 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3b48:	eafffffb 	b	3b3c <_ZN10Cyg_Thread15free_data_indexEi+0x3c>
    3b4c:	400007c8 	.word	0x400007c8
    3b50:	400007c0 	.word	0x400007c0

00003b54 <_ZN10Cyg_Thread19cancel_counted_wakeEv>:
}

// -------------------------------------------------------------------------
// Cancel wakeups for this thread and return how many were pending
cyg_uint32
Cyg_Thread::cancel_counted_wake()
    3b54:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3b58:	e59f2038 	ldr	r2, [pc, #56]	; 3b98 <_ZN10Cyg_Thread19cancel_counted_wakeEv+0x44>
    3b5c:	e5923000 	ldr	r3, [r2]
    3b60:	e2833001 	add	r3, r3, #1	; 0x1
    3b64:	e5823000 	str	r3, [r2]
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    cyg_uint32 result = wakeup_count;
    wakeup_count = 0;
    3b68:	e3a03000 	mov	r3, #0	; 0x0
    CYG_INSTRUMENT_THREAD(WAKE,this,Cyg_Scheduler::current_thread);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    cyg_uint32 result = wakeup_count;
    3b6c:	e5904044 	ldr	r4, [r0, #68]
    wakeup_count = 0;
    3b70:	e5803044 	str	r3, [r0, #68]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3b74:	e5923000 	ldr	r3, [r2]
    3b78:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3b7c:	15820000 	strne	r0, [r2]
    3b80:	0a000001 	beq	3b8c <_ZN10Cyg_Thread19cancel_counted_wakeEv+0x38>
    // Unlock the scheduler
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETVAL( result );
    return result;
}
    3b84:	e1a00004 	mov	r0, r4
    3b88:	e8bd8010 	pop	{r4, pc}
    3b8c:	eb0007a2 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3b90:	e1a00004 	mov	r0, r4
    3b94:	e8bd8010 	pop	{r4, pc}
    3b98:	400007c8 	.word	0x400007c8

00003b9c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj>:
        cyg_thread_entry        *entry,         // entry point function
        CYG_ADDRWORD            entry_data,     // entry data
        char                    *name_arg,      // thread name cookie
        CYG_ADDRESS             stack_base,     // stack base, NULL = allocate
        cyg_ucount32            stack_size      // stack size, 0 = use default
        )
    3b9c:	e92d4070 	push	{r4, r5, r6, lr}
    3ba0:	e59dc014 	ldr	ip, [sp, #20]
    3ba4:	e59d5018 	ldr	r5, [sp, #24]
)
{
    entry_point = e_point;
    entry_data  = e_data;
#ifdef CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT
    saved_context = 0;
    3ba8:	e3a04000 	mov	r4, #0	; 0x0

    HAL_THREAD_ATTACH_STACK(stack_ptr, stack_base, stack_size);
    
#else

    stack_ptr = stack_base + stack_size;
    3bac:	e085e00c 	add	lr, r5, ip
    3bb0:	e1a06000 	mov	r6, r0
    3bb4:	e580e00c 	str	lr, [r0, #12]
	// CYG_WORD in size. Since it's at the top of the stack, it will
	// almost certainly be overwritten the instant the thread starts
	// anyway.
    }
#endif
    stack_base = s_base;
    3bb8:	e580c000 	str	ip, [r0]
    stack_size = s_size;
#ifdef CYGFUN_KERNEL_THREADS_STACK_LIMIT
    stack_limit = s_base;
    3bbc:	e580c008 	str	ip, [r0, #8]
    CYG_ADDRWORD            e_data,     // entry data
    cyg_ucount32            s_size,     // stack size, 0 = use default
    CYG_ADDRESS             s_base      // stack base, NULL = allocate
)
{
    entry_point = e_point;
    3bc0:	e5802010 	str	r2, [r0, #16]
    entry_data  = e_data;
    3bc4:	e5803014 	str	r3, [r0, #20]
:   Cyg_HardwareThread(entry, entry_data, stack_size, stack_base),
    Cyg_SchedThread(this, sched_info)
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    ,timer(this)
    3bc8:	e1a02001 	mov	r2, r1
#ifdef CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT
    saved_context = 0;
    3bcc:	e5804018 	str	r4, [r0, #24]
	// almost certainly be overwritten the instant the thread starts
	// anyway.
    }
#endif
    stack_base = s_base;
    stack_size = s_size;
    3bd0:	e5805004 	str	r5, [r0, #4]
    3bd4:	e1a01000 	mov	r1, r0
    3bd8:	e280001c 	add	r0, r0, #28	; 0x1c
    3bdc:	eb000776 	bl	59bc <_ZN15Cyg_SchedThreadC2EP10Cyg_Threadj>
    Cyg_Thread  *th
    )
    : Cyg_Alarm(Cyg_Clock::real_time_clock,
                &alarm,
                CYG_ADDRWORD(this)
                )
    3be0:	e59f3138 	ldr	r3, [pc, #312]	; 3d20 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x184>
    3be4:	e2860050 	add	r0, r6, #80	; 0x50
    3be8:	e5931000 	ldr	r1, [r3]
    3bec:	e59f2130 	ldr	r2, [pc, #304]	; 3d24 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x188>
    3bf0:	e1a03000 	mov	r3, r0
    3bf4:	eb002bb0 	bl	eabc <_ZN9Cyg_AlarmC2EP11Cyg_CounterPFvPS_jEj>
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    3bf8:	e59fc128 	ldr	ip, [pc, #296]	; 3d28 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x18c>
    CYG_REPORT_FUNCTION();

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    3bfc:	e3a03004 	mov	r3, #4	; 0x4
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    3c00:	e1dc10b0 	ldrh	r1, [ip]
    CYG_REPORT_FUNCTION();

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    3c04:	e586303c 	str	r3, [r6, #60]
    for (int j=0; j<CYGNUM_KERNEL_THREADS_DESTRUCTORS; j++) {
        destructors[j].fn = NULL;
    }
#endif
#ifdef CYGVAR_KERNEL_THREADS_NAME
    name = name_arg;
    3c08:	e59d3010 	ldr	r3, [sp, #16]
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    3c0c:	e2810001 	add	r0, r1, #1	; 0x1

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    suspend_count       = 1;
    3c10:	e3a02001 	mov	r2, #1	; 0x1
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    3c14:	e1c614bc 	strh	r1, [r6, #76]

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    suspend_count       = 1;
    3c18:	e5862040 	str	r2, [r6, #64]
    unique_id           = next_unique_id++;

#ifdef CYGVAR_KERNEL_THREADS_DATA
    // Zero all per-thread data entries.
    for( int i = 0; i < CYGNUM_KERNEL_THREADS_DATA_MAX; i++ )
        thread_data[i] = 0;
    3c1c:	e5864098 	str	r4, [r6, #152]
    for (int j=0; j<CYGNUM_KERNEL_THREADS_DESTRUCTORS; j++) {
        destructors[j].fn = NULL;
    }
#endif
#ifdef CYGVAR_KERNEL_THREADS_NAME
    name = name_arg;
    3c20:	e586309c 	str	r3, [r6, #156]
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    3c24:	e1cc00b0 	strh	r0, [ip]
{
    thread = th;
    3c28:	e586607c 	str	r6, [r6, #124]
    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    suspend_count       = 1;
    wakeup_count        = 0;
    3c2c:	e5864044 	str	r4, [r6, #68]

    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    3c30:	e5c64080 	strb	r4, [r6, #128]
    wake_reason         = NONE;
    3c34:	e5c64081 	strb	r4, [r6, #129]
    unique_id           = next_unique_id++;

#ifdef CYGVAR_KERNEL_THREADS_DATA
    // Zero all per-thread data entries.
    for( int i = 0; i < CYGNUM_KERNEL_THREADS_DATA_MAX; i++ )
        thread_data[i] = 0;
    3c38:	e5864084 	str	r4, [r6, #132]
    3c3c:	e5864088 	str	r4, [r6, #136]
    3c40:	e586408c 	str	r4, [r6, #140]
    3c44:	e5864090 	str	r4, [r6, #144]
    3c48:	e5864094 	str	r4, [r6, #148]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3c4c:	e59f00d8 	ldr	r0, [pc, #216]	; 3d2c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x190>
    3c50:	e5903000 	ldr	r3, [r0]
    3c54:	e0833002 	add	r3, r3, r2
    3c58:	e5803000 	str	r3, [r0]
Cyg_Thread::add_to_list( void )
{
    // Add thread to housekeeping list
    Cyg_Scheduler::lock();

    if( thread_list == 0 )
    3c5c:	e59fc0cc 	ldr	ip, [pc, #204]	; 3d30 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x194>
    3c60:	e59c2000 	ldr	r2, [ip]
    3c64:	e1520004 	cmp	r2, r4
        list_next = this;
    3c68:	058660a0 	streq	r6, [r6, #160]
Cyg_Thread::add_to_list( void )
{
    // Add thread to housekeeping list
    Cyg_Scheduler::lock();

    if( thread_list == 0 )
    3c6c:	0a00000c 	beq	3ca4 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x108>
        list_next = this;
    else {
        Cyg_Thread *prev = thread_list;
        do {
            if ( this == prev )
    3c70:	e1560002 	cmp	r6, r2
    3c74:	0a00000a 	beq	3ca4 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x108>
                break; // found it already!
            prev = prev->list_next;
    3c78:	e59210a0 	ldr	r1, [r2, #160]

    if( thread_list == 0 )
        list_next = this;
    else {
        Cyg_Thread *prev = thread_list;
        do {
    3c7c:	e1520001 	cmp	r2, r1
    3c80:	11a03001 	movne	r3, r1
    3c84:	0a000004 	beq	3c9c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x100>
            if ( this == prev )
    3c88:	e1560003 	cmp	r6, r3
    3c8c:	0a000004 	beq	3ca4 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x108>
                break; // found it already!
            prev = prev->list_next;
    3c90:	e59330a0 	ldr	r3, [r3, #160]

    if( thread_list == 0 )
        list_next = this;
    else {
        Cyg_Thread *prev = thread_list;
        do {
    3c94:	e1520003 	cmp	r2, r3
    3c98:	1afffffa 	bne	3c88 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0xec>
                break; // found it already!
            prev = prev->list_next;
        } while ( prev != thread_list );
        if ( this != prev ) {
            // insert it in the list:
            list_next = thread_list->list_next;
    3c9c:	e58610a0 	str	r1, [r6, #160]
            thread_list->list_next = this;
    3ca0:	e58260a0 	str	r6, [r2, #160]
        }
    }
    thread_list = this;
    3ca4:	e58c6000 	str	r6, [ip]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3ca8:	e5903000 	ldr	r3, [r0]
    3cac:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3cb0:	159f3074 	ldrne	r3, [pc, #116]	; 3d2c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x190>
    3cb4:	15830000 	strne	r0, [r3]
    3cb8:	0a000016 	beq	3d18 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x17c>
#ifdef CYGVAR_KERNEL_THREADS_LIST
    // Add thread to housekeeping list
    add_to_list();
#endif    
    
    Cyg_Scheduler::scheduler.register_thread(this);
    3cbc:	e59f0070 	ldr	r0, [pc, #112]	; 3d34 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x198>
    3cc0:	e1a01006 	mov	r1, r6
    3cc4:	eb0005b0 	bl	538c <_ZN28Cyg_Scheduler_Implementation15register_threadEP10Cyg_Thread>
#ifdef CYGPKG_INFRA_DEBUG
    cyg_uint32 threadid = thread->get_unique_id()*0x01010000;
#else
    cyg_uint32 threadid = 0x11110000;
#endif
    HAL_THREAD_INIT_CONTEXT( stack_ptr, thread, thread_entry, threadid );
    3cc8:	e596300c 	ldr	r3, [r6, #12]
    3ccc:	e3c3000f 	bic	r0, r3, #15	; 0xf
    3cd0:	e2401050 	sub	r1, r0, #80	; 0x50
    3cd4:	e3a02000 	mov	r2, #0	; 0x0
    3cd8:	e3823411 	orr	r3, r2, #285212672	; 0x11000000
    3cdc:	e3833811 	orr	r3, r3, #1114112	; 0x110000
    3ce0:	e7813102 	str	r3, [r1, r2, lsl #2]
    3ce4:	e2822001 	add	r2, r2, #1	; 0x1
    3ce8:	e352000b 	cmp	r2, #11	; 0xb
    3cec:	1afffff9 	bne	3cd8 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x13c>
    3cf0:	e59f2040 	ldr	r2, [pc, #64]	; 3d38 <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x19c>
    3cf4:	e3a03013 	mov	r3, #19	; 0x13
    3cf8:	e5810034 	str	r0, [r1, #52]
    3cfc:	e5006050 	str	r6, [r0, #-80]
    3d00:	e581203c 	str	r2, [r1, #60]
    3d04:	e5813040 	str	r3, [r1, #64]
    3d08:	e5812038 	str	r2, [r1, #56]
    
    init_context(this);

    CYG_REPORT_RETURN();
}
    3d0c:	e1a00006 	mov	r0, r6
    3d10:	e586100c 	str	r1, [r6, #12]
    3d14:	e8bd8070 	pop	{r4, r5, r6, pc}
    3d18:	eb00073f 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3d1c:	eaffffe6 	b	3cbc <_ZN10Cyg_ThreadC1EjPFvjEjPcjj+0x120>
    3d20:	400046bc 	.word	0x400046bc
    3d24:	00004b08 	.word	0x00004b08
    3d28:	400007c4 	.word	0x400007c4
    3d2c:	400007c8 	.word	0x400007c8
    3d30:	40001c64 	.word	0x40001c64
    3d34:	40002540 	.word	0x40002540
    3d38:	00003ad4 	.word	0x00003ad4

00003d3c <_ZN10Cyg_Thread12reinitializeEv>:
// Re-initialize this thread.
// We do this by re-invoking the constructor with the original
// arguments, which are still available in the object.

void
Cyg_Thread::reinitialize()
    3d3c:	e92d4030 	push	{r4, r5, lr}
    3d40:	e1a05000 	mov	r5, r0
    3d44:	e24dd014 	sub	sp, sp, #20	; 0x14
    CYG_ASSERT( get_current_queue() == NULL , "Thread is still on a queue");

#ifdef CYGFUN_KERNEL_THREADS_TIMER
    // Clear the timeout. It is irrelevant whether there was
    // actually a timeout pending.
    timer.disable();
    3d48:	e2800050 	add	r0, r0, #80	; 0x50
    3d4c:	eb002cfe 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
#endif

    // Ensure the scheduler has let go of us.
    Cyg_Scheduler::scheduler.deregister_thread(this);
    3d50:	e1a01005 	mov	r1, r5
    3d54:	e59f0040 	ldr	r0, [pc, #64]	; 3d9c <_ZN10Cyg_Thread12reinitializeEv+0x60>
    3d58:	eb00058c 	bl	5390 <_ZN28Cyg_Scheduler_Implementation17deregister_threadEP10Cyg_Thread>
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_SIMPLE

    // If we have an inherited priority, return our original
    // priority rather than the current one.
    
    if( priority_inherited ) return original_priority;
    3d5c:	e5953038 	ldr	r3, [r5, #56]
    3d60:	e3530000 	cmp	r3, #0	; 0x0
    3d64:	15951034 	ldrne	r1, [r5, #52]

#endif

    return priority;
    3d68:	05951024 	ldreq	r1, [r5, #36]

    cyg_priority pri = get_priority();
#ifdef CYGVAR_KERNEL_THREADS_NAME
    char * name_arg = name;
    3d6c:	e595e09c 	ldr	lr, [r5, #156]
#endif
    
    new(this) Cyg_Thread( pri,
                          entry_point, entry_data,
                          name_arg,
                          get_stack_base(), get_stack_size() );
    3d70:	e595c000 	ldr	ip, [r5]
    3d74:	e5954004 	ldr	r4, [r5, #4]
    3d78:	e2852010 	add	r2, r5, #16	; 0x10
    3d7c:	e892000c 	ldm	r2, {r2, r3}
    3d80:	e1a00005 	mov	r0, r5
    3d84:	e58de000 	str	lr, [sp]
    3d88:	e58dc004 	str	ip, [sp, #4]
    3d8c:	e58d4008 	str	r4, [sp, #8]
    3d90:	ebffff81 	bl	3b9c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj>
    // the constructor re-registers the thread with the scheduler.

    CYG_ASSERTCLASS( this, "Thread corrupted by reinitialize");    

    CYG_REPORT_RETURN();
}
    3d94:	e28dd014 	add	sp, sp, #20	; 0x14
    3d98:	e8bd8030 	pop	{r4, r5, pc}
    3d9c:	40002540 	.word	0x40002540

00003da0 <_ZN10Cyg_Thread7suspendEv>:
// -------------------------------------------------------------------------
// Suspend thread. Increment suspend count and deschedule thread
// if still running.

void
Cyg_Thread::suspend()
    3da0:	e92d4030 	push	{r4, r5, lr}
    3da4:	e1a04000 	mov	r4, r0
    3da8:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3dac:	e59f505c 	ldr	r5, [pc, #92]	; 3e10 <_ZN10Cyg_Thread7suspendEv+0x70>
    3db0:	e5953000 	ldr	r3, [r5]
    3db4:	e2833001 	add	r3, r3, #1	; 0x1
    3db8:	e5853000 	str	r3, [r5]
    CYG_INSTRUMENT_THREAD(SUSPEND,this,Cyg_Scheduler::current_thread);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    suspend_count++;
    3dbc:	e280203c 	add	r2, r0, #60	; 0x3c
    3dc0:	e892000c 	ldm	r2, {r2, r3}
    3dc4:	e2833001 	add	r3, r3, #1	; 0x1
    CYG_ASSERT( CYGNUM_KERNEL_MAX_SUSPEND_COUNT_ASSERT > suspend_count,
                "suspend_count overflow" );
#endif

    // If running, remove from run qs
    if( state == RUNNING )
    3dc8:	e3520000 	cmp	r2, #0	; 0x0
    CYG_INSTRUMENT_THREAD(SUSPEND,this,Cyg_Scheduler::current_thread);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    suspend_count++;
    3dcc:	e5803040 	str	r3, [r0, #64]
    CYG_ASSERT( CYGNUM_KERNEL_MAX_SUSPEND_COUNT_ASSERT > suspend_count,
                "suspend_count overflow" );
#endif

    // If running, remove from run qs
    if( state == RUNNING )
    3dd0:	1a000003 	bne	3de4 <_ZN10Cyg_Thread7suspendEv+0x44>
        Cyg_Scheduler::scheduler.rem_thread(this);
    3dd4:	e59f0038 	ldr	r0, [pc, #56]	; 3e14 <_ZN10Cyg_Thread7suspendEv+0x74>
    3dd8:	e1a01004 	mov	r1, r4
    3ddc:	eb00052e 	bl	529c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread>
    3de0:	e594203c 	ldr	r2, [r4, #60]

    // Set the state
    state |= SUSPENDED;
    3de4:	e3823004 	orr	r3, r2, #4	; 0x4
    3de8:	e584303c 	str	r3, [r4, #60]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3dec:	e5953000 	ldr	r3, [r5]
    3df0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3df4:	159f3014 	ldrne	r3, [pc, #20]	; 3e10 <_ZN10Cyg_Thread7suspendEv+0x70>
    3df8:	15830000 	strne	r0, [r3]
    3dfc:	0a000001 	beq	3e08 <_ZN10Cyg_Thread7suspendEv+0x68>
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    3e00:	e28dd004 	add	sp, sp, #4	; 0x4
    3e04:	e8bd8030 	pop	{r4, r5, pc}
    3e08:	eb000703 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3e0c:	eafffffb 	b	3e00 <_ZN10Cyg_Thread7suspendEv+0x60>
    3e10:	400007c8 	.word	0x400007c8
    3e14:	40002540 	.word	0x40002540

00003e18 <_ZN10Cyg_Thread5sleepEv>:
// Put the thread to sleep.
// This can only be called by the current thread on itself, hence
// it is a static function.

void
Cyg_Thread::sleep()
    3e18:	e92d4030 	push	{r4, r5, lr}
    3e1c:	e59f305c 	ldr	r3, [pc, #92]	; 3e80 <_ZN10Cyg_Thread5sleepEv+0x68>
    3e20:	e24dd004 	sub	sp, sp, #4	; 0x4
    3e24:	e5934000 	ldr	r4, [r3]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3e28:	e59f5054 	ldr	r5, [pc, #84]	; 3e84 <_ZN10Cyg_Thread5sleepEv+0x6c>
    3e2c:	e5953000 	ldr	r3, [r5]
    3e30:	e2833001 	add	r3, r3, #1	; 0x1
    3e34:	e5853000 	str	r3, [r5]
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    // If running, remove from run qs
    if ( current->state == RUNNING )
    3e38:	e594303c 	ldr	r3, [r4, #60]
    3e3c:	e3530000 	cmp	r3, #0	; 0x0
    3e40:	1a000003 	bne	3e54 <_ZN10Cyg_Thread5sleepEv+0x3c>
        Cyg_Scheduler::scheduler.rem_thread(current);
    3e44:	e59f003c 	ldr	r0, [pc, #60]	; 3e88 <_ZN10Cyg_Thread5sleepEv+0x70>
    3e48:	e1a01004 	mov	r1, r4
    3e4c:	eb000512 	bl	529c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread>
    3e50:	e594303c 	ldr	r3, [r4, #60]

    // Set the state
    current->state |= SLEEPING;
    3e54:	e3833001 	orr	r3, r3, #1	; 0x1
    3e58:	e584303c 	str	r3, [r4, #60]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3e5c:	e5953000 	ldr	r3, [r5]
    3e60:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3e64:	159f3018 	ldrne	r3, [pc, #24]	; 3e84 <_ZN10Cyg_Thread5sleepEv+0x6c>
    3e68:	15830000 	strne	r0, [r3]
    3e6c:	0a000001 	beq	3e78 <_ZN10Cyg_Thread5sleepEv+0x60>

    // Unlock the scheduler and switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    3e70:	e28dd004 	add	sp, sp, #4	; 0x4
    3e74:	e8bd8030 	pop	{r4, r5, pc}
    3e78:	eb0006e7 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3e7c:	eafffffb 	b	3e70 <_ZN10Cyg_Thread5sleepEv+0x58>
    3e80:	40002538 	.word	0x40002538
    3e84:	400007c8 	.word	0x400007c8
    3e88:	40002540 	.word	0x40002540

00003e8c <_ZN10Cyg_Thread5delayEy>:

// -------------------------------------------------------------------------
// Thread delay function

void
Cyg_Thread::delay( cyg_tick_count delay)
    3e8c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    3e90:	e1a09000 	mov	r9, r0
    3e94:	e24dd008 	sub	sp, sp, #8	; 0x8
    3e98:	e1a06002 	mov	r6, r2
    3e9c:	e1a07003 	mov	r7, r3
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3ea0:	e59fa0a0 	ldr	sl, [pc, #160]	; 3f48 <_ZN10Cyg_Thread5delayEy+0xbc>
    3ea4:	e59a3000 	ldr	r3, [sl]
    3ea8:	e2833001 	add	r3, r3, #1	; 0x1
    3eac:	e58a3000 	str	r3, [sl]
    CYG_INSTRUMENT_THREAD(DELAY,this,delay);

    // Prevent preemption
    Cyg_Scheduler::lock();
    
    sleep();
    3eb0:	ebffffd8 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>

    set_timer( Cyg_Clock::real_time_clock->current_value()+delay, DELAY );
    3eb4:	e59f3090 	ldr	r3, [pc, #144]	; 3f4c <_ZN10Cyg_Thread5delayEy+0xc0>
    3eb8:	e59f8090 	ldr	r8, [pc, #144]	; 3f50 <_ZN10Cyg_Thread5delayEy+0xc4>
    3ebc:	e5932000 	ldr	r2, [r3]
    3ec0:	e2824008 	add	r4, r2, #8	; 0x8
    3ec4:	e8940030 	ldm	r4, {r4, r5}
    3ec8:	e5981000 	ldr	r1, [r8]
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    3ecc:	e598c000 	ldr	ip, [r8]
    3ed0:	e3a02000 	mov	r2, #0	; 0x0
    3ed4:	e5980000 	ldr	r0, [r8]
    3ed8:	e5cc2081 	strb	r2, [ip, #129]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    3edc:	e3a03002 	mov	r3, #2	; 0x2
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    3ee0:	e0962004 	adds	r2, r6, r4
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    3ee4:	e5c13080 	strb	r3, [r1, #128]
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    3ee8:	e2800050 	add	r0, r0, #80	; 0x50
    3eec:	e0a73005 	adc	r3, r7, r5
    3ef0:	e3a04000 	mov	r4, #0	; 0x0
    3ef4:	e3a05000 	mov	r5, #0	; 0x0
    3ef8:	e88d0030 	stm	sp, {r4, r5}
    3efc:	eb002bfb 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3f00:	e59a3000 	ldr	r3, [sl]
    3f04:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3f08:	158a0000 	strne	r0, [sl]
    3f0c:	0a00000b 	beq	3f40 <_ZN10Cyg_Thread5delayEy+0xb4>
    3f10:	e5980000 	ldr	r0, [r8]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    3f14:	e2800050 	add	r0, r0, #80	; 0x50
    3f18:	eb002c8b 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    // Clear the timeout. It is irrelevant whether the alarm has
    // actually gone off or not.
    clear_timer();

    // and deal with anything else we must do when we return
    switch( wake_reason ) {
    3f1c:	e5d93081 	ldrb	r3, [r9, #129]
    3f20:	e2433005 	sub	r3, r3, #5	; 0x5
    3f24:	e3530001 	cmp	r3, #1	; 0x1
    3f28:	8a000002 	bhi	3f38 <_ZN10Cyg_Thread5delayEy+0xac>
    default:
        break;
    }
#endif
    CYG_REPORT_RETURN();
}
    3f2c:	e28dd008 	add	sp, sp, #8	; 0x8
    3f30:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}

    // and deal with anything else we must do when we return
    switch( wake_reason ) {
    case DESTRUCT:
    case EXIT:            
        exit();
    3f34:	eafffecc 	b	3a6c <_ZN10Cyg_Thread4exitEv>
    default:
        break;
    }
#endif
    CYG_REPORT_RETURN();
}
    3f38:	e28dd008 	add	sp, sp, #8	; 0x8
    3f3c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    3f40:	eb0006b5 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    3f44:	eafffff1 	b	3f10 <_ZN10Cyg_Thread5delayEy+0x84>
    3f48:	400007c8 	.word	0x400007c8
    3f4c:	400046bc 	.word	0x400046bc
    3f50:	40002538 	.word	0x40002538

00003f54 <_ZN10Cyg_Thread13counted_sleepEy>:
// This can only be called by the current thread on itself, hence
// it is a static function.

#ifdef CYGFUN_KERNEL_THREADS_TIMER
void
Cyg_Thread::counted_sleep( cyg_tick_count delay )
    3f54:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f58:	e59fa0f8 	ldr	sl, [pc, #248]	; 4058 <_ZN10Cyg_Thread13counted_sleepEy+0x104>
    3f5c:	e24dd00c 	sub	sp, sp, #12	; 0xc
    3f60:	e1a07000 	mov	r7, r0
    3f64:	e1a08001 	mov	r8, r1
    3f68:	e59a6000 	ldr	r6, [sl]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    3f6c:	e59f90e8 	ldr	r9, [pc, #232]	; 405c <_ZN10Cyg_Thread13counted_sleepEy+0x108>
    3f70:	e5993000 	ldr	r3, [r9]
    3f74:	e2833001 	add	r3, r3, #1	; 0x1
    3f78:	e5893000 	str	r3, [r9]
    CYG_INSTRUMENT_THREAD(SLEEP,current,0);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == current->wakeup_count ) {
    3f7c:	e596c044 	ldr	ip, [r6, #68]
    3f80:	e35c0000 	cmp	ip, #0	; 0x0
            clear_timer();
        }
    }
    else
        // there is a queued wakeup, do not sleep
        current->wakeup_count--;
    3f84:	124c3001 	subne	r3, ip, #1	; 0x1
    3f88:	15863044 	strne	r3, [r6, #68]
    CYG_INSTRUMENT_THREAD(SLEEP,current,0);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == current->wakeup_count ) {
    3f8c:	0a00000d 	beq	3fc8 <_ZN10Cyg_Thread13counted_sleepEy+0x74>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    3f90:	e5993000 	ldr	r3, [r9]
    3f94:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    3f98:	159f30bc 	ldrne	r3, [pc, #188]	; 405c <_ZN10Cyg_Thread13counted_sleepEy+0x108>
    3f9c:	15830000 	strne	r0, [r3]
    3fa0:	0a00002a 	beq	4050 <_ZN10Cyg_Thread13counted_sleepEy+0xfc>

    // Unlock the scheduler and switch threads
    Cyg_Scheduler::unlock();

    // and deal with anything we must do when we return
    switch( current->wake_reason ) {
    3fa4:	e5d63081 	ldrb	r3, [r6, #129]
    3fa8:	e2433005 	sub	r3, r3, #5	; 0x5
    3fac:	e3530001 	cmp	r3, #1	; 0x1
    3fb0:	8a000002 	bhi	3fc0 <_ZN10Cyg_Thread13counted_sleepEy+0x6c>
    default:
        break;
    }

    CYG_REPORT_RETURN();
}
    3fb4:	e28dd00c 	add	sp, sp, #12	; 0xc
    3fb8:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    // and deal with anything we must do when we return
    switch( current->wake_reason ) {
    case DESTRUCT:
    case EXIT:            
        current->exit();
    3fbc:	eafffeaa 	b	3a6c <_ZN10Cyg_Thread4exitEv>
    default:
        break;
    }

    CYG_REPORT_RETURN();
}
    3fc0:	e28dd00c 	add	sp, sp, #12	; 0xc
    3fc4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if ( 0 == current->wakeup_count ) {

        // Set the timer (once outside any waiting loop.)
        set_timer( Cyg_Clock::real_time_clock->current_value()+delay,
                         Cyg_Thread::TIMEOUT  );
    3fc8:	e59f3090 	ldr	r3, [pc, #144]	; 4060 <_ZN10Cyg_Thread13counted_sleepEy+0x10c>
    3fcc:	e5932000 	ldr	r2, [r3]
    3fd0:	e2824008 	add	r4, r2, #8	; 0x8
    3fd4:	e8940030 	ldm	r4, {r4, r5}
    3fd8:	e59a1000 	ldr	r1, [sl]
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    3fdc:	e59a3000 	ldr	r3, [sl]
    3fe0:	e59a0000 	ldr	r0, [sl]
    3fe4:	e0972004 	adds	r2, r7, r4
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    3fe8:	e3a0b003 	mov	fp, #3	; 0x3
    self()->wake_reason = NONE;
    3fec:	e5c3c081 	strb	ip, [r3, #129]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    3ff0:	e5c1b080 	strb	fp, [r1, #128]
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    3ff4:	e0a83005 	adc	r3, r8, r5
    3ff8:	e2800050 	add	r0, r0, #80	; 0x50
    3ffc:	e3a04000 	mov	r4, #0	; 0x0
    4000:	e3a05000 	mov	r5, #0	; 0x0
    4004:	e88d0030 	stm	sp, {r4, r5}
    4008:	eb002bb8 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>

        // If the timeout is in the past, the wake reason will have been
        // set to something other than NONE already.
    
        if( current->get_wake_reason() == Cyg_Thread::NONE )
    400c:	e5d61081 	ldrb	r1, [r6, #129]
    4010:	e3510000 	cmp	r1, #0	; 0x0
    4014:	1affffdd 	bne	3f90 <_ZN10Cyg_Thread13counted_sleepEy+0x3c>
    4018:	e59a3000 	ldr	r3, [sl]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    401c:	e59a2000 	ldr	r2, [sl]
    4020:	e5c3b080 	strb	fp, [r3, #128]
    self()->wake_reason = NONE;
    4024:	e5c21081 	strb	r1, [r2, #129]
        {
            set_sleep_reason( Cyg_Thread::TIMEOUT );
            current->sleep();               // prepare to sleep
    4028:	ebffff7a 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
            current->state |= COUNTSLEEP;   // Set the state
    402c:	e596303c 	ldr	r3, [r6, #60]
    4030:	e3833002 	orr	r3, r3, #2	; 0x2
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4034:	e5990000 	ldr	r0, [r9]
    4038:	e586303c 	str	r3, [r6, #60]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    403c:	eb000676 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    4040:	e59a0000 	ldr	r0, [sl]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    4044:	e2800050 	add	r0, r0, #80	; 0x50
    4048:	eb002c3f 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    404c:	eaffffcf 	b	3f90 <_ZN10Cyg_Thread13counted_sleepEy+0x3c>
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4050:	eb000671 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    4054:	eaffffd2 	b	3fa4 <_ZN10Cyg_Thread13counted_sleepEy+0x50>
    4058:	40002538 	.word	0x40002538
    405c:	400007c8 	.word	0x400007c8
    4060:	400046bc 	.word	0x400046bc

00004064 <_ZN10Cyg_Thread13counted_sleepEv>:
// Put the thread to sleep, with wakeup count.
// This can only be called by the current thread on itself, hence
// it is a static function.

void
Cyg_Thread::counted_sleep()
    4064:	e92d4030 	push	{r4, r5, lr}
    4068:	e59f10a0 	ldr	r1, [pc, #160]	; 4110 <_ZN10Cyg_Thread13counted_sleepEv+0xac>
    406c:	e24dd004 	sub	sp, sp, #4	; 0x4
    4070:	e5914000 	ldr	r4, [r1]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4074:	e59f5098 	ldr	r5, [pc, #152]	; 4114 <_ZN10Cyg_Thread13counted_sleepEv+0xb0>
    4078:	e5953000 	ldr	r3, [r5]
    407c:	e2833001 	add	r3, r3, #1	; 0x1
    4080:	e5853000 	str	r3, [r5]
    CYG_INSTRUMENT_THREAD(SLEEP,current,0);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == current->wakeup_count ) {
    4084:	e5940044 	ldr	r0, [r4, #68]
    4088:	e3500000 	cmp	r0, #0	; 0x0
        current->sleep();               // prepare to sleep
        current->state |= COUNTSLEEP;   // Set the state
    }
    else
        // there is a queued wakeup, do not sleep
        current->wakeup_count--;
    408c:	12403001 	subne	r3, r0, #1	; 0x1
    4090:	15843044 	strne	r3, [r4, #68]
    CYG_INSTRUMENT_THREAD(SLEEP,current,0);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == current->wakeup_count ) {
    4094:	0a00000d 	beq	40d0 <_ZN10Cyg_Thread13counted_sleepEv+0x6c>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4098:	e5953000 	ldr	r3, [r5]
    409c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    40a0:	159f306c 	ldrne	r3, [pc, #108]	; 4114 <_ZN10Cyg_Thread13counted_sleepEv+0xb0>
    40a4:	15830000 	strne	r0, [r3]
    40a8:	0a000016 	beq	4108 <_ZN10Cyg_Thread13counted_sleepEv+0xa4>

    // Unlock the scheduler and switch threads
    Cyg_Scheduler::unlock();

    // and deal with anything we must do when we return
    switch( current->wake_reason ) {
    40ac:	e5d43081 	ldrb	r3, [r4, #129]
    40b0:	e2433005 	sub	r3, r3, #5	; 0x5
    40b4:	e3530001 	cmp	r3, #1	; 0x1
    40b8:	8a000002 	bhi	40c8 <_ZN10Cyg_Thread13counted_sleepEv+0x64>
    default:
        break;
    }

    CYG_REPORT_RETURN();
}
    40bc:	e28dd004 	add	sp, sp, #4	; 0x4
    40c0:	e8bd4030 	pop	{r4, r5, lr}

    // and deal with anything we must do when we return
    switch( current->wake_reason ) {
    case DESTRUCT:
    case EXIT:            
        current->exit();
    40c4:	eafffe68 	b	3a6c <_ZN10Cyg_Thread4exitEv>
    default:
        break;
    }

    CYG_REPORT_RETURN();
}
    40c8:	e28dd004 	add	sp, sp, #4	; 0x4
    40cc:	e8bd8030 	pop	{r4, r5, pc}
    40d0:	e5912000 	ldr	r2, [r1]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    40d4:	e5911000 	ldr	r1, [r1]
    40d8:	e3a03001 	mov	r3, #1	; 0x1
    40dc:	e5c23080 	strb	r3, [r2, #128]
    self()->wake_reason = NONE;
    40e0:	e5c10081 	strb	r0, [r1, #129]
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == current->wakeup_count ) {
        set_sleep_reason( Cyg_Thread::WAIT );
        current->sleep();               // prepare to sleep
    40e4:	ebffff4b 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
        current->state |= COUNTSLEEP;   // Set the state
    40e8:	e594303c 	ldr	r3, [r4, #60]
    40ec:	e3833002 	orr	r3, r3, #2	; 0x2
    40f0:	e584303c 	str	r3, [r4, #60]
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    40f4:	e5953000 	ldr	r3, [r5]
    40f8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    40fc:	159f3010 	ldrne	r3, [pc, #16]	; 4114 <_ZN10Cyg_Thread13counted_sleepEv+0xb0>
    4100:	15830000 	strne	r0, [r3]
    4104:	1affffe8 	bne	40ac <_ZN10Cyg_Thread13counted_sleepEv+0x48>
    4108:	eb000643 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    410c:	eaffffe6 	b	40ac <_ZN10Cyg_Thread13counted_sleepEv+0x48>
    4110:	40002538 	.word	0x40002538
    4114:	400007c8 	.word	0x400007c8

00004118 <_ZN10Cyg_Thread12force_resumeEv>:

// -------------------------------------------------------------------------
// Forced Resume thread.  Zero suspend count and reschedule...

void
Cyg_Thread::force_resume()
    4118:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    411c:	e59f4060 	ldr	r4, [pc, #96]	; 4184 <_ZN10Cyg_Thread12force_resumeEv+0x6c>
    4120:	e5943000 	ldr	r3, [r4]
    4124:	e2833001 	add	r3, r3, #1	; 0x1
    4128:	e5843000 	str	r3, [r4]
    Cyg_Scheduler::lock();

    // If we are about to zero the count, clear the state bit and
    // reschedule the thread if possible.
    
    if ( 0 < suspend_count ) {
    412c:	e5903040 	ldr	r3, [r0, #64]
    4130:	e3530000 	cmp	r3, #0	; 0x0
    4134:	0a000006 	beq	4154 <_ZN10Cyg_Thread12force_resumeEv+0x3c>
        suspend_count = 0;

        CYG_ASSERT( (state & SUSPENDED) != 0, "SUSPENDED bit not set" );
        
        // Set the state
        state &= ~SUSPENDED;
    4138:	e590303c 	ldr	r3, [r0, #60]
    413c:	e3c33004 	bic	r3, r3, #4	; 0x4

    // If we are about to zero the count, clear the state bit and
    // reschedule the thread if possible.
    
    if ( 0 < suspend_count ) {
        suspend_count = 0;
    4140:	e3a02000 	mov	r2, #0	; 0x0
        
        // Set the state
        state &= ~SUSPENDED;

        // Return thread to scheduler if runnable
        if( state == RUNNING )
    4144:	e3530000 	cmp	r3, #0	; 0x0

    // If we are about to zero the count, clear the state bit and
    // reschedule the thread if possible.
    
    if ( 0 < suspend_count ) {
        suspend_count = 0;
    4148:	e5802040 	str	r2, [r0, #64]

        CYG_ASSERT( (state & SUSPENDED) != 0, "SUSPENDED bit not set" );
        
        // Set the state
        state &= ~SUSPENDED;
    414c:	e580303c 	str	r3, [r0, #60]

        // Return thread to scheduler if runnable
        if( state == RUNNING )
    4150:	0a000007 	beq	4174 <_ZN10Cyg_Thread12force_resumeEv+0x5c>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4154:	e5943000 	ldr	r3, [r4]
    4158:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    415c:	159f3020 	ldrne	r3, [pc, #32]	; 4184 <_ZN10Cyg_Thread12force_resumeEv+0x6c>
    4160:	15830000 	strne	r0, [r3]
    4164:	0a000000 	beq	416c <_ZN10Cyg_Thread12force_resumeEv+0x54>
    }

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();
    CYG_REPORT_RETURN();
}
    4168:	e8bd8010 	pop	{r4, pc}
    416c:	eb00062a 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    4170:	e8bd8010 	pop	{r4, pc}
        // Set the state
        state &= ~SUSPENDED;

        // Return thread to scheduler if runnable
        if( state == RUNNING )
            Cyg_Scheduler::scheduler.add_thread(this);
    4174:	e1a01000 	mov	r1, r0
    4178:	e59f0008 	ldr	r0, [pc, #8]	; 4188 <_ZN10Cyg_Thread12force_resumeEv+0x70>
    417c:	eb0004fe 	bl	557c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread>
    4180:	eafffff3 	b	4154 <_ZN10Cyg_Thread12force_resumeEv+0x3c>
    4184:	400007c8 	.word	0x400007c8
    4188:	40002540 	.word	0x40002540

0000418c <_ZN10Cyg_Thread6resumeEv>:
// -------------------------------------------------------------------------
// Resume thread. Decrement suspend count and reschedule if it
// is zero.

void
Cyg_Thread::resume()
    418c:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4190:	e59f406c 	ldr	r4, [pc, #108]	; 4204 <_ZN10Cyg_Thread6resumeEv+0x78>
    4194:	e5943000 	ldr	r3, [r4]
    4198:	e2833001 	add	r3, r3, #1	; 0x1
    419c:	e5843000 	str	r3, [r4]
    Cyg_Scheduler::lock();

    // If we are about to zero the count, clear the state bit and
    // reschedule the thread if possible.
    
    if( suspend_count == 1 )
    41a0:	e5903040 	ldr	r3, [r0, #64]
    41a4:	e3530001 	cmp	r3, #1	; 0x1
    41a8:	0a000008 	beq	41d0 <_ZN10Cyg_Thread6resumeEv+0x44>
        // Return thread to scheduler if runnable
        if( state == RUNNING )
            Cyg_Scheduler::scheduler.add_thread(this);
    }
    else
        if( suspend_count > 0 )
    41ac:	e3530000 	cmp	r3, #0	; 0x0
            suspend_count--;
    41b0:	12433001 	subne	r3, r3, #1	; 0x1
    41b4:	15803040 	strne	r3, [r0, #64]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    41b8:	e5943000 	ldr	r3, [r4]
    41bc:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    41c0:	159f303c 	ldrne	r3, [pc, #60]	; 4204 <_ZN10Cyg_Thread6resumeEv+0x78>
    41c4:	15830000 	strne	r0, [r3]
    41c8:	0a00000b 	beq	41fc <_ZN10Cyg_Thread6resumeEv+0x70>

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    41cc:	e8bd8010 	pop	{r4, pc}
        suspend_count = 0;

        CYG_ASSERT( (state & SUSPENDED) != 0, "SUSPENDED bit not set" );
        
        // Set the state
        state &= ~SUSPENDED;
    41d0:	e590303c 	ldr	r3, [r0, #60]
    41d4:	e3c33004 	bic	r3, r3, #4	; 0x4
    // If we are about to zero the count, clear the state bit and
    // reschedule the thread if possible.
    
    if( suspend_count == 1 )
    {
        suspend_count = 0;
    41d8:	e3a02000 	mov	r2, #0	; 0x0
        
        // Set the state
        state &= ~SUSPENDED;

        // Return thread to scheduler if runnable
        if( state == RUNNING )
    41dc:	e3530000 	cmp	r3, #0	; 0x0
    // If we are about to zero the count, clear the state bit and
    // reschedule the thread if possible.
    
    if( suspend_count == 1 )
    {
        suspend_count = 0;
    41e0:	e5802040 	str	r2, [r0, #64]

        CYG_ASSERT( (state & SUSPENDED) != 0, "SUSPENDED bit not set" );
        
        // Set the state
        state &= ~SUSPENDED;
    41e4:	e580303c 	str	r3, [r0, #60]

        // Return thread to scheduler if runnable
        if( state == RUNNING )
    41e8:	1afffff2 	bne	41b8 <_ZN10Cyg_Thread6resumeEv+0x2c>
            Cyg_Scheduler::scheduler.add_thread(this);
    41ec:	e1a01000 	mov	r1, r0
    41f0:	e59f0010 	ldr	r0, [pc, #16]	; 4208 <_ZN10Cyg_Thread6resumeEv+0x7c>
    41f4:	eb0004e0 	bl	557c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread>
    41f8:	eaffffee 	b	41b8 <_ZN10Cyg_Thread6resumeEv+0x2c>
    41fc:	eb000606 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    4200:	e8bd8010 	pop	{r4, pc}
    4204:	400007c8 	.word	0x400007c8
    4208:	40002540 	.word	0x40002540

0000420c <_ZN10Cyg_Thread4wakeEv>:

// -------------------------------------------------------------------------
// Awaken the thread from sleep.

void
Cyg_Thread::wake()
    420c:	e92d4030 	push	{r4, r5, lr}
    4210:	e1a04000 	mov	r4, r0
    4214:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4218:	e59f5078 	ldr	r5, [pc, #120]	; 4298 <_ZN10Cyg_Thread4wakeEv+0x8c>
    421c:	e5953000 	ldr	r3, [r5]
    4220:	e2833001 	add	r3, r3, #1	; 0x1
    4224:	e5853000 	str	r3, [r5]
    CYG_INSTRUMENT_THREAD(WAKE,this,Cyg_Scheduler::current_thread);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if( 0 != (state & SLEEPSET) )
    4228:	e590303c 	ldr	r3, [r0, #60]
    422c:	e3130003 	tst	r3, #3	; 0x3
    4230:	0a00000b 	beq	4264 <_ZN10Cyg_Thread4wakeEv+0x58>

#include <cyg/kernel/thread.inl>   // we use some thread inlines here

inline void Cyg_SchedThread::remove()
{
    if( queue != NULL )
    4234:	e590002c 	ldr	r0, [r0, #44]
    {
        // Set the state
        state &= ~SLEEPSET;
    4238:	e3c33003 	bic	r3, r3, #3	; 0x3
    423c:	e3500000 	cmp	r0, #0	; 0x0
    4240:	e584303c 	str	r3, [r4, #60]
    4244:	0a000003 	beq	4258 <_ZN10Cyg_Thread4wakeEv+0x4c>

// -------------------------------------------------------------------------

inline void Cyg_ThreadQueue::remove(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::remove(thread);
    4248:	e1a01004 	mov	r1, r4
    424c:	eb0004ad 	bl	5508 <_ZN30Cyg_ThreadQueue_Implementation6removeEP10Cyg_Thread>
    {
        queue->remove((Cyg_Thread *)this);
        queue = NULL;
    4250:	e3a03000 	mov	r3, #0	; 0x0
    4254:	e584302c 	str	r3, [r4, #44]

        // remove from any queue we were on
        remove();

        // If the thread is now runnable, return it to run queue
        if( state == RUNNING )
    4258:	e594303c 	ldr	r3, [r4, #60]
    425c:	e3530000 	cmp	r3, #0	; 0x0
    4260:	0a000008 	beq	4288 <_ZN10Cyg_Thread4wakeEv+0x7c>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4264:	e5953000 	ldr	r3, [r5]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4268:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    426c:	159f3024 	ldrne	r3, [pc, #36]	; 4298 <_ZN10Cyg_Thread4wakeEv+0x8c>
    4270:	15830000 	strne	r0, [r3]
    4274:	0a000001 	beq	4280 <_ZN10Cyg_Thread4wakeEv+0x74>
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    4278:	e28dd004 	add	sp, sp, #4	; 0x4
    427c:	e8bd8030 	pop	{r4, r5, pc}
    4280:	eb0005e5 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    4284:	eafffffb 	b	4278 <_ZN10Cyg_Thread4wakeEv+0x6c>
        // remove from any queue we were on
        remove();

        // If the thread is now runnable, return it to run queue
        if( state == RUNNING )
            Cyg_Scheduler::scheduler.add_thread(this);
    4288:	e1a01004 	mov	r1, r4
    428c:	e59f0008 	ldr	r0, [pc, #8]	; 429c <_ZN10Cyg_Thread4wakeEv+0x90>
    4290:	eb0004b9 	bl	557c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread>
    4294:	eafffff2 	b	4264 <_ZN10Cyg_Thread4wakeEv+0x58>
    4298:	400007c8 	.word	0x400007c8
    429c:	40002540 	.word	0x40002540

000042a0 <_ZN10Cyg_Thread12counted_wakeEv>:

// -------------------------------------------------------------------------
// Awaken the thread from sleep.

void
Cyg_Thread::counted_wake()
    42a0:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    42a4:	e59f4054 	ldr	r4, [pc, #84]	; 4300 <_ZN10Cyg_Thread12counted_wakeEv+0x60>
    42a8:	e5943000 	ldr	r3, [r4]
    42ac:	e2833001 	add	r3, r3, #1	; 0x1
    42b0:	e5843000 	str	r3, [r4]
    CYG_INSTRUMENT_THREAD(WAKE,this,Cyg_Scheduler::current_thread);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == (state & COUNTSLEEP) )    // already awake, or waiting:
    42b4:	e590303c 	ldr	r3, [r0, #60]
    42b8:	e3130002 	tst	r3, #2	; 0x2
        wakeup_count++;                 // not in a counted sleep anyway.
    42bc:	05903044 	ldreq	r3, [r0, #68]
    42c0:	02833001 	addeq	r3, r3, #1	; 0x1
    42c4:	05803044 	streq	r3, [r0, #68]
    CYG_INSTRUMENT_THREAD(WAKE,this,Cyg_Scheduler::current_thread);
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if ( 0 == (state & COUNTSLEEP) )    // already awake, or waiting:
    42c8:	0a000004 	beq	42e0 <_ZN10Cyg_Thread12counted_wakeEv+0x40>
        wakeup_count++;                 // not in a counted sleep anyway.
    else {
        sleep_reason = NONE;
        wake_reason = DONE;
    42cc:	e3a03007 	mov	r3, #7	; 0x7
    Cyg_Scheduler::lock();

    if ( 0 == (state & COUNTSLEEP) )    // already awake, or waiting:
        wakeup_count++;                 // not in a counted sleep anyway.
    else {
        sleep_reason = NONE;
    42d0:	e3a02000 	mov	r2, #0	; 0x0
        wake_reason = DONE;
    42d4:	e5c03081 	strb	r3, [r0, #129]
    Cyg_Scheduler::lock();

    if ( 0 == (state & COUNTSLEEP) )    // already awake, or waiting:
        wakeup_count++;                 // not in a counted sleep anyway.
    else {
        sleep_reason = NONE;
    42d8:	e5c02080 	strb	r2, [r0, #128]
        wake_reason = DONE;
        wake();                         // and awaken the thread
    42dc:	ebffffca 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    42e0:	e5943000 	ldr	r3, [r4]
    42e4:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    42e8:	159f3010 	ldrne	r3, [pc, #16]	; 4300 <_ZN10Cyg_Thread12counted_wakeEv+0x60>
    42ec:	15830000 	strne	r0, [r3]
    42f0:	0a000000 	beq	42f8 <_ZN10Cyg_Thread12counted_wakeEv+0x58>

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    42f4:	e8bd8010 	pop	{r4, pc}
    42f8:	eb0005c7 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    42fc:	e8bd8010 	pop	{r4, pc}
    4300:	400007c8 	.word	0x400007c8

00004304 <_ZN10Cyg_Thread12set_priorityEi>:
// Set thread priority

#ifdef CYGIMP_THREAD_PRIORITY

void
Cyg_Thread::set_priority( cyg_priority new_priority )
    4304:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    4308:	e1a05000 	mov	r5, r0
    430c:	e24dd004 	sub	sp, sp, #4	; 0x4
    4310:	e1a06001 	mov	r6, r1
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4314:	e59f7124 	ldr	r7, [pc, #292]	; 4440 <_ZN10Cyg_Thread12set_priorityEi+0x13c>
    4318:	e5973000 	ldr	r3, [r7]
    431c:	e2833001 	add	r3, r3, #1	; 0x1
    4320:	e5873000 	str	r3, [r7]
    Cyg_Scheduler::lock();

    Cyg_ThreadQueue *queue = NULL;
    
    // If running, remove from run qs
    if( state == RUNNING )
    4324:	e590403c 	ldr	r4, [r0, #60]
    4328:	e3540000 	cmp	r4, #0	; 0x0
    432c:	0a00003d 	beq	4428 <_ZN10Cyg_Thread12set_priorityEi+0x124>
        Cyg_Scheduler::scheduler.rem_thread(this);
    else if( state & SLEEPING )
    4330:	e2140001 	ands	r0, r4, #1	; 0x1
    4334:	01a04000 	moveq	r4, r0
    4338:	1a000031 	bne	4404 <_ZN10Cyg_Thread12set_priorityEi+0x100>
            CYG_CHECK_DATA_PTR(queue, "Bad queue pointer");        
            remove();
        }
    }

    Cyg_Scheduler::scheduler.deregister_thread(this);
    433c:	e59f0100 	ldr	r0, [pc, #256]	; 4444 <_ZN10Cyg_Thread12set_priorityEi+0x140>
    4340:	e1a01005 	mov	r1, r5
    4344:	eb000411 	bl	5390 <_ZN28Cyg_Scheduler_Implementation17deregister_threadEP10Cyg_Thread>
    // priority and not the inherited one.  If the new priority is
    // better than the current inherited one, then use that
    // immediately. We remain in inherited state to avoid problems
    // with multiple mutex inheritances.
    
    if( priority_inherited )
    4348:	e5953038 	ldr	r3, [r5, #56]
    434c:	e3530000 	cmp	r3, #0	; 0x0
    4350:	0a00001a 	beq	43c0 <_ZN10Cyg_Thread12set_priorityEi+0xbc>
    {
        original_priority = new_priority;
        if( priority > new_priority ) priority = new_priority;
    4354:	e5953024 	ldr	r3, [r5, #36]
    4358:	e1560003 	cmp	r6, r3
    // immediately. We remain in inherited state to avoid problems
    // with multiple mutex inheritances.
    
    if( priority_inherited )
    {
        original_priority = new_priority;
    435c:	e5856034 	str	r6, [r5, #52]
        if( priority > new_priority ) priority = new_priority;
    4360:	ba000016 	blt	43c0 <_ZN10Cyg_Thread12set_priorityEi+0xbc>

#endif
    
#endif // CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES

    Cyg_Scheduler::scheduler.register_thread(this);
    4364:	e59f00d8 	ldr	r0, [pc, #216]	; 4444 <_ZN10Cyg_Thread12set_priorityEi+0x140>
    4368:	e1a01005 	mov	r1, r5
    436c:	eb000406 	bl	538c <_ZN28Cyg_Scheduler_Implementation15register_threadEP10Cyg_Thread>
    
    // Return thread to scheduler if runnable
    if( state == RUNNING )
    4370:	e595303c 	ldr	r3, [r5, #60]
    4374:	e3530000 	cmp	r3, #0	; 0x0
    4378:	0a000017 	beq	43dc <_ZN10Cyg_Thread12set_priorityEi+0xd8>
        Cyg_Scheduler::scheduler.add_thread(this);
    else if ( state & SLEEPING )
    437c:	e3130001 	tst	r3, #1	; 0x1
    4380:	1a000019 	bne	43ec <_ZN10Cyg_Thread12set_priorityEi+0xe8>
    4384:	e59f30bc 	ldr	r3, [pc, #188]	; 4448 <_ZN10Cyg_Thread12set_priorityEi+0x144>
    4388:	e5932000 	ldr	r2, [r3]
    // will do anyway).
    // If it is not the current thread then we need to see whether
    // it is more worthy of execution than any current thread and
    // rescheduled if necessary.
    
    if( this == Cyg_Scheduler::get_current_thread() )
    438c:	e1550002 	cmp	r5, r2
// -------------------------------------------------------------------------
// Cyg_Scheduler_Implementation inlines

inline void Cyg_Scheduler_Implementation::set_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
    4390:	059f30b4 	ldreq	r3, [pc, #180]	; 444c <_ZN10Cyg_Thread12set_priorityEi+0x148>
    4394:	03a02001 	moveq	r2, #1	; 0x1
    4398:	05832000 	streq	r2, [r3]
         Cyg_Scheduler::set_need_reschedule();
    else Cyg_Scheduler::set_need_reschedule(this);
    439c:	11a00005 	movne	r0, r5
    43a0:	1b0003e6 	blne	5340 <_ZN28Cyg_Scheduler_Implementation19set_need_rescheduleEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    43a4:	e5973000 	ldr	r3, [r7]
    43a8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    43ac:	159f308c 	ldrne	r3, [pc, #140]	; 4440 <_ZN10Cyg_Thread12set_priorityEi+0x13c>
    43b0:	15830000 	strne	r0, [r3]
    43b4:	0a00001f 	beq	4438 <_ZN10Cyg_Thread12set_priorityEi+0x134>
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();
    CYG_REPORT_RETURN();
}
    43b8:	e28dd004 	add	sp, sp, #4	; 0x4
    43bc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    if( priority_inherited )
    {
        original_priority = new_priority;
        if( priority > new_priority ) priority = new_priority;
    }
    else priority = new_priority;
    43c0:	e5856024 	str	r6, [r5, #36]

#endif
    
#endif // CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES

    Cyg_Scheduler::scheduler.register_thread(this);
    43c4:	e59f0078 	ldr	r0, [pc, #120]	; 4444 <_ZN10Cyg_Thread12set_priorityEi+0x140>
    43c8:	e1a01005 	mov	r1, r5
    43cc:	eb0003ee 	bl	538c <_ZN28Cyg_Scheduler_Implementation15register_threadEP10Cyg_Thread>
    
    // Return thread to scheduler if runnable
    if( state == RUNNING )
    43d0:	e595303c 	ldr	r3, [r5, #60]
    43d4:	e3530000 	cmp	r3, #0	; 0x0
    43d8:	1affffe7 	bne	437c <_ZN10Cyg_Thread12set_priorityEi+0x78>
        Cyg_Scheduler::scheduler.add_thread(this);
    43dc:	e59f0060 	ldr	r0, [pc, #96]	; 4444 <_ZN10Cyg_Thread12set_priorityEi+0x140>
    43e0:	e1a01005 	mov	r1, r5
    43e4:	eb000464 	bl	557c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread>
    43e8:	eaffffe5 	b	4384 <_ZN10Cyg_Thread12set_priorityEi+0x80>
    else if ( state & SLEEPING )
    {
        // return to current queue
        // if indeed we are on a queue
        if ( NULL != queue ) {
    43ec:	e3540000 	cmp	r4, #0	; 0x0
    43f0:	0affffe3 	beq	4384 <_ZN10Cyg_Thread12set_priorityEi+0x80>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    43f4:	e1a00004 	mov	r0, r4
    43f8:	e1a01005 	mov	r1, r5
    43fc:	eb00041d 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
    4400:	eaffffdf 	b	4384 <_ZN10Cyg_Thread12set_priorityEi+0x80>
}

// Return current queue pointer
inline Cyg_ThreadQueue *Cyg_SchedThread::get_current_queue()
{
    return queue;
    4404:	e595402c 	ldr	r4, [r5, #44]
    else if( state & SLEEPING )
    {
        // Remove thread from current queue.
        queue = get_current_queue();
        // if indeed we are on a queue
        if ( NULL != queue ) {
    4408:	e3540000 	cmp	r4, #0	; 0x0
    440c:	0affffca 	beq	433c <_ZN10Cyg_Thread12set_priorityEi+0x38>

// -------------------------------------------------------------------------

inline void Cyg_ThreadQueue::remove(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::remove(thread);
    4410:	e1a00004 	mov	r0, r4
    4414:	e1a01005 	mov	r1, r5
    4418:	eb00043a 	bl	5508 <_ZN30Cyg_ThreadQueue_Implementation6removeEP10Cyg_Thread>
inline void Cyg_SchedThread::remove()
{
    if( queue != NULL )
    {
        queue->remove((Cyg_Thread *)this);
        queue = NULL;
    441c:	e3a03000 	mov	r3, #0	; 0x0
    4420:	e585302c 	str	r3, [r5, #44]
    4424:	eaffffc4 	b	433c <_ZN10Cyg_Thread12set_priorityEi+0x38>

    Cyg_ThreadQueue *queue = NULL;
    
    // If running, remove from run qs
    if( state == RUNNING )
        Cyg_Scheduler::scheduler.rem_thread(this);
    4428:	e59f0014 	ldr	r0, [pc, #20]	; 4444 <_ZN10Cyg_Thread12set_priorityEi+0x140>
    442c:	e1a01005 	mov	r1, r5
    4430:	eb000399 	bl	529c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread>
    4434:	eaffffc0 	b	433c <_ZN10Cyg_Thread12set_priorityEi+0x38>
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4438:	eb000577 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    443c:	eaffffdd 	b	43b8 <_ZN10Cyg_Thread12set_priorityEi+0xb4>
    4440:	400007c8 	.word	0x400007c8
    4444:	40002540 	.word	0x40002540
    4448:	40002538 	.word	0x40002538
    444c:	4000253c 	.word	0x4000253c

00004450 <_ZN10Cyg_ThreadD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor.

Cyg_Thread::~Cyg_Thread()
    4450:	e92d4010 	push	{r4, lr}
{
    CYG_REPORT_FUNCTION();

    Cyg_Scheduler::scheduler.deregister_thread(this);
    4454:	e1a01000 	mov	r1, r0
}

// -------------------------------------------------------------------------
// Destructor.

Cyg_Thread::~Cyg_Thread()
    4458:	e1a04000 	mov	r4, r0
{
    CYG_REPORT_FUNCTION();

    Cyg_Scheduler::scheduler.deregister_thread(this);
    445c:	e59f00a8 	ldr	r0, [pc, #168]	; 450c <_ZN10Cyg_ThreadD1Ev+0xbc>
    4460:	eb0003ca 	bl	5390 <_ZN28Cyg_Scheduler_Implementation17deregister_threadEP10Cyg_Thread>
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4464:	e59f00a4 	ldr	r0, [pc, #164]	; 4510 <_ZN10Cyg_ThreadD1Ev+0xc0>
    4468:	e5903000 	ldr	r3, [r0]
    446c:	e2833001 	add	r3, r3, #1	; 0x1
    4470:	e5803000 	str	r3, [r0]
Cyg_Thread::remove_from_list( void )
{
    // remove thread from housekeeping list
    Cyg_Scheduler::lock();

    Cyg_Thread *prev = thread_list;
    4474:	e59fc098 	ldr	ip, [pc, #152]	; 4514 <_ZN10Cyg_ThreadD1Ev+0xc4>
    4478:	e59c1000 	ldr	r1, [ip]
    447c:	e1a02001 	mov	r2, r1

    do {
        if( prev->list_next == this ) {
    4480:	e59230a0 	ldr	r3, [r2, #160]
    4484:	e1540003 	cmp	r4, r3
    4488:	0a000019 	beq	44f4 <_ZN10Cyg_ThreadD1Ev+0xa4>
    // remove thread from housekeeping list
    Cyg_Scheduler::lock();

    Cyg_Thread *prev = thread_list;

    do {
    448c:	e1510003 	cmp	r1, r3
    4490:	e1a02003 	mov	r2, r3
    4494:	1afffff9 	bne	4480 <_ZN10Cyg_ThreadD1Ev+0x30>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4498:	e5903000 	ldr	r3, [r0]
    449c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    44a0:	159f3068 	ldrne	r3, [pc, #104]	; 4510 <_ZN10Cyg_ThreadD1Ev+0xc0>
    44a4:	15830000 	strne	r0, [r3]
    44a8:	0a00000f 	beq	44ec <_ZN10Cyg_ThreadD1Ev+0x9c>
    // Remove thread from housekeeping list.
    remove_from_list();
#endif 
    
    // Zero the unique_id to render this thread inconsistent.
    unique_id = 0;
    44ac:	e3a03000 	mov	r3, #0	; 0x0
    44b0:	e1c434bc 	strh	r3, [r4, #76]

#ifdef CYGFUN_KERNEL_THREADS_TIMER

class Cyg_ThreadTimer
    : public Cyg_Alarm
{
    44b4:	e2840050 	add	r0, r4, #80	; 0x50
    44b8:	eb002b44 	bl	f1d0 <_ZN9Cyg_AlarmD2Ev>
    };
    
    ~Cyg_DNode()
    {
        // If this node is still linked, unlink it.
        if( next != this )
    44bc:	e594101c 	ldr	r1, [r4, #28]
    : public Cyg_DNode
{
public:

    Cyg_DNode_T() {};
    ~Cyg_DNode_T() {};
    44c0:	e284001c 	add	r0, r4, #28	; 0x1c
    };
    
    ~Cyg_DNode()
    {
        // If this node is still linked, unlink it.
        if( next != this )
    44c4:	e1500001 	cmp	r0, r1
    44c8:	0a000005 	beq	44e4 <_ZN10Cyg_ThreadD1Ev+0x94>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    44cc:	e5943020 	ldr	r3, [r4, #32]
    44d0:	e5813004 	str	r3, [r1, #4]
        prev->next = next;
    44d4:	e5942020 	ldr	r2, [r4, #32]
        next = prev = this;
    44d8:	e5840020 	str	r0, [r4, #32]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    44dc:	e5821000 	str	r1, [r2]
        next = prev = this;
    44e0:	e584001c 	str	r0, [r4, #28]
    
    CYG_REPORT_RETURN();
}
    44e4:	e1a00004 	mov	r0, r4
    44e8:	e8bd8010 	pop	{r4, pc}
    44ec:	eb00054a 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    44f0:	eaffffed 	b	44ac <_ZN10Cyg_ThreadD1Ev+0x5c>

    Cyg_Thread *prev = thread_list;

    do {
        if( prev->list_next == this ) {
            prev->list_next = list_next;
    44f4:	e59430a0 	ldr	r3, [r4, #160]
    44f8:	e58230a0 	str	r3, [r2, #160]
            if( thread_list == this )
    44fc:	e1540001 	cmp	r4, r1
                thread_list = list_next;
    4500:	059430a0 	ldreq	r3, [r4, #160]
    4504:	058c3000 	streq	r3, [ip]
    4508:	eaffffe2 	b	4498 <_ZN10Cyg_ThreadD1Ev+0x48>
    450c:	40002540 	.word	0x40002540
    4510:	400007c8 	.word	0x400007c8
    4514:	40001c64 	.word	0x40001c64

00004518 <_ZN10Cyg_ThreadD2Ev>:
}

// -------------------------------------------------------------------------
// Destructor.

Cyg_Thread::~Cyg_Thread()
    4518:	e92d4010 	push	{r4, lr}
{
    CYG_REPORT_FUNCTION();

    Cyg_Scheduler::scheduler.deregister_thread(this);
    451c:	e1a01000 	mov	r1, r0
}

// -------------------------------------------------------------------------
// Destructor.

Cyg_Thread::~Cyg_Thread()
    4520:	e1a04000 	mov	r4, r0
{
    CYG_REPORT_FUNCTION();

    Cyg_Scheduler::scheduler.deregister_thread(this);
    4524:	e59f00a8 	ldr	r0, [pc, #168]	; 45d4 <_ZN10Cyg_ThreadD2Ev+0xbc>
    4528:	eb000398 	bl	5390 <_ZN28Cyg_Scheduler_Implementation17deregister_threadEP10Cyg_Thread>
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    452c:	e59f00a4 	ldr	r0, [pc, #164]	; 45d8 <_ZN10Cyg_ThreadD2Ev+0xc0>
    4530:	e5903000 	ldr	r3, [r0]
    4534:	e2833001 	add	r3, r3, #1	; 0x1
    4538:	e5803000 	str	r3, [r0]
Cyg_Thread::remove_from_list( void )
{
    // remove thread from housekeeping list
    Cyg_Scheduler::lock();

    Cyg_Thread *prev = thread_list;
    453c:	e59fc098 	ldr	ip, [pc, #152]	; 45dc <_ZN10Cyg_ThreadD2Ev+0xc4>
    4540:	e59c1000 	ldr	r1, [ip]
    4544:	e1a02001 	mov	r2, r1

    do {
        if( prev->list_next == this ) {
    4548:	e59230a0 	ldr	r3, [r2, #160]
    454c:	e1540003 	cmp	r4, r3
    4550:	0a000019 	beq	45bc <_ZN10Cyg_ThreadD2Ev+0xa4>
    // remove thread from housekeeping list
    Cyg_Scheduler::lock();

    Cyg_Thread *prev = thread_list;

    do {
    4554:	e1510003 	cmp	r1, r3
    4558:	e1a02003 	mov	r2, r3
    455c:	1afffff9 	bne	4548 <_ZN10Cyg_ThreadD2Ev+0x30>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4560:	e5903000 	ldr	r3, [r0]
    4564:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4568:	159f3068 	ldrne	r3, [pc, #104]	; 45d8 <_ZN10Cyg_ThreadD2Ev+0xc0>
    456c:	15830000 	strne	r0, [r3]
    4570:	0a00000f 	beq	45b4 <_ZN10Cyg_ThreadD2Ev+0x9c>
    // Remove thread from housekeeping list.
    remove_from_list();
#endif 
    
    // Zero the unique_id to render this thread inconsistent.
    unique_id = 0;
    4574:	e3a03000 	mov	r3, #0	; 0x0
    4578:	e1c434bc 	strh	r3, [r4, #76]
    457c:	e2840050 	add	r0, r4, #80	; 0x50
    4580:	eb002b12 	bl	f1d0 <_ZN9Cyg_AlarmD2Ev>
    };
    
    ~Cyg_DNode()
    {
        // If this node is still linked, unlink it.
        if( next != this )
    4584:	e594101c 	ldr	r1, [r4, #28]
    : public Cyg_DNode
{
public:

    Cyg_DNode_T() {};
    ~Cyg_DNode_T() {};
    4588:	e284001c 	add	r0, r4, #28	; 0x1c
    };
    
    ~Cyg_DNode()
    {
        // If this node is still linked, unlink it.
        if( next != this )
    458c:	e1500001 	cmp	r0, r1
    4590:	0a000005 	beq	45ac <_ZN10Cyg_ThreadD2Ev+0x94>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    4594:	e5943020 	ldr	r3, [r4, #32]
    4598:	e5813004 	str	r3, [r1, #4]
        prev->next = next;
    459c:	e5942020 	ldr	r2, [r4, #32]
        next = prev = this;
    45a0:	e5840020 	str	r0, [r4, #32]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    45a4:	e5821000 	str	r1, [r2]
        next = prev = this;
    45a8:	e584001c 	str	r0, [r4, #28]
    
    CYG_REPORT_RETURN();
}
    45ac:	e1a00004 	mov	r0, r4
    45b0:	e8bd8010 	pop	{r4, pc}
    45b4:	eb000518 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    45b8:	eaffffed 	b	4574 <_ZN10Cyg_ThreadD2Ev+0x5c>

    Cyg_Thread *prev = thread_list;

    do {
        if( prev->list_next == this ) {
            prev->list_next = list_next;
    45bc:	e59430a0 	ldr	r3, [r4, #160]
    45c0:	e58230a0 	str	r3, [r2, #160]
            if( thread_list == this )
    45c4:	e1540001 	cmp	r4, r1
                thread_list = list_next;
    45c8:	059430a0 	ldreq	r3, [r4, #160]
    45cc:	058c3000 	streq	r3, [ip]
    45d0:	eaffffe2 	b	4560 <_ZN10Cyg_ThreadD2Ev+0x48>
    45d4:	40002540 	.word	0x40002540
    45d8:	400007c8 	.word	0x400007c8
    45dc:	40001c64 	.word	0x40001c64

000045e0 <_ZN10Cyg_Thread4killEv>:
// -------------------------------------------------------------------------
// Kill thread. Force the thread into EXITED state externally, or
// make it wake up and call exit().

void
Cyg_Thread::kill()
    45e0:	e92d4030 	push	{r4, r5, lr}
// -------------------------------------------------------------------------
// Simple inline accessor functions

inline Cyg_Thread *Cyg_Scheduler_Base::get_current_thread()
{
    return current_thread[CYG_KERNEL_CPU_THIS()];
    45e4:	e59f30e0 	ldr	r3, [pc, #224]	; 46cc <_ZN10Cyg_Thread4killEv+0xec>
    45e8:	e5932000 	ldr	r2, [r3]
{
    CYG_REPORT_FUNCTION();
    // If this is called by the current thread on itself,
    // just call exit(), which is what he should have done
    // in the first place.
    if( this == Cyg_Scheduler::get_current_thread() )
    45ec:	e1500002 	cmp	r0, r2
// -------------------------------------------------------------------------
// Kill thread. Force the thread into EXITED state externally, or
// make it wake up and call exit().

void
Cyg_Thread::kill()
    45f0:	e24dd004 	sub	sp, sp, #4	; 0x4
    45f4:	e1a04000 	mov	r4, r0
{
    CYG_REPORT_FUNCTION();
    // If this is called by the current thread on itself,
    // just call exit(), which is what he should have done
    // in the first place.
    if( this == Cyg_Scheduler::get_current_thread() )
    45f8:	0a000031 	beq	46c4 <_ZN10Cyg_Thread4killEv+0xe4>
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    45fc:	e59f50cc 	ldr	r5, [pc, #204]	; 46d0 <_ZN10Cyg_Thread4killEv+0xf0>
    4600:	e5953000 	ldr	r3, [r5]
    4604:	e2833001 	add	r3, r3, #1	; 0x1
    4608:	e5853000 	str	r3, [r5]
    Cyg_Scheduler::lock();

    // We are killing someone else. Find out what state he is
    // in and force him to wakeup and call exit().

    force_resume();                     // this is necessary for when
    460c:	e1a00004 	mov	r0, r4
    4610:	ebfffec0 	bl	4118 <_ZN10Cyg_Thread12force_resumeEv>
                                        // he is asleep AND suspended.
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    timer.disable();                    // and make sure the timer
    4614:	e2840050 	add	r0, r4, #80	; 0x50
    4618:	eb002acb 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
                                        // does not persist.
#endif

    if ( EXIT != wake_reason ) switch( sleep_reason ) {
    461c:	e5d43081 	ldrb	r3, [r4, #129]
    4620:	e3530006 	cmp	r3, #6	; 0x6
    4624:	0a00000f 	beq	4668 <_ZN10Cyg_Thread4killEv+0x88>
    4628:	e5d43080 	ldrb	r3, [r4, #128]
    462c:	e3530007 	cmp	r3, #7	; 0x7
    4630:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    4634:	ea00000b 	b	4668 <_ZN10Cyg_Thread4killEv+0x88>
    4638:	0000468c 	.word	0x0000468c
    463c:	00004658 	.word	0x00004658
    4640:	00004658 	.word	0x00004658
    4644:	00004658 	.word	0x00004658
    4648:	00004670 	.word	0x00004670
    464c:	00004670 	.word	0x00004670
    4650:	00004670 	.word	0x00004670
    4654:	00004670 	.word	0x00004670
        // drop through...
        
    case DELAY:
        // The thread was simply delaying, unless it has been
        // woken up for some other reason, wake it now.
        sleep_reason = NONE;
    4658:	e3a03000 	mov	r3, #0	; 0x0
        wake_reason = EXIT;
    465c:	e3a02006 	mov	r2, #6	; 0x6
        // drop through...
        
    case DELAY:
        // The thread was simply delaying, unless it has been
        // woken up for some other reason, wake it now.
        sleep_reason = NONE;
    4660:	e5c43080 	strb	r3, [r4, #128]
        wake_reason = EXIT;
    4664:	e5c42081 	strb	r2, [r4, #129]
        break;
    }

    wake();
    4668:	e1a00004 	mov	r0, r4
    466c:	ebfffee6 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4670:	e5953000 	ldr	r3, [r5]
    4674:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4678:	159f3050 	ldrne	r3, [pc, #80]	; 46d0 <_ZN10Cyg_Thread4killEv+0xf0>
    467c:	15830000 	strne	r0, [r3]
    4680:	0a000009 	beq	46ac <_ZN10Cyg_Thread4killEv+0xcc>

    // Allow preemption
    Cyg_Scheduler::unlock();
    CYG_REPORT_RETURN();
}
    4684:	e28dd004 	add	sp, sp, #4	; 0x4
    4688:	e8bd8030 	pop	{r4, r5, pc}

    case NONE:
        // The thread is not sleeping for any reason, it must be
        // on a run queue.
        // We can safely deschedule and set its state.
        if( state == RUNNING ) Cyg_Scheduler::scheduler.rem_thread(this);
    468c:	e594303c 	ldr	r3, [r4, #60]
    4690:	e3530000 	cmp	r3, #0	; 0x0
    4694:	0a000006 	beq	46b4 <_ZN10Cyg_Thread4killEv+0xd4>
        state = EXITED;
    4698:	e3a03010 	mov	r3, #16	; 0x10
    469c:	e584303c 	str	r3, [r4, #60]
        sleep_reason = NONE;
        wake_reason = EXIT;
        break;
    }

    wake();
    46a0:	e1a00004 	mov	r0, r4
    46a4:	ebfffed8 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    46a8:	eafffff0 	b	4670 <_ZN10Cyg_Thread4killEv+0x90>
    46ac:	eb0004da 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    46b0:	eafffff3 	b	4684 <_ZN10Cyg_Thread4killEv+0xa4>

    case NONE:
        // The thread is not sleeping for any reason, it must be
        // on a run queue.
        // We can safely deschedule and set its state.
        if( state == RUNNING ) Cyg_Scheduler::scheduler.rem_thread(this);
    46b4:	e59f0018 	ldr	r0, [pc, #24]	; 46d4 <_ZN10Cyg_Thread4killEv+0xf4>
    46b8:	e1a01004 	mov	r1, r4
    46bc:	eb0002f6 	bl	529c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread>
    46c0:	eafffff4 	b	4698 <_ZN10Cyg_Thread4killEv+0xb8>
    CYG_REPORT_FUNCTION();
    // If this is called by the current thread on itself,
    // just call exit(), which is what he should have done
    // in the first place.
    if( this == Cyg_Scheduler::get_current_thread() )
        exit();
    46c4:	ebfffce8 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    46c8:	eaffffcb 	b	45fc <_ZN10Cyg_Thread4killEv+0x1c>
    46cc:	40002538 	.word	0x40002538
    46d0:	400007c8 	.word	0x400007c8
    46d4:	40002540 	.word	0x40002540

000046d8 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj>:
        cyg_thread_entry        *entry,         // entry point function
        CYG_ADDRWORD            entry_data,     // entry data
        char                    *name_arg,      // thread name cookie
        CYG_ADDRESS             stack_base,     // stack base, NULL = allocate
        cyg_ucount32            stack_size      // stack size, 0 = use default
        )
    46d8:	e92d4070 	push	{r4, r5, r6, lr}
    46dc:	e59dc014 	ldr	ip, [sp, #20]
    46e0:	e59d5018 	ldr	r5, [sp, #24]
)
{
    entry_point = e_point;
    entry_data  = e_data;
#ifdef CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT
    saved_context = 0;
    46e4:	e3a04000 	mov	r4, #0	; 0x0

    HAL_THREAD_ATTACH_STACK(stack_ptr, stack_base, stack_size);
    
#else

    stack_ptr = stack_base + stack_size;
    46e8:	e085e00c 	add	lr, r5, ip
    46ec:	e1a06000 	mov	r6, r0
    46f0:	e580e00c 	str	lr, [r0, #12]
	// CYG_WORD in size. Since it's at the top of the stack, it will
	// almost certainly be overwritten the instant the thread starts
	// anyway.
    }
#endif
    stack_base = s_base;
    46f4:	e580c000 	str	ip, [r0]
    stack_size = s_size;
#ifdef CYGFUN_KERNEL_THREADS_STACK_LIMIT
    stack_limit = s_base;
    46f8:	e580c008 	str	ip, [r0, #8]
    CYG_ADDRWORD            e_data,     // entry data
    cyg_ucount32            s_size,     // stack size, 0 = use default
    CYG_ADDRESS             s_base      // stack base, NULL = allocate
)
{
    entry_point = e_point;
    46fc:	e5802010 	str	r2, [r0, #16]
    entry_data  = e_data;
    4700:	e5803014 	str	r3, [r0, #20]
:   Cyg_HardwareThread(entry, entry_data, stack_size, stack_base),
    Cyg_SchedThread(this, sched_info)
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    ,timer(this)
    4704:	e1a02001 	mov	r2, r1
#ifdef CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT
    saved_context = 0;
    4708:	e5804018 	str	r4, [r0, #24]
	// almost certainly be overwritten the instant the thread starts
	// anyway.
    }
#endif
    stack_base = s_base;
    stack_size = s_size;
    470c:	e5805004 	str	r5, [r0, #4]
    4710:	e1a01000 	mov	r1, r0
    4714:	e280001c 	add	r0, r0, #28	; 0x1c
    4718:	eb0004a7 	bl	59bc <_ZN15Cyg_SchedThreadC2EP10Cyg_Threadj>
    Cyg_Thread  *th
    )
    : Cyg_Alarm(Cyg_Clock::real_time_clock,
                &alarm,
                CYG_ADDRWORD(this)
                )
    471c:	e59f3138 	ldr	r3, [pc, #312]	; 485c <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x184>
    4720:	e2860050 	add	r0, r6, #80	; 0x50
    4724:	e5931000 	ldr	r1, [r3]
    4728:	e59f2130 	ldr	r2, [pc, #304]	; 4860 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x188>
    472c:	e1a03000 	mov	r3, r0
    4730:	eb0028e1 	bl	eabc <_ZN9Cyg_AlarmC2EP11Cyg_CounterPFvPS_jEj>
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    4734:	e59fc128 	ldr	ip, [pc, #296]	; 4864 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x18c>
    CYG_REPORT_FUNCTION();

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    4738:	e3a03004 	mov	r3, #4	; 0x4
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    473c:	e1dc10b0 	ldrh	r1, [ip]
    CYG_REPORT_FUNCTION();

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    4740:	e586303c 	str	r3, [r6, #60]
    for (int j=0; j<CYGNUM_KERNEL_THREADS_DESTRUCTORS; j++) {
        destructors[j].fn = NULL;
    }
#endif
#ifdef CYGVAR_KERNEL_THREADS_NAME
    name = name_arg;
    4744:	e59d3010 	ldr	r3, [sp, #16]
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    4748:	e2810001 	add	r0, r1, #1	; 0x1

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    suspend_count       = 1;
    474c:	e3a02001 	mov	r2, #1	; 0x1
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    4750:	e1c614bc 	strh	r1, [r6, #76]

    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    suspend_count       = 1;
    4754:	e5862040 	str	r2, [r6, #64]
    unique_id           = next_unique_id++;

#ifdef CYGVAR_KERNEL_THREADS_DATA
    // Zero all per-thread data entries.
    for( int i = 0; i < CYGNUM_KERNEL_THREADS_DATA_MAX; i++ )
        thread_data[i] = 0;
    4758:	e5864098 	str	r4, [r6, #152]
    for (int j=0; j<CYGNUM_KERNEL_THREADS_DESTRUCTORS; j++) {
        destructors[j].fn = NULL;
    }
#endif
#ifdef CYGVAR_KERNEL_THREADS_NAME
    name = name_arg;
    475c:	e586309c 	str	r3, [r6, #156]
    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    wake_reason         = NONE;

    // Assign a 16 bit id to the thread.
    unique_id           = next_unique_id++;
    4760:	e1cc00b0 	strh	r0, [ip]
{
    thread = th;
    4764:	e586607c 	str	r6, [r6, #124]
    CYG_INSTRUMENT_THREAD(CREATE,this,0);
    
    // Start the thread in suspended state.
    state               = SUSPENDED;
    suspend_count       = 1;
    wakeup_count        = 0;
    4768:	e5864044 	str	r4, [r6, #68]

    // Initialize sleep_reason which is used by kill, release
    sleep_reason        = NONE;
    476c:	e5c64080 	strb	r4, [r6, #128]
    wake_reason         = NONE;
    4770:	e5c64081 	strb	r4, [r6, #129]
    unique_id           = next_unique_id++;

#ifdef CYGVAR_KERNEL_THREADS_DATA
    // Zero all per-thread data entries.
    for( int i = 0; i < CYGNUM_KERNEL_THREADS_DATA_MAX; i++ )
        thread_data[i] = 0;
    4774:	e5864084 	str	r4, [r6, #132]
    4778:	e5864088 	str	r4, [r6, #136]
    477c:	e586408c 	str	r4, [r6, #140]
    4780:	e5864090 	str	r4, [r6, #144]
    4784:	e5864094 	str	r4, [r6, #148]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4788:	e59f00d8 	ldr	r0, [pc, #216]	; 4868 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x190>
    478c:	e5903000 	ldr	r3, [r0]
    4790:	e0833002 	add	r3, r3, r2
    4794:	e5803000 	str	r3, [r0]
Cyg_Thread::add_to_list( void )
{
    // Add thread to housekeeping list
    Cyg_Scheduler::lock();

    if( thread_list == 0 )
    4798:	e59fc0cc 	ldr	ip, [pc, #204]	; 486c <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x194>
    479c:	e59c2000 	ldr	r2, [ip]
    47a0:	e1520004 	cmp	r2, r4
        list_next = this;
    47a4:	058660a0 	streq	r6, [r6, #160]
Cyg_Thread::add_to_list( void )
{
    // Add thread to housekeeping list
    Cyg_Scheduler::lock();

    if( thread_list == 0 )
    47a8:	0a00000c 	beq	47e0 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x108>
        list_next = this;
    else {
        Cyg_Thread *prev = thread_list;
        do {
            if ( this == prev )
    47ac:	e1560002 	cmp	r6, r2
    47b0:	0a00000a 	beq	47e0 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x108>
                break; // found it already!
            prev = prev->list_next;
    47b4:	e59210a0 	ldr	r1, [r2, #160]

    if( thread_list == 0 )
        list_next = this;
    else {
        Cyg_Thread *prev = thread_list;
        do {
    47b8:	e1520001 	cmp	r2, r1
    47bc:	11a03001 	movne	r3, r1
    47c0:	0a000004 	beq	47d8 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x100>
            if ( this == prev )
    47c4:	e1560003 	cmp	r6, r3
    47c8:	0a000004 	beq	47e0 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x108>
                break; // found it already!
            prev = prev->list_next;
    47cc:	e59330a0 	ldr	r3, [r3, #160]

    if( thread_list == 0 )
        list_next = this;
    else {
        Cyg_Thread *prev = thread_list;
        do {
    47d0:	e1520003 	cmp	r2, r3
    47d4:	1afffffa 	bne	47c4 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0xec>
                break; // found it already!
            prev = prev->list_next;
        } while ( prev != thread_list );
        if ( this != prev ) {
            // insert it in the list:
            list_next = thread_list->list_next;
    47d8:	e58610a0 	str	r1, [r6, #160]
            thread_list->list_next = this;
    47dc:	e58260a0 	str	r6, [r2, #160]
        }
    }
    thread_list = this;
    47e0:	e58c6000 	str	r6, [ip]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    47e4:	e5903000 	ldr	r3, [r0]
    47e8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    47ec:	159f3074 	ldrne	r3, [pc, #116]	; 4868 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x190>
    47f0:	15830000 	strne	r0, [r3]
    47f4:	0a000016 	beq	4854 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x17c>
#ifdef CYGVAR_KERNEL_THREADS_LIST
    // Add thread to housekeeping list
    add_to_list();
#endif    
    
    Cyg_Scheduler::scheduler.register_thread(this);
    47f8:	e59f0070 	ldr	r0, [pc, #112]	; 4870 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x198>
    47fc:	e1a01006 	mov	r1, r6
    4800:	eb0002e1 	bl	538c <_ZN28Cyg_Scheduler_Implementation15register_threadEP10Cyg_Thread>
#ifdef CYGPKG_INFRA_DEBUG
    cyg_uint32 threadid = thread->get_unique_id()*0x01010000;
#else
    cyg_uint32 threadid = 0x11110000;
#endif
    HAL_THREAD_INIT_CONTEXT( stack_ptr, thread, thread_entry, threadid );
    4804:	e596300c 	ldr	r3, [r6, #12]
    4808:	e3c3000f 	bic	r0, r3, #15	; 0xf
    480c:	e2401050 	sub	r1, r0, #80	; 0x50
    4810:	e3a02000 	mov	r2, #0	; 0x0
    4814:	e3823411 	orr	r3, r2, #285212672	; 0x11000000
    4818:	e3833811 	orr	r3, r3, #1114112	; 0x110000
    481c:	e7813102 	str	r3, [r1, r2, lsl #2]
    4820:	e2822001 	add	r2, r2, #1	; 0x1
    4824:	e352000b 	cmp	r2, #11	; 0xb
    4828:	1afffff9 	bne	4814 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x13c>
    482c:	e59f2040 	ldr	r2, [pc, #64]	; 4874 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x19c>
    4830:	e3a03013 	mov	r3, #19	; 0x13
    4834:	e5810034 	str	r0, [r1, #52]
    4838:	e5006050 	str	r6, [r0, #-80]
    483c:	e581203c 	str	r2, [r1, #60]
    4840:	e5813040 	str	r3, [r1, #64]
    4844:	e5812038 	str	r2, [r1, #56]
    
    init_context(this);

    CYG_REPORT_RETURN();
}
    4848:	e1a00006 	mov	r0, r6
    484c:	e586100c 	str	r1, [r6, #12]
    4850:	e8bd8070 	pop	{r4, r5, r6, pc}
    4854:	eb000470 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    4858:	eaffffe6 	b	47f8 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj+0x120>
    485c:	400046bc 	.word	0x400046bc
    4860:	00004b08 	.word	0x00004b08
    4864:	400007c4 	.word	0x400007c4
    4868:	400007c8 	.word	0x400007c8
    486c:	40001c64 	.word	0x40001c64
    4870:	40002540 	.word	0x40002540
    4874:	00003ad4 	.word	0x00003ad4

00004878 <_ZN14Cyg_IdleThreadC1Ev>:
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    4878:	e59f3080 	ldr	r3, [pc, #128]	; 4900 <_ZN14Cyg_IdleThreadC1Ev+0x88>
    487c:	e0633000 	rsb	r3, r3, r0
    4880:	e1a031c3 	asr	r3, r3, #3
Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );

// -------------------------------------------------------------------------
// Idle threads constructor

Cyg_IdleThread::Cyg_IdleThread()
    4884:	e92d4030 	push	{r4, r5, lr}
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    4888:	e1a04303 	lsl	r4, r3, #6
    488c:	e0444203 	sub	r4, r4, r3, lsl #4
    4890:	e1a02304 	lsl	r2, r4, #6
    4894:	e0844002 	add	r4, r4, r2
    4898:	e0844003 	add	r4, r4, r3
    489c:	e1a04104 	lsl	r4, r4, #2
    48a0:	e0634004 	rsb	r4, r3, r4
    48a4:	e1a02904 	lsl	r2, r4, #18
    48a8:	e59fc054 	ldr	ip, [pc, #84]	; 4904 <_ZN14Cyg_IdleThreadC1Ev+0x8c>
    48ac:	e59fe054 	ldr	lr, [pc, #84]	; 4908 <_ZN14Cyg_IdleThreadC1Ev+0x90>
Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );

// -------------------------------------------------------------------------
// Idle threads constructor

Cyg_IdleThread::Cyg_IdleThread()
    48b0:	e24dd014 	sub	sp, sp, #20	; 0x14
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    48b4:	e0844002 	add	r4, r4, r2
    48b8:	e04ee584 	sub	lr, lr, r4, lsl #11
Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );

// -------------------------------------------------------------------------
// Idle threads constructor

Cyg_IdleThread::Cyg_IdleThread()
    48bc:	e1a05000 	mov	r5, r0
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    48c0:	e3a03000 	mov	r3, #0	; 0x0
    48c4:	e58dc000 	str	ip, [sp]
    48c8:	e2644000 	rsb	r4, r4, #0	; 0x0
    48cc:	e3a0cb02 	mov	ip, #2048	; 0x800
    48d0:	e3a0101f 	mov	r1, #31	; 0x1f
    48d4:	e59f2030 	ldr	r2, [pc, #48]	; 490c <_ZN14Cyg_IdleThreadC1Ev+0x94>
    48d8:	e58de004 	str	lr, [sp, #4]
    48dc:	e58dc008 	str	ip, [sp, #8]
    48e0:	ebffff7c 	bl	46d8 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj>
    CYG_REPORT_FUNCTION();

    // Call into scheduler to set up this thread as the default
    // current thread for its CPU.
    
    Cyg_Scheduler::scheduler.set_idle_thread( this, this-&idle_thread[0] );
    48e4:	e1a02004 	mov	r2, r4
    48e8:	e59f0020 	ldr	r0, [pc, #32]	; 4910 <_ZN14Cyg_IdleThreadC1Ev+0x98>
    48ec:	e1a01005 	mov	r1, r5
    48f0:	eb0003be 	bl	57f0 <_ZN28Cyg_Scheduler_Implementation15set_idle_threadEP10Cyg_Threadj>

    CYG_REPORT_RETURN();
}
    48f4:	e1a00005 	mov	r0, r5
    48f8:	e28dd014 	add	sp, sp, #20	; 0x14
    48fc:	e8bd8030 	pop	{r4, r5, pc}
    4900:	40001c70 	.word	0x40001c70
    4904:	00012a50 	.word	0x00012a50
    4908:	40001d18 	.word	0x40001d18
    490c:	00003a34 	.word	0x00003a34
    4910:	40002540 	.word	0x40002540

00004914 <_Z41__static_initialization_and_destruction_0ii>:
    4914:	e3500001 	cmp	r0, #1	; 0x1
    4918:	0a000007 	beq	493c <_Z41__static_initialization_and_destruction_0ii+0x28>
};

// -------------------------------------------------------------------------
// Instantiate the idle thread

Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );
    491c:	e3500000 	cmp	r0, #0	; 0x0
    4920:	112fff1e 	bxne	lr
    4924:	e3a03dad 	mov	r3, #11072	; 0x2b40
    4928:	e283301c 	add	r3, r3, #28	; 0x1c
    492c:	e1510003 	cmp	r1, r3
    4930:	112fff1e 	bxne	lr

// -------------------------------------------------------------------------
// Idle thread class

class Cyg_IdleThread : public Cyg_Thread
{
    4934:	e59f0018 	ldr	r0, [pc, #24]	; 4954 <_Z41__static_initialization_and_destruction_0ii+0x40>
    4938:	eafffef6 	b	4518 <_ZN10Cyg_ThreadD2Ev>
    // current thread for its CPU.
    
    Cyg_Scheduler::scheduler.set_idle_thread( this, this-&idle_thread[0] );

    CYG_REPORT_RETURN();
}
    493c:	e3a03dad 	mov	r3, #11072	; 0x2b40
    4940:	e283301c 	add	r3, r3, #28	; 0x1c
    4944:	e1510003 	cmp	r1, r3
    4948:	112fff1e 	bxne	lr
};

// -------------------------------------------------------------------------
// Instantiate the idle thread

Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );
    494c:	e59f0000 	ldr	r0, [pc, #0]	; 4954 <_Z41__static_initialization_and_destruction_0ii+0x40>
    4950:	eaffffc8 	b	4878 <_ZN14Cyg_IdleThreadC1Ev>
    4954:	40001c70 	.word	0x40001c70

00004958 <_GLOBAL__D.11100__ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread>:
    // current thread for its CPU.
    
    Cyg_Scheduler::scheduler.set_idle_thread( this, this-&idle_thread[0] );

    CYG_REPORT_RETURN();
}
    4958:	e3a01dad 	mov	r1, #11072	; 0x2b40
    495c:	e281101c 	add	r1, r1, #28	; 0x1c
    4960:	e3a00000 	mov	r0, #0	; 0x0
    4964:	eaffffea 	b	4914 <_Z41__static_initialization_and_destruction_0ii>

00004968 <_GLOBAL__I.11100__ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread>:
    4968:	e3a01dad 	mov	r1, #11072	; 0x2b40
    496c:	e281101c 	add	r1, r1, #28	; 0x1c
    4970:	e3a00001 	mov	r0, #1	; 0x1
    4974:	eaffffe6 	b	4914 <_Z41__static_initialization_and_destruction_0ii>

00004978 <_ZN14Cyg_IdleThreadC2Ev>:
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    4978:	e59f3080 	ldr	r3, [pc, #128]	; 4a00 <_ZN14Cyg_IdleThreadC2Ev+0x88>
    497c:	e0633000 	rsb	r3, r3, r0
    4980:	e1a031c3 	asr	r3, r3, #3
Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );

// -------------------------------------------------------------------------
// Idle threads constructor

Cyg_IdleThread::Cyg_IdleThread()
    4984:	e92d4030 	push	{r4, r5, lr}
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    4988:	e1a04303 	lsl	r4, r3, #6
    498c:	e0444203 	sub	r4, r4, r3, lsl #4
    4990:	e1a02304 	lsl	r2, r4, #6
    4994:	e0844002 	add	r4, r4, r2
    4998:	e0844003 	add	r4, r4, r3
    499c:	e1a04104 	lsl	r4, r4, #2
    49a0:	e0634004 	rsb	r4, r3, r4
    49a4:	e1a02904 	lsl	r2, r4, #18
    49a8:	e59fc054 	ldr	ip, [pc, #84]	; 4a04 <_ZN14Cyg_IdleThreadC2Ev+0x8c>
    49ac:	e59fe054 	ldr	lr, [pc, #84]	; 4a08 <_ZN14Cyg_IdleThreadC2Ev+0x90>
Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );

// -------------------------------------------------------------------------
// Idle threads constructor

Cyg_IdleThread::Cyg_IdleThread()
    49b0:	e24dd014 	sub	sp, sp, #20	; 0x14
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    49b4:	e0844002 	add	r4, r4, r2
    49b8:	e04ee584 	sub	lr, lr, r4, lsl #11
Cyg_IdleThread idle_thread[CYGNUM_KERNEL_CPU_MAX] CYG_INIT_PRIORITY( IDLE_THREAD );

// -------------------------------------------------------------------------
// Idle threads constructor

Cyg_IdleThread::Cyg_IdleThread()
    49bc:	e1a05000 	mov	r5, r0
    : Cyg_Thread( CYG_THREAD_MIN_PRIORITY,
                  idle_thread_main,
                  0,
                  (char *)"Idle Thread",
                  (CYG_ADDRESS)idle_thread_stack[this-&idle_thread[0]],
                  CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE)
    49c0:	e3a03000 	mov	r3, #0	; 0x0
    49c4:	e58dc000 	str	ip, [sp]
    49c8:	e2644000 	rsb	r4, r4, #0	; 0x0
    49cc:	e3a0cb02 	mov	ip, #2048	; 0x800
    49d0:	e3a0101f 	mov	r1, #31	; 0x1f
    49d4:	e59f2030 	ldr	r2, [pc, #48]	; 4a0c <_ZN14Cyg_IdleThreadC2Ev+0x94>
    49d8:	e58de004 	str	lr, [sp, #4]
    49dc:	e58dc008 	str	ip, [sp, #8]
    49e0:	ebffff3c 	bl	46d8 <_ZN10Cyg_ThreadC2EjPFvjEjPcjj>
    CYG_REPORT_FUNCTION();

    // Call into scheduler to set up this thread as the default
    // current thread for its CPU.
    
    Cyg_Scheduler::scheduler.set_idle_thread( this, this-&idle_thread[0] );
    49e4:	e1a02004 	mov	r2, r4
    49e8:	e59f0020 	ldr	r0, [pc, #32]	; 4a10 <_ZN14Cyg_IdleThreadC2Ev+0x98>
    49ec:	e1a01005 	mov	r1, r5
    49f0:	eb00037e 	bl	57f0 <_ZN28Cyg_Scheduler_Implementation15set_idle_threadEP10Cyg_Threadj>

    CYG_REPORT_RETURN();
}
    49f4:	e1a00005 	mov	r0, r5
    49f8:	e28dd014 	add	sp, sp, #20	; 0x14
    49fc:	e8bd8030 	pop	{r4, r5, pc}
    4a00:	40001c70 	.word	0x40001c70
    4a04:	00012a50 	.word	0x00012a50
    4a08:	40001d18 	.word	0x40001d18
    4a0c:	00003a34 	.word	0x00003a34
    4a10:	40002540 	.word	0x40002540

00004a14 <_ZN10Cyg_Thread14new_data_indexEv>:
             (1+(((cyg_ucount32)(1<<(CYGNUM_KERNEL_THREADS_DATA_MAX-1))-1)<<1));
// the second expression is equivalent to ((1<<CYGNUM_KERNEL_THREADS_DATA_MAX)-1);
// but avoids overflow. The compiler will compile to a constant just fine.

Cyg_Thread::cyg_data_index
Cyg_Thread::new_data_index()
    4a14:	e92d4070 	push	{r4, r5, r6, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4a18:	e59f6064 	ldr	r6, [pc, #100]	; 4a84 <_ZN10Cyg_Thread14new_data_indexEv+0x70>
    4a1c:	e5963000 	ldr	r3, [r6]
    4a20:	e2833001 	add	r3, r3, #1	; 0x1
    4a24:	e5863000 	str	r3, [r6]
{
    Cyg_Scheduler::lock();

    Cyg_Thread::cyg_data_index index;

    if (0 == thread_data_map)
    4a28:	e59f5058 	ldr	r5, [pc, #88]	; 4a88 <_ZN10Cyg_Thread14new_data_indexEv+0x74>
    4a2c:	e5950000 	ldr	r0, [r5]
    4a30:	e3500000 	cmp	r0, #0	; 0x0
    4a34:	03e04000 	mvneq	r4, #0	; 0x0
    4a38:	1a000001 	bne	4a44 <_ZN10Cyg_Thread14new_data_indexEv+0x30>
    thread_data_map &= ~(1<<index);
    
    Cyg_Scheduler::unlock();

    return index;
}
    4a3c:	e1a00004 	mov	r0, r4
    4a40:	e8bd8070 	pop	{r4, r5, r6, pc}

    if (0 == thread_data_map)
        return -1;
    
    // find ls set bit
    HAL_LSBIT_INDEX( index, thread_data_map );
    4a44:	eb0023e2 	bl	d9d4 <hal_lsbindex>

    // clear the bit
    thread_data_map &= ~(1<<index);
    4a48:	e3a03001 	mov	r3, #1	; 0x1
    4a4c:	e1a03013 	lsl	r3, r3, r0
    4a50:	e5952000 	ldr	r2, [r5]
    4a54:	e1e03003 	mvn	r3, r3
    4a58:	e0033002 	and	r3, r3, r2

    if (0 == thread_data_map)
        return -1;
    
    // find ls set bit
    HAL_LSBIT_INDEX( index, thread_data_map );
    4a5c:	e1a04000 	mov	r4, r0

    // clear the bit
    thread_data_map &= ~(1<<index);
    4a60:	e5853000 	str	r3, [r5]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4a64:	e5963000 	ldr	r3, [r6]
    4a68:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4a6c:	15860000 	strne	r0, [r6]
    4a70:	0a000001 	beq	4a7c <_ZN10Cyg_Thread14new_data_indexEv+0x68>
    
    Cyg_Scheduler::unlock();

    return index;
}
    4a74:	e1a00004 	mov	r0, r4
    4a78:	e8bd8070 	pop	{r4, r5, r6, pc}
    4a7c:	eb0003e6 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    4a80:	eafffffb 	b	4a74 <_ZN10Cyg_Thread14new_data_indexEv+0x60>
    4a84:	400007c8 	.word	0x400007c8
    4a88:	400007c0 	.word	0x400007c0

00004a8c <_ZN10Cyg_Thread7releaseEv>:
// Force thread to wake up from a sleep with a wake_reason of
// BREAK. It is the responsibility of the woken thread to detect
// the release() and do the right thing.

void
Cyg_Thread::release()
    4a8c:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4a90:	e59f406c 	ldr	r4, [pc, #108]	; 4b04 <_ZN10Cyg_Thread7releaseEv+0x78>
    4a94:	e5943000 	ldr	r3, [r4]
    4a98:	e2833001 	add	r3, r3, #1	; 0x1
    4a9c:	e5843000 	str	r3, [r4]
    Cyg_Scheduler::lock();

    // If the thread is in any of the sleep states, set the
    // wake reason and wake it up.

    switch( sleep_reason )
    4aa0:	e5d03080 	ldrb	r3, [r0, #128]
    4aa4:	e3530007 	cmp	r3, #7	; 0x7
    4aa8:	8a00000d 	bhi	4ae4 <_ZN10Cyg_Thread7releaseEv+0x58>
    4aac:	e1d028d0 	ldrsb	r2, [r0, #128]
    4ab0:	e3a03001 	mov	r3, #1	; 0x1
    4ab4:	e1a03213 	lsl	r3, r3, r2
    4ab8:	e21320f1 	ands	r2, r3, #241	; 0xf1
    4abc:	0a000004 	beq	4ad4 <_ZN10Cyg_Thread7releaseEv+0x48>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4ac0:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4ac4:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4ac8:	15840000 	strne	r0, [r4]
    4acc:	0a00000a 	beq	4afc <_ZN10Cyg_Thread7releaseEv+0x70>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    4ad0:	e8bd8010 	pop	{r4, pc}
    4ad4:	e313000e 	tst	r3, #14	; 0xe
        
    case DELAY:
        // The thread was simply delaying, unless it has been
        // woken up for some other reason, wake it now.
        sleep_reason = NONE;
        wake_reason = BREAK;
    4ad8:	13a03004 	movne	r3, #4	; 0x4
        // drop through...
        
    case DELAY:
        // The thread was simply delaying, unless it has been
        // woken up for some other reason, wake it now.
        sleep_reason = NONE;
    4adc:	15c02080 	strbne	r2, [r0, #128]
        wake_reason = BREAK;
    4ae0:	15c03081 	strbne	r3, [r0, #129]
        break;
    }

    wake();
    4ae4:	ebfffdc8 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4ae8:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4aec:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4af0:	159f300c 	ldrne	r3, [pc, #12]	; 4b04 <_ZN10Cyg_Thread7releaseEv+0x78>
    4af4:	15830000 	strne	r0, [r3]
    4af8:	1afffff4 	bne	4ad0 <_ZN10Cyg_Thread7releaseEv+0x44>
    4afc:	eb0003c6 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    4b00:	e8bd8010 	pop	{r4, pc}
    4b04:	400007c8 	.word	0x400007c8

00004b08 <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj>:

void
Cyg_ThreadTimer::alarm(
    Cyg_Alarm           *alarm,
    CYG_ADDRWORD        data
)
    4b08:	e92d4010 	push	{r4, lr}
{
    CYG_REPORT_FUNCTION();

    Cyg_ThreadTimer *self = (Cyg_ThreadTimer *)data;
    Cyg_Thread *thread = self->thread;
    4b0c:	e591002c 	ldr	r0, [r1, #44]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    4b10:	e59f4080 	ldr	r4, [pc, #128]	; 4b98 <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x90>
    4b14:	e5943000 	ldr	r3, [r4]
    4b18:	e2833001 	add	r3, r3, #1	; 0x1
    4b1c:	e5843000 	str	r3, [r4]
    
    Cyg_Scheduler::lock();

    Cyg_Thread::cyg_reason sleep_reason = thread->get_sleep_reason();
    
    switch( sleep_reason ) {
    4b20:	e5d03080 	ldrb	r3, [r0, #128]
    4b24:	e3530007 	cmp	r3, #7	; 0x7
    4b28:	8a000013 	bhi	4b7c <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x74>
    4b2c:	e1d028d0 	ldrsb	r2, [r0, #128]
    4b30:	e3a03001 	mov	r3, #1	; 0x1
    4b34:	e1a03213 	lsl	r3, r3, r2
    4b38:	e21320f3 	ands	r2, r3, #243	; 0xf3
    4b3c:	0a000005 	beq	4b58 <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x50>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4b40:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4b44:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4b48:	15840000 	strne	r0, [r4]
    4b4c:	1a000010 	bne	4b94 <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x8c>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    4b50:	eb0003b1 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    4b54:	e8bd8010 	pop	{r4, pc}
    4b58:	e2131008 	ands	r1, r3, #8	; 0x8
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    4b5c:	13a03003 	movne	r3, #3	; 0x3

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    4b60:	15c02080 	strbne	r2, [r0, #128]
    wake_reason = reason;
    4b64:	15c03081 	strbne	r3, [r0, #129]
    4b68:	1a000003 	bne	4b7c <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x74>
    4b6c:	e3130004 	tst	r3, #4	; 0x4
    4b70:	13a03007 	movne	r3, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    4b74:	15c01080 	strbne	r1, [r0, #128]
    wake_reason = reason;
    4b78:	15c03081 	strbne	r3, [r0, #129]
        // TIMEOUT and restart.
        thread->set_wake_reason(Cyg_Thread::TIMEOUT);
        break;
    }

    thread->wake();
    4b7c:	ebfffda2 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    4b80:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    4b84:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    4b88:	159f3008 	ldrne	r3, [pc, #8]	; 4b98 <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x90>
    4b8c:	15830000 	strne	r0, [r3]
    4b90:	0affffee 	beq	4b50 <_ZN15Cyg_ThreadTimer5alarmEP9Cyg_Alarmj+0x48>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    4b94:	e8bd8010 	pop	{r4, pc}
    4b98:	400007c8 	.word	0x400007c8

00004b9c <_Z26cyg_null_exception_handlerjij>:
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG3("data=%08x, exception=%d, info=%08x", data,
                        exception_number, exception_info);
    CYG_TRACE1( 1, "Uncaught exception: %d", exception_number);
    CYG_REPORT_RETURN();
}
    4b9c:	e12fff1e 	bx	lr

00004ba0 <_ZN21Cyg_Exception_ControlC2Ev>:
    for( int i = 0; i < CYGNUM_HAL_EXCEPTION_COUNT ; i++ )
        exception_handler[i] = cyg_null_exception_handler,
            exception_data[i] = 0;
#else

    exception_handler = cyg_null_exception_handler;    
    4ba0:	e59f1008 	ldr	r1, [pc, #8]	; 4bb0 <_ZN21Cyg_Exception_ControlC2Ev+0x10>
    exception_data = 0;
    4ba4:	e3a02000 	mov	r2, #0	; 0x0
    4ba8:	e8800006 	stm	r0, {r1, r2}
    
#endif
    CYG_REPORT_RETURN();
}
    4bac:	e12fff1e 	bx	lr
    4bb0:	00004b9c 	.word	0x00004b9c

00004bb4 <_ZN21Cyg_Exception_ControlC1Ev>:
    for( int i = 0; i < CYGNUM_HAL_EXCEPTION_COUNT ; i++ )
        exception_handler[i] = cyg_null_exception_handler,
            exception_data[i] = 0;
#else

    exception_handler = cyg_null_exception_handler;    
    4bb4:	e59f1008 	ldr	r1, [pc, #8]	; 4bc4 <_ZN21Cyg_Exception_ControlC1Ev+0x10>
    exception_data = 0;
    4bb8:	e3a02000 	mov	r2, #0	; 0x0
    4bbc:	e8800006 	stm	r0, {r1, r2}
    
#endif
    CYG_REPORT_RETURN();
}
    4bc0:	e12fff1e 	bx	lr
    4bc4:	00004b9c 	.word	0x00004b9c

00004bc8 <_ZN21Cyg_Exception_Control18register_exceptionEiPFvjijEjPS1_Pj>:
    cyg_code                exception_number,       // exception number
    cyg_exception_handler   handler,                // handler function
    CYG_ADDRWORD            data,                   // data argument
    cyg_exception_handler   **old_handler,          // handler function
    CYG_ADDRWORD            *old_data               // data argument
    )
    4bc8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    4bcc:	e59d4004 	ldr	r4, [sp, #4]
    exception_handler[exception_number - CYGNUM_HAL_EXCEPTION_MIN] = handler;
    exception_data[exception_number - CYGNUM_HAL_EXCEPTION_MIN] = data;
    
#else
    
    if( old_handler != NULL )
    4bd0:	e3540000 	cmp	r4, #0	; 0x0
    cyg_code                exception_number,       // exception number
    cyg_exception_handler   handler,                // handler function
    CYG_ADDRWORD            data,                   // data argument
    cyg_exception_handler   **old_handler,          // handler function
    CYG_ADDRWORD            *old_data               // data argument
    )
    4bd4:	e1a01003 	mov	r1, r3
    4bd8:	e59dc008 	ldr	ip, [sp, #8]
    exception_data[exception_number - CYGNUM_HAL_EXCEPTION_MIN] = data;
    
#else
    
    if( old_handler != NULL )
        *old_handler = exception_handler;
    4bdc:	15903000 	ldrne	r3, [r0]
    4be0:	15843000 	strne	r3, [r4]
    if( old_data != NULL )
    4be4:	e35c0000 	cmp	ip, #0	; 0x0
        *old_data = exception_data;
    4be8:	15903004 	ldrne	r3, [r0, #4]
    exception_handler = handler;
    4bec:	e5802000 	str	r2, [r0]
#else
    
    if( old_handler != NULL )
        *old_handler = exception_handler;
    if( old_data != NULL )
        *old_data = exception_data;
    4bf0:	158c3000 	strne	r3, [ip]
    exception_handler = handler;
    exception_data = data;
    4bf4:	e5801004 	str	r1, [r0, #4]
    
#endif
    CYG_REPORT_RETURN();
}
    4bf8:	e8bd0010 	pop	{r4}
    4bfc:	e12fff1e 	bx	lr

00004c00 <_ZN21Cyg_Exception_Control20deregister_exceptionEi>:
        cyg_null_exception_handler;
    exception_data[exception_number - CYGNUM_HAL_EXCEPTION_MIN] = 0;
    
#else
    
    exception_handler = cyg_null_exception_handler;
    4c00:	e59f2008 	ldr	r2, [pc, #8]	; 4c10 <_ZN21Cyg_Exception_Control20deregister_exceptionEi+0x10>
    exception_data = 0;
    4c04:	e3a03000 	mov	r3, #0	; 0x0
    4c08:	e880000c 	stm	r0, {r2, r3}
    
#endif

    CYG_REPORT_RETURN();
}
    4c0c:	e12fff1e 	bx	lr
    4c10:	00004b9c 	.word	0x00004b9c

00004c14 <_ZN21Cyg_Exception_Control17deliver_exceptionEij>:

void
Cyg_Exception_Control::deliver_exception(
    cyg_code            exception_number,       // exception being raised
    CYG_ADDRWORD        exception_info          // exception specific info
    )
    4c14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    4c18:	e1a03000 	mov	r3, r0
    4c1c:	e24dd004 	sub	sp, sp, #4	; 0x4

    // The handler will always be a callable function: either the user's
    // registered function or the null handler. So it is always safe to
    // just go ahead and call it.
    
    handler( data, exception_number, exception_info );
    4c20:	e5900004 	ldr	r0, [r0, #4]
    4c24:	e1a0e00f 	mov	lr, pc
    4c28:	e593f000 	ldr	pc, [r3]

    CYG_REPORT_RETURN();
}
    4c2c:	e28dd004 	add	sp, sp, #4	; 0x4
    4c30:	e8bd8000 	pop	{pc}

00004c34 <_GLOBAL__I.12000__Z26cyg_null_exception_handlerjij>:
    for( int i = 0; i < CYGNUM_HAL_EXCEPTION_COUNT ; i++ )
        exception_handler[i] = cyg_null_exception_handler,
            exception_data[i] = 0;
#else

    exception_handler = cyg_null_exception_handler;    
    4c34:	e59f300c 	ldr	r3, [pc, #12]	; 4c48 <_GLOBAL__I.12000__Z26cyg_null_exception_handlerjij+0x14>
    4c38:	e59f100c 	ldr	r1, [pc, #12]	; 4c4c <_GLOBAL__I.12000__Z26cyg_null_exception_handlerjij+0x18>
    exception_data = 0;
    4c3c:	e3a02000 	mov	r2, #0	; 0x0
    4c40:	e8830006 	stm	r3, {r1, r2}
// exception control object. Define it here.

#ifdef CYGSEM_KERNEL_EXCEPTIONS_GLOBAL

Cyg_Exception_Control Cyg_Thread::exception_control 
                                              CYG_INIT_PRIORITY(INTERRUPTS);
    4c44:	e12fff1e 	bx	lr
    4c48:	40002518 	.word	0x40002518
    4c4c:	00004b9c 	.word	0x00004b9c

00004c50 <cyg_hal_deliver_exception>:
// -------------------------------------------------------------------------
// Exception delivery function called from the HAL as a result of a
// hardware exception being raised.

externC void
cyg_hal_deliver_exception( CYG_WORD code, CYG_ADDRWORD data )
    4c50:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    4c54:	e59f3018 	ldr	r3, [pc, #24]	; 4c74 <cyg_hal_deliver_exception+0x24>
    4c58:	e593c000 	ldr	ip, [r3]
    4c5c:	e1a04000 	mov	r4, r0
    4c60:	e1a02001 	mov	r2, r1
{
    CYG_REPORT_FUNCTION();
    Cyg_Thread::self()->deliver_exception( (cyg_code)code, data );
    4c64:	e1a0000c 	mov	r0, ip
    4c68:	e1a01004 	mov	r1, r4
    CYG_REPORT_RETURN();
}
    4c6c:	e8bd0010 	pop	{r4}

externC void
cyg_hal_deliver_exception( CYG_WORD code, CYG_ADDRWORD data )
{
    CYG_REPORT_FUNCTION();
    Cyg_Thread::self()->deliver_exception( (cyg_code)code, data );
    4c70:	eafffb75 	b	3a4c <_ZN10Cyg_Thread17deliver_exceptionEij>
    4c74:	40002538 	.word	0x40002538

00004c78 <_ZN13Cyg_InterruptC2EjijPFjjjEPFvjjjE>:
    cyg_vector      vec,                // Vector to attach to
    cyg_priority    pri,                // Queue priority
    CYG_ADDRWORD    d,                  // Data pointer
    cyg_ISR         *ir,                // Interrupt Service Routine
    cyg_DSR         *dr                 // Deferred Service Routine
    )
    4c78:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG5("vector=%d, priority=%d, data=%08x, isr=%08x, "
                        "dsr=%08x", vec, pri, d, ir, dr);
    
    vector      = vec;
    4c7c:	e8800006 	stm	r0, {r1, r2}
    priority    = pri;
    isr         = ir;
    dsr         = dr;
    4c80:	e59d1008 	ldr	r1, [sp, #8]
    CYG_REPORT_FUNCARG5("vector=%d, priority=%d, data=%08x, isr=%08x, "
                        "dsr=%08x", vec, pri, d, ir, dr);
    
    vector      = vec;
    priority    = pri;
    isr         = ir;
    4c84:	e59d2004 	ldr	r2, [sp, #4]
    dsr         = dr;
    data        = d;

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    dsr_count   = 0;
    4c88:	e3a04000 	mov	r4, #0	; 0x0
    4c8c:	e5804014 	str	r4, [r0, #20]
    CYG_REPORT_FUNCARG5("vector=%d, priority=%d, data=%08x, isr=%08x, "
                        "dsr=%08x", vec, pri, d, ir, dr);
    
    vector      = vec;
    priority    = pri;
    isr         = ir;
    4c90:	e5802008 	str	r2, [r0, #8]
    dsr         = dr;
    4c94:	e580100c 	str	r1, [r0, #12]
    data        = d;
    4c98:	e5803010 	str	r3, [r0, #16]

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    dsr_count   = 0;
    next_dsr    = NULL;
    4c9c:	e5804018 	str	r4, [r0, #24]
    
#endif

    CYG_REPORT_RETURN();
    
};
    4ca0:	e8bd0010 	pop	{r4}
    4ca4:	e12fff1e 	bx	lr

00004ca8 <_ZN13Cyg_InterruptC1EjijPFjjjEPFvjjjE>:
    cyg_vector      vec,                // Vector to attach to
    cyg_priority    pri,                // Queue priority
    CYG_ADDRWORD    d,                  // Data pointer
    cyg_ISR         *ir,                // Interrupt Service Routine
    cyg_DSR         *dr                 // Deferred Service Routine
    )
    4ca8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG5("vector=%d, priority=%d, data=%08x, isr=%08x, "
                        "dsr=%08x", vec, pri, d, ir, dr);
    
    vector      = vec;
    4cac:	e8800006 	stm	r0, {r1, r2}
    priority    = pri;
    isr         = ir;
    dsr         = dr;
    4cb0:	e59d1008 	ldr	r1, [sp, #8]
    CYG_REPORT_FUNCARG5("vector=%d, priority=%d, data=%08x, isr=%08x, "
                        "dsr=%08x", vec, pri, d, ir, dr);
    
    vector      = vec;
    priority    = pri;
    isr         = ir;
    4cb4:	e59d2004 	ldr	r2, [sp, #4]
    dsr         = dr;
    data        = d;

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    dsr_count   = 0;
    4cb8:	e3a04000 	mov	r4, #0	; 0x0
    4cbc:	e5804014 	str	r4, [r0, #20]
    CYG_REPORT_FUNCARG5("vector=%d, priority=%d, data=%08x, isr=%08x, "
                        "dsr=%08x", vec, pri, d, ir, dr);
    
    vector      = vec;
    priority    = pri;
    isr         = ir;
    4cc0:	e5802008 	str	r2, [r0, #8]
    dsr         = dr;
    4cc4:	e580100c 	str	r1, [r0, #12]
    data        = d;
    4cc8:	e5803010 	str	r3, [r0, #16]

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    dsr_count   = 0;
    next_dsr    = NULL;
    4ccc:	e5804018 	str	r4, [r0, #24]
    
#endif

    CYG_REPORT_RETURN();
    
};
    4cd0:	e8bd0010 	pop	{r4}
    4cd4:	e12fff1e 	bx	lr

00004cd8 <_ZN13Cyg_InterruptD2Ev>:

// -------------------------------------------------------------------------

Cyg_Interrupt::~Cyg_Interrupt()
    4cd8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    if( chain_list[index] == NULL )
        HAL_INTERRUPT_DETACH( vector, chain_isr );
    
#else
    
    HAL_INTERRUPT_DETACH( vector, isr );
    4cdc:	e590c000 	ldr	ip, [r0]
    4ce0:	e59f4030 	ldr	r4, [pc, #48]	; 4d18 <_ZN13Cyg_InterruptD2Ev+0x40>
    4ce4:	e5902008 	ldr	r2, [r0, #8]
    4ce8:	e794310c 	ldr	r3, [r4, ip, lsl #2]
    4cec:	e1520003 	cmp	r2, r3
    4cf0:	1a000006 	bne	4d10 <_ZN13Cyg_InterruptD2Ev+0x38>
    4cf4:	e59f3020 	ldr	r3, [pc, #32]	; 4d1c <_ZN13Cyg_InterruptD2Ev+0x44>
    4cf8:	e3a01000 	mov	r1, #0	; 0x0
    4cfc:	e783110c 	str	r1, [r3, ip, lsl #2]
    4d00:	e59f2018 	ldr	r2, [pc, #24]	; 4d20 <_ZN13Cyg_InterruptD2Ev+0x48>
    4d04:	e59f3018 	ldr	r3, [pc, #24]	; 4d24 <_ZN13Cyg_InterruptD2Ev+0x4c>
    4d08:	e784210c 	str	r2, [r4, ip, lsl #2]
    4d0c:	e783110c 	str	r1, [r3, ip, lsl #2]
Cyg_Interrupt::~Cyg_Interrupt()
{
    CYG_REPORT_FUNCTION();
    detach();
    CYG_REPORT_RETURN();
};
    4d10:	e8bd0010 	pop	{r4}
    4d14:	e12fff1e 	bx	lr
    4d18:	40000544 	.word	0x40000544
    4d1c:	40000644 	.word	0x40000644
    4d20:	00001af4 	.word	0x00001af4
    4d24:	400005c4 	.word	0x400005c4

00004d28 <_ZN13Cyg_InterruptD1Ev>:
    
};

// -------------------------------------------------------------------------

Cyg_Interrupt::~Cyg_Interrupt()
    4d28:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    if( chain_list[index] == NULL )
        HAL_INTERRUPT_DETACH( vector, chain_isr );
    
#else
    
    HAL_INTERRUPT_DETACH( vector, isr );
    4d2c:	e590c000 	ldr	ip, [r0]
    4d30:	e59f4030 	ldr	r4, [pc, #48]	; 4d68 <_ZN13Cyg_InterruptD1Ev+0x40>
    4d34:	e5902008 	ldr	r2, [r0, #8]
    4d38:	e794310c 	ldr	r3, [r4, ip, lsl #2]
    4d3c:	e1520003 	cmp	r2, r3
    4d40:	1a000006 	bne	4d60 <_ZN13Cyg_InterruptD1Ev+0x38>
    4d44:	e59f3020 	ldr	r3, [pc, #32]	; 4d6c <_ZN13Cyg_InterruptD1Ev+0x44>
    4d48:	e3a01000 	mov	r1, #0	; 0x0
    4d4c:	e783110c 	str	r1, [r3, ip, lsl #2]
    4d50:	e59f2018 	ldr	r2, [pc, #24]	; 4d70 <_ZN13Cyg_InterruptD1Ev+0x48>
    4d54:	e59f3018 	ldr	r3, [pc, #24]	; 4d74 <_ZN13Cyg_InterruptD1Ev+0x4c>
    4d58:	e784210c 	str	r2, [r4, ip, lsl #2]
    4d5c:	e783110c 	str	r1, [r3, ip, lsl #2]
Cyg_Interrupt::~Cyg_Interrupt()
{
    CYG_REPORT_FUNCTION();
    detach();
    CYG_REPORT_RETURN();
};
    4d60:	e8bd0010 	pop	{r4}
    4d64:	e12fff1e 	bx	lr
    4d68:	40000544 	.word	0x40000544
    4d6c:	40000644 	.word	0x40000644
    4d70:	00001af4 	.word	0x00001af4
    4d74:	400005c4 	.word	0x400005c4

00004d78 <_ZN13Cyg_Interrupt23call_pending_DSRs_innerEv>:

// -------------------------------------------------------------------------
// Call any pending DSRs

void
Cyg_Interrupt::call_pending_DSRs_inner(void)
    4d78:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

    cyg_uint32 old_intr;
    HAL_DISABLE_INTERRUPTS(old_intr);
    4d7c:	e10f0000 	mrs	r0, CPSR
    4d80:	e10f4000 	mrs	r4, CPSR
    4d84:	e38440c0 	orr	r4, r4, #192	; 0xc0
    4d88:	e129f004 	msr	CPSR_fc, r4
    Cyg_Interrupt* intr = dsr_list[cpu];
    4d8c:	e59f1068 	ldr	r1, [pc, #104]	; 4dfc <_ZN13Cyg_Interrupt23call_pending_DSRs_innerEv+0x84>
    CYG_ASSERT(intr != 0, "No DSRs are pended");
    dsr_list[cpu] = 0;
    dsr_list_tail[cpu] = 0;
    4d90:	e59f3068 	ldr	r3, [pc, #104]	; 4e00 <_ZN13Cyg_Interrupt23call_pending_DSRs_innerEv+0x88>

    cyg_uint32 old_intr;
    HAL_DISABLE_INTERRUPTS(old_intr);
    Cyg_Interrupt* intr = dsr_list[cpu];
    CYG_ASSERT(intr != 0, "No DSRs are pended");
    dsr_list[cpu] = 0;
    4d94:	e3a02000 	mov	r2, #0	; 0x0

#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

    cyg_uint32 old_intr;
    HAL_DISABLE_INTERRUPTS(old_intr);
    Cyg_Interrupt* intr = dsr_list[cpu];
    4d98:	e591c000 	ldr	ip, [r1]
    CYG_ASSERT(intr != 0, "No DSRs are pended");
    dsr_list[cpu] = 0;
    4d9c:	e5812000 	str	r2, [r1]
    dsr_list_tail[cpu] = 0;
    4da0:	e5832000 	str	r2, [r3]
    while(true)
    {
        cyg_count32 count = intr->dsr_count;
        Cyg_Interrupt* next = intr->next_dsr;
        intr->dsr_count = 0;
    4da4:	e1a06002 	mov	r6, r2
    CYG_ASSERT(intr != 0, "No DSRs are pended");
    dsr_list[cpu] = 0;
    dsr_list_tail[cpu] = 0;
    while(true)
    {
        cyg_count32 count = intr->dsr_count;
    4da8:	e59c1014 	ldr	r1, [ip, #20]
        Cyg_Interrupt* next = intr->next_dsr;
    4dac:	e59c5018 	ldr	r5, [ip, #24]
        intr->dsr_count = 0;
    4db0:	e58c6014 	str	r6, [ip, #20]
        intr->next_dsr = 0;
    4db4:	e58c6018 	str	r6, [ip, #24]
        HAL_RESTORE_INTERRUPTS(old_intr);
    4db8:	e10f3000 	mrs	r3, CPSR
    4dbc:	e20040c0 	and	r4, r0, #192	; 0xc0
    4dc0:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    4dc4:	e1833004 	orr	r3, r3, r4
    4dc8:	e129f003 	msr	CPSR_fc, r3

        CYG_ASSERT(intr->dsr != 0, "No DSR defined");
        CYG_ASSERT(count > 0, "DSR posted but post count is zero");
        intr->dsr(intr->vector, count, (CYG_ADDRWORD)intr->data);
    4dcc:	e59c0000 	ldr	r0, [ip]
    4dd0:	e59c2010 	ldr	r2, [ip, #16]
    4dd4:	e1a0e00f 	mov	lr, pc
    4dd8:	e59cf00c 	ldr	pc, [ip, #12]

        if (!next)
    4ddc:	e3550000 	cmp	r5, #0	; 0x0
    4de0:	08bd8070 	popeq	{r4, r5, r6, pc}
            break;

        intr = next;
        HAL_DISABLE_INTERRUPTS(old_intr);
    4de4:	e10f0000 	mrs	r0, CPSR
    4de8:	e10f4000 	mrs	r4, CPSR
    4dec:	e38440c0 	orr	r4, r4, #192	; 0xc0
    4df0:	e129f004 	msr	CPSR_fc, r4
    4df4:	e1a0c005 	mov	ip, r5
    4df8:	eaffffea 	b	4da8 <_ZN13Cyg_Interrupt23call_pending_DSRs_innerEv+0x30>
    4dfc:	4000252c 	.word	0x4000252c
    4e00:	40002530 	.word	0x40002530

00004e04 <cyg_interrupt_call_pending_DSRs>:
};

externC void
cyg_interrupt_call_pending_DSRs(void)
{
    Cyg_Interrupt::call_pending_DSRs_inner();
    4e04:	eaffffdb 	b	4d78 <_ZN13Cyg_Interrupt23call_pending_DSRs_innerEv>

00004e08 <_ZN13Cyg_Interrupt8post_dsrEv>:


// -------------------------------------------------------------------------

void
Cyg_Interrupt::post_dsr(void)
    4e08:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    cyg_uint32 old_intr;

    // We need to disable interrupts during this part to
    // guard against nested interrupts.
    
    HAL_DISABLE_INTERRUPTS(old_intr);
    4e0c:	e10f1000 	mrs	r1, CPSR
    4e10:	e10f4000 	mrs	r4, CPSR
    4e14:	e38440c0 	orr	r4, r4, #192	; 0xc0
    4e18:	e129f004 	msr	CPSR_fc, r4

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    // Only add the interrupt to the dsr list if this is
    // the first DSR call.
    if( dsr_count++ == 0 )
    4e1c:	e5903014 	ldr	r3, [r0, #20]
    4e20:	e3530000 	cmp	r3, #0	; 0x0
    4e24:	e2833001 	add	r3, r3, #1	; 0x1
    4e28:	e5803014 	str	r3, [r0, #20]
    4e2c:	1a000006 	bne	4e4c <_ZN13Cyg_Interrupt8post_dsrEv+0x44>
    {
#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

        // Add to the tail of the list.
        Cyg_Interrupt* tail = dsr_list_tail[cpu];
    4e30:	e59f3030 	ldr	r3, [pc, #48]	; 4e68 <_ZN13Cyg_Interrupt8post_dsrEv+0x60>
    4e34:	e5932000 	ldr	r2, [r3]
        dsr_list_tail[cpu] = this;
        if( tail )
    4e38:	e3520000 	cmp	r2, #0	; 0x0
    {
#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

        // Add to the tail of the list.
        Cyg_Interrupt* tail = dsr_list_tail[cpu];
        dsr_list_tail[cpu] = this;
    4e3c:	e5830000 	str	r0, [r3]
        }
        else
        {
            CYG_ASSERT( 0 == dsr_list[cpu] ,
              "DSR list tail is 0 but its head is not");
            dsr_list[cpu] = this;
    4e40:	059f3024 	ldreq	r3, [pc, #36]	; 4e6c <_ZN13Cyg_Interrupt8post_dsrEv+0x64>
        dsr_list_tail[cpu] = this;
        if( tail )
        {
            CYG_ASSERT( 0 != dsr_list[cpu] ,
              "DSR list is not empty but its head is 0");
            tail->next_dsr = this;
    4e44:	15820018 	strne	r0, [r2, #24]
        }
        else
        {
            CYG_ASSERT( 0 == dsr_list[cpu] ,
              "DSR list tail is 0 but its head is not");
            dsr_list[cpu] = this;
    4e48:	05830000 	streq	r0, [r3]

    }

#endif  // defined CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST
    
    HAL_RESTORE_INTERRUPTS(old_intr);    
    4e4c:	e10f3000 	mrs	r3, CPSR
    4e50:	e20140c0 	and	r4, r1, #192	; 0xc0
    4e54:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    4e58:	e1833004 	orr	r3, r3, r4
    4e5c:	e129f003 	msr	CPSR_fc, r3
};
    4e60:	e8bd0010 	pop	{r4}
    4e64:	e12fff1e 	bx	lr
    4e68:	40002530 	.word	0x40002530
    4e6c:	4000252c 	.word	0x4000252c

00004e70 <cyg_interrupt_post_dsr>:
// -------------------------------------------------------------------------
// A C callable interface to Cyg_Interrupt::post_dsr() that can be used from
// the HAL.

externC void
cyg_interrupt_post_dsr( CYG_ADDRWORD intr_obj )
    4e70:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    cyg_uint32 old_intr;

    // We need to disable interrupts during this part to
    // guard against nested interrupts.
    
    HAL_DISABLE_INTERRUPTS(old_intr);
    4e74:	e10f1000 	mrs	r1, CPSR
    4e78:	e10f4000 	mrs	r4, CPSR
    4e7c:	e38440c0 	orr	r4, r4, #192	; 0xc0
    4e80:	e129f004 	msr	CPSR_fc, r4

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    // Only add the interrupt to the dsr list if this is
    // the first DSR call.
    if( dsr_count++ == 0 )
    4e84:	e5903014 	ldr	r3, [r0, #20]
    4e88:	e3530000 	cmp	r3, #0	; 0x0
    4e8c:	e2833001 	add	r3, r3, #1	; 0x1
    4e90:	e5803014 	str	r3, [r0, #20]
    4e94:	1a000006 	bne	4eb4 <cyg_interrupt_post_dsr+0x44>
    {
#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

        // Add to the tail of the list.
        Cyg_Interrupt* tail = dsr_list_tail[cpu];
    4e98:	e59f3030 	ldr	r3, [pc, #48]	; 4ed0 <cyg_interrupt_post_dsr+0x60>
    4e9c:	e5932000 	ldr	r2, [r3]
        dsr_list_tail[cpu] = this;
        if( tail )
    4ea0:	e3520000 	cmp	r2, #0	; 0x0
    {
#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

        // Add to the tail of the list.
        Cyg_Interrupt* tail = dsr_list_tail[cpu];
        dsr_list_tail[cpu] = this;
    4ea4:	e5830000 	str	r0, [r3]
        }
        else
        {
            CYG_ASSERT( 0 == dsr_list[cpu] ,
              "DSR list tail is 0 but its head is not");
            dsr_list[cpu] = this;
    4ea8:	059f3024 	ldreq	r3, [pc, #36]	; 4ed4 <cyg_interrupt_post_dsr+0x64>
        dsr_list_tail[cpu] = this;
        if( tail )
        {
            CYG_ASSERT( 0 != dsr_list[cpu] ,
              "DSR list is not empty but its head is 0");
            tail->next_dsr = this;
    4eac:	15820018 	strne	r0, [r2, #24]
        }
        else
        {
            CYG_ASSERT( 0 == dsr_list[cpu] ,
              "DSR list tail is 0 but its head is not");
            dsr_list[cpu] = this;
    4eb0:	05830000 	streq	r0, [r3]

    }

#endif  // defined CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST
    
    HAL_RESTORE_INTERRUPTS(old_intr);    
    4eb4:	e10f3000 	mrs	r3, CPSR
    4eb8:	e20140c0 	and	r4, r1, #192	; 0xc0
    4ebc:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    4ec0:	e1833004 	orr	r3, r3, r4
    4ec4:	e129f003 	msr	CPSR_fc, r3
externC void
cyg_interrupt_post_dsr( CYG_ADDRWORD intr_obj )
{
    Cyg_Interrupt* intr = (Cyg_Interrupt*) intr_obj;
    intr->post_dsr ();
}
    4ec8:	e8bd0010 	pop	{r4}
    4ecc:	e12fff1e 	bx	lr
    4ed0:	40002530 	.word	0x40002530
    4ed4:	4000252c 	.word	0x4000252c

00004ed8 <_ZN13Cyg_Interrupt6detachEv>:

// -------------------------------------------------------------------------
// Detach the ISR from the vector

void
Cyg_Interrupt::detach(void)
    4ed8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    if( chain_list[index] == NULL )
        HAL_INTERRUPT_DETACH( vector, chain_isr );
    
#else
    
    HAL_INTERRUPT_DETACH( vector, isr );
    4edc:	e590c000 	ldr	ip, [r0]
    4ee0:	e59f4030 	ldr	r4, [pc, #48]	; 4f18 <_ZN13Cyg_Interrupt6detachEv+0x40>
    4ee4:	e5902008 	ldr	r2, [r0, #8]
    4ee8:	e794310c 	ldr	r3, [r4, ip, lsl #2]
    4eec:	e1520003 	cmp	r2, r3
    4ef0:	1a000006 	bne	4f10 <_ZN13Cyg_Interrupt6detachEv+0x38>
    4ef4:	e59f3020 	ldr	r3, [pc, #32]	; 4f1c <_ZN13Cyg_Interrupt6detachEv+0x44>
    4ef8:	e3a01000 	mov	r1, #0	; 0x0
    4efc:	e783110c 	str	r1, [r3, ip, lsl #2]
    4f00:	e59f2018 	ldr	r2, [pc, #24]	; 4f20 <_ZN13Cyg_Interrupt6detachEv+0x48>
    4f04:	e59f3018 	ldr	r3, [pc, #24]	; 4f24 <_ZN13Cyg_Interrupt6detachEv+0x4c>
    4f08:	e784210c 	str	r2, [r4, ip, lsl #2]
    4f0c:	e783110c 	str	r1, [r3, ip, lsl #2]

#endif

    CYG_REPORT_RETURN();
    
}
    4f10:	e8bd0010 	pop	{r4}
    4f14:	e12fff1e 	bx	lr
    4f18:	40000544 	.word	0x40000544
    4f1c:	40000644 	.word	0x40000644
    4f20:	00001af4 	.word	0x00001af4
    4f24:	400005c4 	.word	0x400005c4

00004f28 <_ZN13Cyg_Interrupt7get_vsrEjPPFvvE>:
                        vsr);

    CYG_ASSERT( vector >= CYGNUM_HAL_VSR_MIN, "Invalid vector");        
    CYG_ASSERT( vector <= CYGNUM_HAL_VSR_MAX, "Invalid vector");

    HAL_VSR_GET( vector, vsr );
    4f28:	e59f3008 	ldr	r3, [pc, #8]	; 4f38 <_ZN13Cyg_Interrupt7get_vsrEjPPFvvE+0x10>
    4f2c:	e7932100 	ldr	r2, [r3, r0, lsl #2]
    4f30:	e5812000 	str	r2, [r1]

    CYG_REPORT_RETURN();
}
    4f34:	e12fff1e 	bx	lr
    4f38:	40000400 	.word	0x40000400

00004f3c <_ZN13Cyg_Interrupt7set_vsrEjPFvvEPS1_>:

// -------------------------------------------------------------------------
// Install a vector service routine

void
Cyg_Interrupt::set_vsr(cyg_vector vector, cyg_VSR *vsr, cyg_VSR **old)
    4f3c:	e92d0030 	push	{r4, r5}
    4f40:	e1a05001 	mov	r5, r1
    CYG_ASSERT( vector >= CYGNUM_HAL_VSR_MIN, "Invalid vector");    
    CYG_ASSERT( vector <= CYGNUM_HAL_VSR_MAX, "Invalid vector");    

    CYG_INTERRUPT_STATE old_ints;
    
    HAL_DISABLE_INTERRUPTS(old_ints);
    4f44:	e10f1000 	mrs	r1, CPSR
    4f48:	e10f4000 	mrs	r4, CPSR
    4f4c:	e38440c0 	orr	r4, r4, #192	; 0xc0
    4f50:	e129f004 	msr	CPSR_fc, r4

    HAL_VSR_SET( vector, vsr, old );
    4f54:	e3520000 	cmp	r2, #0	; 0x0
    4f58:	159fc028 	ldrne	ip, [pc, #40]	; 4f88 <_ZN13Cyg_Interrupt7set_vsrEjPFvvEPS1_+0x4c>
    4f5c:	059fc024 	ldreq	ip, [pc, #36]	; 4f88 <_ZN13Cyg_Interrupt7set_vsrEjPFvvEPS1_+0x4c>
    4f60:	179c3100 	ldrne	r3, [ip, r0, lsl #2]
    4f64:	15823000 	strne	r3, [r2]
    4f68:	e78c5100 	str	r5, [ip, r0, lsl #2]
    
    HAL_RESTORE_INTERRUPTS(old_ints);
    4f6c:	e10f3000 	mrs	r3, CPSR
    4f70:	e20140c0 	and	r4, r1, #192	; 0xc0
    4f74:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    4f78:	e1833004 	orr	r3, r3, r4
    4f7c:	e129f003 	msr	CPSR_fc, r3

    CYG_REPORT_RETURN();
}
    4f80:	e8bd0030 	pop	{r4, r5}
    4f84:	e12fff1e 	bx	lr
    4f88:	40000400 	.word	0x40000400

00004f8c <_ZN13Cyg_Interrupt18disable_interruptsEv>:

    HAL_SMP_CPU_TYPE cpu_this = CYG_KERNEL_CPU_THIS();

    // If the disable_counter is zero, disable interrupts and claim the spinlock.
    
    if( 0 == disable_counter[cpu_this] )
    4f8c:	e59f0044 	ldr	r0, [pc, #68]	; 4fd8 <_ZN13Cyg_Interrupt18disable_interruptsEv+0x4c>
    4f90:	e5903000 	ldr	r3, [r0]
    4f94:	e3530000 	cmp	r3, #0	; 0x0
// -------------------------------------------------------------------------
// Disable interrupts at the CPU


void
Cyg_Interrupt::disable_interrupts(void)
    4f98:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)

    HAL_SMP_CPU_TYPE cpu_this = CYG_KERNEL_CPU_THIS();

    // If the disable_counter is zero, disable interrupts and claim the spinlock.
    
    if( 0 == disable_counter[cpu_this] )
    4f9c:	1a000008 	bne	4fc4 <_ZN13Cyg_Interrupt18disable_interruptsEv+0x38>
    // Claim the spinlock, but also mask this CPU's interrupts while
    // we have it.
    void spin_intsave(CYG_INTERRUPT_STATE *state)
    {
        CYG_INTERRUPT_STATE s;
        HAL_DISABLE_INTERRUPTS(s);
    4fa0:	e10f2000 	mrs	r2, CPSR
    4fa4:	e10f4000 	mrs	r4, CPSR
    4fa8:	e38440c0 	orr	r4, r4, #192	; 0xc0
    4fac:	e129f004 	msr	CPSR_fc, r4
        *state = s;
    4fb0:	e59f3024 	ldr	r3, [pc, #36]	; 4fdc <_ZN13Cyg_Interrupt18disable_interruptsEv+0x50>
    4fb4:	e5832000 	str	r2, [r3]
    
    // Spin on the lock. In this case we just set it to 1 and proceed.
    void spin()
    {
        CYG_ASSERT( lock == 0, "spinlock already claimed!");
        lock = 1;
    4fb8:	e59f3020 	ldr	r3, [pc, #32]	; 4fe0 <_ZN13Cyg_Interrupt18disable_interruptsEv+0x54>
    4fbc:	e3a01001 	mov	r1, #1	; 0x1
    4fc0:	e5831000 	str	r1, [r3]
        interrupt_disable_spinlock.spin_intsave(&interrupt_disable_state[cpu_this]);
    }

    // Now increment our disable counter.
    
    disable_counter[cpu_this]++;
    4fc4:	e5903000 	ldr	r3, [r0]
    4fc8:	e2833001 	add	r3, r3, #1	; 0x1
    4fcc:	e5803000 	str	r3, [r0]
    
    CYG_REPORT_RETURN();
}
    4fd0:	e8bd0010 	pop	{r4}
    4fd4:	e12fff1e 	bx	lr
    4fd8:	40002520 	.word	0x40002520
    4fdc:	40002528 	.word	0x40002528
    4fe0:	40002524 	.word	0x40002524

00004fe4 <_ZN13Cyg_Interrupt17enable_interruptsEv>:
    CYG_ASSERT( disable_counter[cpu_this] > 0 , "Disable counter not greater than zero");
    
    // If the disable counter goes to zero, then release the spinlock and restore
    // the previous interrupt state.
    
    if( --disable_counter[cpu_this] == 0 )
    4fe4:	e59f2044 	ldr	r2, [pc, #68]	; 5030 <_ZN13Cyg_Interrupt17enable_interruptsEv+0x4c>
    4fe8:	e5923000 	ldr	r3, [r2]
    4fec:	e2433001 	sub	r3, r3, #1	; 0x1
    4ff0:	e5823000 	str	r3, [r2]
    4ff4:	e5922000 	ldr	r2, [r2]
    4ff8:	e3520000 	cmp	r2, #0	; 0x0

// -------------------------------------------------------------------------
// Re-enable CPU interrupts

void
Cyg_Interrupt::enable_interrupts(void)
    4ffc:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    CYG_ASSERT( disable_counter[cpu_this] > 0 , "Disable counter not greater than zero");
    
    // If the disable counter goes to zero, then release the spinlock and restore
    // the previous interrupt state.
    
    if( --disable_counter[cpu_this] == 0 )
    5000:	1a000008 	bne	5028 <_ZN13Cyg_Interrupt17enable_interruptsEv+0x44>

    // Clear the lock. Again, just set the value.
    void clear()
    {
        CYG_ASSERT( lock != 0, "spinlock already cleared!");
        lock = 0;
    5004:	e59f3028 	ldr	r3, [pc, #40]	; 5034 <_ZN13Cyg_Interrupt17enable_interruptsEv+0x50>
    5008:	e5832000 	str	r2, [r3]
    {
        interrupt_disable_spinlock.clear_intsave(interrupt_disable_state[cpu_this]);
    500c:	e59f2024 	ldr	r2, [pc, #36]	; 5038 <_ZN13Cyg_Interrupt17enable_interruptsEv+0x54>
    5010:	e5921000 	ldr	r1, [r2]
    // Clear the lock, and restore the interrupt state saved in
    // spin_intsave().
    void clear_intsave(CYG_INTERRUPT_STATE state)
    {
        clear();
        HAL_RESTORE_INTERRUPTS(state);
    5014:	e10f3000 	mrs	r3, CPSR
    5018:	e20140c0 	and	r4, r1, #192	; 0xc0
    501c:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    5020:	e1833004 	orr	r3, r3, r4
    5024:	e129f003 	msr	CPSR_fc, r3
    }

    CYG_REPORT_RETURN();
}
    5028:	e8bd0010 	pop	{r4}
    502c:	e12fff1e 	bx	lr
    5030:	40002520 	.word	0x40002520
    5034:	40002524 	.word	0x40002524
    5038:	40002528 	.word	0x40002528

0000503c <_GLOBAL__I.12000__ZN13Cyg_Interrupt15disable_counterE>:
    volatile cyg_uint32 lock;

public:

    // Constructor, initialize the lock to clear
    Cyg_SpinLock() { lock = 0; };
    503c:	e59f3008 	ldr	r3, [pc, #8]	; 504c <_GLOBAL__I.12000__ZN13Cyg_Interrupt15disable_counterE+0x10>
    5040:	e3a02000 	mov	r2, #0	; 0x0
    5044:	e5832000 	str	r2, [r3]
    CYG_INSTRUMENT_INTR(CONFIGURE, vector, (level<<1)|up);

    HAL_INTERRUPT_CONFIGURE( vector, level, up );

    CYG_REPORT_RETURN();
}
    5048:	e12fff1e 	bx	lr
    504c:	40002524 	.word	0x40002524

00005050 <_GLOBAL__D.12000__ZN13Cyg_Interrupt15disable_counterE>:
    5050:	e12fff1e 	bx	lr

00005054 <_ZN13Cyg_Interrupt19configure_interruptEjii>:
    CYG_ASSERT( vector >= CYGNUM_HAL_ISR_MIN, "Invalid vector");    
    CYG_ASSERT( vector <= CYGNUM_HAL_ISR_MAX, "Invalid vector");

    CYG_INSTRUMENT_INTR(CONFIGURE, vector, (level<<1)|up);

    HAL_INTERRUPT_CONFIGURE( vector, level, up );
    5054:	ea0022fa 	b	dc44 <hal_interrupt_configure>

00005058 <_ZN13Cyg_Interrupt21acknowledge_interruptEj>:
    CYG_ASSERT( vector >= CYGNUM_HAL_ISR_MIN, "Invalid vector");    
    CYG_ASSERT( vector <= CYGNUM_HAL_ISR_MAX, "Invalid vector");

    CYG_INSTRUMENT_INTR(ACK, vector, 0);

    HAL_INTERRUPT_ACKNOWLEDGE( vector );
    5058:	ea0022ee 	b	dc18 <hal_interrupt_acknowledge>

0000505c <_ZN13Cyg_Interrupt26unmask_interrupt_intunsafeEj>:
    CYG_ASSERT( vector >= CYGNUM_HAL_ISR_MIN, "Invalid vector");    
    CYG_ASSERT( vector <= CYGNUM_HAL_ISR_MAX, "Invalid vector");
    
    CYG_INSTRUMENT_INTR(UNMASK, vector, 0);

    HAL_INTERRUPT_UNMASK( vector );
    505c:	ea0022e8 	b	dc04 <hal_interrupt_unmask>

00005060 <_ZN13Cyg_Interrupt16unmask_interruptEj>:

// -------------------------------------------------------------------------
// Clear PIC mask

void
Cyg_Interrupt::unmask_interrupt(cyg_vector vector)
    5060:	e92d4030 	push	{r4, r5, lr}
    5064:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    CYG_INSTRUMENT_INTR(UNMASK, vector, 0);

    CYG_INTERRUPT_STATE old_ints;
    
    HAL_DISABLE_INTERRUPTS(old_ints);
    5068:	e10f5000 	mrs	r5, CPSR
    506c:	e10f4000 	mrs	r4, CPSR
    5070:	e38440c0 	orr	r4, r4, #192	; 0xc0
    5074:	e129f004 	msr	CPSR_fc, r4
    HAL_INTERRUPT_UNMASK( vector );
    5078:	eb0022e1 	bl	dc04 <hal_interrupt_unmask>
    HAL_RESTORE_INTERRUPTS(old_ints);
    507c:	e10f3000 	mrs	r3, CPSR
    5080:	e20540c0 	and	r4, r5, #192	; 0xc0
    5084:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    5088:	e1833004 	orr	r3, r3, r4
    508c:	e129f003 	msr	CPSR_fc, r3

    CYG_REPORT_RETURN();
}
    5090:	e28dd004 	add	sp, sp, #4	; 0x4
    5094:	e8bd8030 	pop	{r4, r5, pc}

00005098 <_ZN13Cyg_Interrupt24mask_interrupt_intunsafeEj>:
    CYG_ASSERT( vector >= CYGNUM_HAL_ISR_MIN, "Invalid vector");    
    CYG_ASSERT( vector <= CYGNUM_HAL_ISR_MAX, "Invalid vector");

    CYG_INSTRUMENT_INTR(MASK, vector, 0);

    HAL_INTERRUPT_MASK( vector );
    5098:	ea0022d4 	b	dbf0 <hal_interrupt_mask>

0000509c <_ZN13Cyg_Interrupt14mask_interruptEj>:
    
// -------------------------------------------------------------------------
// Mask a specific interrupt in a PIC

void
Cyg_Interrupt::mask_interrupt(cyg_vector vector)
    509c:	e92d4030 	push	{r4, r5, lr}
    50a0:	e24dd004 	sub	sp, sp, #4	; 0x4

    CYG_INSTRUMENT_INTR(MASK, vector, 0);

    CYG_INTERRUPT_STATE old_ints;
    
    HAL_DISABLE_INTERRUPTS(old_ints);
    50a4:	e10f5000 	mrs	r5, CPSR
    50a8:	e10f4000 	mrs	r4, CPSR
    50ac:	e38440c0 	orr	r4, r4, #192	; 0xc0
    50b0:	e129f004 	msr	CPSR_fc, r4
    HAL_INTERRUPT_MASK( vector );
    50b4:	eb0022cd 	bl	dbf0 <hal_interrupt_mask>
    HAL_RESTORE_INTERRUPTS(old_ints);
    50b8:	e10f3000 	mrs	r3, CPSR
    50bc:	e20540c0 	and	r4, r5, #192	; 0xc0
    50c0:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    50c4:	e1833004 	orr	r3, r3, r4
    50c8:	e129f003 	msr	CPSR_fc, r3

    CYG_REPORT_RETURN();
}
    50cc:	e28dd004 	add	sp, sp, #4	; 0x4
    50d0:	e8bd8030 	pop	{r4, r5, pc}

000050d4 <_ZN13Cyg_Interrupt6attachEv>:

// -------------------------------------------------------------------------
// Attach an ISR to an interrupt vector.

void
Cyg_Interrupt::attach(void)
    50d4:	e92d4010 	push	{r4, lr}
    50d8:	e1a04000 	mov	r4, r0
    CYG_ASSERT( vector >= CYGNUM_HAL_ISR_MIN, "Invalid vector");
    CYG_ASSERT( vector <= CYGNUM_HAL_ISR_MAX, "Invalid vector");

    CYG_INSTRUMENT_INTR(ATTACH, vector, 0);

    HAL_INTERRUPT_SET_LEVEL( vector, priority );
    50dc:	e5941004 	ldr	r1, [r4, #4]
    50e0:	e5900000 	ldr	r0, [r0]
    50e4:	eb0022f9 	bl	dcd0 <hal_interrupt_set_level>
    
    {
        int in_use;


        HAL_INTERRUPT_IN_USE( vector, in_use );
    50e8:	e5940000 	ldr	r0, [r4]
        CYG_ASSERT( 0 == in_use, "Interrupt vector not free.");

        HAL_INTERRUPT_ATTACH( vector, isr, data, this );
    50ec:	e59f102c 	ldr	r1, [pc, #44]	; 5120 <_ZN13Cyg_Interrupt6attachEv+0x4c>
    50f0:	e59f302c 	ldr	r3, [pc, #44]	; 5124 <_ZN13Cyg_Interrupt6attachEv+0x50>
    50f4:	e7912100 	ldr	r2, [r1, r0, lsl #2]
    50f8:	e1520003 	cmp	r2, r3
    50fc:	18bd8010 	popne	{r4, pc}
    5100:	e5943008 	ldr	r3, [r4, #8]
    5104:	e7813100 	str	r3, [r1, r0, lsl #2]
    5108:	e59f2018 	ldr	r2, [pc, #24]	; 5128 <_ZN13Cyg_Interrupt6attachEv+0x54>
    510c:	e5941010 	ldr	r1, [r4, #16]
    5110:	e59f3014 	ldr	r3, [pc, #20]	; 512c <_ZN13Cyg_Interrupt6attachEv+0x58>
    5114:	e7821100 	str	r1, [r2, r0, lsl #2]
    5118:	e7834100 	str	r4, [r3, r0, lsl #2]
    511c:	e8bd8010 	pop	{r4, pc}
    5120:	40000544 	.word	0x40000544
    5124:	00001af4 	.word	0x00001af4
    5128:	400005c4 	.word	0x400005c4
    512c:	40000644 	.word	0x40000644

00005130 <interrupt_end>:

    // Only do this if we are in a non-chained configuration.
    // If we are chained, then chain_isr below will do the DSR
    // posting.
    
    if( isr_ret & Cyg_Interrupt::CALL_DSR && intr != NULL ) intr->post_dsr();
    5130:	e2513000 	subs	r3, r1, #0	; 0x0
    5134:	13a03001 	movne	r3, #1	; 0x1
    5138:	e01330a0 	ands	r3, r3, r0, lsr #1
externC void
interrupt_end(
    cyg_uint32          isr_ret,
    Cyg_Interrupt       *intr,
    HAL_SavedRegisters  *regs
    )
    513c:	e92d4010 	push	{r4, lr}

    // Only do this if we are in a non-chained configuration.
    // If we are chained, then chain_isr below will do the DSR
    // posting.
    
    if( isr_ret & Cyg_Interrupt::CALL_DSR && intr != NULL ) intr->post_dsr();
    5140:	0a00000d 	beq	517c <interrupt_end+0x4c>
    cyg_uint32 old_intr;

    // We need to disable interrupts during this part to
    // guard against nested interrupts.
    
    HAL_DISABLE_INTERRUPTS(old_intr);
    5144:	e10fc000 	mrs	ip, CPSR
    5148:	e10f4000 	mrs	r4, CPSR
    514c:	e38440c0 	orr	r4, r4, #192	; 0xc0
    5150:	e129f004 	msr	CPSR_fc, r4

#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST

    // Only add the interrupt to the dsr list if this is
    // the first DSR call.
    if( dsr_count++ == 0 )
    5154:	e5913014 	ldr	r3, [r1, #20]
    5158:	e3530000 	cmp	r3, #0	; 0x0
    515c:	e2833001 	add	r3, r3, #1	; 0x1
    5160:	e5813014 	str	r3, [r1, #20]
    5164:	0a000010 	beq	51ac <interrupt_end+0x7c>

    }

#endif  // defined CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST
    
    HAL_RESTORE_INTERRUPTS(old_intr);    
    5168:	e10f3000 	mrs	r3, CPSR
    516c:	e20c40c0 	and	r4, ip, #192	; 0xc0
    5170:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    5174:	e1833004 	orr	r3, r3, r4
    5178:	e129f003 	msr	CPSR_fc, r3
    517c:	e59f405c 	ldr	r4, [pc, #92]	; 51e0 <interrupt_end+0xb0>
    5180:	e5943000 	ldr	r3, [r4]
    return regs;
}

inline void Cyg_HardwareThread::set_saved_context(HAL_SavedRegisters *ctx)
{
    saved_context = ctx;
    5184:	e5832018 	str	r2, [r3, #24]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5188:	e59f2054 	ldr	r2, [pc, #84]	; 51e4 <interrupt_end+0xb4>
    518c:	e5923000 	ldr	r3, [r2]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    5190:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5194:	15820000 	strne	r0, [r2]
    5198:	0a00000b 	beq	51cc <interrupt_end+0x9c>
    519c:	e5942000 	ldr	r2, [r4]
    51a0:	e3a03000 	mov	r3, #0	; 0x0
    51a4:	e5823018 	str	r3, [r2, #24]
    Cyg_Scheduler::get_current_thread()->set_saved_context(0);
    
#endif    
    
    CYG_INSTRUMENT_INTR(RESTORE, vector, 0);    
}
    51a8:	e8bd8010 	pop	{r4, pc}
    if( dsr_count++ == 0 )
    {
#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

        // Add to the tail of the list.
        Cyg_Interrupt* tail = dsr_list_tail[cpu];
    51ac:	e59f3034 	ldr	r3, [pc, #52]	; 51e8 <interrupt_end+0xb8>
    51b0:	e5930000 	ldr	r0, [r3]
        dsr_list_tail[cpu] = this;
        if( tail )
    51b4:	e3500000 	cmp	r0, #0	; 0x0
    {
#  ifdef CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO

        // Add to the tail of the list.
        Cyg_Interrupt* tail = dsr_list_tail[cpu];
        dsr_list_tail[cpu] = this;
    51b8:	e5831000 	str	r1, [r3]
        }
        else
        {
            CYG_ASSERT( 0 == dsr_list[cpu] ,
              "DSR list tail is 0 but its head is not");
            dsr_list[cpu] = this;
    51bc:	059f3028 	ldreq	r3, [pc, #40]	; 51ec <interrupt_end+0xbc>
        dsr_list_tail[cpu] = this;
        if( tail )
        {
            CYG_ASSERT( 0 != dsr_list[cpu] ,
              "DSR list is not empty but its head is 0");
            tail->next_dsr = this;
    51c0:	15801018 	strne	r1, [r0, #24]
        }
        else
        {
            CYG_ASSERT( 0 == dsr_list[cpu] ,
              "DSR list tail is 0 but its head is not");
            dsr_list[cpu] = this;
    51c4:	05831000 	streq	r1, [r3]
    51c8:	eaffffe6 	b	5168 <interrupt_end+0x38>
    51cc:	eb000212 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    51d0:	e5942000 	ldr	r2, [r4]
    51d4:	e3a03000 	mov	r3, #0	; 0x0
    51d8:	e5823018 	str	r3, [r2, #24]
    Cyg_Scheduler::get_current_thread()->set_saved_context(0);
    
#endif    
    
    CYG_INSTRUMENT_INTR(RESTORE, vector, 0);    
}
    51dc:	e8bd8010 	pop	{r4, pc}
    51e0:	40002538 	.word	0x40002538
    51e4:	400007c8 	.word	0x400007c8
    51e8:	40002530 	.word	0x40002530
    51ec:	4000252c 	.word	0x4000252c

000051f0 <_ZN13Cyg_Interrupt17call_pending_DSRsEv>:
void
Cyg_Interrupt::call_pending_DSRs(void)
{
    CYG_ASSERT( Cyg_Scheduler::get_sched_lock() == 1,
                "DSRs being called with sched_lock not equal to 1");
    HAL_INTERRUPT_STACK_CALL_PENDING_DSRS();
    51f0:	eaffecbb 	b	4e4 <hal_interrupt_stack_call_pending_DSRs>

000051f4 <_ZN28Cyg_Scheduler_ImplementationC2Ev>:
    // For non-SMP versions, the code here does the basic and obvious things.
protected:

    Cyg_Scheduler_SchedLock()
    {
        sched_lock = 1;
    51f4:	e59f3040 	ldr	r3, [pc, #64]	; 523c <_ZN28Cyg_Scheduler_ImplementationC2Ev+0x48>
    51f8:	e3a02001 	mov	r2, #1	; 0x1
    51fc:	e5832000 	str	r2, [r3]
// Cyg_Scheduler_Implementation class members

// -------------------------------------------------------------------------
// Constructor.

Cyg_Scheduler_Implementation::Cyg_Scheduler_Implementation()
    5200:	e3a03000 	mov	r3, #0	; 0x0
    5204:	e2802004 	add	r2, r0, #4	; 0x4

public:

    Cyg_CList()
    {
        head = NULL;
    5208:	e1a01003 	mov	r1, r3
    520c:	e7821003 	str	r1, [r2, r3]
template <class T> class Cyg_CList_T
    : public Cyg_CList
{
public:

    Cyg_CList_T() {};
    5210:	e2833004 	add	r3, r3, #4	; 0x4
    5214:	e3530080 	cmp	r3, #128	; 0x80
    5218:	1afffffb 	bne	520c <_ZN28Cyg_Scheduler_ImplementationC2Ev+0x18>
#endif
    
    for( int i = 0; i < CYGNUM_KERNEL_CPU_MAX; i++ )
    {
#ifdef CYGSEM_KERNEL_SCHED_TIMESLICE        
        timeslice_count[i] = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    521c:	e59f301c 	ldr	r3, [pc, #28]	; 5240 <_ZN28Cyg_Scheduler_ImplementationC2Ev+0x4c>
    5220:	e3a02005 	mov	r2, #5	; 0x5

Cyg_Scheduler_Implementation::Cyg_Scheduler_Implementation()
{
    CYG_REPORT_FUNCTION();
        
    queue_map   = 0;
    5224:	e5801000 	str	r1, [r0]
#endif
    
    for( int i = 0; i < CYGNUM_KERNEL_CPU_MAX; i++ )
    {
#ifdef CYGSEM_KERNEL_SCHED_TIMESLICE        
        timeslice_count[i] = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    5228:	e5832000 	str	r2, [r3]
#endif        
        need_reschedule[i] = true;
    522c:	e59f3010 	ldr	r3, [pc, #16]	; 5244 <_ZN28Cyg_Scheduler_ImplementationC2Ev+0x50>
    5230:	e3a01001 	mov	r1, #1	; 0x1
    5234:	e5831000 	str	r1, [r3]
    }
    
    CYG_REPORT_RETURN();
}
    5238:	e12fff1e 	bx	lr
    523c:	400007c8 	.word	0x400007c8
    5240:	40002534 	.word	0x40002534
    5244:	4000253c 	.word	0x4000253c

00005248 <_ZN28Cyg_Scheduler_ImplementationC1Ev>:
    5248:	e59f3040 	ldr	r3, [pc, #64]	; 5290 <_ZN28Cyg_Scheduler_ImplementationC1Ev+0x48>
    524c:	e3a02001 	mov	r2, #1	; 0x1
    5250:	e5832000 	str	r2, [r3]
// Cyg_Scheduler_Implementation class members

// -------------------------------------------------------------------------
// Constructor.

Cyg_Scheduler_Implementation::Cyg_Scheduler_Implementation()
    5254:	e3a03000 	mov	r3, #0	; 0x0
    5258:	e2802004 	add	r2, r0, #4	; 0x4

public:

    Cyg_CList()
    {
        head = NULL;
    525c:	e1a01003 	mov	r1, r3
    5260:	e7821003 	str	r1, [r2, r3]
template <class T> class Cyg_CList_T
    : public Cyg_CList
{
public:

    Cyg_CList_T() {};
    5264:	e2833004 	add	r3, r3, #4	; 0x4
    5268:	e3530080 	cmp	r3, #128	; 0x80
    526c:	1afffffb 	bne	5260 <_ZN28Cyg_Scheduler_ImplementationC1Ev+0x18>
#endif
    
    for( int i = 0; i < CYGNUM_KERNEL_CPU_MAX; i++ )
    {
#ifdef CYGSEM_KERNEL_SCHED_TIMESLICE        
        timeslice_count[i] = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    5270:	e59f301c 	ldr	r3, [pc, #28]	; 5294 <_ZN28Cyg_Scheduler_ImplementationC1Ev+0x4c>
    5274:	e3a02005 	mov	r2, #5	; 0x5

Cyg_Scheduler_Implementation::Cyg_Scheduler_Implementation()
{
    CYG_REPORT_FUNCTION();
        
    queue_map   = 0;
    5278:	e5801000 	str	r1, [r0]
#endif
    
    for( int i = 0; i < CYGNUM_KERNEL_CPU_MAX; i++ )
    {
#ifdef CYGSEM_KERNEL_SCHED_TIMESLICE        
        timeslice_count[i] = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    527c:	e5832000 	str	r2, [r3]
#endif        
        need_reschedule[i] = true;
    5280:	e59f3010 	ldr	r3, [pc, #16]	; 5298 <_ZN28Cyg_Scheduler_ImplementationC1Ev+0x50>
    5284:	e3a01001 	mov	r1, #1	; 0x1
    5288:	e5831000 	str	r1, [r3]
    }
    
    CYG_REPORT_RETURN();
}
    528c:	e12fff1e 	bx	lr
    5290:	400007c8 	.word	0x400007c8
    5294:	40002534 	.word	0x40002534
    5298:	4000253c 	.word	0x4000253c

0000529c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread>:
}

// -------------------------------------------------------------------------

void
Cyg_Scheduler_Implementation::rem_thread(Cyg_Thread *thread)
    529c:	e92d0070 	push	{r4, r5, r6}
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("thread=%08x", thread);
        
    CYG_ASSERT( queue_map != 0, "Run queue empty");

    cyg_priority pri    = thread->priority;
    52a0:	e5916024 	ldr	r6, [r1, #36]
    
    // General removal. Deals with what happend if this is only
    // object on list, or is the head.
    void remove( Cyg_DNode *node )
    {
        if( node == head )
    52a4:	e1a03106 	lsl	r3, r6, #2
}

// -------------------------------------------------------------------------

void
Cyg_Scheduler_Implementation::rem_thread(Cyg_Thread *thread)
    52a8:	e1a0c001 	mov	ip, r1
    52ac:	e0801003 	add	r1, r0, r3
    52b0:	e1a05000 	mov	r5, r0
    52b4:	e5910004 	ldr	r0, [r1, #4]
        
    CYG_ASSERT( queue_map & (1<<pri), "Queue map bit not set for pri");
    CYG_ASSERT( !run_queue[pri].empty(), "Queue for pri empty");
    
    // remove thread from queue
    queue->remove(thread);
    52b8:	e28c401c 	add	r4, ip, #28	; 0x1c
    52bc:	e1540000 	cmp	r4, r0
    52c0:	0a000011 	beq	530c <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread+0x70>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    52c4:	e59c301c 	ldr	r3, [ip, #28]
    52c8:	e59c2020 	ldr	r2, [ip, #32]
    52cc:	e5832004 	str	r2, [r3, #4]
        prev->next = next;
    52d0:	e59c1020 	ldr	r1, [ip, #32]
        next = prev = this;
    52d4:	e58c4020 	str	r4, [ip, #32]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    52d8:	e5813000 	str	r3, [r1]
        next = prev = this;
    52dc:	e58c401c 	str	r4, [ip, #28]

    if( queue->empty() )
    52e0:	e3500000 	cmp	r0, #0	; 0x0
    52e4:	0a000001 	beq	52f0 <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread+0x54>
    CYG_ASSERT( queue_map & (1<<CYG_THREAD_MIN_PRIORITY), "Idle thread vanished!!!");
    CYG_ASSERT( !run_queue[CYG_THREAD_MIN_PRIORITY].empty(), "Idle thread vanished!!!");
    CYG_ASSERT( ((queue_map & (1<<pri))!=0) == ((!run_queue[pri].empty())!=0), "Map and queue disagree");
    
    CYG_REPORT_RETURN();
}
    52e8:	e8bd0070 	pop	{r4, r5, r6}
    52ec:	e12fff1e 	bx	lr
    if( queue->empty() )
    {
        // If this was only thread in
        // queue, clear map.
      
        queue_map &= ~(1<<pri);
    52f0:	e3a03001 	mov	r3, #1	; 0x1
    52f4:	e1a03613 	lsl	r3, r3, r6
    52f8:	e5952000 	ldr	r2, [r5]
    52fc:	e1e03003 	mvn	r3, r3
    5300:	e0022003 	and	r2, r2, r3
    5304:	e5852000 	str	r2, [r5]
    5308:	eafffff6 	b	52e8 <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread+0x4c>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    530c:	e59c001c 	ldr	r0, [ip, #28]
            if( next == node )
    5310:	e1540000 	cmp	r4, r0
            {
                // Only node on list
                head = NULL;
    5314:	03a03000 	moveq	r3, #0	; 0x0
    5318:	05813004 	streq	r3, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    531c:	0afffff3 	beq	52f0 <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread+0x54>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    5320:	e59c3020 	ldr	r3, [ip, #32]
    5324:	e5803004 	str	r3, [r0, #4]
        prev->next = next;
    5328:	e59c2020 	ldr	r2, [ip, #32]
        next = prev = this;
    532c:	e58c4020 	str	r4, [ip, #32]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    5330:	e5820000 	str	r0, [r2]
        next = prev = this;
    5334:	e58c401c 	str	r4, [ip, #28]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    5338:	e5810004 	str	r0, [r1, #4]
    533c:	eaffffe7 	b	52e0 <_ZN28Cyg_Scheduler_Implementation10rem_threadEP10Cyg_Thread+0x44>

00005340 <_ZN28Cyg_Scheduler_Implementation19set_need_rescheduleEP10Cyg_Thread>:

void Cyg_Scheduler_Implementation::set_need_reschedule(Cyg_Thread *thread)
{
#ifndef CYGPKG_KERNEL_SMP_SUPPORT

    if( current_thread[0]->priority > thread->priority ||
    5340:	e59fc03c 	ldr	ip, [pc, #60]	; 5384 <_ZN28Cyg_Scheduler_Implementation19set_need_rescheduleEP10Cyg_Thread+0x44>
    5344:	e59c3000 	ldr	r3, [ip]
    5348:	e5901024 	ldr	r1, [r0, #36]
    534c:	e5932024 	ldr	r2, [r3, #36]
    5350:	e1520001 	cmp	r2, r1
    5354:	da000003 	ble	5368 <_ZN28Cyg_Scheduler_Implementation19set_need_rescheduleEP10Cyg_Thread+0x28>
        current_thread[0]->get_state() != Cyg_Thread::RUNNING )
        need_reschedule[0] = true;
    5358:	e59f3028 	ldr	r3, [pc, #40]	; 5388 <_ZN28Cyg_Scheduler_Implementation19set_need_rescheduleEP10Cyg_Thread+0x48>
    535c:	e3a02001 	mov	r2, #1	; 0x1
    5360:	e5832000 	str	r2, [r3]
    5364:	e12fff1e 	bx	lr

void Cyg_Scheduler_Implementation::set_need_reschedule(Cyg_Thread *thread)
{
#ifndef CYGPKG_KERNEL_SMP_SUPPORT

    if( current_thread[0]->priority > thread->priority ||
    5368:	e59c3000 	ldr	r3, [ip]
    536c:	e593203c 	ldr	r2, [r3, #60]
    5370:	e3520000 	cmp	r2, #0	; 0x0
        current_thread[0]->get_state() != Cyg_Thread::RUNNING )
        need_reschedule[0] = true;
    5374:	159f300c 	ldrne	r3, [pc, #12]	; 5388 <_ZN28Cyg_Scheduler_Implementation19set_need_rescheduleEP10Cyg_Thread+0x48>
    5378:	13a02001 	movne	r2, #1	; 0x1
    537c:	15832000 	strne	r2, [r3]
    5380:	e12fff1e 	bx	lr
    5384:	40002538 	.word	0x40002538
    5388:	4000253c 	.word	0x4000253c

0000538c <_ZN28Cyg_Scheduler_Implementation15register_threadEP10Cyg_Thread>:
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("thread=%08x", thread);
    // No registration necessary in this scheduler
    CYG_REPORT_RETURN();
}
    538c:	e12fff1e 	bx	lr

00005390 <_ZN28Cyg_Scheduler_Implementation17deregister_threadEP10Cyg_Thread>:
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("thread=%08x", thread);
    // No registration necessary in this scheduler    
    CYG_REPORT_RETURN();
}
    5390:	e12fff1e 	bx	lr

00005394 <_ZN28Cyg_Scheduler_Implementation6uniqueEi>:
    CYG_REPORT_FUNCTYPE("returning %d");
    CYG_REPORT_FUNCARG1("priority=%d", priority);
    // Priorities are not unique
    CYG_REPORT_RETVAL(true);
    return true;
}
    5394:	e3a00001 	mov	r0, #1	; 0x1
    5398:	e12fff1e 	bx	lr

0000539c <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv>:

#ifdef CYGSEM_KERNEL_SCHED_TIMESLICE_ENABLE
    if( thread->timeslice_enabled &&
        timeslice_count[cpu_this] == 0 )
#else    
    if( timeslice_count[cpu_this] == 0 )
    539c:	e59f0070 	ldr	r0, [pc, #112]	; 5414 <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x78>
    53a0:	e5903000 	ldr	r3, [r0]
    53a4:	e59f206c 	ldr	r2, [pc, #108]	; 5418 <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x7c>
    53a8:	e3530000 	cmp	r3, #0	; 0x0
    53ac:	e5921000 	ldr	r1, [r2]
    53b0:	112fff1e 	bxne	lr

        CYG_ASSERT( get_sched_lock() > 0 , "Timeslice called with zero sched_lock");

        // Only try to rotate the run queue if the current thread is running.
        // Otherwise we are going to reschedule anyway.
        if( thread->get_state() == Cyg_Thread::RUNNING )
    53b4:	e591303c 	ldr	r3, [r1, #60]
    53b8:	e3530000 	cmp	r3, #0	; 0x0
    53bc:	112fff1e 	bxne	lr
            CYG_INSTRUMENT_MLQ( TIMESLICE, thread, 0);
                
            CYG_ASSERTCLASS( thread, "Bad current thread");
            CYG_ASSERTCLASS( sched, "Bad scheduler");
    
            cyg_priority pri    = thread->priority;
    53c0:	e5913024 	ldr	r3, [r1, #36]
    };

    // Rotation - move the head to the next node in the list.
    void rotate()
    {
        if( head )
    53c4:	e59f2050 	ldr	r2, [pc, #80]	; 541c <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x80>
    53c8:	e1a03103 	lsl	r3, r3, #2
    53cc:	e0822003 	add	r2, r2, r3
    53d0:	e5923004 	ldr	r3, [r2, #4]
    53d4:	e3530000 	cmp	r3, #0	; 0x0
    53d8:	0a00000b 	beq	540c <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x70>
            head = head->next;
    53dc:	e5933000 	ldr	r3, [r3]
    ~Cyg_CList_T() {};

    T *get_head()
    {
        Cyg_DNode *node = Cyg_CList::get_head();
        if( node ) return CYG_CLASSFROMBASE( T, Cyg_DNode, node );
    53e0:	e3530000 	cmp	r3, #0	; 0x0

    // Rotation - move the head to the next node in the list.
    void rotate()
    {
        if( head )
            head = head->next;
    53e4:	e5823004 	str	r3, [r2, #4]
    ~Cyg_CList_T() {};

    T *get_head()
    {
        Cyg_DNode *node = Cyg_CList::get_head();
        if( node ) return CYG_CLASSFROMBASE( T, Cyg_DNode, node );
    53e8:	1243301c 	subne	r3, r3, #28	; 0x1c
    53ec:	0a000006 	beq	540c <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x70>
            queue->to_head( thread->get_next() );
#else            
            queue->rotate();
#endif
            
            if( queue->get_head() != thread )
    53f0:	e1510003 	cmp	r1, r3
    53f4:	159f3024 	ldrne	r3, [pc, #36]	; 5420 <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x84>
    53f8:	13a02001 	movne	r2, #1	; 0x1
    53fc:	15832000 	strne	r2, [r3]
                sched->set_need_reschedule();

            timeslice_count[cpu_this] = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    5400:	e3a03005 	mov	r3, #5	; 0x5
    5404:	e5803000 	str	r3, [r0]
    5408:	e12fff1e 	bx	lr
    540c:	e3a03000 	mov	r3, #0	; 0x0
    5410:	eafffff6 	b	53f0 <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv+0x54>
    5414:	40002534 	.word	0x40002534
    5418:	40002538 	.word	0x40002538
    541c:	40002540 	.word	0x40002540
    5420:	4000253c 	.word	0x4000253c

00005424 <_ZN28Cyg_Scheduler_Implementation9timesliceEv>:
            else CYG_KERNEL_CPU_TIMESLICE_INTERRUPT( cpu, 0 );
    }

#else    

    if( --timeslice_count[CYG_KERNEL_CPU_THIS()] == 0 )
    5424:	e59f2014 	ldr	r2, [pc, #20]	; 5440 <_ZN28Cyg_Scheduler_Implementation9timesliceEv+0x1c>
    5428:	e5923000 	ldr	r3, [r2]
    542c:	e2433001 	sub	r3, r3, #1	; 0x1
    5430:	e3530000 	cmp	r3, #0	; 0x0
    5434:	e5823000 	str	r3, [r2]
    5438:	112fff1e 	bxne	lr
        timeslice_cpu();
    543c:	eaffffd6 	b	539c <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv>
    5440:	40002534 	.word	0x40002534

00005444 <cyg_scheduler_timeslice_cpu>:

// -------------------------------------------------------------------------

__externC void cyg_scheduler_timeslice_cpu(void)
{
    Cyg_Scheduler::scheduler.timeslice_cpu();
    5444:	e59f0000 	ldr	r0, [pc, #0]	; 544c <cyg_scheduler_timeslice_cpu+0x8>
    5448:	eaffffd3 	b	539c <_ZN28Cyg_Scheduler_Implementation13timeslice_cpuEv>
    544c:	40002540 	.word	0x40002540

00005450 <_ZN30Cyg_SchedThread_ImplementationC2Ej>:
// Cyg_SchedThread_Implementation class members

Cyg_SchedThread_Implementation::Cyg_SchedThread_Implementation
(
    CYG_ADDRWORD sched_info
)
    5450:	e1a03000 	mov	r3, r0
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("sched_info=%08x", sched_info);
        
    // Set priority to the supplied value.
    priority = (cyg_priority)sched_info;
    5454:	e5801008 	str	r1, [r0, #8]
public:

    Cyg_DNode()
    {
        // Initialize pointers to point here
        next = prev = this;
    5458:	e5830004 	str	r0, [r3, #4]
    545c:	e5830000 	str	r0, [r3]
#ifdef CYGPKG_KERNEL_SMP_SUPPORT
    cpu = CYG_KERNEL_CPU_NONE;
#endif
    
    CYG_REPORT_RETURN();
}
    5460:	e12fff1e 	bx	lr

00005464 <_ZN30Cyg_SchedThread_ImplementationC1Ej>:
// Cyg_SchedThread_Implementation class members

Cyg_SchedThread_Implementation::Cyg_SchedThread_Implementation
(
    CYG_ADDRWORD sched_info
)
    5464:	e1a03000 	mov	r3, r0
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("sched_info=%08x", sched_info);
        
    // Set priority to the supplied value.
    priority = (cyg_priority)sched_info;
    5468:	e5801008 	str	r1, [r0, #8]
    546c:	e5830004 	str	r0, [r3, #4]
    5470:	e5830000 	str	r0, [r3]
#ifdef CYGPKG_KERNEL_SMP_SUPPORT
    cpu = CYG_KERNEL_CPU_NONE;
#endif
    
    CYG_REPORT_RETURN();
}
    5474:	e12fff1e 	bx	lr

00005478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>:


    // Add a node at the tail of the list
    void add_tail( Cyg_DNode *node )
    {
        if( head == NULL )
    5478:	e590c000 	ldr	ip, [r0]
// Cyg_ThreadQueue_Implementation class members

// -------------------------------------------------------------------------        

void
Cyg_ThreadQueue_Implementation::enqueue(Cyg_Thread *thread)
    547c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
            qtmp->append( thread );
        }
    }
#else
    // Just add the thread to the tail of the list
    add_tail( thread );
    5480:	e2514000 	subs	r4, r1, #0	; 0x0
    5484:	01a01004 	moveq	r1, r4
    5488:	1284101c 	addne	r1, r4, #28	; 0x1c
    548c:	e35c0000 	cmp	ip, #0	; 0x0
    // so that it becomes this nodes predecessor in
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
    5490:	159c3004 	ldrne	r3, [ip, #4]
    5494:	15813004 	strne	r3, [r1, #4]
        prev->next = node;
    5498:	159c2004 	ldrne	r2, [ip, #4]
    // Insert a node into the list before this one,
    // so that it becomes this nodes predecessor in
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
    549c:	1581c000 	strne	ip, [r1]

    // Add a node at the tail of the list
    void add_tail( Cyg_DNode *node )
    {
        if( head == NULL )
            head = node;
    54a0:	05801000 	streq	r1, [r0]
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
        prev->next = node;
        prev = node;
    54a4:	158c1004 	strne	r1, [ip, #4]
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
        prev->next = node;
    54a8:	15821000 	strne	r1, [r2]
#endif
    
    thread->queue = CYG_CLASSFROMBASE(Cyg_ThreadQueue,
                                      Cyg_ThreadQueue_Implementation,
                                      this);
    54ac:	e584002c 	str	r0, [r4, #44]
    CYG_REPORT_RETURN();
}
    54b0:	e8bd0010 	pop	{r4}
    54b4:	e12fff1e 	bx	lr

000054b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>:

// -------------------------------------------------------------------------

Cyg_Thread *
Cyg_ThreadQueue_Implementation::dequeue(void)
    54b8:	e1a0c000 	mov	ip, r0
    };

    // Remove the node at the head of the list
    Cyg_DNode *rem_head()
    {
        Cyg_DNode *node = head;
    54bc:	e5900000 	ldr	r0, [r0]
        if( node != NULL )
    54c0:	e3500000 	cmp	r0, #0	; 0x0
    54c4:	012fff1e 	bxeq	lr
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    54c8:	e5901000 	ldr	r1, [r0]
            if( next == node )
    54cc:	e1500001 	cmp	r0, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    54d0:	15903004 	ldrne	r3, [r0, #4]
    54d4:	15813004 	strne	r3, [r1, #4]
        prev->next = next;
    54d8:	15902004 	ldrne	r2, [r0, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    54dc:	03a03000 	moveq	r3, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    54e0:	15821000 	strne	r1, [r2]
        next = prev = this;
    54e4:	15800004 	strne	r0, [r0, #4]
    54e8:	15800000 	strne	r0, [r0]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    54ec:	058c3000 	streq	r3, [ip]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    54f0:	158c1000 	strne	r1, [ip]
        
    Cyg_Thread *thread = rem_head();

    CYG_INSTRUMENT_MLQ( DEQUEUE, this, thread );
    
    if( thread != NULL )
    54f4:	e250001c 	subs	r0, r0, #28	; 0x1c
    54f8:	012fff1e 	bxeq	lr
        thread->queue = NULL;
    54fc:	e3a03000 	mov	r3, #0	; 0x0
    5500:	e580302c 	str	r3, [r0, #44]

    CYG_REPORT_RETVAL(thread);
    return thread;
}
    5504:	e12fff1e 	bx	lr

00005508 <_ZN30Cyg_ThreadQueue_Implementation6removeEP10Cyg_Thread>:
    
    // General removal. Deals with what happend if this is only
    // object on list, or is the head.
    void remove( Cyg_DNode *node )
    {
        if( node == head )
    5508:	e5903000 	ldr	r3, [r0]

// -------------------------------------------------------------------------

void
Cyg_ThreadQueue_Implementation::remove( Cyg_Thread *thread )
    550c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    5510:	e1a04000 	mov	r4, r0

    CYG_INSTRUMENT_MLQ( REMOVE, this, thread );
    
    thread->queue = NULL;

    Cyg_CList_T<Cyg_Thread>::remove( thread );
    5514:	e281001c 	add	r0, r1, #28	; 0x1c
    5518:	e1500003 	cmp	r0, r3
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("thread=%08x", thread);

    CYG_INSTRUMENT_MLQ( REMOVE, this, thread );
    
    thread->queue = NULL;
    551c:	e3a03000 	mov	r3, #0	; 0x0
}

// -------------------------------------------------------------------------

void
Cyg_ThreadQueue_Implementation::remove( Cyg_Thread *thread )
    5520:	e1a0c001 	mov	ip, r1
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("thread=%08x", thread);

    CYG_INSTRUMENT_MLQ( REMOVE, this, thread );
    
    thread->queue = NULL;
    5524:	e581302c 	str	r3, [r1, #44]
    5528:	0a000008 	beq	5550 <_ZN30Cyg_ThreadQueue_Implementation6removeEP10Cyg_Thread+0x48>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    552c:	e591301c 	ldr	r3, [r1, #28]
    5530:	e5912020 	ldr	r2, [r1, #32]
    5534:	e5832004 	str	r2, [r3, #4]
        prev->next = next;
    5538:	e5911020 	ldr	r1, [r1, #32]
        next = prev = this;
    553c:	e58c0020 	str	r0, [ip, #32]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    5540:	e5813000 	str	r3, [r1]
        next = prev = this;
    5544:	e58c001c 	str	r0, [ip, #28]

    Cyg_CList_T<Cyg_Thread>::remove( thread );

    CYG_REPORT_RETURN();
}
    5548:	e8bd0010 	pop	{r4}
    554c:	e12fff1e 	bx	lr
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    5550:	e591101c 	ldr	r1, [r1, #28]
            if( next == node )
    5554:	e1500001 	cmp	r0, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    5558:	159c3020 	ldrne	r3, [ip, #32]
    555c:	15813004 	strne	r3, [r1, #4]
        prev->next = next;
    5560:	159c2020 	ldrne	r2, [ip, #32]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    5564:	05843000 	streq	r3, [r4]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    5568:	15821000 	strne	r1, [r2]
        next = prev = this;
    556c:	158c0020 	strne	r0, [ip, #32]
    5570:	158c001c 	strne	r0, [ip, #28]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    5574:	15841000 	strne	r1, [r4]
    5578:	eafffff2 	b	5548 <_ZN30Cyg_ThreadQueue_Implementation6removeEP10Cyg_Thread+0x40>

0000557c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread>:

    CYG_ASSERT( ((queue_map & (1<<pri))!=0) == ((!run_queue[pri].empty())!=0), "Map and queue disagree");

    // If the thread is on some other queue, remove it
    // here.
    if( thread->queue != NULL )
    557c:	e591302c 	ldr	r3, [r1, #44]
    5580:	e3530000 	cmp	r3, #0	; 0x0
}

// -------------------------------------------------------------------------

void
Cyg_Scheduler_Implementation::add_thread(Cyg_Thread *thread)
    5584:	e92d4070 	push	{r4, r5, r6, lr}
    5588:	e1a04001 	mov	r4, r1
    558c:	e1a05000 	mov	r5, r0
{
    CYG_REPORT_FUNCTION();
    CYG_REPORT_FUNCARG1("thread=%08x", thread);

    cyg_priority pri                               = thread->priority;
    5590:	e5916024 	ldr	r6, [r1, #36]

// -------------------------------------------------------------------------

inline void Cyg_ThreadQueue::remove(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::remove(thread);
    5594:	11a00003 	movne	r0, r3
    5598:	1bffffda 	blne	5508 <_ZN30Cyg_ThreadQueue_Implementation6removeEP10Cyg_Thread>
    };

    // Accessor and test functions
    Cyg_DNode *get_head() { return head; };
    Cyg_DNode *get_tail() { return head?head->prev:NULL; };
    cyg_bool empty() { return head == NULL; };
    559c:	e1a03106 	lsl	r3, r6, #2
    55a0:	e085c003 	add	ip, r5, r3
    55a4:	e59c1004 	ldr	r1, [ip, #4]
    if( thread->queue != NULL )
    {
        thread->queue->remove(thread);
    }
    
    if( queue->empty() )
    55a8:	e3510000 	cmp	r1, #0	; 0x0
    55ac:	0a000016 	beq	560c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread+0x90>
    // so that it becomes this nodes predecessor in
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
    55b0:	e5913004 	ldr	r3, [r1, #4]
        queue_map |= (1<<pri);

    }
    // else the queue already has an occupant, queue behind him

    queue->add_tail(thread);
    55b4:	e284001c 	add	r0, r4, #28	; 0x1c
    55b8:	e5803004 	str	r3, [r0, #4]
        prev->next = node;
    55bc:	e5912004 	ldr	r2, [r1, #4]
    // Insert a node into the list before this one,
    // so that it becomes this nodes predecessor in
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
    55c0:	e584101c 	str	r1, [r4, #28]
        node->prev = prev;
        prev->next = node;
        prev = node;
    55c4:	e5810004 	str	r0, [r1, #4]
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
        prev->next = node;
    55c8:	e5820000 	str	r0, [r2]

void Cyg_Scheduler_Implementation::set_need_reschedule(Cyg_Thread *thread)
{
#ifndef CYGPKG_KERNEL_SMP_SUPPORT

    if( current_thread[0]->priority > thread->priority ||
    55cc:	e59f0054 	ldr	r0, [pc, #84]	; 5628 <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread+0xac>
    55d0:	e5903000 	ldr	r3, [r0]
    55d4:	e5942024 	ldr	r2, [r4, #36]
    55d8:	e5931024 	ldr	r1, [r3, #36]
    55dc:	e1510002 	cmp	r1, r2
    55e0:	ca000003 	bgt	55f4 <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread+0x78>
    55e4:	e5903000 	ldr	r3, [r0]
    55e8:	e593203c 	ldr	r2, [r3, #60]
    55ec:	e3520000 	cmp	r2, #0	; 0x0
    55f0:	0a000002 	beq	5600 <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread+0x84>
        current_thread[0]->get_state() != Cyg_Thread::RUNNING )
        need_reschedule[0] = true;
    55f4:	e59f3030 	ldr	r3, [pc, #48]	; 562c <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread+0xb0>
    55f8:	e3a02001 	mov	r2, #1	; 0x1
    55fc:	e5832000 	str	r2, [r3]
    Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()] = timeslice_count;
}

inline void Cyg_SchedThread_Implementation::timeslice_reset()
{
    timeslice_count = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    5600:	e3a03005 	mov	r3, #5	; 0x5
    5604:	e5843028 	str	r3, [r4, #40]
    CYG_ASSERT( ((queue_map & (1<<pri))!=0) == ((!run_queue[pri].empty())!=0), "Map and queue disagree");    
    CYG_ASSERT( queue_map & (1<<CYG_THREAD_MIN_PRIORITY), "Idle thread vanished!!!");
    CYG_ASSERT( !run_queue[CYG_THREAD_MIN_PRIORITY].empty(), "Idle thread vanished!!!");
    
    CYG_REPORT_RETURN();
}
    5608:	e8bd8070 	pop	{r4, r5, r6, pc}
    if( queue->empty() )
    {
        // set the map bit and ask for a reschedule if this is a
        // new highest priority thread.
      
        queue_map |= (1<<pri);
    560c:	e5953000 	ldr	r3, [r5]
    5610:	e3a02001 	mov	r2, #1	; 0x1
    5614:	e1833612 	orr	r3, r3, r2, lsl r6

    }
    // else the queue already has an occupant, queue behind him

    queue->add_tail(thread);
    5618:	e284001c 	add	r0, r4, #28	; 0x1c
    if( queue->empty() )
    {
        // set the map bit and ask for a reschedule if this is a
        // new highest priority thread.
      
        queue_map |= (1<<pri);
    561c:	e5853000 	str	r3, [r5]

    // Add a node at the tail of the list
    void add_tail( Cyg_DNode *node )
    {
        if( head == NULL )
            head = node;
    5620:	e58c0004 	str	r0, [ip, #4]
    5624:	eaffffe8 	b	55cc <_ZN28Cyg_Scheduler_Implementation10add_threadEP10Cyg_Thread+0x50>
    5628:	40002538 	.word	0x40002538
    562c:	4000253c 	.word	0x4000253c

00005630 <_ZN30Cyg_ThreadQueue_Implementation7highpriEv>:
    {
        head = NULL;
    };

    // Accessor and test functions
    Cyg_DNode *get_head() { return head; };
    5630:	e5900000 	ldr	r0, [r0]
    ~Cyg_CList_T() {};

    T *get_head()
    {
        Cyg_DNode *node = Cyg_CList::get_head();
        if( node ) return CYG_CLASSFROMBASE( T, Cyg_DNode, node );
    5634:	e3500000 	cmp	r0, #0	; 0x0
    5638:	1240001c 	subne	r0, r0, #28	; 0x1c
Cyg_ThreadQueue_Implementation::highpri(void)
{
    CYG_REPORT_FUNCTYPE("returning thread %08x");
    CYG_REPORT_RETVAL(get_head());
    return get_head();
}
    563c:	e12fff1e 	bx	lr

00005640 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv>:
// -------------------------------------------------------------------------
// Move this thread to the head of its queue
// (not necessarily a scheduler queue)

void
Cyg_SchedThread_Implementation::to_queue_head( void )
    5640:	e92d4030 	push	{r4, r5, lr}
    5644:	e1a0c000 	mov	ip, r0
    5648:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    564c:	e59f4094 	ldr	r4, [pc, #148]	; 56e8 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0xa8>
    5650:	e5943000 	ldr	r3, [r4]
    5654:	e2833001 	add	r3, r3, #1	; 0x1
    5658:	e5843000 	str	r3, [r4]
    CYG_REPORT_FUNCTION();
        
    // Prevent preemption
    Cyg_Scheduler::lock();

    Cyg_Thread *thread  = CYG_CLASSFROMBASE(Cyg_Thread,
    565c:	e240201c 	sub	r2, r0, #28	; 0x1c
}

// Return current queue pointer
inline Cyg_ThreadQueue *Cyg_SchedThread::get_current_queue()
{
    return queue;
    5660:	e592302c 	ldr	r3, [r2, #44]
                                            this);

    CYG_ASSERTCLASS( thread, "Bad current thread");
    
    Cyg_ThreadQueue *q = thread->get_current_queue();
    if( q != NULL )
    5664:	e3530000 	cmp	r3, #0	; 0x0

    // Move a node to the head of the list. Assumes that the
    // node is in this list.
    void to_head( Cyg_DNode *node )
    {
        head = node;
    5668:	15830000 	strne	r0, [r3]
    566c:	0a000008 	beq	5694 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x54>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5670:	e5943000 	ldr	r3, [r4]
    5674:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5678:	159f3068 	ldrne	r3, [pc, #104]	; 56e8 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0xa8>
    567c:	15830000 	strne	r0, [r3]
    5680:	0a000001 	beq	568c <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x4c>

    // Unlock the scheduler and switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    5684:	e28dd004 	add	sp, sp, #4	; 0x4
    5688:	e8bd8030 	pop	{r4, r5, pc}
    568c:	eb0000e2 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    5690:	eafffffb 	b	5684 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x44>
    CYG_ASSERTCLASS( thread, "Bad current thread");
    
    Cyg_ThreadQueue *q = thread->get_current_queue();
    if( q != NULL )
        q->to_head( thread );
    else if( thread->in_list() )
    5694:	e592301c 	ldr	r3, [r2, #28]
    5698:	e1500003 	cmp	r0, r3
    569c:	0afffff3 	beq	5670 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x30>

void Cyg_Scheduler_Implementation::set_need_reschedule(Cyg_Thread *thread)
{
#ifndef CYGPKG_KERNEL_SMP_SUPPORT

    if( current_thread[0]->priority > thread->priority ||
    56a0:	e59f5044 	ldr	r5, [pc, #68]	; 56ec <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0xac>
    56a4:	e5953000 	ldr	r3, [r5]
        // If the queue pointer is NULL then it is on a run
        // queue. Move the thread to the head of it's priority list
        // and force a reschedule.
        
        Cyg_Scheduler *sched = &Cyg_Scheduler::scheduler;
        sched->run_queue[thread->priority].to_head( thread );
    56a8:	e5922024 	ldr	r2, [r2, #36]

void Cyg_Scheduler_Implementation::set_need_reschedule(Cyg_Thread *thread)
{
#ifndef CYGPKG_KERNEL_SMP_SUPPORT

    if( current_thread[0]->priority > thread->priority ||
    56ac:	e5931024 	ldr	r1, [r3, #36]
    56b0:	e59f3038 	ldr	r3, [pc, #56]	; 56f0 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0xb0>
    56b4:	e1a00102 	lsl	r0, r2, #2
    56b8:	e0833000 	add	r3, r3, r0
    56bc:	e1520001 	cmp	r2, r1
    56c0:	e583c004 	str	ip, [r3, #4]
    56c4:	ba000003 	blt	56d8 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x98>
    56c8:	e5953000 	ldr	r3, [r5]
    56cc:	e593203c 	ldr	r2, [r3, #60]
    56d0:	e3520000 	cmp	r2, #0	; 0x0
    56d4:	0affffe5 	beq	5670 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x30>
        current_thread[0]->get_state() != Cyg_Thread::RUNNING )
        need_reschedule[0] = true;
    56d8:	e59f3014 	ldr	r3, [pc, #20]	; 56f4 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0xb4>
    56dc:	e3a02001 	mov	r2, #1	; 0x1
    56e0:	e5832000 	str	r2, [r3]
    56e4:	eaffffe1 	b	5670 <_ZN30Cyg_SchedThread_Implementation13to_queue_headEv+0x30>
    56e8:	400007c8 	.word	0x400007c8
    56ec:	40002538 	.word	0x40002538
    56f0:	40002540 	.word	0x40002540
    56f4:	4000253c 	.word	0x4000253c

000056f8 <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi>:
// -------------------------------------------------------------------------
// Rotate the run queue at a specified priority.
// (pri is the decider, not this, so the routine is static)

void
Cyg_SchedThread_Implementation::rotate_queue( cyg_priority pri )
    56f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    56fc:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5700:	e59f1054 	ldr	r1, [pc, #84]	; 575c <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi+0x64>
    5704:	e5913000 	ldr	r3, [r1]
    5708:	e2833001 	add	r3, r3, #1	; 0x1
    570c:	e5813000 	str	r3, [r1]
    };

    // Accessor and test functions
    Cyg_DNode *get_head() { return head; };
    Cyg_DNode *get_tail() { return head?head->prev:NULL; };
    cyg_bool empty() { return head == NULL; };
    5710:	e59f3048 	ldr	r3, [pc, #72]	; 5760 <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi+0x68>
    5714:	e1a00100 	lsl	r0, r0, #2
    5718:	e0832000 	add	r2, r3, r0
    571c:	e5923004 	ldr	r3, [r2, #4]

    CYG_ASSERTCLASS( sched, "Bad scheduler");
    
    Cyg_RunQueue *queue = &sched->run_queue[pri];

    if ( !queue->empty() ) {
    5720:	e3530000 	cmp	r3, #0	; 0x0

    // Rotation - move the head to the next node in the list.
    void rotate()
    {
        if( head )
            head = head->next;
    5724:	15933000 	ldrne	r3, [r3]
    5728:	15823004 	strne	r3, [r2, #4]
// -------------------------------------------------------------------------
// Cyg_Scheduler_Implementation inlines

inline void Cyg_Scheduler_Implementation::set_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
    572c:	159f3030 	ldrne	r3, [pc, #48]	; 5764 <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi+0x6c>
    5730:	13a02001 	movne	r2, #1	; 0x1
    5734:	15832000 	strne	r2, [r3]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5738:	e5913000 	ldr	r3, [r1]
    573c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5740:	159f3014 	ldrne	r3, [pc, #20]	; 575c <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi+0x64>
    5744:	15830000 	strne	r0, [r3]
    5748:	0a000001 	beq	5754 <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi+0x5c>

    // Unlock the scheduler and switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    574c:	e28dd004 	add	sp, sp, #4	; 0x4
    5750:	e8bd8000 	pop	{pc}
    5754:	eb0000b0 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    5758:	eafffffb 	b	574c <_ZN30Cyg_SchedThread_Implementation12rotate_queueEi+0x54>
    575c:	400007c8 	.word	0x400007c8
    5760:	40002540 	.word	0x40002540
    5764:	4000253c 	.word	0x4000253c

00005768 <_ZN30Cyg_SchedThread_Implementation5yieldEv>:
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5768:	e59f1074 	ldr	r1, [pc, #116]	; 57e4 <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x7c>
    576c:	e5913000 	ldr	r3, [r1]
    5770:	e2833001 	add	r3, r3, #1	; 0x1
    5774:	e5813000 	str	r3, [r1]
    CYG_REPORT_FUNCTION();
        
    // Prevent preemption
    Cyg_Scheduler::lock();

    Cyg_Thread *thread  = CYG_CLASSFROMBASE(Cyg_Thread,
    5778:	e240001c 	sub	r0, r0, #28	; 0x1c
                                            this);

    // Only do this if this thread is running. If it is not, there
    // is no point.
    
    if( thread->get_state() == Cyg_Thread::RUNNING )
    577c:	e590303c 	ldr	r3, [r0, #60]
    5780:	e3530000 	cmp	r3, #0	; 0x0
    5784:	1a000011 	bne	57d0 <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x68>
    
        Cyg_Scheduler *sched = &Cyg_Scheduler::scheduler;

        CYG_ASSERTCLASS( sched, "Bad scheduler");
    
        cyg_priority pri    = thread->priority;
    5788:	e5903024 	ldr	r3, [r0, #36]
    };

    // Rotation - move the head to the next node in the list.
    void rotate()
    {
        if( head )
    578c:	e59f2054 	ldr	r2, [pc, #84]	; 57e8 <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x80>
    5790:	e1a03103 	lsl	r3, r3, #2
    5794:	e0822003 	add	r2, r2, r3
    5798:	e5923004 	ldr	r3, [r2, #4]
    579c:	e3530000 	cmp	r3, #0	; 0x0
    57a0:	0a00000d 	beq	57dc <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x74>
            head = head->next;
    57a4:	e5933000 	ldr	r3, [r3]
    ~Cyg_CList_T() {};

    T *get_head()
    {
        Cyg_DNode *node = Cyg_CList::get_head();
        if( node ) return CYG_CLASSFROMBASE( T, Cyg_DNode, node );
    57a8:	e3530000 	cmp	r3, #0	; 0x0

    // Rotation - move the head to the next node in the list.
    void rotate()
    {
        if( head )
            head = head->next;
    57ac:	e5823004 	str	r3, [r2, #4]
    ~Cyg_CList_T() {};

    T *get_head()
    {
        Cyg_DNode *node = Cyg_CList::get_head();
        if( node ) return CYG_CLASSFROMBASE( T, Cyg_DNode, node );
    57b0:	1243301c 	subne	r3, r3, #28	; 0x1c
    57b4:	0a000008 	beq	57dc <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x74>
            queue->to_head( thread->get_next() );
#else            
            queue->rotate();
#endif
        
        if( queue->get_head() != thread )
    57b8:	e1500003 	cmp	r0, r3
    57bc:	159f3028 	ldrne	r3, [pc, #40]	; 57ec <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x84>
    57c0:	13a02001 	movne	r2, #1	; 0x1
    Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()] = timeslice_count;
}

inline void Cyg_SchedThread_Implementation::timeslice_reset()
{
    timeslice_count = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    57c4:	03a03005 	moveq	r3, #5	; 0x5
// -------------------------------------------------------------------------
// Cyg_Scheduler_Implementation inlines

inline void Cyg_Scheduler_Implementation::set_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
    57c8:	15832000 	strne	r2, [r3]
    Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()] = timeslice_count;
}

inline void Cyg_SchedThread_Implementation::timeslice_reset()
{
    timeslice_count = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    57cc:	05803028 	streq	r3, [r0, #40]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    57d0:	e5910000 	ldr	r0, [r1]
    // lock is being decremented to a non-zero value, it is more or less
    // equivalent to reschedule() followed by unlock().
    
    CYG_INSTRUMENT_SCHED(UNLOCK,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() - 1 );
    57d4:	e2400001 	sub	r0, r0, #1	; 0x1
    57d8:	ea00008f 	b	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    57dc:	e3a03000 	mov	r3, #0	; 0x0
    57e0:	eafffff4 	b	57b8 <_ZN30Cyg_SchedThread_Implementation5yieldEv+0x50>
    57e4:	400007c8 	.word	0x400007c8
    57e8:	40002540 	.word	0x40002540
    57ec:	4000253c 	.word	0x4000253c

000057f0 <_ZN28Cyg_Scheduler_Implementation15set_idle_threadEP10Cyg_Threadj>:

void Cyg_Scheduler_Implementation::set_idle_thread( Cyg_Thread *thread, HAL_SMP_CPU_TYPE cpu )
{
    // Make the thread the current thread for this CPU.
    
    current_thread[cpu] = thread;
    57f0:	e59f3008 	ldr	r3, [pc, #8]	; 5800 <_ZN28Cyg_Scheduler_Implementation15set_idle_threadEP10Cyg_Threadj+0x10>

    // This will insert the thread in the run queues and make it
    // available to execute.
    thread->resume();
    57f4:	e1a00001 	mov	r0, r1

void Cyg_Scheduler_Implementation::set_idle_thread( Cyg_Thread *thread, HAL_SMP_CPU_TYPE cpu )
{
    // Make the thread the current thread for this CPU.
    
    current_thread[cpu] = thread;
    57f8:	e7831102 	str	r1, [r3, r2, lsl #2]

    // This will insert the thread in the run queues and make it
    // available to execute.
    thread->resume();
    57fc:	eafffa62 	b	418c <_ZN10Cyg_Thread6resumeEv>
    5800:	40002538 	.word	0x40002538

00005804 <_ZN28Cyg_Scheduler_Implementation8scheduleEv>:

// -------------------------------------------------------------------------
// Choose the best thread to run next

Cyg_Thread *
Cyg_Scheduler_Implementation::schedule(void)
    5804:	e92d4010 	push	{r4, lr}
    5808:	e1a04000 	mov	r4, r0
    
#else    

    register cyg_uint32 index;

    HAL_LSBIT_INDEX(index, queue_map);
    580c:	e5900000 	ldr	r0, [r0]
    5810:	eb00206f 	bl	d9d4 <hal_lsbindex>
    {
        head = NULL;
    };

    // Accessor and test functions
    Cyg_DNode *get_head() { return head; };
    5814:	e1a00100 	lsl	r0, r0, #2
    5818:	e0844000 	add	r4, r4, r0
    581c:	e5940004 	ldr	r0, [r4, #4]
    ~Cyg_CList_T() {};

    T *get_head()
    {
        Cyg_DNode *node = Cyg_CList::get_head();
        if( node ) return CYG_CLASSFROMBASE( T, Cyg_DNode, node );
    5820:	e3500000 	cmp	r0, #0	; 0x0
    5824:	1240001c 	subne	r0, r0, #28	; 0x1c
    CYG_ASSERT( thread->queue == NULL , "Runnable thread on a queue!");
   
    CYG_REPORT_RETVAL(thread);

    return thread;
}
    5828:	e8bd8010 	pop	{r4, pc}

0000582c <_Z41__static_initialization_and_destruction_0ii>:
    CYG_REPORT_FUNCTION();

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");

    clear_inherited_priority();
}
    582c:	e3500001 	cmp	r0, #1	; 0x1
    5830:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    5834:	0a000010 	beq	587c <_Z41__static_initialization_and_destruction_0ii+0x50>

Cyg_Thread              *volatile Cyg_Scheduler_Base::current_thread[CYGNUM_KERNEL_CPU_MAX];

volatile cyg_bool       Cyg_Scheduler_Base::need_reschedule[CYGNUM_KERNEL_CPU_MAX];

Cyg_Scheduler           Cyg_Scheduler::scheduler CYG_INIT_PRIORITY( SCHEDULER );
    5838:	e3500000 	cmp	r0, #0	; 0x0
    583c:	1a000005 	bne	5858 <_Z41__static_initialization_and_destruction_0ii+0x2c>
    5840:	e3a03dab 	mov	r3, #10944	; 0x2ac0
    5844:	e2833038 	add	r3, r3, #56	; 0x38
    5848:	e1510003 	cmp	r1, r3
    584c:	059f0070 	ldreq	r0, [pc, #112]	; 58c4 <_Z41__static_initialization_and_destruction_0ii+0x98>
    5850:	0240c080 	subeq	ip, r0, #128	; 0x80
    5854:	0a000001 	beq	5860 <_Z41__static_initialization_and_destruction_0ii+0x34>
    CYG_REPORT_FUNCTION();

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");

    clear_inherited_priority();
}
    5858:	e8bd0010 	pop	{r4}
    585c:	e12fff1e 	bx	lr
// This class contains the implementation details of the scheduler, and
// provides a standard API for accessing it.

class Cyg_Scheduler_Implementation
    : public Cyg_Scheduler_Base
{
    5860:	e5101004 	ldr	r1, [r0, #-4]
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    5864:	e3510000 	cmp	r1, #0	; 0x0
    5868:	1a00000a 	bne	5898 <_Z41__static_initialization_and_destruction_0ii+0x6c>

Cyg_Thread              *volatile Cyg_Scheduler_Base::current_thread[CYGNUM_KERNEL_CPU_MAX];

volatile cyg_bool       Cyg_Scheduler_Base::need_reschedule[CYGNUM_KERNEL_CPU_MAX];

Cyg_Scheduler           Cyg_Scheduler::scheduler CYG_INIT_PRIORITY( SCHEDULER );
    586c:	e5201004 	str	r1, [r0, #-4]!
    5870:	e150000c 	cmp	r0, ip
    5874:	1afffff9 	bne	5860 <_Z41__static_initialization_and_destruction_0ii+0x34>
    5878:	eafffff6 	b	5858 <_Z41__static_initialization_and_destruction_0ii+0x2c>
    CYG_REPORT_FUNCTION();

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");

    clear_inherited_priority();
}
    587c:	e3a03dab 	mov	r3, #10944	; 0x2ac0
    5880:	e2833038 	add	r3, r3, #56	; 0x38
    5884:	e1510003 	cmp	r1, r3
    5888:	1afffff2 	bne	5858 <_Z41__static_initialization_and_destruction_0ii+0x2c>
// Scheduler class. This is the public scheduler interface seen by the
// rest of the kernel.

class Cyg_Scheduler
    : public Cyg_Scheduler_Implementation
{
    588c:	e59f0034 	ldr	r0, [pc, #52]	; 58c8 <_Z41__static_initialization_and_destruction_0ii+0x9c>
    5890:	e8bd0010 	pop	{r4}
    5894:	eafffe56 	b	51f4 <_ZN28Cyg_Scheduler_ImplementationC2Ev>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    5898:	e5914000 	ldr	r4, [r1]
            if( next == node )
    589c:	e1540001 	cmp	r4, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    58a0:	15913004 	ldrne	r3, [r1, #4]
    58a4:	15843004 	strne	r3, [r4, #4]
        prev->next = next;
    58a8:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    58ac:	03a04000 	moveq	r4, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    58b0:	15824000 	strne	r4, [r2]
        next = prev = this;
    58b4:	15811004 	strne	r1, [r1, #4]
    58b8:	15811000 	strne	r1, [r1]
    58bc:	e1a01004 	mov	r1, r4
    58c0:	eaffffe7 	b	5864 <_Z41__static_initialization_and_destruction_0ii+0x38>
    58c4:	400025c4 	.word	0x400025c4
    58c8:	40002540 	.word	0x40002540

000058cc <_GLOBAL__D.11000_cyg_scheduler_sched_lock>:
    58cc:	e3a01dab 	mov	r1, #10944	; 0x2ac0
    58d0:	e2811038 	add	r1, r1, #56	; 0x38
    58d4:	e3a00000 	mov	r0, #0	; 0x0
    58d8:	eaffffd3 	b	582c <_Z41__static_initialization_and_destruction_0ii>

000058dc <_GLOBAL__I.11000_cyg_scheduler_sched_lock>:
    58dc:	e3a01dab 	mov	r1, #10944	; 0x2ac0
    58e0:	e2811038 	add	r1, r1, #56	; 0x38
    58e4:	e3a00001 	mov	r0, #1	; 0x1
    58e8:	eaffffcf 	b	582c <_Z41__static_initialization_and_destruction_0ii>

000058ec <_ZN15Cyg_SchedThread24clear_inherited_priorityEv>:
                                         Cyg_SchedThread,
                                         this);

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");
    
    if( mutex_count == 0 && priority_inherited )
    58ec:	e5902014 	ldr	r2, [r0, #20]
    58f0:	e3520000 	cmp	r2, #0	; 0x0
    58f4:	112fff1e 	bxne	lr
    58f8:	e590301c 	ldr	r3, [r0, #28]
    58fc:	e3530000 	cmp	r3, #0	; 0x0
    5900:	012fff1e 	bxeq	lr
    {
        priority_inherited = false;

        // Only make an effort if the priority must change
        if( priority < original_priority )
    5904:	e5901018 	ldr	r1, [r0, #24]
    5908:	e5903008 	ldr	r3, [r0, #8]
    590c:	e1530001 	cmp	r3, r1

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");
    
    if( mutex_count == 0 && priority_inherited )
    {
        priority_inherited = false;
    5910:	e580201c 	str	r2, [r0, #28]

        // Only make an effort if the priority must change
        if( priority < original_priority )
    5914:	a12fff1e 	bxge	lr
            self->set_priority( original_priority );
    5918:	e240001c 	sub	r0, r0, #28	; 0x1c
    591c:	eafffa78 	b	4304 <_ZN10Cyg_Thread12set_priorityEi>

00005920 <_ZN15Cyg_SchedThread22clear_priority_ceilingEv>:
{
    CYG_REPORT_FUNCTION();

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");

    clear_inherited_priority();
    5920:	eafffff1 	b	58ec <_ZN15Cyg_SchedThread24clear_inherited_priorityEv>

00005924 <_ZN15Cyg_SchedThread19disinherit_priorityEv>:
{
    CYG_REPORT_FUNCTION();

    CYG_ASSERT( mutex_count >= 0, "Non-positive mutex count");

    clear_inherited_priority();
    5924:	eafffff0 	b	58ec <_ZN15Cyg_SchedThread24clear_inherited_priorityEv>

00005928 <_ZN15Cyg_SchedThread22set_inherited_priorityEiP10Cyg_Thread>:
// -------------------------------------------------------------------------
// Generic priority protocol support

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

void Cyg_SchedThread::set_inherited_priority( cyg_priority pri, Cyg_Thread *thread )
    5928:	e92d4070 	push	{r4, r5, r6, lr}

    CYG_ASSERT( mutex_count > 0, "Non-positive mutex count");
    
    // Compare with *current* priority in case thread has already
    // inherited - for relay case below.
    if( pri < priority )
    592c:	e5906008 	ldr	r6, [r0, #8]
    5930:	e1560001 	cmp	r6, r1
// -------------------------------------------------------------------------
// Generic priority protocol support

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

void Cyg_SchedThread::set_inherited_priority( cyg_priority pri, Cyg_Thread *thread )
    5934:	e1a05000 	mov	r5, r0

    CYG_ASSERT( mutex_count > 0, "Non-positive mutex count");
    
    // Compare with *current* priority in case thread has already
    // inherited - for relay case below.
    if( pri < priority )
    5938:	d8bd8070 	pople	{r4, r5, r6, pc}
    {
        cyg_priority mypri = priority;
        cyg_bool already_inherited = priority_inherited;
    593c:	e590401c 	ldr	r4, [r0, #28]
        // If this is first inheritance, copy the old pri
        // and set inherited flag. We clear it before setting the
        // pri since set_priority() is inheritance aware.
        // This is called with the sched locked, so no race conditions.

        priority_inherited = false;     // so that set_prio DTRT
    5940:	e3a03000 	mov	r3, #0	; 0x0
    5944:	e580301c 	str	r3, [r0, #28]

        self->set_priority( pri );            
    5948:	e240001c 	sub	r0, r0, #28	; 0x1c
    594c:	ebfffa6c 	bl	4304 <_ZN10Cyg_Thread12set_priorityEi>

        if( !already_inherited )
    5950:	e3540000 	cmp	r4, #0	; 0x0
            original_priority = mypri;

        priority_inherited = true;      // regardless, because it is now
    5954:	e3a03001 	mov	r3, #1	; 0x1
        priority_inherited = false;     // so that set_prio DTRT

        self->set_priority( pri );            

        if( !already_inherited )
            original_priority = mypri;
    5958:	05856018 	streq	r6, [r5, #24]

        priority_inherited = true;      // regardless, because it is now
    595c:	e585301c 	str	r3, [r5, #28]
    5960:	e8bd8070 	pop	{r4, r5, r6, pc}

00005964 <_ZN15Cyg_SchedThread20set_priority_ceilingEi>:
{
    CYG_REPORT_FUNCTION();

    CYG_ASSERT( mutex_count > 0, "Non-positive mutex count");

    set_inherited_priority( pri );
    5964:	e3a02000 	mov	r2, #0	; 0x0
    5968:	eaffffee 	b	5928 <_ZN15Cyg_SchedThread22set_inherited_priorityEiP10Cyg_Thread>

0000596c <_ZN15Cyg_SchedThread16inherit_priorityEP10Cyg_Thread>:
                                         this);

    CYG_ASSERT( mutex_count > 0, "Non-positive mutex count");
    CYG_ASSERT( self != thread, "Trying to inherit from self!");

    self->set_inherited_priority( thread->get_current_priority(), thread );
    596c:	e1a02001 	mov	r2, r1
    5970:	e5911024 	ldr	r1, [r1, #36]
    5974:	eaffffeb 	b	5928 <_ZN15Cyg_SchedThread22set_inherited_priorityEiP10Cyg_Thread>

00005978 <_ZN15Cyg_SchedThread24relay_inherited_priorityEP10Cyg_ThreadP15Cyg_ThreadQueue>:
    // the current one, since that is a maxima of the others waiting.
    // (It's worth not doing if there's nobody waiting to prevent
    // unneccessary priority skew.)  This could be viewed as a discovered
    // priority ceiling.

    if ( !pqueue->empty() )
    5978:	e5923000 	ldr	r3, [r2]
    597c:	e3530000 	cmp	r3, #0	; 0x0
    5980:	012fff1e 	bxeq	lr
        set_inherited_priority( ex_owner->get_current_priority(), ex_owner );
    5984:	e1a02001 	mov	r2, r1
    5988:	e5911024 	ldr	r1, [r1, #36]
    598c:	eaffffe5 	b	5928 <_ZN15Cyg_SchedThread22set_inherited_priorityEiP10Cyg_Thread>

00005990 <_ZN15Cyg_SchedThread14relay_priorityEP10Cyg_ThreadP15Cyg_ThreadQueue>:

void Cyg_SchedThread::relay_priority( Cyg_Thread *ex_owner, Cyg_ThreadQueue *pqueue)
{
    CYG_REPORT_FUNCTION();

    relay_inherited_priority( ex_owner, pqueue );
    5990:	eafffff8 	b	5978 <_ZN15Cyg_SchedThread24relay_inherited_priorityEP10Cyg_ThreadP15Cyg_ThreadQueue>

00005994 <_ZN15Cyg_SchedThreadC1EP10Cyg_Threadj>:
#endif // CYGSEM_KERNEL_SCHED_ASR_SUPPORT

// -------------------------------------------------------------------------
// Constructor

Cyg_SchedThread::Cyg_SchedThread(Cyg_Thread *thread, CYG_ADDRWORD sched_info)
    5994:	e92d4010 	push	{r4, lr}
: Cyg_SchedThread_Implementation(sched_info)
    5998:	e1a01002 	mov	r1, r2
#endif // CYGSEM_KERNEL_SCHED_ASR_SUPPORT

// -------------------------------------------------------------------------
// Constructor

Cyg_SchedThread::Cyg_SchedThread(Cyg_Thread *thread, CYG_ADDRWORD sched_info)
    599c:	e1a04000 	mov	r4, r0
: Cyg_SchedThread_Implementation(sched_info)
    59a0:	ebfffeaa 	bl	5450 <_ZN30Cyg_SchedThread_ImplementationC2Ej>
{
    CYG_REPORT_FUNCTION();
        
    queue = NULL;
    59a4:	e3a03000 	mov	r3, #0	; 0x0

    mutex_count = 0;
    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_SIMPLE
    
    priority_inherited = false;
    59a8:	e584301c 	str	r3, [r4, #28]
Cyg_SchedThread::Cyg_SchedThread(Cyg_Thread *thread, CYG_ADDRWORD sched_info)
: Cyg_SchedThread_Implementation(sched_info)
{
    CYG_REPORT_FUNCTION();
        
    queue = NULL;
    59ac:	e5843010 	str	r3, [r4, #16]

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

    mutex_count = 0;
    59b0:	e5843014 	str	r3, [r4, #20]
#ifdef CYGSEM_KERNEL_SCHED_ASR_DATA_GLOBAL
    asr_data = NULL
#endif        
    
#endif    
}
    59b4:	e1a00004 	mov	r0, r4
    59b8:	e8bd8010 	pop	{r4, pc}

000059bc <_ZN15Cyg_SchedThreadC2EP10Cyg_Threadj>:
#endif // CYGSEM_KERNEL_SCHED_ASR_SUPPORT

// -------------------------------------------------------------------------
// Constructor

Cyg_SchedThread::Cyg_SchedThread(Cyg_Thread *thread, CYG_ADDRWORD sched_info)
    59bc:	e92d4010 	push	{r4, lr}
: Cyg_SchedThread_Implementation(sched_info)
    59c0:	e1a01002 	mov	r1, r2
#endif // CYGSEM_KERNEL_SCHED_ASR_SUPPORT

// -------------------------------------------------------------------------
// Constructor

Cyg_SchedThread::Cyg_SchedThread(Cyg_Thread *thread, CYG_ADDRWORD sched_info)
    59c4:	e1a04000 	mov	r4, r0
: Cyg_SchedThread_Implementation(sched_info)
    59c8:	ebfffea0 	bl	5450 <_ZN30Cyg_SchedThread_ImplementationC2Ej>
{
    CYG_REPORT_FUNCTION();
        
    queue = NULL;
    59cc:	e3a03000 	mov	r3, #0	; 0x0

    mutex_count = 0;
    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_SIMPLE
    
    priority_inherited = false;
    59d0:	e584301c 	str	r3, [r4, #28]
Cyg_SchedThread::Cyg_SchedThread(Cyg_Thread *thread, CYG_ADDRWORD sched_info)
: Cyg_SchedThread_Implementation(sched_info)
{
    CYG_REPORT_FUNCTION();
        
    queue = NULL;
    59d4:	e5843010 	str	r3, [r4, #16]

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

    mutex_count = 0;
    59d8:	e5843014 	str	r3, [r4, #20]
#ifdef CYGSEM_KERNEL_SCHED_ASR_DATA_GLOBAL
    asr_data = NULL
#endif        
    
#endif    
}
    59dc:	e1a00004 	mov	r0, r4
    59e0:	e8bd8010 	pop	{r4, pc}

000059e4 <_ZN13Cyg_Scheduler9start_cpuEv>:
    intr->unmask_interrupt( intr->get_vector() );
    
#endif    
    
    // Get the first thread to run from scheduler
    register Cyg_Thread *next = scheduler.schedule();
    59e4:	e59f0020 	ldr	r0, [pc, #32]	; 5a0c <_ZN13Cyg_Scheduler9start_cpuEv+0x28>
    59e8:	ebffff85 	bl	5804 <_ZN28Cyg_Scheduler_Implementation8scheduleEv>
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
}

inline void Cyg_Scheduler_Base::clear_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = false;
    59ec:	e59f301c 	ldr	r3, [pc, #28]	; 5a10 <_ZN13Cyg_Scheduler9start_cpuEv+0x2c>
    return current_thread[CYG_KERNEL_CPU_THIS()];
}

inline void Cyg_Scheduler_Base::set_current_thread(Cyg_Thread *thread )
{
    current_thread[CYG_KERNEL_CPU_THIS()] = thread;
    59f0:	e59f201c 	ldr	r2, [pc, #28]	; 5a14 <_ZN13Cyg_Scheduler9start_cpuEv+0x30>
    59f4:	e1a0c000 	mov	ip, r0
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
}

inline void Cyg_Scheduler_Base::clear_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = false;
    59f8:	e3a01000 	mov	r1, #0	; 0x0
    59fc:	e5831000 	str	r1, [r3]
#endif

    // Load the first thread. This will also enable interrupts since
    // the initial state of all threads is to have interrupts enabled.
    
    HAL_THREAD_LOAD_CONTEXT( &next->stack_ptr );    
    5a00:	e280000c 	add	r0, r0, #12	; 0xc
    return current_thread[CYG_KERNEL_CPU_THIS()];
}

inline void Cyg_Scheduler_Base::set_current_thread(Cyg_Thread *thread )
{
    current_thread[CYG_KERNEL_CPU_THIS()] = thread;
    5a04:	e582c000 	str	ip, [r2]
    5a08:	eb00200d 	bl	da44 <hal_thread_load_context>
    5a0c:	40002540 	.word	0x40002540
    5a10:	4000253c 	.word	0x4000253c
    5a14:	40002538 	.word	0x40002538

00005a18 <_ZN13Cyg_Scheduler5startEv>:
        CYG_KERNEL_CPU_START( cpu );
    }

#endif    
    
    start_cpu();
    5a18:	ebfffff1 	bl	59e4 <_ZN13Cyg_Scheduler9start_cpuEv>

00005a1c <_ZN13Cyg_Scheduler12unlock_innerEj>:
// When it is non-zero, and the thread is rescheduled, no ASRS are run,
// or DSRs processed. By doing this, it makes it possible for threads
// that want to go to sleep to wake up with the scheduler lock in the
// same state it was in before.

void Cyg_Scheduler::unlock_inner( cyg_ucount32 new_lock )
    5a1c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS
        
        // Call any pending DSRs. Do this here to ensure that any
        // threads that get awakened are properly scheduled.

        if( new_lock == 0 && Cyg_Interrupt::DSRs_pending() )
    5a20:	e2506000 	subs	r6, r0, #0	; 0x0
// When it is non-zero, and the thread is rescheduled, no ASRS are run,
// or DSRs processed. By doing this, it makes it possible for threads
// that want to go to sleep to wake up with the scheduler lock in the
// same state it was in before.

void Cyg_Scheduler::unlock_inner( cyg_ucount32 new_lock )
    5a24:	e24dd004 	sub	sp, sp, #4	; 0x4
    5a28:	e59f70c4 	ldr	r7, [pc, #196]	; 5af4 <_ZN13Cyg_Scheduler12unlock_innerEj+0xd8>
    5a2c:	e59fa0c4 	ldr	sl, [pc, #196]	; 5af8 <_ZN13Cyg_Scheduler12unlock_innerEj+0xdc>
    5a30:	e59f80c4 	ldr	r8, [pc, #196]	; 5afc <_ZN13Cyg_Scheduler12unlock_innerEj+0xe0>
#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS
        
        // Call any pending DSRs. Do this here to ensure that any
        // threads that get awakened are properly scheduled.

        if( new_lock == 0 && Cyg_Interrupt::DSRs_pending() )
    5a34:	1a000022 	bne	5ac4 <_ZN13Cyg_Scheduler12unlock_innerEj+0xa8>
    5a38:	ea00001d 	b	5ab4 <_ZN13Cyg_Scheduler12unlock_innerEj+0x98>
        if( current->state != Cyg_Thread::RUNNING || get_need_reschedule() ) {

            CYG_INSTRUMENT_SCHED(RESCHEDULE,0,0);
            
            // Get the next thread to run from scheduler
            Cyg_Thread *next = scheduler.schedule();
    5a3c:	e59f00bc 	ldr	r0, [pc, #188]	; 5b00 <_ZN13Cyg_Scheduler12unlock_innerEj+0xe4>
    5a40:	ebffff6f 	bl	5804 <_ZN28Cyg_Scheduler_Implementation8scheduleEv>

            CYG_CHECK_DATA_PTR( next, "Invalid next thread pointer");
            CYG_ASSERTCLASS( next, "Bad next thread" );

            if( current != next )
    5a44:	e1500005 	cmp	r0, r5
    5a48:	0a00000c 	beq	5a80 <_ZN13Cyg_Scheduler12unlock_innerEj+0x64>
            {

                CYG_INSTRUMENT_THREAD(SWITCH,current,next);

                // Count this thread switch
                thread_switches[CYG_KERNEL_CPU_THIS()]++;
    5a4c:	e59f10b0 	ldr	r1, [pc, #176]	; 5b04 <_ZN13Cyg_Scheduler12unlock_innerEj+0xe8>

#ifdef CYGSEM_KERNEL_SCHED_TIMESLICE

inline void Cyg_SchedThread_Implementation::timeslice_save()
{
    timeslice_count = Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()];
    5a50:	e59f40b0 	ldr	r4, [pc, #176]	; 5b08 <_ZN13Cyg_Scheduler12unlock_innerEj+0xec>
    5a54:	e5913000 	ldr	r3, [r1]
    5a58:	e5942000 	ldr	r2, [r4]
    5a5c:	e2833001 	add	r3, r3, #1	; 0x1
    5a60:	e5813000 	str	r3, [r1]
                next->check_stack(); // before running it
#endif
                current->timeslice_save();
                
                // Switch contexts
                HAL_THREAD_SWITCH_CONTEXT( &current->stack_ptr,
    5a64:	e280000c 	add	r0, r0, #12	; 0xc
    5a68:	e5852028 	str	r2, [r5, #40]
    5a6c:	e285100c 	add	r1, r5, #12	; 0xc
    5a70:	eb001fec 	bl	da28 <hal_thread_switch_context>
}

inline void Cyg_SchedThread_Implementation::timeslice_restore()
{
    Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()] = timeslice_count;
    5a74:	e5953028 	ldr	r3, [r5, #40]
                // here before we are allowed to go on our way.

                CYG_CHECK_DATA_PTR( current, "Invalid current thread pointer");
                CYG_ASSERTCLASS( current, "Bad current thread" );

                current_thread[CYG_KERNEL_CPU_THIS()] = current;   // restore current thread pointer
    5a78:	e5875000 	str	r5, [r7]
    5a7c:	e5843000 	str	r3, [r4]
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
}

inline void Cyg_Scheduler_Base::clear_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = false;
    5a80:	e3a03000 	mov	r3, #0	; 0x0
            }

            clear_need_reschedule();    // finished rescheduling
        }

        if( new_lock == 0 )
    5a84:	e3560000 	cmp	r6, #0	; 0x0
    5a88:	e58a3000 	str	r3, [sl]
    5a8c:	1a000015 	bne	5ae8 <_ZN13Cyg_Scheduler12unlock_innerEj+0xcc>
    };

    static void zero_sched_lock()
    {
        CYG_ASSERT( sched_lock != 0, "Scheduler lock already zero");
        sched_lock = 0;
    5a90:	e59f1064 	ldr	r1, [pc, #100]	; 5afc <_ZN13Cyg_Scheduler12unlock_innerEj+0xe0>
    5a94:	e5886000 	str	r6, [r8]
    return dsr_table_head[cpu] != dsr_table_tail[cpu];

#endif
#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST
    
    return dsr_list[cpu] != NULL;
    5a98:	e59f306c 	ldr	r3, [pc, #108]	; 5b0c <_ZN13Cyg_Scheduler12unlock_innerEj+0xf0>
    5a9c:	e5932000 	ldr	r2, [r3]
            // switch and if so, go around again. Making this test after
            // the lock has been zeroed avoids a race condition in which
            // a DSR could have been posted during a reschedule, but would
            // not be run until the _next_ time we release the sched lock.

            if( Cyg_Interrupt::DSRs_pending() ) {
    5aa0:	e3520000 	cmp	r2, #0	; 0x0
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5aa4:	15913000 	ldrne	r3, [r1]
    5aa8:	12833001 	addne	r3, r3, #1	; 0x1
    5aac:	15813000 	strne	r3, [r1]
    5ab0:	0a00000d 	beq	5aec <_ZN13Cyg_Scheduler12unlock_innerEj+0xd0>
    5ab4:	e59f3050 	ldr	r3, [pc, #80]	; 5b0c <_ZN13Cyg_Scheduler12unlock_innerEj+0xf0>
    5ab8:	e5932000 	ldr	r2, [r3]
#ifdef CYGIMP_KERNEL_INTERRUPTS_DSRS
        
        // Call any pending DSRs. Do this here to ensure that any
        // threads that get awakened are properly scheduled.

        if( new_lock == 0 && Cyg_Interrupt::DSRs_pending() )
    5abc:	e3520000 	cmp	r2, #0	; 0x0
            Cyg_Interrupt::call_pending_DSRs();
    5ac0:	1bfffdca 	blne	51f0 <_ZN13Cyg_Interrupt17call_pending_DSRsEv>
// -------------------------------------------------------------------------
// Simple inline accessor functions

inline Cyg_Thread *Cyg_Scheduler_Base::get_current_thread()
{
    return current_thread[CYG_KERNEL_CPU_THIS()];
    5ac4:	e5975000 	ldr	r5, [r7]
#endif

        // If the current thread is going to sleep, or someone
        // wants a reschedule, choose another thread to run

        if( current->state != Cyg_Thread::RUNNING || get_need_reschedule() ) {
    5ac8:	e595303c 	ldr	r3, [r5, #60]
    5acc:	e3530000 	cmp	r3, #0	; 0x0
    5ad0:	1affffd9 	bne	5a3c <_ZN13Cyg_Scheduler12unlock_innerEj+0x20>
    current_thread[cpu] = thread;
}

inline cyg_bool Cyg_Scheduler_Base::get_need_reschedule()
{
    return need_reschedule[CYG_KERNEL_CPU_THIS()];
    5ad4:	e59a3000 	ldr	r3, [sl]
    5ad8:	e3530000 	cmp	r3, #0	; 0x0
    5adc:	1affffd6 	bne	5a3c <_ZN13Cyg_Scheduler12unlock_innerEj+0x20>
            }

            clear_need_reschedule();    // finished rescheduling
        }

        if( new_lock == 0 )
    5ae0:	e3560000 	cmp	r6, #0	; 0x0
    5ae4:	0affffe9 	beq	5a90 <_ZN13Cyg_Scheduler12unlock_innerEj+0x74>
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5ae8:	e5886000 	str	r6, [r8]
        return;

    } while( 1 );

    CYG_FAIL( "Should not be executed" );
}
    5aec:	e28dd004 	add	sp, sp, #4	; 0x4
    5af0:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    5af4:	40002538 	.word	0x40002538
    5af8:	4000253c 	.word	0x4000253c
    5afc:	400007c8 	.word	0x400007c8
    5b00:	40002540 	.word	0x40002540
    5b04:	400025c4 	.word	0x400025c4
    5b08:	40002534 	.word	0x40002534
    5b0c:	4000252c 	.word	0x4000252c

00005b10 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread>:
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
}

inline void Cyg_Scheduler_Base::clear_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = false;
    5b10:	e59f3070 	ldr	r3, [pc, #112]	; 5b88 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x78>
    return current_thread[CYG_KERNEL_CPU_THIS()];
}

inline void Cyg_Scheduler_Base::set_current_thread(Cyg_Thread *thread )
{
    current_thread[CYG_KERNEL_CPU_THIS()] = thread;
    5b14:	e59f2070 	ldr	r2, [pc, #112]	; 5b8c <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x7c>
    need_reschedule[CYG_KERNEL_CPU_THIS()] = true;
}

inline void Cyg_Scheduler_Base::clear_need_reschedule()
{
    need_reschedule[CYG_KERNEL_CPU_THIS()] = false;
    5b18:	e3a00000 	mov	r0, #0	; 0x0
    5b1c:	e5830000 	str	r0, [r3]

// -------------------------------------------------------------------------
// Thread startup. This is called from Cyg_Thread::thread_entry() and
// performs some housekeeping for a newly started thread.

void Cyg_Scheduler::thread_entry( Cyg_Thread *thread )
    5b20:	e92d4030 	push	{r4, r5, lr}
    return current_thread[CYG_KERNEL_CPU_THIS()];
}

inline void Cyg_Scheduler_Base::set_current_thread(Cyg_Thread *thread )
{
    current_thread[CYG_KERNEL_CPU_THIS()] = thread;
    5b24:	e5821000 	str	r1, [r2]
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5b28:	e59f4060 	ldr	r4, [pc, #96]	; 5b90 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x80>
    5b2c:	e5943000 	ldr	r3, [r4]
    
    // Finally unlock the scheduler. As well as clearing the scheduler
    // lock this allows any pending DSRs to execute. The new thread
    // must start with a lock of zero, so we keep unlocking until the
    // lock reaches zero.
    while( get_sched_lock() != 0 )
    5b30:	e1530000 	cmp	r3, r0
    5b34:	e59f3058 	ldr	r3, [pc, #88]	; 5b94 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x84>
}

inline void Cyg_SchedThread_Implementation::timeslice_reset()
{
    timeslice_count = CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS;
    5b38:	e3a02005 	mov	r2, #5	; 0x5
    5b3c:	e5812028 	str	r2, [r1, #40]

// -------------------------------------------------------------------------
// Thread startup. This is called from Cyg_Thread::thread_entry() and
// performs some housekeeping for a newly started thread.

void Cyg_Scheduler::thread_entry( Cyg_Thread *thread )
    5b40:	e24dd004 	sub	sp, sp, #4	; 0x4
    timeslice_count = Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()];
}

inline void Cyg_SchedThread_Implementation::timeslice_restore()
{
    Cyg_Scheduler_Implementation::timeslice_count[CYG_KERNEL_CPU_THIS()] = timeslice_count;
    5b44:	e5832000 	str	r2, [r3]
    
    // Finally unlock the scheduler. As well as clearing the scheduler
    // lock this allows any pending DSRs to execute. The new thread
    // must start with a lock of zero, so we keep unlocking until the
    // lock reaches zero.
    while( get_sched_lock() != 0 )
    5b48:	0a00000c 	beq	5b80 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x70>
    5b4c:	e1a05004 	mov	r5, r4
    5b50:	ea000002 	b	5b60 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x50>
    5b54:	e5943000 	ldr	r3, [r4]
    5b58:	e3530000 	cmp	r3, #0	; 0x0
    5b5c:	0a000007 	beq	5b80 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x70>
    5b60:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    5b64:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5b68:	15850000 	strne	r0, [r5]
    5b6c:	1afffff8 	bne	5b54 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x44>
    5b70:	ebffffa9 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5b74:	e5943000 	ldr	r3, [r4]
    5b78:	e3530000 	cmp	r3, #0	; 0x0
    5b7c:	1afffff7 	bne	5b60 <_ZN13Cyg_Scheduler12thread_entryEP10Cyg_Thread+0x50>
        unlock();    
}
    5b80:	e28dd004 	add	sp, sp, #4	; 0x4
    5b84:	e8bd8030 	pop	{r4, r5, pc}
    5b88:	4000253c 	.word	0x4000253c
    5b8c:	40002538 	.word	0x40002538
    5b90:	400007c8 	.word	0x400007c8
    5b94:	40002534 	.word	0x40002534

00005b98 <_ZN22Cyg_Counting_SemaphoreC2Ei>:

public:

    Cyg_CList()
    {
        head = NULL;
    5b98:	e3a03000 	mov	r3, #0	; 0x0

Cyg_Counting_Semaphore::Cyg_Counting_Semaphore(             
    cyg_count32 init_count              // Initial count value
    )
{
    count       = init_count;
    5b9c:	e880000a 	stm	r0, {r1, r3}
}
    5ba0:	e12fff1e 	bx	lr

00005ba4 <_ZN22Cyg_Counting_SemaphoreC1Ei>:
    5ba4:	e3a03000 	mov	r3, #0	; 0x0

Cyg_Counting_Semaphore::Cyg_Counting_Semaphore(             
    cyg_count32 init_count              // Initial count value
    )
{
    count       = init_count;
    5ba8:	e880000a 	stm	r0, {r1, r3}
}
    5bac:	e12fff1e 	bx	lr

00005bb0 <_ZN22Cyg_Counting_SemaphoreD2Ev>:

// -------------------------------------------------------------------------
// Destructor

Cyg_Counting_Semaphore::~Cyg_Counting_Semaphore()
    5bb0:	e5901004 	ldr	r1, [r0, #4]
    5bb4:	ea000009 	b	5be0 <_ZN22Cyg_Counting_SemaphoreD2Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    5bb8:	e591c000 	ldr	ip, [r1]
            if( next == node )
    5bbc:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    5bc0:	15913004 	ldrne	r3, [r1, #4]
    5bc4:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    5bc8:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    5bcc:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    5bd0:	1582c000 	strne	ip, [r2]
        next = prev = this;
    5bd4:	15811004 	strne	r1, [r1, #4]
    5bd8:	15811000 	strne	r1, [r1]
    5bdc:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    5be0:	e3510000 	cmp	r1, #0	; 0x0
    5be4:	1afffff3 	bne	5bb8 <_ZN22Cyg_Counting_SemaphoreD2Ev+0x8>
{
    CYG_ASSERT( queue.empty(), "Destroying semaphore with waiting threads");
}
    5be8:	e5801004 	str	r1, [r0, #4]
    5bec:	e12fff1e 	bx	lr

00005bf0 <_ZN22Cyg_Counting_SemaphoreD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor

Cyg_Counting_Semaphore::~Cyg_Counting_Semaphore()
    5bf0:	e5901004 	ldr	r1, [r0, #4]
    5bf4:	ea000009 	b	5c20 <_ZN22Cyg_Counting_SemaphoreD1Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    5bf8:	e591c000 	ldr	ip, [r1]
            if( next == node )
    5bfc:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    5c00:	15913004 	ldrne	r3, [r1, #4]
    5c04:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    5c08:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    5c0c:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    5c10:	1582c000 	strne	ip, [r2]
        next = prev = this;
    5c14:	15811004 	strne	r1, [r1, #4]
    5c18:	15811000 	strne	r1, [r1]
    5c1c:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    5c20:	e3510000 	cmp	r1, #0	; 0x0
    5c24:	1afffff3 	bne	5bf8 <_ZN22Cyg_Counting_SemaphoreD1Ev+0x8>
{
    CYG_ASSERT( queue.empty(), "Destroying semaphore with waiting threads");
}
    5c28:	e5801004 	str	r1, [r0, #4]
    5c2c:	e12fff1e 	bx	lr

00005c30 <_ZNK22Cyg_Counting_Semaphore4peekEv>:
    // This is a single read of the value of count.
    // This is already atomic, hence there is no need
    // to lock the scheduler.
    
    return count;    
}
    5c30:	e5900000 	ldr	r0, [r0]
    5c34:	e12fff1e 	bx	lr

00005c38 <_ZN22Cyg_Counting_Semaphore4waitEv>:
        
// -------------------------------------------------------------------------
// Wait until the count can be decremented without it becoming
// negative.

cyg_bool Cyg_Counting_Semaphore::wait()
    5c38:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
// -------------------------------------------------------------------------
// Simple inline accessor functions

inline Cyg_Thread *Cyg_Scheduler_Base::get_current_thread()
{
    return current_thread[CYG_KERNEL_CPU_THIS()];
    5c3c:	e59f80d0 	ldr	r8, [pc, #208]	; 5d14 <_ZN22Cyg_Counting_Semaphore4waitEv+0xdc>
    5c40:	e24dd004 	sub	sp, sp, #4	; 0x4
    5c44:	e1a07000 	mov	r7, r0
    5c48:	e5986000 	ldr	r6, [r8]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5c4c:	e59f90c4 	ldr	r9, [pc, #196]	; 5d18 <_ZN22Cyg_Counting_Semaphore4waitEv+0xe0>
    5c50:	e5993000 	ldr	r3, [r9]
    5c54:	e2833001 	add	r3, r3, #1	; 0x1
    5c58:	e5893000 	str	r3, [r9]
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    5c5c:	e3a0b000 	mov	fp, #0	; 0x0
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    5c60:	e280a004 	add	sl, r0, #4	; 0x4
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    5c64:	e3a05001 	mov	r5, #1	; 0x1
    5c68:	e1a04005 	mov	r4, r5
    // Prevent preemption
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_CNTSEM( CLAIM, this, count );
        
    while( count == 0 && result )
    5c6c:	e5972000 	ldr	r2, [r7]
    5c70:	e3520000 	cmp	r2, #0	; 0x0
    5c74:	13a03000 	movne	r3, #0	; 0x0
    5c78:	02043001 	andeq	r3, r4, #1	; 0x1
    5c7c:	e3530000 	cmp	r3, #0	; 0x0
    5c80:	0a000016 	beq	5ce0 <_ZN22Cyg_Counting_Semaphore4waitEv+0xa8>
    5c84:	e5983000 	ldr	r3, [r8]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    5c88:	e5982000 	ldr	r2, [r8]
    5c8c:	e3a01001 	mov	r1, #1	; 0x1
    5c90:	e5c31080 	strb	r1, [r3, #128]
    self()->wake_reason = NONE;
    5c94:	e5c2b081 	strb	fp, [r2, #129]
    {
        self->set_sleep_reason( Cyg_Thread::WAIT );
        
        self->sleep();
    5c98:	ebfff85e 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    5c9c:	e1a0000a 	mov	r0, sl
    5ca0:	e1a01006 	mov	r1, r6
    5ca4:	ebfffdf3 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5ca8:	e5990000 	ldr	r0, [r9]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    5cac:	ebffff5a 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_INSTRUMENT_CNTSEM( WOKE, this, count );

        switch( self->get_wake_reason() )
    5cb0:	e5d63081 	ldrb	r3, [r6, #129]
    5cb4:	e3530004 	cmp	r3, #4	; 0x4
    5cb8:	3affffeb 	bcc	5c6c <_ZN22Cyg_Counting_Semaphore4waitEv+0x34>
    5cbc:	e3530005 	cmp	r3, #5	; 0x5
    5cc0:	9a000004 	bls	5cd8 <_ZN22Cyg_Counting_Semaphore4waitEv+0xa0>
    5cc4:	e3530006 	cmp	r3, #6	; 0x6
    5cc8:	1affffe7 	bne	5c6c <_ZN22Cyg_Counting_Semaphore4waitEv+0x34>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    5ccc:	ebfff766 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    5cd0:	e3a05001 	mov	r5, #1	; 0x1
    5cd4:	eaffffe3 	b	5c68 <_ZN22Cyg_Counting_Semaphore4waitEv+0x30>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_INSTRUMENT_CNTSEM( WOKE, this, count );

        switch( self->get_wake_reason() )
    5cd8:	e3a05000 	mov	r5, #0	; 0x0
    5cdc:	eaffffe1 	b	5c68 <_ZN22Cyg_Counting_Semaphore4waitEv+0x30>
        default:
            break;
        }
    }

    if( result ) count--;
    5ce0:	e3550000 	cmp	r5, #0	; 0x0
    5ce4:	12423001 	subne	r3, r2, #1	; 0x1
    5ce8:	15873000 	strne	r3, [r7]
    5cec:	e5993000 	ldr	r3, [r9]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    5cf0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5cf4:	159f301c 	ldrne	r3, [pc, #28]	; 5d18 <_ZN22Cyg_Counting_Semaphore4waitEv+0xe0>
    5cf8:	15830000 	strne	r0, [r3]
    5cfc:	0a000002 	beq	5d0c <_ZN22Cyg_Counting_Semaphore4waitEv+0xd4>
        
    // Unlock the scheduler
    Cyg_Scheduler::unlock();

    return result;
}
    5d00:	e1a00005 	mov	r0, r5
    5d04:	e28dd004 	add	sp, sp, #4	; 0x4
    5d08:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5d0c:	ebffff42 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    5d10:	eafffffa 	b	5d00 <_ZN22Cyg_Counting_Semaphore4waitEv+0xc8>
    5d14:	40002538 	.word	0x40002538
    5d18:	400007c8 	.word	0x400007c8

00005d1c <_ZN22Cyg_Counting_Semaphore4waitEy>:
// negative.

#ifdef CYGFUN_KERNEL_THREADS_TIMER

cyg_bool
Cyg_Counting_Semaphore::wait( cyg_tick_count timeout )
    5d1c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5d20:	e59f8148 	ldr	r8, [pc, #328]	; 5e70 <_ZN22Cyg_Counting_Semaphore4waitEy+0x154>
    5d24:	e24dd00c 	sub	sp, sp, #12	; 0xc
    5d28:	e1a07000 	mov	r7, r0
    5d2c:	e5986000 	ldr	r6, [r8]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5d30:	e59f913c 	ldr	r9, [pc, #316]	; 5e74 <_ZN22Cyg_Counting_Semaphore4waitEy+0x158>
    5d34:	e5991000 	ldr	r1, [r9]
    5d38:	e2811001 	add	r1, r1, #1	; 0x1
    5d3c:	e5891000 	str	r1, [r9]
    5d40:	e598e000 	ldr	lr, [r8]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    5d44:	e5984000 	ldr	r4, [r8]
    5d48:	e5980000 	ldr	r0, [r8]
    5d4c:	e3a01003 	mov	r1, #3	; 0x3
    self()->wake_reason = NONE;
    5d50:	e3a0c000 	mov	ip, #0	; 0x0
    5d54:	e5c4c081 	strb	ip, [r4, #129]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    5d58:	e5ce1080 	strb	r1, [lr, #128]
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    5d5c:	e3a05000 	mov	r5, #0	; 0x0
    5d60:	e2800050 	add	r0, r0, #80	; 0x50
    5d64:	e3a04000 	mov	r4, #0	; 0x0
    5d68:	e88d0030 	stm	sp, {r4, r5}
    5d6c:	eb00245f 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>
    // If the timeout is in the past, the wake reason will have been
    // set to something other than NONE already. If the count is zero,
    // set the result false to force an immediate return. If the count
    // is non-zero, then this wait will succeed anyway.
    
    if( self->get_wake_reason() != Cyg_Thread::NONE &&
    5d70:	e5d63081 	ldrb	r3, [r6, #129]
    5d74:	e3530000 	cmp	r3, #0	; 0x0
    5d78:	03a05001 	moveq	r5, #1	; 0x1
    5d7c:	05973000 	ldreq	r3, [r7]
    5d80:	0a000002 	beq	5d90 <_ZN22Cyg_Counting_Semaphore4waitEy+0x74>
    5d84:	e5973000 	ldr	r3, [r7]
    5d88:	e2535000 	subs	r5, r3, #0	; 0x0
    5d8c:	13a05001 	movne	r5, #1	; 0x1
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    5d90:	e287a004 	add	sl, r7, #4	; 0x4
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    5d94:	e3a0b000 	mov	fp, #0	; 0x0
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    5d98:	e1a04005 	mov	r4, r5
    
    if( self->get_wake_reason() != Cyg_Thread::NONE &&
        0 == count )
        result = false;
            
    while ( 0 == count && result ) {
    5d9c:	e3530000 	cmp	r3, #0	; 0x0
    5da0:	13a03000 	movne	r3, #0	; 0x0
    5da4:	02043001 	andeq	r3, r4, #1	; 0x1
    5da8:	e3530000 	cmp	r3, #0	; 0x0
    5dac:	0a000017 	beq	5e10 <_ZN22Cyg_Counting_Semaphore4waitEy+0xf4>
    5db0:	e5983000 	ldr	r3, [r8]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    5db4:	e5982000 	ldr	r2, [r8]
    5db8:	e3a01003 	mov	r1, #3	; 0x3
    5dbc:	e5c31080 	strb	r1, [r3, #128]
    self()->wake_reason = NONE;
    5dc0:	e5c2b081 	strb	fp, [r2, #129]

        // must reset the sleep reason every time
        self->set_sleep_reason( Cyg_Thread::TIMEOUT );

        self->sleep();
    5dc4:	ebfff813 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    5dc8:	e1a0000a 	mov	r0, sl
    5dcc:	e1a01006 	mov	r1, r6
    5dd0:	ebfffda8 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5dd4:	e5990000 	ldr	r0, [r9]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    5dd8:	ebffff0f 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_INSTRUMENT_CNTSEM( WOKE, this, count );

        switch( self->get_wake_reason() )
    5ddc:	e5d63081 	ldrb	r3, [r6, #129]
    5de0:	e3530003 	cmp	r3, #3	; 0x3
    5de4:	3a000003 	bcc	5df8 <_ZN22Cyg_Counting_Semaphore4waitEy+0xdc>
    5de8:	e3530005 	cmp	r3, #5	; 0x5
    5dec:	9a00001a 	bls	5e5c <_ZN22Cyg_Counting_Semaphore4waitEy+0x140>
    5df0:	e3530006 	cmp	r3, #6	; 0x6
    5df4:	0a000014 	beq	5e4c <_ZN22Cyg_Counting_Semaphore4waitEy+0x130>
    5df8:	e5973000 	ldr	r3, [r7]
    
    if( self->get_wake_reason() != Cyg_Thread::NONE &&
        0 == count )
        result = false;
            
    while ( 0 == count && result ) {
    5dfc:	e3530000 	cmp	r3, #0	; 0x0
    5e00:	13a03000 	movne	r3, #0	; 0x0
    5e04:	02043001 	andeq	r3, r4, #1	; 0x1
    5e08:	e3530000 	cmp	r3, #0	; 0x0
    5e0c:	1affffe7 	bne	5db0 <_ZN22Cyg_Counting_Semaphore4waitEy+0x94>
    5e10:	e5980000 	ldr	r0, [r8]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    5e14:	e2800050 	add	r0, r0, #80	; 0x50
    5e18:	eb0024cb 	bl	f14c <_ZN9Cyg_Alarm7disableEv>

    // Clear the timeout. It is irrelevant whether the alarm has
    // actually gone off or not.
    self->clear_timer();
        
    if ( result ) count--;
    5e1c:	e3550000 	cmp	r5, #0	; 0x0
    5e20:	15973000 	ldrne	r3, [r7]
    5e24:	12433001 	subne	r3, r3, #1	; 0x1
    5e28:	15873000 	strne	r3, [r7]
    5e2c:	e5993000 	ldr	r3, [r9]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    5e30:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5e34:	159f3038 	ldrne	r3, [pc, #56]	; 5e74 <_ZN22Cyg_Counting_Semaphore4waitEy+0x158>
    5e38:	15830000 	strne	r0, [r3]
    5e3c:	0a000009 	beq	5e68 <_ZN22Cyg_Counting_Semaphore4waitEy+0x14c>

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    return result;
}
    5e40:	e1a00005 	mov	r0, r5
    5e44:	e28dd00c 	add	sp, sp, #12	; 0xc
    5e48:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    5e4c:	ebfff706 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    5e50:	e3a05001 	mov	r5, #1	; 0x1
    5e54:	e5973000 	ldr	r3, [r7]
    5e58:	eaffffce 	b	5d98 <_ZN22Cyg_Counting_Semaphore4waitEy+0x7c>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_INSTRUMENT_CNTSEM( WOKE, this, count );

        switch( self->get_wake_reason() )
    5e5c:	e3a05000 	mov	r5, #0	; 0x0
    5e60:	e5973000 	ldr	r3, [r7]
    5e64:	eaffffcb 	b	5d98 <_ZN22Cyg_Counting_Semaphore4waitEy+0x7c>
    5e68:	ebfffeeb 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    5e6c:	eafffff3 	b	5e40 <_ZN22Cyg_Counting_Semaphore4waitEy+0x124>
    5e70:	40002538 	.word	0x40002538
    5e74:	400007c8 	.word	0x400007c8

00005e78 <_ZN22Cyg_Counting_Semaphore4postEv>:
}
        
// -------------------------------------------------------------------------
// Increment count

void Cyg_Counting_Semaphore::post()
    5e78:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5e7c:	e59f405c 	ldr	r4, [pc, #92]	; 5ee0 <_ZN22Cyg_Counting_Semaphore4postEv+0x68>
    5e80:	e5943000 	ldr	r3, [r4]
    5e84:	e2833001 	add	r3, r3, #1	; 0x1
    5e88:	e5843000 	str	r3, [r4]
    // Prevent preemption
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_CNTSEM( POST, this, 0 );
            
    count++;
    5e8c:	e5903000 	ldr	r3, [r0]
        
    if( !queue.empty() ) {
    5e90:	e5902004 	ldr	r2, [r0, #4]
    // Prevent preemption
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_CNTSEM( POST, this, 0 );
            
    count++;
    5e94:	e2833001 	add	r3, r3, #1	; 0x1
        
    if( !queue.empty() ) {
    5e98:	e3520000 	cmp	r2, #0	; 0x0
    // Prevent preemption
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_CNTSEM( POST, this, 0 );
            
    count++;
    5e9c:	e5803000 	str	r3, [r0]
        
    if( !queue.empty() ) {
    5ea0:	0a000006 	beq	5ec0 <_ZN22Cyg_Counting_Semaphore4postEv+0x48>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    5ea4:	e2800004 	add	r0, r0, #4	; 0x4
    5ea8:	ebfffd82 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    5eac:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    5eb0:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    5eb4:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    5eb8:	e5c01080 	strb	r1, [r0, #128]

        Cyg_Thread *thread = queue.dequeue();

        thread->set_wake_reason( Cyg_Thread::DONE );
        
        thread->wake();
    5ebc:	ebfff8d2 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5ec0:	e5943000 	ldr	r3, [r4]
    5ec4:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5ec8:	159f3010 	ldrne	r3, [pc, #16]	; 5ee0 <_ZN22Cyg_Counting_Semaphore4postEv+0x68>
    5ecc:	15830000 	strne	r0, [r3]
    5ed0:	0a000000 	beq	5ed8 <_ZN22Cyg_Counting_Semaphore4postEv+0x60>
        CYG_INSTRUMENT_CNTSEM( WAKE, this, thread );
    }
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();    
}
    5ed4:	e8bd8010 	pop	{r4, pc}
    5ed8:	ebfffecf 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    5edc:	e8bd8010 	pop	{r4, pc}
    5ee0:	400007c8 	.word	0x400007c8

00005ee4 <_ZN22Cyg_Counting_Semaphore7trywaitEv>:
#endif // CYGFUN_KERNEL_THREADS_TIMER

// -------------------------------------------------------------------------
// Try to decrement, but fail if not possible

cyg_bool Cyg_Counting_Semaphore::trywait()
    5ee4:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5ee8:	e59f2048 	ldr	r2, [pc, #72]	; 5f38 <_ZN22Cyg_Counting_Semaphore7trywaitEv+0x54>
    5eec:	e5923000 	ldr	r3, [r2]
    5ef0:	e2833001 	add	r3, r3, #1	; 0x1
    5ef4:	e5823000 	str	r3, [r2]
    cyg_bool result = true;
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    if( count > 0 ) count--;
    5ef8:	e5903000 	ldr	r3, [r0]
    5efc:	e3530000 	cmp	r3, #0	; 0x0
    5f00:	c2433001 	subgt	r3, r3, #1	; 0x1
    5f04:	d3a04000 	movle	r4, #0	; 0x0
    5f08:	c5803000 	strgt	r3, [r0]
    5f0c:	c3a04001 	movgt	r4, #1	; 0x1
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5f10:	e5923000 	ldr	r3, [r2]
    5f14:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5f18:	159f3018 	ldrne	r3, [pc, #24]	; 5f38 <_ZN22Cyg_Counting_Semaphore7trywaitEv+0x54>
    5f1c:	15830000 	strne	r0, [r3]
    5f20:	0a000001 	beq	5f2c <_ZN22Cyg_Counting_Semaphore7trywaitEv+0x48>
            
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();
    
    return result;
}
    5f24:	e1a00004 	mov	r0, r4
    5f28:	e8bd8010 	pop	{r4, pc}
    5f2c:	ebfffeba 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    5f30:	e1a00004 	mov	r0, r4
    5f34:	e8bd8010 	pop	{r4, pc}
    5f38:	400007c8 	.word	0x400007c8

00005f3c <_ZN8Cyg_FlagC2Ej>:

public:

    Cyg_CList()
    {
        head = NULL;
    5f3c:	e3a03000 	mov	r3, #0	; 0x0
// Constructor

Cyg_Flag::Cyg_Flag( Cyg_FlagValue init )
{
    CYG_REPORT_FUNCTION();
    value = init;
    5f40:	e880000a 	stm	r0, {r1, r3}
    CYG_REPORT_RETURN();
}
    5f44:	e12fff1e 	bx	lr

00005f48 <_ZN8Cyg_FlagC1Ej>:
    5f48:	e3a03000 	mov	r3, #0	; 0x0
// Constructor

Cyg_Flag::Cyg_Flag( Cyg_FlagValue init )
{
    CYG_REPORT_FUNCTION();
    value = init;
    5f4c:	e880000a 	stm	r0, {r1, r3}
    CYG_REPORT_RETURN();
}
    5f50:	e12fff1e 	bx	lr

00005f54 <_ZN8Cyg_FlagD2Ev>:

// -------------------------------------------------------------------------
// Destructor

Cyg_Flag::~Cyg_Flag()
    5f54:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    5f58:	e1a05000 	mov	r5, r0
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    5f5c:	e59f80a0 	ldr	r8, [pc, #160]	; 6004 <_ZN8Cyg_FlagD2Ev+0xb0>
    5f60:	e5983000 	ldr	r3, [r8]
    5f64:	e2833001 	add	r3, r3, #1	; 0x1
    5f68:	e5883000 	str	r3, [r8]
    CYG_ASSERT( queue.empty(), "Deleting flag with threads waiting");
#endif
    // Prevent preemption
    Cyg_Scheduler::lock();

    while ( ! queue.empty() ) {
    5f6c:	e5903004 	ldr	r3, [r0, #4]
    5f70:	e3530000 	cmp	r3, #0	; 0x0
    5f74:	0a00000a 	beq	5fa4 <_ZN8Cyg_FlagD2Ev+0x50>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    5f78:	e2804004 	add	r4, r0, #4	; 0x4

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    5f7c:	e3a07000 	mov	r7, #0	; 0x0
    wake_reason = reason;
    5f80:	e3a06005 	mov	r6, #5	; 0x5

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    5f84:	e1a00004 	mov	r0, r4
    5f88:	ebfffd4a 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    5f8c:	e5c06081 	strb	r6, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    5f90:	e5c07080 	strb	r7, [r0, #128]
        Cyg_Thread *thread = queue.dequeue();
        thread->set_wake_reason( Cyg_Thread::DESTRUCT );
        thread->wake();
    5f94:	ebfff89c 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    CYG_ASSERT( queue.empty(), "Deleting flag with threads waiting");
#endif
    // Prevent preemption
    Cyg_Scheduler::lock();

    while ( ! queue.empty() ) {
    5f98:	e5953004 	ldr	r3, [r5, #4]
    5f9c:	e3530000 	cmp	r3, #0	; 0x0
    5fa0:	1afffff7 	bne	5f84 <_ZN8Cyg_FlagD2Ev+0x30>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    5fa4:	e5983000 	ldr	r3, [r8]
    5fa8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    5fac:	159f3050 	ldrne	r3, [pc, #80]	; 6004 <_ZN8Cyg_FlagD2Ev+0xb0>
    5fb0:	15830000 	strne	r0, [r3]
    5fb4:	0a000010 	beq	5ffc <_ZN8Cyg_FlagD2Ev+0xa8>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    5fb8:	e5951004 	ldr	r1, [r5, #4]
    5fbc:	ea000009 	b	5fe8 <_ZN8Cyg_FlagD2Ev+0x94>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    5fc0:	e5910000 	ldr	r0, [r1]
            if( next == node )
    5fc4:	e1500001 	cmp	r0, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    5fc8:	15913004 	ldrne	r3, [r1, #4]
    5fcc:	15803004 	strne	r3, [r0, #4]
        prev->next = next;
    5fd0:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    5fd4:	03a00000 	moveq	r0, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    5fd8:	15820000 	strne	r0, [r2]
        next = prev = this;
    5fdc:	15811004 	strne	r1, [r1, #4]
    5fe0:	15811000 	strne	r1, [r1]
    5fe4:	e1a01000 	mov	r1, r0
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    5fe8:	e3510000 	cmp	r1, #0	; 0x0
    5fec:	1afffff3 	bne	5fc0 <_ZN8Cyg_FlagD2Ev+0x6c>
    }

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();    
    CYG_REPORT_RETURN();
}
    5ff0:	e5851004 	str	r1, [r5, #4]
    5ff4:	e1a00005 	mov	r0, r5
    5ff8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    5ffc:	ebfffe86 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6000:	eaffffec 	b	5fb8 <_ZN8Cyg_FlagD2Ev+0x64>
    6004:	400007c8 	.word	0x400007c8

00006008 <_ZN8Cyg_Flag4pollEjh>:

// -------------------------------------------------------------------------
// Test for a match on our pattern, according to the flags given.
// Return the matching value if success, else zero.
Cyg_FlagValue
Cyg_Flag::poll( Cyg_FlagValue pattern, WaitMode mode )
    6008:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    600c:	e59fc08c 	ldr	ip, [pc, #140]	; 60a0 <_ZN8Cyg_Flag4pollEjh+0x98>
    6010:	e59c3000 	ldr	r3, [ip]
    6014:	e2833001 	add	r3, r3, #1	; 0x1
    6018:	e58c3000 	str	r3, [ip]
    // Prevent preemption so that we compare atomically
    Cyg_Scheduler::lock();

    Cyg_FlagValue result = 0;

    if ( Cyg_Flag::OR & mode ) {
    601c:	e3120002 	tst	r2, #2	; 0x2
    6020:	0a00000c 	beq	6058 <_ZN8Cyg_Flag4pollEjh+0x50>
        if ( 0 != (value & pattern) )
    6024:	e5904000 	ldr	r4, [r0]
    6028:	e1110004 	tst	r1, r4
    602c:	0a00000f 	beq	6070 <_ZN8Cyg_Flag4pollEjh+0x68>
        if ( (pattern != 0) && (pattern == (value & pattern)) )
            result = value;
    }

    // result != 0 <=> test passed
    if ( result && (Cyg_Flag::CLR & mode) )
    6030:	e3120001 	tst	r2, #1	; 0x1
        value = 0;
    6034:	13a03000 	movne	r3, #0	; 0x0
    6038:	15803000 	strne	r3, [r0]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    603c:	e59c3000 	ldr	r3, [ip]
    6040:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6044:	159f3054 	ldrne	r3, [pc, #84]	; 60a0 <_ZN8Cyg_Flag4pollEjh+0x98>
    6048:	15830000 	strne	r0, [r3]
    604c:	0a00000d 	beq	6088 <_ZN8Cyg_Flag4pollEjh+0x80>

    Cyg_Scheduler::unlock();

    CYG_REPORT_RETVAL( result );
    return result;
}
    6050:	e1a00004 	mov	r0, r4
    6054:	e8bd8010 	pop	{r4, pc}
    if ( Cyg_Flag::OR & mode ) {
        if ( 0 != (value & pattern) )
            result = value;
    }
    else { // Cyg_Flag::AND - all must be set
        if ( (pattern != 0) && (pattern == (value & pattern)) )
    6058:	e3510000 	cmp	r1, #0	; 0x0
    605c:	0a000003 	beq	6070 <_ZN8Cyg_Flag4pollEjh+0x68>
    6060:	e5904000 	ldr	r4, [r0]
    6064:	e0013004 	and	r3, r1, r4
    6068:	e1530001 	cmp	r3, r1
    606c:	0a000008 	beq	6094 <_ZN8Cyg_Flag4pollEjh+0x8c>
            result = value;
    }

    // result != 0 <=> test passed
    if ( result && (Cyg_Flag::CLR & mode) )
        value = 0;
    6070:	e3a04000 	mov	r4, #0	; 0x0
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6074:	e59c3000 	ldr	r3, [ip]
    6078:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    607c:	159f301c 	ldrne	r3, [pc, #28]	; 60a0 <_ZN8Cyg_Flag4pollEjh+0x98>
    6080:	15830000 	strne	r0, [r3]
    6084:	1afffff1 	bne	6050 <_ZN8Cyg_Flag4pollEjh+0x48>
    6088:	ebfffe63 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>

    Cyg_Scheduler::unlock();

    CYG_REPORT_RETVAL( result );
    return result;
}
    608c:	e1a00004 	mov	r0, r4
    6090:	e8bd8010 	pop	{r4, pc}
        if ( (pattern != 0) && (pattern == (value & pattern)) )
            result = value;
    }

    // result != 0 <=> test passed
    if ( result && (Cyg_Flag::CLR & mode) )
    6094:	e3540000 	cmp	r4, #0	; 0x0
    6098:	1affffe4 	bne	6030 <_ZN8Cyg_Flag4pollEjh+0x28>
    609c:	eaffffe6 	b	603c <_ZN8Cyg_Flag4pollEjh+0x34>
    60a0:	400007c8 	.word	0x400007c8

000060a4 <_ZN8Cyg_Flag8maskbitsEj>:
    
// clear some bits in the value (all of them by default) by ANDing with the
// argument.  This cannot make a wait condition become true, so there's not
// much to it.
void
Cyg_Flag::maskbits( Cyg_FlagValue arg )
    60a4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    60a8:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    60ac:	e59f2034 	ldr	r2, [pc, #52]	; 60e8 <_ZN8Cyg_Flag8maskbitsEj+0x44>
    60b0:	e5923000 	ldr	r3, [r2]
    60b4:	e2833001 	add	r3, r3, #1	; 0x1
    60b8:	e5823000 	str	r3, [r2]
    CYG_REPORT_FUNCTION();
  
    // Prevent preemption
    Cyg_Scheduler::lock();

    value &= arg;
    60bc:	e5903000 	ldr	r3, [r0]
    60c0:	e0033001 	and	r3, r3, r1
    60c4:	e5803000 	str	r3, [r0]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    60c8:	e5923000 	ldr	r3, [r2]
    60cc:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    60d0:	15820000 	strne	r0, [r2]
    60d4:	0a000001 	beq	60e0 <_ZN8Cyg_Flag8maskbitsEj+0x3c>
    // consequence of this operation.

    // Unlock scheduler and allow other threads to run
    Cyg_Scheduler::unlock();
    CYG_REPORT_RETURN();
}
    60d8:	e28dd004 	add	sp, sp, #4	; 0x4
    60dc:	e8bd8000 	pop	{pc}
    60e0:	ebfffe4d 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    60e4:	eafffffb 	b	60d8 <_ZN8Cyg_Flag8maskbitsEj+0x34>
    60e8:	400007c8 	.word	0x400007c8

000060ec <_ZN8Cyg_Flag7setbitsEj>:
// affected waiting threads; we do the decision making here so as to get
// atomicity wrt the other threads waking up - the value might have changed
// by the time they get to run.

void
Cyg_Flag::setbits( Cyg_FlagValue arg )
    60ec:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    60f0:	e1a05000 	mov	r5, r0
    60f4:	e24dd008 	sub	sp, sp, #8	; 0x8
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    60f8:	e59f910c 	ldr	r9, [pc, #268]	; 620c <_ZN8Cyg_Flag7setbitsEj+0x120>
    60fc:	e5993000 	ldr	r3, [r9]
    6100:	e2833001 	add	r3, r3, #1	; 0x1
    6104:	e5893000 	str	r3, [r9]

    // Prevent preemption
    Cyg_Scheduler::lock();
    
    // OR in the argument to get a new flag value.
    value |= arg;
    6108:	e5903000 	ldr	r3, [r0]

    // anyone waiting?
    if ( !(queue.empty()) ) {
    610c:	e5902004 	ldr	r2, [r0, #4]

    // Prevent preemption
    Cyg_Scheduler::lock();
    
    // OR in the argument to get a new flag value.
    value |= arg;
    6110:	e1833001 	orr	r3, r3, r1

    // anyone waiting?
    if ( !(queue.empty()) ) {
    6114:	e3520000 	cmp	r2, #0	; 0x0

    // Prevent preemption
    Cyg_Scheduler::lock();
    
    // OR in the argument to get a new flag value.
    value |= arg;
    6118:	e5803000 	str	r3, [r0]

    // anyone waiting?
    if ( !(queue.empty()) ) {
    611c:	0a000031 	beq	61e8 <_ZN8Cyg_Flag7setbitsEj+0xfc>

public:

    Cyg_CList()
    {
        head = NULL;
    6120:	e3a03000 	mov	r3, #0	; 0x0
    6124:	e28d7008 	add	r7, sp, #8	; 0x8
    6128:	e5273004 	str	r3, [r7, #-4]!
    612c:	e1a08003 	mov	r8, r3

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6130:	e2806004 	add	r6, r0, #4	; 0x4
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    6134:	e3a0a007 	mov	sl, #7	; 0x7
    6138:	ea00000a 	b	6168 <_ZN8Cyg_Flag7setbitsEj+0x7c>

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    613c:	e5c08080 	strb	r8, [r0, #128]
    wake_reason = reason;
    6140:	e5c0a081 	strb	sl, [r0, #129]

            if ( ((p->allmask != 0) && (p->allmask & value) == p->allmask) ||
                 ((p->anymask & value) != 0 ) ) {
                // success!  awaken the thread
                thread->set_wake_reason( Cyg_Thread::DONE );
                thread->wake();
    6144:	ebfff830 	bl	420c <_ZN10Cyg_Thread4wakeEv>
                // return the successful value to it
                p->value_out = value;
                // do we clear the value; is this the end?
                if ( p->do_clear ) {
    6148:	e594300c 	ldr	r3, [r4, #12]
                 ((p->anymask & value) != 0 ) ) {
                // success!  awaken the thread
                thread->set_wake_reason( Cyg_Thread::DONE );
                thread->wake();
                // return the successful value to it
                p->value_out = value;
    614c:	e5952000 	ldr	r2, [r5]
                // do we clear the value; is this the end?
                if ( p->do_clear ) {
    6150:	e3530000 	cmp	r3, #0	; 0x0
    if ( !(queue.empty()) ) {
        FlagWaitInfo   *p;
        Cyg_Thread     *thread;
        Cyg_ThreadQueue holding;

        do {
    6154:	e5953004 	ldr	r3, [r5, #4]
                 ((p->anymask & value) != 0 ) ) {
                // success!  awaken the thread
                thread->set_wake_reason( Cyg_Thread::DONE );
                thread->wake();
                // return the successful value to it
                p->value_out = value;
    6158:	e5842008 	str	r2, [r4, #8]
                // do we clear the value; is this the end?
                if ( p->do_clear ) {
                    // we can break here but need to preserve ordering
                    value = 0;
    615c:	15858000 	strne	r8, [r5]
    if ( !(queue.empty()) ) {
        FlagWaitInfo   *p;
        Cyg_Thread     *thread;
        Cyg_ThreadQueue holding;

        do {
    6160:	e3530000 	cmp	r3, #0	; 0x0
    6164:	0a000013 	beq	61b8 <_ZN8Cyg_Flag7setbitsEj+0xcc>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6168:	e1a00006 	mov	r0, r6
    616c:	ebfffcd1 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
            thread = queue.dequeue();
            p = (FlagWaitInfo *)(thread->get_wait_info());
    6170:	e5904048 	ldr	r4, [r0, #72]

            CYG_ASSERT( (p->allmask == 0) != (p->anymask == 0),
                        "Both masks set" );
            CYG_ASSERT( 0 == p->value_out, "Thread already awoken?" );

            if ( ((p->allmask != 0) && (p->allmask & value) == p->allmask) ||
    6174:	e5942000 	ldr	r2, [r4]
    6178:	e3520000 	cmp	r2, #0	; 0x0
    617c:	0595c000 	ldreq	ip, [r5]
    6180:	0a000003 	beq	6194 <_ZN8Cyg_Flag7setbitsEj+0xa8>
    6184:	e595c000 	ldr	ip, [r5]
    6188:	e00c3002 	and	r3, ip, r2
    618c:	e1520003 	cmp	r2, r3
    6190:	0affffe9 	beq	613c <_ZN8Cyg_Flag7setbitsEj+0x50>
    6194:	e5943004 	ldr	r3, [r4, #4]
    6198:	e11c0003 	tst	ip, r3
    619c:	1affffe6 	bne	613c <_ZN8Cyg_Flag7setbitsEj+0x50>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    61a0:	e1a01000 	mov	r1, r0
    61a4:	e1a00007 	mov	r0, r7
    61a8:	ebfffcb2 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
    if ( !(queue.empty()) ) {
        FlagWaitInfo   *p;
        Cyg_Thread     *thread;
        Cyg_ThreadQueue holding;

        do {
    61ac:	e5953004 	ldr	r3, [r5, #4]
    61b0:	e3530000 	cmp	r3, #0	; 0x0
    61b4:	1affffeb 	bne	6168 <_ZN8Cyg_Flag7setbitsEj+0x7c>
                holding.enqueue( thread );
            }
        } while ( !(queue.empty()) );
            
        // Now re-queue the unaffected threads back into the flag queue
        while ( !(holding.empty()) ) {
    61b8:	e59d3004 	ldr	r3, [sp, #4]
    61bc:	e3530000 	cmp	r3, #0	; 0x0
    61c0:	0a000008 	beq	61e8 <_ZN8Cyg_Flag7setbitsEj+0xfc>
    61c4:	e28d4004 	add	r4, sp, #4	; 0x4

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    61c8:	e1a00004 	mov	r0, r4
    61cc:	ebfffcb9 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
    61d0:	e1a01000 	mov	r1, r0
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    61d4:	e1a00006 	mov	r0, r6
    61d8:	ebfffca6 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
    61dc:	e59d3004 	ldr	r3, [sp, #4]
    61e0:	e3530000 	cmp	r3, #0	; 0x0
    61e4:	1afffff7 	bne	61c8 <_ZN8Cyg_Flag7setbitsEj+0xdc>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    61e8:	e5993000 	ldr	r3, [r9]
    61ec:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    61f0:	159f3014 	ldrne	r3, [pc, #20]	; 620c <_ZN8Cyg_Flag7setbitsEj+0x120>
    61f4:	15830000 	strne	r0, [r3]
    61f8:	0a000001 	beq	6204 <_ZN8Cyg_Flag7setbitsEj+0x118>
        }
    }
    // Unlock scheduler and allow other threads to run
    Cyg_Scheduler::unlock();
    CYG_REPORT_RETURN();
}
    61fc:	e28dd008 	add	sp, sp, #8	; 0x8
    6200:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    6204:	ebfffe04 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6208:	eafffffb 	b	61fc <_ZN8Cyg_Flag7setbitsEj+0x110>
    620c:	400007c8 	.word	0x400007c8

00006210 <_ZN8Cyg_FlagD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor

Cyg_Flag::~Cyg_Flag()
    6210:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    6214:	e1a05000 	mov	r5, r0
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6218:	e59f80a0 	ldr	r8, [pc, #160]	; 62c0 <_ZN8Cyg_FlagD1Ev+0xb0>
    621c:	e5983000 	ldr	r3, [r8]
    6220:	e2833001 	add	r3, r3, #1	; 0x1
    6224:	e5883000 	str	r3, [r8]
    CYG_ASSERT( queue.empty(), "Deleting flag with threads waiting");
#endif
    // Prevent preemption
    Cyg_Scheduler::lock();

    while ( ! queue.empty() ) {
    6228:	e5903004 	ldr	r3, [r0, #4]
    622c:	e3530000 	cmp	r3, #0	; 0x0
    6230:	0a00000a 	beq	6260 <_ZN8Cyg_FlagD1Ev+0x50>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6234:	e2804004 	add	r4, r0, #4	; 0x4

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6238:	e3a07000 	mov	r7, #0	; 0x0
    wake_reason = reason;
    623c:	e3a06005 	mov	r6, #5	; 0x5

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6240:	e1a00004 	mov	r0, r4
    6244:	ebfffc9b 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    6248:	e5c06081 	strb	r6, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    624c:	e5c07080 	strb	r7, [r0, #128]
        Cyg_Thread *thread = queue.dequeue();
        thread->set_wake_reason( Cyg_Thread::DESTRUCT );
        thread->wake();
    6250:	ebfff7ed 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    CYG_ASSERT( queue.empty(), "Deleting flag with threads waiting");
#endif
    // Prevent preemption
    Cyg_Scheduler::lock();

    while ( ! queue.empty() ) {
    6254:	e5953004 	ldr	r3, [r5, #4]
    6258:	e3530000 	cmp	r3, #0	; 0x0
    625c:	1afffff7 	bne	6240 <_ZN8Cyg_FlagD1Ev+0x30>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6260:	e5983000 	ldr	r3, [r8]
    6264:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6268:	159f3050 	ldrne	r3, [pc, #80]	; 62c0 <_ZN8Cyg_FlagD1Ev+0xb0>
    626c:	15830000 	strne	r0, [r3]
    6270:	0a000010 	beq	62b8 <_ZN8Cyg_FlagD1Ev+0xa8>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    6274:	e5951004 	ldr	r1, [r5, #4]
    6278:	ea000009 	b	62a4 <_ZN8Cyg_FlagD1Ev+0x94>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    627c:	e5910000 	ldr	r0, [r1]
            if( next == node )
    6280:	e1500001 	cmp	r0, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    6284:	15913004 	ldrne	r3, [r1, #4]
    6288:	15803004 	strne	r3, [r0, #4]
        prev->next = next;
    628c:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    6290:	03a00000 	moveq	r0, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6294:	15820000 	strne	r0, [r2]
        next = prev = this;
    6298:	15811004 	strne	r1, [r1, #4]
    629c:	15811000 	strne	r1, [r1]
    62a0:	e1a01000 	mov	r1, r0
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    62a4:	e3510000 	cmp	r1, #0	; 0x0
    62a8:	1afffff3 	bne	627c <_ZN8Cyg_FlagD1Ev+0x6c>
    }

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();    
    CYG_REPORT_RETURN();
}
    62ac:	e5851004 	str	r1, [r5, #4]
    62b0:	e1a00005 	mov	r0, r5
    62b4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    62b8:	ebfffdd7 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    62bc:	eaffffec 	b	6274 <_ZN8Cyg_FlagD1Ev+0x64>
    62c0:	400007c8 	.word	0x400007c8

000062c4 <_ZN8Cyg_Flag4waitEjh>:

// -------------------------------------------------------------------------
// Wait for a match on our pattern, according to the flags given.
// Return the matching value.
Cyg_FlagValue
Cyg_Flag::wait( Cyg_FlagValue pattern, WaitMode mode )
    62c4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    62c8:	e1a09000 	mov	r9, r0
    62cc:	e24dd010 	sub	sp, sp, #16	; 0x10
    62d0:	e1a0a001 	mov	sl, r1
    62d4:	e1a06002 	mov	r6, r2
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    62d8:	e59f70ec 	ldr	r7, [pc, #236]	; 63cc <_ZN8Cyg_Flag4waitEjh+0x108>
    62dc:	e5973000 	ldr	r3, [r7]
    62e0:	e2833001 	add	r3, r3, #1	; 0x1
    62e4:	e5873000 	str	r3, [r7]

    // Prevent preemption so that we compare atomically
    Cyg_Scheduler::lock();

    // try the current value
    result = poll( pattern, mode );
    62e8:	ebffff46 	bl	6008 <_ZN8Cyg_Flag4pollEjh>

    if ( 0 != result ) {
    62ec:	e2508000 	subs	r8, r0, #0	; 0x0
    62f0:	1a00002c 	bne	63a8 <_ZN8Cyg_Flag4waitEjh+0xe4>
    62f4:	e59f50d4 	ldr	r5, [pc, #212]	; 63d0 <_ZN8Cyg_Flag4waitEjh+0x10c>

    // we have to wait until we are awoken
    Cyg_Thread *self = Cyg_Thread::self();

    FlagWaitInfo saveme;
    saveme.allmask = (Cyg_Flag::OR & mode) ? 0 : pattern;
    62f8:	e2163002 	ands	r3, r6, #2	; 0x2
    62fc:	e5954000 	ldr	r4, [r5]
    6300:	058da000 	streq	sl, [sp]
        Cyg_FlagValue   allmask;        // these are separate words to
        Cyg_FlagValue   anymask;        // save time in wakeup.
        Cyg_FlagValue   value_out;      // return the value that satisfied
        cyg_bool        do_clear;

        FlagWaitInfo() { value_out = 0; }
    6304:	e3a02000 	mov	r2, #0	; 0x0
    6308:	01a0a003 	moveq	sl, r3
    saveme.anymask = (Cyg_Flag::OR & mode) ? pattern : 0;
    saveme.do_clear = (0 != (Cyg_Flag::CLR & mode));
    630c:	e2063001 	and	r3, r6, #1	; 0x1

    // we have to wait until we are awoken
    Cyg_Thread *self = Cyg_Thread::self();

    FlagWaitInfo saveme;
    saveme.allmask = (Cyg_Flag::OR & mode) ? 0 : pattern;
    6310:	158d8000 	strne	r8, [sp]
    6314:	e58d2008 	str	r2, [sp, #8]
    saveme.anymask = (Cyg_Flag::OR & mode) ? pattern : 0;
    6318:	e58da004 	str	sl, [sp, #4]
    saveme.do_clear = (0 != (Cyg_Flag::CLR & mode));
    631c:	e58d300c 	str	r3, [sp, #12]
    return state;
}

inline void Cyg_Thread::set_wait_info(CYG_ADDRWORD data)
{
    wait_info = data;
    6320:	e584d048 	str	sp, [r4, #72]
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6324:	e2896004 	add	r6, r9, #4	; 0x4

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6328:	e3a08001 	mov	r8, #1	; 0x1

    self->set_wait_info( (CYG_ADDRWORD)&saveme );

    result = true; // just being used as an early-out flag now
    // this loop allows us to deal correctly with spurious wakeups
    while ( result && (0 == saveme.value_out) ) {
    632c:	e59d1008 	ldr	r1, [sp, #8]
    6330:	e3510000 	cmp	r1, #0	; 0x0
    6334:	1a00000e 	bne	6374 <_ZN8Cyg_Flag4waitEjh+0xb0>
    6338:	e5953000 	ldr	r3, [r5]
    633c:	e5952000 	ldr	r2, [r5]
    6340:	e5c38080 	strb	r8, [r3, #128]
    self()->wake_reason = NONE;
    6344:	e5c21081 	strb	r1, [r2, #129]
        self->set_sleep_reason( Cyg_Thread::WAIT );
        self->sleep();
    6348:	ebfff6b2 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    634c:	e1a00006 	mov	r0, r6
    6350:	e1a01004 	mov	r1, r4
    6354:	ebfffc47 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6358:	e5970000 	ldr	r0, [r7]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    635c:	ebfffdae 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>

        CYG_ASSERT( ((CYG_ADDRWORD)&saveme) == 
                    Cyg_Thread::self()->get_wait_info(),
                    "Wait info lost" );

        switch( self->get_wake_reason() )
    6360:	e5d43081 	ldrb	r3, [r4, #129]
    6364:	e3530004 	cmp	r3, #4	; 0x4
    6368:	3affffef 	bcc	632c <_ZN8Cyg_Flag4waitEjh+0x68>
    636c:	e3530005 	cmp	r3, #5	; 0x5
    6370:	8a000008 	bhi	6398 <_ZN8Cyg_Flag4waitEjh+0xd4>
    6374:	e5973000 	ldr	r3, [r7]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    6378:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    637c:	159f3048 	ldrne	r3, [pc, #72]	; 63cc <_ZN8Cyg_Flag4waitEjh+0x108>
    6380:	15830000 	strne	r0, [r3]
    6384:	0a00000c 	beq	63bc <_ZN8Cyg_Flag4waitEjh+0xf8>
                "Break out but also good result!" );

    // Unlock scheduler and allow other threads to run
    Cyg_Scheduler::unlock();
    CYG_REPORT_RETVAL( saveme.value_out );
    return saveme.value_out;
    6388:	e59d8008 	ldr	r8, [sp, #8]
}
    638c:	e1a00008 	mov	r0, r8
    6390:	e28dd010 	add	sp, sp, #16	; 0x10
    6394:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

        CYG_ASSERT( ((CYG_ADDRWORD)&saveme) == 
                    Cyg_Thread::self()->get_wait_info(),
                    "Wait info lost" );

        switch( self->get_wake_reason() )
    6398:	e3530006 	cmp	r3, #6	; 0x6
    639c:	1affffe2 	bne	632c <_ZN8Cyg_Flag4waitEjh+0x68>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    63a0:	ebfff5b1 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    63a4:	eaffffe0 	b	632c <_ZN8Cyg_Flag4waitEjh+0x68>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    63a8:	e5973000 	ldr	r3, [r7]
    63ac:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    63b0:	15870000 	strne	r0, [r7]
    63b4:	0a000002 	beq	63c4 <_ZN8Cyg_Flag4waitEjh+0x100>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    63b8:	eafffff3 	b	638c <_ZN8Cyg_Flag4waitEjh+0xc8>
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    63bc:	ebfffd96 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    63c0:	eafffff0 	b	6388 <_ZN8Cyg_Flag4waitEjh+0xc4>
    63c4:	ebfffd94 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    63c8:	eaffffef 	b	638c <_ZN8Cyg_Flag4waitEjh+0xc8>
    63cc:	400007c8 	.word	0x400007c8
    63d0:	40002538 	.word	0x40002538

000063d4 <_ZN8Cyg_Flag4waitEjhy>:
// Return the matching value, or zero if timed out.
// (zero cannot match any pattern).
#ifdef CYGFUN_KERNEL_THREADS_TIMER
Cyg_FlagValue
Cyg_Flag::wait( Cyg_FlagValue pattern, WaitMode mode,
                cyg_tick_count abs_timeout )
    63d4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    63d8:	e1a0b000 	mov	fp, r0
    63dc:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    63e0:	e1a0a001 	mov	sl, r1
    63e4:	e1a05002 	mov	r5, r2
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    63e8:	e59f813c 	ldr	r8, [pc, #316]	; 652c <_ZN8Cyg_Flag4waitEjhy+0x158>
    63ec:	e5983000 	ldr	r3, [r8]
    63f0:	e2833001 	add	r3, r3, #1	; 0x1
    63f4:	e5883000 	str	r3, [r8]

    // Prevent preemption so that we compare atomically
    Cyg_Scheduler::lock();

    // try the current value
    result = poll( pattern, mode );
    63f8:	ebffff02 	bl	6008 <_ZN8Cyg_Flag4pollEjh>

    if ( 0 != result ) {
    63fc:	e2504000 	subs	r4, r0, #0	; 0x0
    6400:	1a000040 	bne	6508 <_ZN8Cyg_Flag4waitEjhy+0x134>
    6404:	e59f7124 	ldr	r7, [pc, #292]	; 6530 <_ZN8Cyg_Flag4waitEjhy+0x15c>

    // we have to wait until we are awoken
    Cyg_Thread *self = Cyg_Thread::self();

    FlagWaitInfo saveme;
    saveme.allmask = (Cyg_Flag::OR & mode) ? 0 : pattern;
    6408:	e2153002 	ands	r3, r5, #2	; 0x2
    640c:	e5976000 	ldr	r6, [r7]
    6410:	058da008 	streq	sl, [sp, #8]
    6414:	e5972000 	ldr	r2, [r7]
    6418:	01a0a003 	moveq	sl, r3
    641c:	e597c000 	ldr	ip, [r7]
    saveme.anymask = (Cyg_Flag::OR & mode) ? pattern : 0;
    saveme.do_clear = (0 != (Cyg_Flag::CLR & mode));
    6420:	e2053001 	and	r3, r5, #1	; 0x1
    6424:	e5970000 	ldr	r0, [r7]
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    6428:	e3a01000 	mov	r1, #0	; 0x0
    642c:	e58d3014 	str	r3, [sp, #20]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    6430:	e3a09003 	mov	r9, #3	; 0x3
    6434:	e28d3008 	add	r3, sp, #8	; 0x8

    // we have to wait until we are awoken
    Cyg_Thread *self = Cyg_Thread::self();

    FlagWaitInfo saveme;
    saveme.allmask = (Cyg_Flag::OR & mode) ? 0 : pattern;
    6438:	158d4008 	strne	r4, [sp, #8]
    643c:	e5c29080 	strb	r9, [r2, #128]
    saveme.anymask = (Cyg_Flag::OR & mode) ? pattern : 0;
    6440:	e58da00c 	str	sl, [sp, #12]
    self()->wake_reason = NONE;
    6444:	e5cc1081 	strb	r1, [ip, #129]
    6448:	e5863048 	str	r3, [r6, #72]
    self()->timer.initialize( trigger);
    644c:	e3a04000 	mov	r4, #0	; 0x0
    6450:	e28d2040 	add	r2, sp, #64	; 0x40
    6454:	e892000c 	ldm	r2, {r2, r3}
    6458:	e3a05000 	mov	r5, #0	; 0x0
    645c:	e2800050 	add	r0, r0, #80	; 0x50
    6460:	e88d0030 	stm	sp, {r4, r5}
    6464:	e58d1010 	str	r1, [sp, #16]
    6468:	eb0022a0 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>
    else result = true;

    // Result is just being used as an early-out flag now. This loop
    // allows us to deal correctly with spurious wakeups.

    while ( result && (0 == saveme.value_out) ) {
    646c:	e5d63081 	ldrb	r3, [r6, #129]
    6470:	e3530000 	cmp	r3, #0	; 0x0
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6474:	028b4004 	addeq	r4, fp, #4	; 0x4

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6478:	01a05009 	moveq	r5, r9
    647c:	1a000011 	bne	64c8 <_ZN8Cyg_Flag4waitEjhy+0xf4>
    6480:	e59d1010 	ldr	r1, [sp, #16]
    6484:	e3510000 	cmp	r1, #0	; 0x0
    6488:	1a00000e 	bne	64c8 <_ZN8Cyg_Flag4waitEjhy+0xf4>
    648c:	e5973000 	ldr	r3, [r7]
    6490:	e5972000 	ldr	r2, [r7]
    6494:	e5c35080 	strb	r5, [r3, #128]
    self()->wake_reason = NONE;
    6498:	e5c21081 	strb	r1, [r2, #129]
        self->set_sleep_reason( Cyg_Thread::TIMEOUT );
        self->sleep();
    649c:	ebfff65d 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    64a0:	e1a00004 	mov	r0, r4
    64a4:	e1a01006 	mov	r1, r6
    64a8:	ebfffbf2 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    64ac:	e5980000 	ldr	r0, [r8]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    64b0:	ebfffd59 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>

        CYG_ASSERT( ((CYG_ADDRWORD)&saveme) == 
                    Cyg_Thread::self()->get_wait_info(),
                    "Wait info lost" );

        switch( self->get_wake_reason() )
    64b4:	e5d63081 	ldrb	r3, [r6, #129]
    64b8:	e3530003 	cmp	r3, #3	; 0x3
    64bc:	3affffef 	bcc	6480 <_ZN8Cyg_Flag4waitEjhy+0xac>
    64c0:	e3530005 	cmp	r3, #5	; 0x5
    64c4:	8a00000b 	bhi	64f8 <_ZN8Cyg_Flag4waitEjhy+0x124>
    64c8:	e5970000 	ldr	r0, [r7]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    64cc:	e2800050 	add	r0, r0, #80	; 0x50
    64d0:	eb00231d 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    64d4:	e5983000 	ldr	r3, [r8]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    64d8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    64dc:	159f3048 	ldrne	r3, [pc, #72]	; 652c <_ZN8Cyg_Flag4waitEjhy+0x158>
    64e0:	15830000 	strne	r0, [r3]
    64e4:	0a00000c 	beq	651c <_ZN8Cyg_Flag4waitEjhy+0x148>

    // Unlock scheduler and allow other threads to run
    Cyg_Scheduler::unlock();
    // in this version, value_out might be zero meaning timed out.
    CYG_REPORT_RETVAL( saveme.value_out );
    return saveme.value_out;
    64e8:	e59d4010 	ldr	r4, [sp, #16]
}
    64ec:	e1a00004 	mov	r0, r4
    64f0:	e28dd01c 	add	sp, sp, #28	; 0x1c
    64f4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

        CYG_ASSERT( ((CYG_ADDRWORD)&saveme) == 
                    Cyg_Thread::self()->get_wait_info(),
                    "Wait info lost" );

        switch( self->get_wake_reason() )
    64f8:	e3530006 	cmp	r3, #6	; 0x6
    64fc:	1affffdf 	bne	6480 <_ZN8Cyg_Flag4waitEjhy+0xac>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    6500:	ebfff559 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    6504:	eaffffdd 	b	6480 <_ZN8Cyg_Flag4waitEjhy+0xac>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6508:	e5983000 	ldr	r3, [r8]
    650c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6510:	15880000 	strne	r0, [r8]
    6514:	0a000002 	beq	6524 <_ZN8Cyg_Flag4waitEjhy+0x150>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    6518:	eafffff3 	b	64ec <_ZN8Cyg_Flag4waitEjhy+0x118>
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    651c:	ebfffd3e 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6520:	eafffff0 	b	64e8 <_ZN8Cyg_Flag4waitEjhy+0x114>
    6524:	ebfffd3c 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    6528:	eaffffef 	b	64ec <_ZN8Cyg_Flag4waitEjhy+0x118>
    652c:	400007c8 	.word	0x400007c8
    6530:	40002538 	.word	0x40002538

00006534 <_ZN8Cyg_MboxC2Ev>:

public:

    Cyg_CList()
    {
        head = NULL;
    6534:	e3a03000 	mov	r3, #0	; 0x0
template <class T, cyg_count32 QUEUE_SIZE>
Cyg_Mboxt<T,QUEUE_SIZE>::Cyg_Mboxt()
{
    CYG_REPORT_FUNCTION();
    base = 0;
    count = 0;
    6538:	e5803004 	str	r3, [r0, #4]
    653c:	e5803008 	str	r3, [r0, #8]
// Thread Queue class.
// This defines the main API for manipulating queues of threads.

class Cyg_ThreadQueue
    : public Cyg_ThreadQueue_Implementation
{
    6540:	e580300c 	str	r3, [r0, #12]

template <class T, cyg_count32 QUEUE_SIZE>
Cyg_Mboxt<T,QUEUE_SIZE>::Cyg_Mboxt()
{
    CYG_REPORT_FUNCTION();
    base = 0;
    6544:	e5803000 	str	r3, [r0]
// -------------------------------------------------------------------------
// Constructor

Cyg_Mbox::Cyg_Mbox()
{
}
    6548:	e12fff1e 	bx	lr

0000654c <_ZN8Cyg_MboxC1Ev>:
    654c:	e3a03000 	mov	r3, #0	; 0x0
    count = 0;
    6550:	e5803004 	str	r3, [r0, #4]
    6554:	e5803008 	str	r3, [r0, #8]
    6558:	e580300c 	str	r3, [r0, #12]

template <class T, cyg_count32 QUEUE_SIZE>
Cyg_Mboxt<T,QUEUE_SIZE>::Cyg_Mboxt()
{
    CYG_REPORT_FUNCTION();
    base = 0;
    655c:	e5803000 	str	r3, [r0]
    6560:	e12fff1e 	bx	lr

00006564 <_ZN8Cyg_MboxD2Ev>:

// -------------------------------------------------------------------------
// Destructor

Cyg_Mbox::~Cyg_Mbox()
    6564:	e590100c 	ldr	r1, [r0, #12]
    6568:	ea000009 	b	6594 <_ZN8Cyg_MboxD2Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    656c:	e591c000 	ldr	ip, [r1]
            if( next == node )
    6570:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    6574:	15913004 	ldrne	r3, [r1, #4]
    6578:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    657c:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    6580:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6584:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6588:	15811004 	strne	r1, [r1, #4]
    658c:	15811000 	strne	r1, [r1]
    6590:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    6594:	e3510000 	cmp	r1, #0	; 0x0
    6598:	1afffff3 	bne	656c <_ZN8Cyg_MboxD2Ev+0x8>
    659c:	e580100c 	str	r1, [r0, #12]
    65a0:	e5901008 	ldr	r1, [r0, #8]
    65a4:	ea000009 	b	65d0 <_ZN8Cyg_MboxD2Ev+0x6c>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    65a8:	e591c000 	ldr	ip, [r1]
            if( next == node )
    65ac:	e151000c 	cmp	r1, ip

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    65b0:	15913004 	ldrne	r3, [r1, #4]
    65b4:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    65b8:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    65bc:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    65c0:	1582c000 	strne	ip, [r2]
        next = prev = this;
    65c4:	15811004 	strne	r1, [r1, #4]
    65c8:	15811000 	strne	r1, [r1]
    65cc:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    65d0:	e3510000 	cmp	r1, #0	; 0x0
    65d4:	1afffff3 	bne	65a8 <_ZN8Cyg_MboxD2Ev+0x44>
{
}
    65d8:	e5801008 	str	r1, [r0, #8]
    65dc:	e12fff1e 	bx	lr

000065e0 <_ZN8Cyg_MboxD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor

Cyg_Mbox::~Cyg_Mbox()
    65e0:	e590100c 	ldr	r1, [r0, #12]
    65e4:	ea000009 	b	6610 <_ZN8Cyg_MboxD1Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    65e8:	e591c000 	ldr	ip, [r1]
            if( next == node )
    65ec:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    65f0:	15913004 	ldrne	r3, [r1, #4]
    65f4:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    65f8:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    65fc:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6600:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6604:	15811004 	strne	r1, [r1, #4]
    6608:	15811000 	strne	r1, [r1]
    660c:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    6610:	e3510000 	cmp	r1, #0	; 0x0
    6614:	1afffff3 	bne	65e8 <_ZN8Cyg_MboxD1Ev+0x8>
    6618:	e580100c 	str	r1, [r0, #12]
    661c:	e5901008 	ldr	r1, [r0, #8]
    6620:	ea000009 	b	664c <_ZN8Cyg_MboxD1Ev+0x6c>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    6624:	e591c000 	ldr	ip, [r1]
            if( next == node )
    6628:	e151000c 	cmp	r1, ip

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    662c:	15913004 	ldrne	r3, [r1, #4]
    6630:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    6634:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    6638:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    663c:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6640:	15811004 	strne	r1, [r1, #4]
    6644:	15811000 	strne	r1, [r1]
    6648:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    664c:	e3510000 	cmp	r1, #0	; 0x0
    6650:	1afffff3 	bne	6624 <_ZN8Cyg_MboxD1Ev+0x44>
{
}
    6654:	e5801008 	str	r1, [r0, #8]
    6658:	e12fff1e 	bx	lr

0000665c <_ZN8Cyg_Mbox9peek_itemEv>:
{
    return m.tryput( item );
}

void *
Cyg_Mbox::peek_item()                   // Get next item to be returned
    665c:	e92d4030 	push	{r4, r5, lr}
    6660:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6664:	e59f205c 	ldr	r2, [pc, #92]	; 66c8 <_ZN8Cyg_Mbox9peek_itemEv+0x6c>
    6668:	e5923000 	ldr	r3, [r2]
    666c:	e2833001 	add	r3, r3, #1	; 0x1
    6670:	e5823000 	str	r3, [r2]

    CYG_ASSERTCLASS( this, "Bad this pointer");
    
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    6674:	e5903004 	ldr	r3, [r0, #4]
    6678:	e3530000 	cmp	r3, #0	; 0x0
    667c:	d3a04000 	movle	r4, #0	; 0x0
    6680:	c3a04001 	movgt	r4, #1	; 0x1
    // If the mboxt is not empty, grab an item and return it.
    if ( result )
    6684:	e3540000 	cmp	r4, #0	; 0x0
        ritem = itemqueue[ base ];
    6688:	15903000 	ldrne	r3, [r0]
    668c:	12833004 	addne	r3, r3, #4	; 0x4
    
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    // If the mboxt is not empty, grab an item and return it.
    if ( result )
    6690:	01a05004 	moveq	r5, r4
        ritem = itemqueue[ base ];
    6694:	17905103 	ldrne	r5, [r0, r3, lsl #2]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6698:	e5923000 	ldr	r3, [r2]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    669c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    66a0:	159f3020 	ldrne	r3, [pc, #32]	; 66c8 <_ZN8Cyg_Mbox9peek_itemEv+0x6c>
    66a4:	15830000 	strne	r0, [r3]
    66a8:	0a000004 	beq	66c0 <_ZN8Cyg_Mbox9peek_itemEv+0x64>
{
    void *p=NULL;
    if ( ! m.peek_item( p ) )
        return NULL;
    return p;
}
    66ac:	e3540000 	cmp	r4, #0	; 0x0
    66b0:	11a00005 	movne	r0, r5
    66b4:	03a00000 	moveq	r0, #0	; 0x0
    66b8:	e28dd004 	add	sp, sp, #4	; 0x4
    66bc:	e8bd8030 	pop	{r4, r5, pc}
    66c0:	ebfffcd5 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    66c4:	eafffff8 	b	66ac <_ZN8Cyg_Mbox9peek_itemEv+0x50>
    66c8:	400007c8 	.word	0x400007c8

000066cc <_ZN8Cyg_Mbox3getEy>:
    return p;
}

#ifdef CYGFUN_KERNEL_THREADS_TIMER
void *
Cyg_Mbox::get( cyg_tick_count timeout )
    66cc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    66d0:	e59f7174 	ldr	r7, [pc, #372]	; 684c <_ZN8Cyg_Mbox3getEy+0x180>
    66d4:	e24dd008 	sub	sp, sp, #8	; 0x8
    66d8:	e1a08000 	mov	r8, r0
    66dc:	e5976000 	ldr	r6, [r7]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    66e0:	e59fa168 	ldr	sl, [pc, #360]	; 6850 <_ZN8Cyg_Mbox3getEy+0x184>
    66e4:	e59a1000 	ldr	r1, [sl]
    66e8:	e2811001 	add	r1, r1, #1	; 0x1
    66ec:	e58a1000 	str	r1, [sl]
    66f0:	e597e000 	ldr	lr, [r7]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    66f4:	e597c000 	ldr	ip, [r7]
    66f8:	e5970000 	ldr	r0, [r7]
    66fc:	e3a09003 	mov	r9, #3	; 0x3
    self()->wake_reason = NONE;
    6700:	e3a01000 	mov	r1, #0	; 0x0
    6704:	e5cc1081 	strb	r1, [ip, #129]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    6708:	e5ce9080 	strb	r9, [lr, #128]
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    670c:	e3a04000 	mov	r4, #0	; 0x0
    6710:	e3a05000 	mov	r5, #0	; 0x0
    6714:	e2800050 	add	r0, r0, #80	; 0x50
    6718:	e88d0030 	stm	sp, {r4, r5}
    671c:	eb0021f3 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>
                
    // Loop while the mboxt is empty, sleeping each time around the loop.
    // This copes with the possibility of a higher priority thread grabbing
    // the message between the wakeup in put()&c and this thread actually
    // starting.
    while ( result && (0 == count) ) {
    6720:	e5d63081 	ldrb	r3, [r6, #129]
    6724:	e3530000 	cmp	r3, #0	; 0x0

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6728:	01a05009 	moveq	r5, r9
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    672c:	02884008 	addeq	r4, r8, #8	; 0x8
    6730:	1a000011 	bne	677c <_ZN8Cyg_Mbox3getEy+0xb0>
    6734:	e5981004 	ldr	r1, [r8, #4]
    6738:	e3510000 	cmp	r1, #0	; 0x0
    673c:	1a000023 	bne	67d0 <_ZN8Cyg_Mbox3getEy+0x104>
    6740:	e5973000 	ldr	r3, [r7]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6744:	e5972000 	ldr	r2, [r7]
    6748:	e5c35080 	strb	r5, [r3, #128]
    self()->wake_reason = NONE;
    674c:	e5c21081 	strb	r1, [r2, #129]
        // must reset the sleep reason every time
        self->set_sleep_reason( Cyg_Thread::TIMEOUT );
        self->sleep();
    6750:	ebfff5b0 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6754:	e1a00004 	mov	r0, r4
    6758:	e1a01006 	mov	r1, r6
    675c:	ebfffb45 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6760:	e59a0000 	ldr	r0, [sl]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    6764:	ebfffcac 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_ASSERTCLASS( this, "Bad this pointer");        

        switch( self->get_wake_reason() )
    6768:	e5d63081 	ldrb	r3, [r6, #129]
    676c:	e3530003 	cmp	r3, #3	; 0x3
    6770:	3affffef 	bcc	6734 <_ZN8Cyg_Mbox3getEy+0x68>
    6774:	e3530005 	cmp	r3, #5	; 0x5
    6778:	8a00000e 	bhi	67b8 <_ZN8Cyg_Mbox3getEy+0xec>
    677c:	e5970000 	ldr	r0, [r7]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    6780:	e3a05000 	mov	r5, #0	; 0x0
    6784:	e2800050 	add	r0, r0, #80	; 0x50
    6788:	eb00226f 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    678c:	e1a04005 	mov	r4, r5
    6790:	e59a3000 	ldr	r3, [sl]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    6794:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6798:	159f30b0 	ldrne	r3, [pc, #176]	; 6850 <_ZN8Cyg_Mbox3getEy+0x184>
    679c:	15830000 	strne	r0, [r3]
    67a0:	0a000027 	beq	6844 <_ZN8Cyg_Mbox3getEy+0x178>
{
    void * p=NULL;
    if ( ! m.get( p, timeout ) )
        return NULL;
    return p;
}
    67a4:	e3540000 	cmp	r4, #0	; 0x0
    67a8:	11a00005 	movne	r0, r5
    67ac:	03a00000 	moveq	r0, #0	; 0x0
    67b0:	e28dd008 	add	sp, sp, #8	; 0x8
    67b4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    67b8:	e3530006 	cmp	r3, #6	; 0x6
    67bc:	1affffdc 	bne	6734 <_ZN8Cyg_Mbox3getEy+0x68>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    67c0:	ebfff4a9 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
                
    // Loop while the mboxt is empty, sleeping each time around the loop.
    // This copes with the possibility of a higher priority thread grabbing
    // the message between the wakeup in put()&c and this thread actually
    // starting.
    while ( result && (0 == count) ) {
    67c4:	e5981004 	ldr	r1, [r8, #4]
    67c8:	e3510000 	cmp	r1, #0	; 0x0
    67cc:	0affffdb 	beq	6740 <_ZN8Cyg_Mbox3getEy+0x74>
    67d0:	e5970000 	ldr	r0, [r7]
    67d4:	e2800050 	add	r0, r0, #80	; 0x50
    67d8:	eb00225b 	bl	f14c <_ZN9Cyg_Alarm7disableEv>

    if ( result ) {

        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    67dc:	e898000c 	ldm	r8, {r2, r3}
    67e0:	e2821001 	add	r1, r2, #1	; 0x1
    67e4:	e2433001 	sub	r3, r3, #1	; 0x1
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );

        if ( size <= base )
    67e8:	e3510009 	cmp	r1, #9	; 0x9

    if ( result ) {

        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    67ec:	e5883004 	str	r3, [r8, #4]
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );

        if ( size <= base )
            base = 0;
    67f0:	c3a03000 	movgt	r3, #0	; 0x0

    if ( result ) {

        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    67f4:	e5881000 	str	r1, [r8]
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );

        if ( size <= base )
            base = 0;
    67f8:	c5883000 	strgt	r3, [r8]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    67fc:	e598300c 	ldr	r3, [r8, #12]

    if ( result ) {

        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6800:	e2822004 	add	r2, r2, #4	; 0x4

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6804:	e3530000 	cmp	r3, #0	; 0x0

    if ( result ) {

        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6808:	e7985102 	ldr	r5, [r8, r2, lsl #2]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    680c:	0a000006 	beq	682c <_ZN8Cyg_Mbox3getEy+0x160>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6810:	e288000c 	add	r0, r8, #12	; 0xc
    6814:	ebfffb27 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    6818:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    681c:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    6820:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6824:	e5c01080 	strb	r1, [r0, #128]
        Cyg_Thread *thread = q.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->set_wake_reason( Cyg_Thread::DONE );
        thread->wake();
    6828:	ebfff677 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    682c:	e3a04001 	mov	r4, #1	; 0x1
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6830:	e59a3000 	ldr	r3, [sl]
    6834:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6838:	159f3010 	ldrne	r3, [pc, #16]	; 6850 <_ZN8Cyg_Mbox3getEy+0x184>
    683c:	15830000 	strne	r0, [r3]
    6840:	1affffd7 	bne	67a4 <_ZN8Cyg_Mbox3getEy+0xd8>
    6844:	ebfffc74 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6848:	eaffffd5 	b	67a4 <_ZN8Cyg_Mbox3getEy+0xd8>
    684c:	40002538 	.word	0x40002538
    6850:	400007c8 	.word	0x400007c8

00006854 <_ZN8Cyg_Mbox6tryputEPv>:
}
#endif
#endif // CYGMFN_KERNEL_SYNCH_MBOXT_PUT_CAN_WAIT

cyg_bool
Cyg_Mbox::tryput( void *item )
    6854:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6858:	e59f40a4 	ldr	r4, [pc, #164]	; 6904 <_ZN8Cyg_Mbox6tryputEPv+0xb0>
    685c:	e5943000 	ldr	r3, [r4]
    6860:	e2833001 	add	r3, r3, #1	; 0x1
    6864:	e5843000 	str	r3, [r4]
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_MBOXT(PUT, this, count);
    CYG_ASSERTCLASS( this, "Bad this pointer");

    if ( size == count ) {
    6868:	e5902004 	ldr	r2, [r0, #4]
    686c:	e352000a 	cmp	r2, #10	; 0xa
    6870:	0a00001b 	beq	68e4 <_ZN8Cyg_Mbox6tryputEPv+0x90>
        Cyg_Scheduler::unlock();        // unlock, maybe switch threads
        return false;                   // the mboxt is full
    }

    cyg_count32 in = base + (count++);
    6874:	e5903000 	ldr	r3, [r0]
    6878:	e082c003 	add	ip, r2, r3
    if ( size <= in )
    687c:	e35c0009 	cmp	ip, #9	; 0x9

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6880:	e5903008 	ldr	r3, [r0, #8]
    if ( size == count ) {
        Cyg_Scheduler::unlock();        // unlock, maybe switch threads
        return false;                   // the mboxt is full
    }

    cyg_count32 in = base + (count++);
    6884:	e2822001 	add	r2, r2, #1	; 0x1
    if ( size <= in )
        in -= size;
    6888:	c24cc00a 	subgt	ip, ip, #10	; 0xa
    if ( size == count ) {
        Cyg_Scheduler::unlock();        // unlock, maybe switch threads
        return false;                   // the mboxt is full
    }

    cyg_count32 in = base + (count++);
    688c:	e5802004 	str	r2, [r0, #4]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6890:	e3530000 	cmp	r3, #0	; 0x0

    CYG_ASSERT( size > in, "in overflow" );
    CYG_ASSERT( 0 <= in, "in overflow" );
    CYG_ASSERT( size >= count, "count overflow" );

    itemqueue[ in ] = item;
    6894:	e28c2004 	add	r2, ip, #4	; 0x4
    6898:	e7801102 	str	r1, [r0, r2, lsl #2]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    689c:	0a000006 	beq	68bc <_ZN8Cyg_Mbox6tryputEPv+0x68>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    68a0:	e2800008 	add	r0, r0, #8	; 0x8
    68a4:	ebfffb03 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    68a8:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    68ac:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    68b0:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    68b4:	e5c01080 	strb	r1, [r0, #128]
        Cyg_Thread *thread = q.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->set_wake_reason( Cyg_Thread::DONE );
        thread->wake();
    68b8:	ebfff653 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    68bc:	e5943000 	ldr	r3, [r4]
    68c0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    68c4:	159f3038 	ldrne	r3, [pc, #56]	; 6904 <_ZN8Cyg_Mbox6tryputEPv+0xb0>
    68c8:	15830000 	strne	r0, [r3]
    68cc:	0a000001 	beq	68d8 <_ZN8Cyg_Mbox6tryputEPv+0x84>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    68d0:	e3a00001 	mov	r0, #1	; 0x1
{
    return m.tryput( item );
}
    68d4:	e8bd8010 	pop	{r4, pc}
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    68d8:	ebfffc4f 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    68dc:	e3a00001 	mov	r0, #1	; 0x1
    68e0:	e8bd8010 	pop	{r4, pc}
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    68e4:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    68e8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    68ec:	15840000 	strne	r0, [r4]
    68f0:	0a000001 	beq	68fc <_ZN8Cyg_Mbox6tryputEPv+0xa8>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    68f4:	e3a00000 	mov	r0, #0	; 0x0
    68f8:	e8bd8010 	pop	{r4, pc}
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    68fc:	ebfffc46 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6900:	eafffffb 	b	68f4 <_ZN8Cyg_Mbox6tryputEPv+0xa0>
    6904:	400007c8 	.word	0x400007c8

00006908 <_ZN8Cyg_Mbox3putEPv>:
    return p;
}

#ifdef  CYGMFN_KERNEL_SYNCH_MBOXT_PUT_CAN_WAIT
cyg_bool
Cyg_Mbox::put( void *item )
    6908:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    690c:	e59f6114 	ldr	r6, [pc, #276]	; 6a28 <_ZN8Cyg_Mbox3putEPv+0x120>
    6910:	e24dd004 	sub	sp, sp, #4	; 0x4
    6914:	e1a04000 	mov	r4, r0
    6918:	e1a0b001 	mov	fp, r1
    691c:	e5965000 	ldr	r5, [r6]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6920:	e59fa104 	ldr	sl, [pc, #260]	; 6a2c <_ZN8Cyg_Mbox3putEPv+0x124>
    6924:	e59a3000 	ldr	r3, [sl]
    6928:	e2833001 	add	r3, r3, #1	; 0x1
    692c:	e58a3000 	str	r3, [sl]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6930:	e3a09001 	mov	r9, #1	; 0x1
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6934:	e280700c 	add	r7, r0, #12	; 0xc
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    6938:	e3a08000 	mov	r8, #0	; 0x0
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_MBOXT(PUT, this, count);
    CYG_ASSERTCLASS( this, "Bad this pointer");

    while ( result && (size == count) ) {
    693c:	e5942004 	ldr	r2, [r4, #4]
    6940:	e352000a 	cmp	r2, #10	; 0xa
    6944:	1a000014 	bne	699c <_ZN8Cyg_Mbox3putEPv+0x94>
    6948:	e5963000 	ldr	r3, [r6]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    694c:	e5962000 	ldr	r2, [r6]
    6950:	e5c39080 	strb	r9, [r3, #128]
    self()->wake_reason = NONE;
    6954:	e5c28081 	strb	r8, [r2, #129]
        self->set_sleep_reason( Cyg_Thread::WAIT );
        self->sleep();
    6958:	ebfff52e 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    695c:	e1a00007 	mov	r0, r7
    6960:	e1a01005 	mov	r1, r5
    6964:	ebfffac3 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6968:	e59a0000 	ldr	r0, [sl]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    696c:	ebfffc2a 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_ASSERTCLASS( this, "Bad this pointer");        

        switch( self->get_wake_reason() )
    6970:	e5d53081 	ldrb	r3, [r5, #129]
    6974:	e3530004 	cmp	r3, #4	; 0x4
    6978:	3affffef 	bcc	693c <_ZN8Cyg_Mbox3putEPv+0x34>
    697c:	e3530005 	cmp	r3, #5	; 0x5
    6980:	9a00001f 	bls	6a04 <_ZN8Cyg_Mbox3putEPv+0xfc>
    6984:	e3530006 	cmp	r3, #6	; 0x6
    6988:	1affffeb 	bne	693c <_ZN8Cyg_Mbox3putEPv+0x34>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    698c:	ebfff436 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_MBOXT(PUT, this, count);
    CYG_ASSERTCLASS( this, "Bad this pointer");

    while ( result && (size == count) ) {
    6990:	e5942004 	ldr	r2, [r4, #4]
    6994:	e352000a 	cmp	r2, #10	; 0xa
    6998:	0affffea 	beq	6948 <_ZN8Cyg_Mbox3putEPv+0x40>
            break;
        }
    }

    if ( result ) {
        cyg_count32 in = base + (count++);
    699c:	e5943000 	ldr	r3, [r4]
    69a0:	e0821003 	add	r1, r2, r3
        if ( size <= in )
    69a4:	e3510009 	cmp	r1, #9	; 0x9

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    69a8:	e5943008 	ldr	r3, [r4, #8]
            break;
        }
    }

    if ( result ) {
        cyg_count32 in = base + (count++);
    69ac:	e2822001 	add	r2, r2, #1	; 0x1
        if ( size <= in )
            in -= size;
    69b0:	c241100a 	subgt	r1, r1, #10	; 0xa
            break;
        }
    }

    if ( result ) {
        cyg_count32 in = base + (count++);
    69b4:	e5842004 	str	r2, [r4, #4]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    69b8:	e3530000 	cmp	r3, #0	; 0x0

        CYG_ASSERT( size > in, "in overflow" );
        CYG_ASSERT( 0 <= in, "in overflow" );
        CYG_ASSERT( size >= count, "count overflow" );

        itemqueue[ in ] = item;
    69bc:	e2812004 	add	r2, r1, #4	; 0x4
    69c0:	e784b102 	str	fp, [r4, r2, lsl #2]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    69c4:	0a000006 	beq	69e4 <_ZN8Cyg_Mbox3putEPv+0xdc>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    69c8:	e2840008 	add	r0, r4, #8	; 0x8
    69cc:	ebfffab9 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    69d0:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    69d4:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    69d8:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    69dc:	e5c01080 	strb	r1, [r0, #128]
        Cyg_Thread *thread = q.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->set_wake_reason( Cyg_Thread::DONE );
        thread->wake();
    69e0:	ebfff609 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    69e4:	e3a04001 	mov	r4, #1	; 0x1
    69e8:	e59a3000 	ldr	r3, [sl]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    69ec:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    69f0:	159f3034 	ldrne	r3, [pc, #52]	; 6a2c <_ZN8Cyg_Mbox3putEPv+0x124>
    69f4:	15830000 	strne	r0, [r3]
    69f8:	1a000007 	bne	6a1c <_ZN8Cyg_Mbox3putEPv+0x114>
    69fc:	ebfffc06 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6a00:	ea000005 	b	6a1c <_ZN8Cyg_Mbox3putEPv+0x114>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_ASSERTCLASS( this, "Bad this pointer");        

        switch( self->get_wake_reason() )
    6a04:	e3a04000 	mov	r4, #0	; 0x0
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6a08:	e59a3000 	ldr	r3, [sl]
    6a0c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6a10:	159f3014 	ldrne	r3, [pc, #20]	; 6a2c <_ZN8Cyg_Mbox3putEPv+0x124>
    6a14:	15830000 	strne	r0, [r3]
    6a18:	0afffff7 	beq	69fc <_ZN8Cyg_Mbox3putEPv+0xf4>
{
    return m.put( item );
}
    6a1c:	e1a00004 	mov	r0, r4
    6a20:	e28dd004 	add	sp, sp, #4	; 0x4
    6a24:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6a28:	40002538 	.word	0x40002538
    6a2c:	400007c8 	.word	0x400007c8

00006a30 <_ZN8Cyg_Mbox3putEPvy>:

#ifdef CYGFUN_KERNEL_THREADS_TIMER
cyg_bool
Cyg_Mbox::put( void *item, cyg_tick_count timeout )
    6a30:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6a34:	e59f7168 	ldr	r7, [pc, #360]	; 6ba4 <_ZN8Cyg_Mbox3putEPvy+0x174>
    6a38:	e24dd00c 	sub	sp, sp, #12	; 0xc
    6a3c:	e1a08000 	mov	r8, r0
    6a40:	e1a0b001 	mov	fp, r1
    6a44:	e5976000 	ldr	r6, [r7]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6a48:	e59f9158 	ldr	r9, [pc, #344]	; 6ba8 <_ZN8Cyg_Mbox3putEPvy+0x178>
    6a4c:	e5991000 	ldr	r1, [r9]
    6a50:	e2811001 	add	r1, r1, #1	; 0x1
    6a54:	e5891000 	str	r1, [r9]
    6a58:	e597e000 	ldr	lr, [r7]
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    6a5c:	e597c000 	ldr	ip, [r7]
    6a60:	e5970000 	ldr	r0, [r7]
    6a64:	e3a01000 	mov	r1, #0	; 0x0
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    6a68:	e3a0a003 	mov	sl, #3	; 0x3
    self()->wake_reason = NONE;
    6a6c:	e5cc1081 	strb	r1, [ip, #129]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    6a70:	e5cea080 	strb	sl, [lr, #128]
    self()->wake_reason = NONE;
    self()->timer.initialize( trigger);
    6a74:	e3a04000 	mov	r4, #0	; 0x0
    6a78:	e3a05000 	mov	r5, #0	; 0x0
    6a7c:	e2800050 	add	r0, r0, #80	; 0x50
    6a80:	e88d0030 	stm	sp, {r4, r5}
    6a84:	eb002119 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>
    
    // Loop while the mboxt is full, sleeping each time around the loop.
    // This copes with the possibility of a higher priority thread filling
    // the empty slot between the wakeup in get()&c and this thread
    // actually starting.
    while ( result && (size == count) ) {
    6a88:	e5d63081 	ldrb	r3, [r6, #129]
    6a8c:	e3530000 	cmp	r3, #0	; 0x0
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    6a90:	01a05003 	moveq	r5, r3
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6a94:	0288400c 	addeq	r4, r8, #12	; 0xc
    6a98:	1a000011 	bne	6ae4 <_ZN8Cyg_Mbox3putEPvy+0xb4>
    6a9c:	e5983004 	ldr	r3, [r8, #4]
    6aa0:	e353000a 	cmp	r3, #10	; 0xa
    6aa4:	1a000020 	bne	6b2c <_ZN8Cyg_Mbox3putEPvy+0xfc>
    6aa8:	e5973000 	ldr	r3, [r7]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6aac:	e5972000 	ldr	r2, [r7]
    6ab0:	e5c3a080 	strb	sl, [r3, #128]
    self()->wake_reason = NONE;
    6ab4:	e5c25081 	strb	r5, [r2, #129]
        // must reset the sleep reason every time
        self->set_sleep_reason( Cyg_Thread::TIMEOUT );
        self->sleep();
    6ab8:	ebfff4d6 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6abc:	e1a00004 	mov	r0, r4
    6ac0:	e1a01006 	mov	r1, r6
    6ac4:	ebfffa6b 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6ac8:	e5990000 	ldr	r0, [r9]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    6acc:	ebfffbd2 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        CYG_ASSERTCLASS( this, "Bad this pointer");        

        switch( self->get_wake_reason() )
    6ad0:	e5d63081 	ldrb	r3, [r6, #129]
    6ad4:	e3530003 	cmp	r3, #3	; 0x3
    6ad8:	3affffef 	bcc	6a9c <_ZN8Cyg_Mbox3putEPvy+0x6c>
    6adc:	e3530005 	cmp	r3, #5	; 0x5
    6ae0:	8a00000b 	bhi	6b14 <_ZN8Cyg_Mbox3putEPvy+0xe4>
    6ae4:	e5970000 	ldr	r0, [r7]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    6ae8:	e2800050 	add	r0, r0, #80	; 0x50
    6aec:	eb002196 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    6af0:	e3a04000 	mov	r4, #0	; 0x0
    6af4:	e5993000 	ldr	r3, [r9]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    6af8:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6afc:	159f30a4 	ldrne	r3, [pc, #164]	; 6ba8 <_ZN8Cyg_Mbox3putEPvy+0x178>
    6b00:	15830000 	strne	r0, [r3]
    6b04:	0a000024 	beq	6b9c <_ZN8Cyg_Mbox3putEPvy+0x16c>
{
    return m.put( item, timeout );
}
    6b08:	e1a00004 	mov	r0, r4
    6b0c:	e28dd00c 	add	sp, sp, #12	; 0xc
    6b10:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6b14:	e3530006 	cmp	r3, #6	; 0x6
    6b18:	1affffdf 	bne	6a9c <_ZN8Cyg_Mbox3putEPvy+0x6c>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    6b1c:	ebfff3d2 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    
    // Loop while the mboxt is full, sleeping each time around the loop.
    // This copes with the possibility of a higher priority thread filling
    // the empty slot between the wakeup in get()&c and this thread
    // actually starting.
    while ( result && (size == count) ) {
    6b20:	e5983004 	ldr	r3, [r8, #4]
    6b24:	e353000a 	cmp	r3, #10	; 0xa
    6b28:	0affffde 	beq	6aa8 <_ZN8Cyg_Mbox3putEPvy+0x78>
    6b2c:	e5970000 	ldr	r0, [r7]
    6b30:	e2800050 	add	r0, r0, #80	; 0x50
    6b34:	eb002184 	bl	f14c <_ZN9Cyg_Alarm7disableEv>

    // clear the timer; if it actually fired, no worries.
    self->clear_timer();

    if ( result ) {
        cyg_count32 in = base + (count++);
    6b38:	e5983004 	ldr	r3, [r8, #4]
    6b3c:	e8980006 	ldm	r8, {r1, r2}
    6b40:	e0822001 	add	r2, r2, r1
    6b44:	e2833001 	add	r3, r3, #1	; 0x1
        if ( size <= in )
    6b48:	e3520009 	cmp	r2, #9	; 0x9

    // clear the timer; if it actually fired, no worries.
    self->clear_timer();

    if ( result ) {
        cyg_count32 in = base + (count++);
    6b4c:	e5883004 	str	r3, [r8, #4]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6b50:	e5983008 	ldr	r3, [r8, #8]
    self->clear_timer();

    if ( result ) {
        cyg_count32 in = base + (count++);
        if ( size <= in )
            in -= size;
    6b54:	c242200a 	subgt	r2, r2, #10	; 0xa

        CYG_ASSERT( size > in, "in overflow" );
        CYG_ASSERT( 0 <= in, "in overflow" );
        CYG_ASSERT( size >= count, "count overflow" );

        itemqueue[ in ] = item;
    6b58:	e2822004 	add	r2, r2, #4	; 0x4

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6b5c:	e3530000 	cmp	r3, #0	; 0x0

        CYG_ASSERT( size > in, "in overflow" );
        CYG_ASSERT( 0 <= in, "in overflow" );
        CYG_ASSERT( size >= count, "count overflow" );

        itemqueue[ in ] = item;
    6b60:	e788b102 	str	fp, [r8, r2, lsl #2]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6b64:	0a000006 	beq	6b84 <_ZN8Cyg_Mbox3putEPvy+0x154>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6b68:	e2880008 	add	r0, r8, #8	; 0x8
    6b6c:	ebfffa51 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    6b70:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6b74:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    6b78:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6b7c:	e5c01080 	strb	r1, [r0, #128]
        Cyg_Thread *thread = q.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->set_wake_reason( Cyg_Thread::DONE );
        thread->wake();
    6b80:	ebfff5a1 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    6b84:	e3a04001 	mov	r4, #1	; 0x1
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6b88:	e5993000 	ldr	r3, [r9]
    6b8c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6b90:	159f3010 	ldrne	r3, [pc, #16]	; 6ba8 <_ZN8Cyg_Mbox3putEPvy+0x178>
    6b94:	15830000 	strne	r0, [r3]
    6b98:	1affffda 	bne	6b08 <_ZN8Cyg_Mbox3putEPvy+0xd8>
    6b9c:	ebfffb9e 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6ba0:	eaffffd8 	b	6b08 <_ZN8Cyg_Mbox3putEPvy+0xd8>
    6ba4:	40002538 	.word	0x40002538
    6ba8:	400007c8 	.word	0x400007c8

00006bac <_ZN8Cyg_Mbox6trygetEv>:
    return p;
}
#endif

void *
Cyg_Mbox::tryget()
    6bac:	e92d4070 	push	{r4, r5, r6, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6bb0:	e59f50ac 	ldr	r5, [pc, #172]	; 6c64 <_ZN8Cyg_Mbox6trygetEv+0xb8>
    6bb4:	e5953000 	ldr	r3, [r5]
    6bb8:	e2833001 	add	r3, r3, #1	; 0x1
    6bbc:	e5853000 	str	r3, [r5]

    CYG_ASSERTCLASS( this, "Bad this pointer");
    
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    6bc0:	e5902004 	ldr	r2, [r0, #4]
    6bc4:	e3520000 	cmp	r2, #0	; 0x0
    6bc8:	d3a04000 	movle	r4, #0	; 0x0
    6bcc:	c3a04001 	movgt	r4, #1	; 0x1
    // If the mboxt is not empty, grab an item and return it.
    if ( result ) {
    6bd0:	e3540000 	cmp	r4, #0	; 0x0
    6bd4:	01a06004 	moveq	r6, r4
    6bd8:	0a000013 	beq	6c2c <_ZN8Cyg_Mbox6trygetEv+0x80>
        ritem = itemqueue[ (count--, base++) ];
    6bdc:	e5903000 	ldr	r3, [r0]
    6be0:	e2831001 	add	r1, r3, #1	; 0x1
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );
        if ( size <= base )
    6be4:	e3510009 	cmp	r1, #9	; 0x9
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    // If the mboxt is not empty, grab an item and return it.
    if ( result ) {
        ritem = itemqueue[ (count--, base++) ];
    6be8:	e2833004 	add	r3, r3, #4	; 0x4
    6bec:	e7906103 	ldr	r6, [r0, r3, lsl #2]
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );
        if ( size <= base )
            base = 0;
    6bf0:	c3a03000 	movgt	r3, #0	; 0x0
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    // If the mboxt is not empty, grab an item and return it.
    if ( result ) {
        ritem = itemqueue[ (count--, base++) ];
    6bf4:	e5801000 	str	r1, [r0]
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );
        if ( size <= base )
            base = 0;
    6bf8:	c5803000 	strgt	r3, [r0]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6bfc:	e590300c 	ldr	r3, [r0, #12]
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    // If the mboxt is not empty, grab an item and return it.
    if ( result ) {
        ritem = itemqueue[ (count--, base++) ];
    6c00:	e2422001 	sub	r2, r2, #1	; 0x1

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6c04:	e3530000 	cmp	r3, #0	; 0x0
    CYG_INSTRUMENT_MBOXT(TRY, this, count);
    
    cyg_bool result = ( 0 < count );
    // If the mboxt is not empty, grab an item and return it.
    if ( result ) {
        ritem = itemqueue[ (count--, base++) ];
    6c08:	e5802004 	str	r2, [r0, #4]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6c0c:	0a000006 	beq	6c2c <_ZN8Cyg_Mbox6trygetEv+0x80>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6c10:	e280000c 	add	r0, r0, #12	; 0xc
    6c14:	ebfffa27 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    6c18:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6c1c:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    6c20:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6c24:	e5c01080 	strb	r1, [r0, #128]
        Cyg_Thread *thread = q.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->set_wake_reason( Cyg_Thread::DONE );
        thread->wake();
    6c28:	ebfff577 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6c2c:	e5953000 	ldr	r3, [r5]
    6c30:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6c34:	159f3028 	ldrne	r3, [pc, #40]	; 6c64 <_ZN8Cyg_Mbox6trygetEv+0xb8>
    6c38:	15830000 	strne	r0, [r3]
    6c3c:	0a000003 	beq	6c50 <_ZN8Cyg_Mbox6trygetEv+0xa4>
{
    void * p=NULL;
    if ( ! m.tryget( p ) )
        return NULL;
    return p;
}
    6c40:	e3540000 	cmp	r4, #0	; 0x0
    6c44:	11a00006 	movne	r0, r6
    6c48:	03a00000 	moveq	r0, #0	; 0x0
    6c4c:	e8bd8070 	pop	{r4, r5, r6, pc}
    6c50:	ebfffb71 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    6c54:	e3540000 	cmp	r4, #0	; 0x0
    6c58:	11a00006 	movne	r0, r6
    6c5c:	03a00000 	moveq	r0, #0	; 0x0
    6c60:	e8bd8070 	pop	{r4, r5, r6, pc}
    6c64:	400007c8 	.word	0x400007c8

00006c68 <_ZN8Cyg_Mbox3getEv>:

// -------------------------------------------------------------------------
// now the members themselves:
    
void *
Cyg_Mbox::get()
    6c68:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    6c6c:	e59f7120 	ldr	r7, [pc, #288]	; 6d94 <_ZN8Cyg_Mbox3getEv+0x12c>
    6c70:	e1a05000 	mov	r5, r0
    6c74:	e5976000 	ldr	r6, [r7]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6c78:	e59f9118 	ldr	r9, [pc, #280]	; 6d98 <_ZN8Cyg_Mbox3getEv+0x130>
    6c7c:	e5993000 	ldr	r3, [r9]
    6c80:	e2833001 	add	r3, r3, #1	; 0x1
    6c84:	e5893000 	str	r3, [r9]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6c88:	e3a0a001 	mov	sl, #1	; 0x1
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6c8c:	e2808008 	add	r8, r0, #8	; 0x8
    // Loop while the mboxt is empty, sleeping each time around
    // the loop. This copes with the possibility of a higher priority
    // thread grabbing the message between the wakeup in unlock() and
    // this thread actually starting.
    
    while( result && (0 == count) ) {
    6c90:	e5954004 	ldr	r4, [r5, #4]
    6c94:	e3540000 	cmp	r4, #0	; 0x0
    6c98:	1a000014 	bne	6cf0 <_ZN8Cyg_Mbox3getEv+0x88>
    6c9c:	e5973000 	ldr	r3, [r7]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    6ca0:	e5972000 	ldr	r2, [r7]
    6ca4:	e5c3a080 	strb	sl, [r3, #128]
    self()->wake_reason = NONE;
    6ca8:	e5c24081 	strb	r4, [r2, #129]
        self->set_sleep_reason( Cyg_Thread::WAIT );
        self->sleep();
    6cac:	ebfff459 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6cb0:	e1a00008 	mov	r0, r8
    6cb4:	e1a01006 	mov	r1, r6
    6cb8:	ebfff9ee 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6cbc:	e5990000 	ldr	r0, [r9]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    6cc0:	ebfffb55 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        CYG_ASSERTCLASS( this, "Bad this pointer");        

        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        switch( self->get_wake_reason() )
    6cc4:	e5d63081 	ldrb	r3, [r6, #129]
    6cc8:	e3530004 	cmp	r3, #4	; 0x4
    6ccc:	3affffef 	bcc	6c90 <_ZN8Cyg_Mbox3getEv+0x28>
    6cd0:	e3530005 	cmp	r3, #5	; 0x5
    6cd4:	9a000024 	bls	6d6c <_ZN8Cyg_Mbox3getEv+0x104>
    6cd8:	e3530006 	cmp	r3, #6	; 0x6
    6cdc:	1affffeb 	bne	6c90 <_ZN8Cyg_Mbox3getEv+0x28>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    6ce0:	ebfff361 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    // Loop while the mboxt is empty, sleeping each time around
    // the loop. This copes with the possibility of a higher priority
    // thread grabbing the message between the wakeup in unlock() and
    // this thread actually starting.
    
    while( result && (0 == count) ) {
    6ce4:	e5954004 	ldr	r4, [r5, #4]
    6ce8:	e3540000 	cmp	r4, #0	; 0x0
    6cec:	0affffea 	beq	6c9c <_ZN8Cyg_Mbox3getEv+0x34>
    }

    if ( result ) {
        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6cf0:	e5953000 	ldr	r3, [r5]
    6cf4:	e2831001 	add	r1, r3, #1	; 0x1
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );

        if ( size <= base )
    6cf8:	e3510009 	cmp	r1, #9	; 0x9
    }

    if ( result ) {
        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6cfc:	e2833004 	add	r3, r3, #4	; 0x4
    6d00:	e7956103 	ldr	r6, [r5, r3, lsl #2]
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );

        if ( size <= base )
            base = 0;
    6d04:	c3a03000 	movgt	r3, #0	; 0x0
    }

    if ( result ) {
        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6d08:	e5851000 	str	r1, [r5]
        CYG_ASSERT( 0 <= count, "Count went -ve" );
        CYG_ASSERT( size >= base, "Base overflow" );

        if ( size <= base )
            base = 0;
    6d0c:	c5853000 	strgt	r3, [r5]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6d10:	e595300c 	ldr	r3, [r5, #12]
    }

    if ( result ) {
        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6d14:	e2442001 	sub	r2, r4, #1	; 0x1

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6d18:	e3530000 	cmp	r3, #0	; 0x0
    }

    if ( result ) {
        CYG_INSTRUMENT_MBOXT(GOT, this, count);
    
        ritem = itemqueue[ (count--, base++) ];
    6d1c:	e5852004 	str	r2, [r5, #4]

template <class T, cyg_count32 QUEUE_SIZE>
inline void
Cyg_Mboxt<T,QUEUE_SIZE>::wakeup_waiter( Cyg_ThreadQueue &q )
{
    if( !q.empty() ) {
    6d20:	0a000006 	beq	6d40 <_ZN8Cyg_Mbox3getEv+0xd8>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    6d24:	e285000c 	add	r0, r5, #12	; 0xc
    6d28:	ebfff9e2 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    6d2c:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6d30:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    6d34:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    6d38:	e5c01080 	strb	r1, [r0, #128]
        Cyg_Thread *thread = q.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->set_wake_reason( Cyg_Thread::DONE );
        thread->wake();
    6d3c:	ebfff532 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    6d40:	e3a04001 	mov	r4, #1	; 0x1
    6d44:	e5993000 	ldr	r3, [r9]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    6d48:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6d4c:	159f3044 	ldrne	r3, [pc, #68]	; 6d98 <_ZN8Cyg_Mbox3getEv+0x130>
    6d50:	15830000 	strne	r0, [r3]
    6d54:	1a00000a 	bne	6d84 <_ZN8Cyg_Mbox3getEv+0x11c>
    6d58:	ebfffb2f 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
{
    void * p=NULL;
    if ( ! m.get( p ) )
        return NULL;
    return p;
}
    6d5c:	e3540000 	cmp	r4, #0	; 0x0
    6d60:	11a00006 	movne	r0, r6
    6d64:	03a00000 	moveq	r0, #0	; 0x0
    6d68:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        CYG_ASSERTCLASS( this, "Bad this pointer");        

        // Allow other threads to run
        Cyg_Scheduler::reschedule();

        switch( self->get_wake_reason() )
    6d6c:	e1a06004 	mov	r6, r4
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6d70:	e5993000 	ldr	r3, [r9]
    6d74:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6d78:	159f3018 	ldrne	r3, [pc, #24]	; 6d98 <_ZN8Cyg_Mbox3getEv+0x130>
    6d7c:	15830000 	strne	r0, [r3]
    6d80:	0afffff4 	beq	6d58 <_ZN8Cyg_Mbox3getEv+0xf0>
    6d84:	e3540000 	cmp	r4, #0	; 0x0
    6d88:	11a00006 	movne	r0, r6
    6d8c:	03a00000 	moveq	r0, #0	; 0x0
    6d90:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    6d94:	40002538 	.word	0x40002538
    6d98:	400007c8 	.word	0x400007c8

00006d9c <_ZN9Cyg_MutexC2Ev>:

public:

    Cyg_CList()
    {
        head = NULL;
    6d9c:	e3a01000 	mov	r1, #0	; 0x0

#if defined(CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT) && \
    defined(CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DYNAMIC)

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_INHERIT
    protocol    = INHERIT;
    6da0:	e3a02001 	mov	r2, #1	; 0x1
    6da4:	e5c0200c 	strb	r2, [r0, #12]
Cyg_Mutex::Cyg_Mutex()
{
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    owner       = NULL;
    6da8:	e5801004 	str	r1, [r0, #4]
    6dac:	e5801008 	str	r1, [r0, #8]

Cyg_Mutex::Cyg_Mutex()
{
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    6db0:	e5c01000 	strb	r1, [r0]
#endif

#endif // DYNAMIC and DEFAULT defined
    
    CYG_REPORT_RETURN();
}
    6db4:	e12fff1e 	bx	lr

00006db8 <_ZN9Cyg_MutexC1Ev>:
    6db8:	e3a01000 	mov	r1, #0	; 0x0

#if defined(CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT) && \
    defined(CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DYNAMIC)

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_INHERIT
    protocol    = INHERIT;
    6dbc:	e3a02001 	mov	r2, #1	; 0x1
    6dc0:	e5c0200c 	strb	r2, [r0, #12]
Cyg_Mutex::Cyg_Mutex()
{
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    owner       = NULL;
    6dc4:	e5801004 	str	r1, [r0, #4]
    6dc8:	e5801008 	str	r1, [r0, #8]

Cyg_Mutex::Cyg_Mutex()
{
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    6dcc:	e5c01000 	strb	r1, [r0]
#endif

#endif // DYNAMIC and DEFAULT defined
    
    CYG_REPORT_RETURN();
}
    6dd0:	e12fff1e 	bx	lr

00006dd4 <_ZN9Cyg_MutexC2ENS_11cyg_protcolE>:
    6dd4:	e3a02000 	mov	r2, #0	; 0x0
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY

    // if there is a default priority ceiling defined, use that to initialize
    // the ceiling.
    ceiling = CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY;    
    6dd8:	e5802010 	str	r2, [r0, #16]
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    owner       = NULL;

    protocol    = protocol_arg;
    6ddc:	e5c0100c 	strb	r1, [r0, #12]
    6de0:	e5802008 	str	r2, [r0, #8]

Cyg_Mutex::Cyg_Mutex( cyg_protcol protocol_arg )
{
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    6de4:	e5c02000 	strb	r2, [r0]
    owner       = NULL;
    6de8:	e5802004 	str	r2, [r0, #4]
    
#endif    
#endif
    
    CYG_REPORT_RETURN();
}
    6dec:	e12fff1e 	bx	lr

00006df0 <_ZN9Cyg_MutexC1ENS_11cyg_protcolE>:
    6df0:	e3a02000 	mov	r2, #0	; 0x0
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY

    // if there is a default priority ceiling defined, use that to initialize
    // the ceiling.
    ceiling = CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY;    
    6df4:	e5802010 	str	r2, [r0, #16]
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    owner       = NULL;

    protocol    = protocol_arg;
    6df8:	e5c0100c 	strb	r1, [r0, #12]
    6dfc:	e5802008 	str	r2, [r0, #8]

Cyg_Mutex::Cyg_Mutex( cyg_protcol protocol_arg )
{
    CYG_REPORT_FUNCTION();
        
    locked      = false;
    6e00:	e5c02000 	strb	r2, [r0]
    owner       = NULL;
    6e04:	e5802004 	str	r2, [r0, #4]
    
#endif    
#endif
    
    CYG_REPORT_RETURN();
}
    6e08:	e12fff1e 	bx	lr

00006e0c <_ZN9Cyg_MutexD2Ev>:
#endif

// -------------------------------------------------------------------------
// Destructor

Cyg_Mutex::~Cyg_Mutex()
    6e0c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    6e10:	e3a04000 	mov	r4, #0	; 0x0
    6e14:	ea000009 	b	6e40 <_ZN9Cyg_MutexD2Ev+0x34>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    6e18:	e591c000 	ldr	ip, [r1]
            if( next == node )
    6e1c:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    6e20:	15913004 	ldrne	r3, [r1, #4]
    6e24:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    6e28:	15912004 	ldrne	r2, [r1, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    6e2c:	05804008 	streq	r4, [r0, #8]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6e30:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6e34:	15811004 	strne	r1, [r1, #4]
    6e38:	15811000 	strne	r1, [r1]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    6e3c:	1580c008 	strne	ip, [r0, #8]
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    6e40:	e5901008 	ldr	r1, [r0, #8]
    6e44:	e3510000 	cmp	r1, #0	; 0x0
    6e48:	1afffff2 	bne	6e18 <_ZN9Cyg_MutexD2Ev+0xc>
    CYG_REPORT_FUNCTION();
        
    CYG_ASSERT( owner == NULL, "Deleting mutex with owner");
    CYG_ASSERT( queue.empty(), "Deleting mutex with waiting threads");
    CYG_REPORT_RETURN();
}
    6e4c:	e8bd0010 	pop	{r4}
    6e50:	e12fff1e 	bx	lr

00006e54 <_ZN9Cyg_MutexD1Ev>:
#endif

// -------------------------------------------------------------------------
// Destructor

Cyg_Mutex::~Cyg_Mutex()
    6e54:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    6e58:	e3a04000 	mov	r4, #0	; 0x0
    6e5c:	ea000009 	b	6e88 <_ZN9Cyg_MutexD1Ev+0x34>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    6e60:	e591c000 	ldr	ip, [r1]
            if( next == node )
    6e64:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    6e68:	15913004 	ldrne	r3, [r1, #4]
    6e6c:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    6e70:	15912004 	ldrne	r2, [r1, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    6e74:	05804008 	streq	r4, [r0, #8]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6e78:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6e7c:	15811004 	strne	r1, [r1, #4]
    6e80:	15811000 	strne	r1, [r1]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    6e84:	1580c008 	strne	ip, [r0, #8]
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    6e88:	e5901008 	ldr	r1, [r0, #8]
    6e8c:	e3510000 	cmp	r1, #0	; 0x0
    6e90:	1afffff2 	bne	6e60 <_ZN9Cyg_MutexD1Ev+0xc>
    CYG_REPORT_FUNCTION();
        
    CYG_ASSERT( owner == NULL, "Deleting mutex with owner");
    CYG_ASSERT( queue.empty(), "Deleting mutex with waiting threads");
    CYG_REPORT_RETURN();
}
    6e94:	e8bd0010 	pop	{r4}
    6e98:	e12fff1e 	bx	lr

00006e9c <_ZN22Cyg_Condition_VariableC2ER9Cyg_Mutex>:

public:

    Cyg_CList()
    {
        head = NULL;
    6e9c:	e3a03000 	mov	r3, #0	; 0x0
    Cyg_Mutex   &mx                // linked mutex
    )
{
    CYG_REPORT_FUNCTION();
        
    mutex       = &mx;
    6ea0:	e880000a 	stm	r0, {r1, r3}

    CYG_ASSERTCLASS( mutex, "Invalid mutex argument");

    CYG_REPORT_RETURN();
}
    6ea4:	e12fff1e 	bx	lr

00006ea8 <_ZN22Cyg_Condition_VariableC1ER9Cyg_Mutex>:
    6ea8:	e3a03000 	mov	r3, #0	; 0x0
    Cyg_Mutex   &mx                // linked mutex
    )
{
    CYG_REPORT_FUNCTION();
        
    mutex       = &mx;
    6eac:	e880000a 	stm	r0, {r1, r3}

    CYG_ASSERTCLASS( mutex, "Invalid mutex argument");

    CYG_REPORT_RETURN();
}
    6eb0:	e12fff1e 	bx	lr

00006eb4 <_ZN22Cyg_Condition_VariableC2Ev>:
    6eb4:	e3a03000 	mov	r3, #0	; 0x0

Cyg_Condition_Variable::Cyg_Condition_Variable()
{
    CYG_REPORT_FUNCTION();
        
    mutex       = NULL;
    6eb8:	e5803000 	str	r3, [r0]
    6ebc:	e5803004 	str	r3, [r0, #4]

    CYG_REPORT_RETURN();
}
    6ec0:	e12fff1e 	bx	lr

00006ec4 <_ZN22Cyg_Condition_VariableC1Ev>:
    6ec4:	e3a03000 	mov	r3, #0	; 0x0

Cyg_Condition_Variable::Cyg_Condition_Variable()
{
    CYG_REPORT_FUNCTION();
        
    mutex       = NULL;
    6ec8:	e5803000 	str	r3, [r0]
    6ecc:	e5803004 	str	r3, [r0, #4]

    CYG_REPORT_RETURN();
}
    6ed0:	e12fff1e 	bx	lr

00006ed4 <_ZN22Cyg_Condition_VariableD2Ev>:

// -------------------------------------------------------------------------
// Destructor

Cyg_Condition_Variable::~Cyg_Condition_Variable()
    6ed4:	e5901004 	ldr	r1, [r0, #4]
    6ed8:	ea000009 	b	6f04 <_ZN22Cyg_Condition_VariableD2Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    6edc:	e591c000 	ldr	ip, [r1]
            if( next == node )
    6ee0:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    6ee4:	15913004 	ldrne	r3, [r1, #4]
    6ee8:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    6eec:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    6ef0:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6ef4:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6ef8:	15811004 	strne	r1, [r1, #4]
    6efc:	15811000 	strne	r1, [r1]
    6f00:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    6f04:	e3510000 	cmp	r1, #0	; 0x0
    6f08:	1afffff3 	bne	6edc <_ZN22Cyg_Condition_VariableD2Ev+0x8>
    CYG_REPORT_FUNCTION();
        
    CYG_ASSERT( queue.empty(), "Deleting condvar with waiting threads");

    CYG_REPORT_RETURN();
}
    6f0c:	e5801004 	str	r1, [r0, #4]
    6f10:	e12fff1e 	bx	lr

00006f14 <_ZN22Cyg_Condition_VariableD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor

Cyg_Condition_Variable::~Cyg_Condition_Variable()
    6f14:	e5901004 	ldr	r1, [r0, #4]
    6f18:	ea000009 	b	6f44 <_ZN22Cyg_Condition_VariableD1Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    6f1c:	e591c000 	ldr	ip, [r1]
            if( next == node )
    6f20:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    6f24:	15913004 	ldrne	r3, [r1, #4]
    6f28:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    6f2c:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    6f30:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    6f34:	1582c000 	strne	ip, [r2]
        next = prev = this;
    6f38:	15811004 	strne	r1, [r1, #4]
    6f3c:	15811000 	strne	r1, [r1]
    6f40:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    6f44:	e3510000 	cmp	r1, #0	; 0x0
    6f48:	1afffff3 	bne	6f1c <_ZN22Cyg_Condition_VariableD1Ev+0x8>
    CYG_REPORT_FUNCTION();
        
    CYG_ASSERT( queue.empty(), "Deleting condvar with waiting threads");

    CYG_REPORT_RETURN();
}
    6f4c:	e5801004 	str	r1, [r0, #4]
    6f50:	e12fff1e 	bx	lr

00006f54 <_ZN9Cyg_Mutex4lockEv>:

// -------------------------------------------------------------------------
// Lock and/or wait

cyg_bool
Cyg_Mutex::lock(void)
    6f54:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6f58:	e59f8170 	ldr	r8, [pc, #368]	; 70d0 <_ZN9Cyg_Mutex4lockEv+0x17c>
    6f5c:	e24dd004 	sub	sp, sp, #4	; 0x4
    6f60:	e1a04000 	mov	r4, r0
    6f64:	e5985000 	ldr	r5, [r8]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    6f68:	e59f7164 	ldr	r7, [pc, #356]	; 70d4 <_ZN9Cyg_Mutex4lockEv+0x180>
    6f6c:	e5973000 	ldr	r3, [r7]
    6f70:	e2833001 	add	r3, r3, #1	; 0x1
    6f74:	e5873000 	str	r3, [r7]
    // thread grabbing the mutex between the wakeup in unlock() and
    // this thread actually starting.
    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

    IF_PROTOCOL_ACTIVE
    6f78:	e5d0200c 	ldrb	r2, [r0, #12]
    6f7c:	e3520000 	cmp	r2, #0	; 0x0
    6f80:	0a000004 	beq	6f98 <_ZN9Cyg_Mutex4lockEv+0x44>
    void clear_inherited_priority();
    
public:    
    // Count and uncount the number of mutexes held by
    // this thread.
    void count_mutex() { mutex_count++; };
    6f84:	e5953030 	ldr	r3, [r5, #48]

#endif

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
    
    IF_PROTOCOL_CEILING
    6f88:	e3520002 	cmp	r2, #2	; 0x2
    6f8c:	e2833001 	add	r3, r3, #1	; 0x1
    6f90:	e5853030 	str	r3, [r5, #48]
    6f94:	0a000042 	beq	70a4 <_ZN9Cyg_Mutex4lockEv+0x150>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    6f98:	e284a008 	add	sl, r4, #8	; 0x8
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    6f9c:	e3a0b001 	mov	fp, #1	; 0x1
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    6fa0:	e3a09000 	mov	r9, #0	; 0x0
    6fa4:	e3a06001 	mov	r6, #1	; 0x1
    IF_PROTOCOL_CEILING
        self->set_priority_ceiling(ceiling);

#endif        
               
    while( locked && result )
    6fa8:	e5d43000 	ldrb	r3, [r4]
    6fac:	e3530000 	cmp	r3, #0	; 0x0
    6fb0:	1a00000c 	bne	6fe8 <_ZN9Cyg_Mutex4lockEv+0x94>
            break;
        }

    }

    if( result )
    6fb4:	e3560000 	cmp	r6, #0	; 0x0
    {
        locked      = true;
    6fb8:	13a03001 	movne	r3, #1	; 0x1
        owner       = self;
    6fbc:	15845004 	strne	r5, [r4, #4]

    }

    if( result )
    {
        locked      = true;
    6fc0:	15c43000 	strbne	r3, [r4]
            break;
        }

    }

    if( result )
    6fc4:	0a000009 	beq	6ff0 <_ZN9Cyg_Mutex4lockEv+0x9c>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    6fc8:	e5973000 	ldr	r3, [r7]
    6fcc:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    6fd0:	159f30fc 	ldrne	r3, [pc, #252]	; 70d4 <_ZN9Cyg_Mutex4lockEv+0x180>
    6fd4:	15830000 	strne	r0, [r3]
    6fd8:	0a000015 	beq	7034 <_ZN9Cyg_Mutex4lockEv+0xe0>
    CYG_ASSERTCLASS( this, "Bad this pointer");    

    CYG_REPORT_RETVAL(result);

    return result;
}
    6fdc:	e1a00006 	mov	r0, r6
    6fe0:	e28dd004 	add	sp, sp, #4	; 0x4
    6fe4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    IF_PROTOCOL_CEILING
        self->set_priority_ceiling(ceiling);

#endif        
               
    while( locked && result )
    6fe8:	e3560000 	cmp	r6, #0	; 0x0
    6fec:	1a000012 	bne	703c <_ZN9Cyg_Mutex4lockEv+0xe8>
    }
    else
    {
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

       IF_PROTOCOL_ACTIVE
    6ff0:	e5d4200c 	ldrb	r2, [r4, #12]
    6ff4:	e3520000 	cmp	r2, #0	; 0x0
    6ff8:	0afffff2 	beq	6fc8 <_ZN9Cyg_Mutex4lockEv+0x74>
    void uncount_mutex() { mutex_count--; };
    6ffc:	e5953030 	ldr	r3, [r5, #48]
           self->uncount_mutex();

#endif    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT

        IF_PROTOCOL_INHERIT
    7000:	e3520001 	cmp	r2, #1	; 0x1
    7004:	e2433001 	sub	r3, r3, #1	; 0x1
    7008:	e5853030 	str	r3, [r5, #48]
    700c:	0a00002b 	beq	70c0 <_ZN9Cyg_Mutex4lockEv+0x16c>
            self->disinherit_priority();

#endif
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

        IF_PROTOCOL_CEILING
    7010:	e3520002 	cmp	r2, #2	; 0x2
    7014:	1affffeb 	bne	6fc8 <_ZN9Cyg_Mutex4lockEv+0x74>
            self->clear_priority_ceiling();
    7018:	e285001c 	add	r0, r5, #28	; 0x1c
    701c:	ebfffa3f 	bl	5920 <_ZN15Cyg_SchedThread22clear_priority_ceilingEv>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    7020:	e5973000 	ldr	r3, [r7]
    7024:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    7028:	159f30a4 	ldrne	r3, [pc, #164]	; 70d4 <_ZN9Cyg_Mutex4lockEv+0x180>
    702c:	15830000 	strne	r0, [r3]
    7030:	1affffe9 	bne	6fdc <_ZN9Cyg_Mutex4lockEv+0x88>
    7034:	ebfffa78 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    7038:	eaffffe7 	b	6fdc <_ZN9Cyg_Mutex4lockEv+0x88>
// -------------------------------------------------------------------------
// Simple inline accessor functions

inline Cyg_Thread *Cyg_Scheduler_Base::get_current_thread()
{
    return current_thread[CYG_KERNEL_CPU_THIS()];
    703c:	e5983000 	ldr	r3, [r8]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    7040:	e5982000 	ldr	r2, [r8]
    7044:	e5c3b080 	strb	fp, [r3, #128]
    self()->wake_reason = NONE;
    7048:	e5c29081 	strb	r9, [r2, #129]
    {
        CYG_ASSERT( self != owner, "Locking mutex I already own");
        
        self->set_sleep_reason( Cyg_Thread::WAIT );
        
        self->sleep();
    704c:	ebfff371 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    7050:	e1a0000a 	mov	r0, sl
    7054:	e1a01005 	mov	r1, r5
    7058:	ebfff906 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        
        queue.enqueue( self );

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT

        IF_PROTOCOL_INHERIT
    705c:	e5d4300c 	ldrb	r3, [r4, #12]
    7060:	e3530001 	cmp	r3, #1	; 0x1
            owner->inherit_priority(self);
    7064:	05940004 	ldreq	r0, [r4, #4]
    7068:	01a01005 	moveq	r1, r5
    706c:	0280001c 	addeq	r0, r0, #28	; 0x1c
    7070:	0bfffa3d 	bleq	596c <_ZN15Cyg_SchedThread16inherit_priorityEP10Cyg_Thread>
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    7074:	e5970000 	ldr	r0, [r7]
    // leave a brief window between the calls when the lock is unclaimed
    // by the current thread.
    
    CYG_INSTRUMENT_SCHED(RESCHEDULE,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() );
    7078:	ebfffa67 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
        // Allow other threads to run
        Cyg_Scheduler::reschedule();
        
        CYG_ASSERTCLASS( this, "Bad this pointer");

        switch( self->get_wake_reason() )
    707c:	e5d53081 	ldrb	r3, [r5, #129]
    7080:	e3530004 	cmp	r3, #4	; 0x4
    7084:	3affffc7 	bcc	6fa8 <_ZN9Cyg_Mutex4lockEv+0x54>
    7088:	e3530005 	cmp	r3, #5	; 0x5
    708c:	93a06000 	movls	r6, #0	; 0x0
    7090:	9affffc4 	bls	6fa8 <_ZN9Cyg_Mutex4lockEv+0x54>
    7094:	e3530006 	cmp	r3, #6	; 0x6
    7098:	1affffc2 	bne	6fa8 <_ZN9Cyg_Mutex4lockEv+0x54>
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    709c:	ebfff272 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    70a0:	eaffffbf 	b	6fa4 <_ZN9Cyg_Mutex4lockEv+0x50>
#endif

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
    
    IF_PROTOCOL_CEILING
        self->set_priority_ceiling(ceiling);
    70a4:	e285001c 	add	r0, r5, #28	; 0x1c
    70a8:	e5941010 	ldr	r1, [r4, #16]
    70ac:	ebfffa2c 	bl	5964 <_ZN15Cyg_SchedThread20set_priority_ceilingEi>
    70b0:	e284a008 	add	sl, r4, #8	; 0x8
        case Cyg_Thread::BREAK:
            result = false;
            break;
            
        case Cyg_Thread::EXIT:            
            self->exit();
    70b4:	e3a0b001 	mov	fp, #1	; 0x1
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    self()->wake_reason = NONE;
    70b8:	e3a09000 	mov	r9, #0	; 0x0
    70bc:	eaffffb8 	b	6fa4 <_ZN9Cyg_Mutex4lockEv+0x50>

#endif    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT

        IF_PROTOCOL_INHERIT
            self->disinherit_priority();
    70c0:	e285001c 	add	r0, r5, #28	; 0x1c
    70c4:	ebfffa16 	bl	5924 <_ZN15Cyg_SchedThread19disinherit_priorityEv>
    70c8:	e5d4200c 	ldrb	r2, [r4, #12]
    70cc:	eaffffcf 	b	7010 <_ZN9Cyg_Mutex4lockEv+0xbc>
    70d0:	40002538 	.word	0x40002538
    70d4:	400007c8 	.word	0x400007c8

000070d8 <_ZN9Cyg_Mutex7trylockEv>:

// -------------------------------------------------------------------------
// Try to lock and return success

cyg_bool
Cyg_Mutex::trylock(void)
    70d8:	e92d4030 	push	{r4, r5, lr}
    70dc:	e1a02000 	mov	r2, r0
    70e0:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    70e4:	e59f5088 	ldr	r5, [pc, #136]	; 7174 <_ZN9Cyg_Mutex7trylockEv+0x9c>
    70e8:	e5953000 	ldr	r3, [r5]
    70ec:	e2833001 	add	r3, r3, #1	; 0x1
    70f0:	e5853000 	str	r3, [r5]
    // Prevent preemption
    Cyg_Scheduler::lock();

    // If the mutex is not locked, grab it
    // for ourself. Otherwise return failure.
    if( !locked )
    70f4:	e5d03000 	ldrb	r3, [r0]
    70f8:	e3530000 	cmp	r3, #0	; 0x0
    70fc:	13a04000 	movne	r4, #0	; 0x0
    7100:	1a00000d 	bne	713c <_ZN9Cyg_Mutex7trylockEv+0x64>
    7104:	e59f306c 	ldr	r3, [pc, #108]	; 7178 <_ZN9Cyg_Mutex7trylockEv+0xa0>
        locked  = true;
        owner   = self;

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

       IF_PROTOCOL_ACTIVE
    7108:	e5d0100c 	ldrb	r1, [r0, #12]
    710c:	e5930000 	ldr	r0, [r3]
    // for ourself. Otherwise return failure.
    if( !locked )
    {
        Cyg_Thread *self = Cyg_Thread::self();
        
        locked  = true;
    7110:	e3a04001 	mov	r4, #1	; 0x1
        owner   = self;

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

       IF_PROTOCOL_ACTIVE
    7114:	e3510000 	cmp	r1, #0	; 0x0
    // for ourself. Otherwise return failure.
    if( !locked )
    {
        Cyg_Thread *self = Cyg_Thread::self();
        
        locked  = true;
    7118:	e5c24000 	strb	r4, [r2]
        owner   = self;
    711c:	e5820004 	str	r0, [r2, #4]

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

       IF_PROTOCOL_ACTIVE
    7120:	0a000004 	beq	7138 <_ZN9Cyg_Mutex7trylockEv+0x60>
    void clear_inherited_priority();
    
public:    
    // Count and uncount the number of mutexes held by
    // this thread.
    void count_mutex() { mutex_count++; };
    7124:	e5903030 	ldr	r3, [r0, #48]
            self->count_mutex();

#endif
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

        IF_PROTOCOL_CEILING
    7128:	e3510002 	cmp	r1, #2	; 0x2
    712c:	e0833004 	add	r3, r3, r4
    7130:	e5803030 	str	r3, [r0, #48]
    7134:	0a00000a 	beq	7164 <_ZN9Cyg_Mutex7trylockEv+0x8c>
            self->set_priority_ceiling(ceiling);
    7138:	e3a04001 	mov	r4, #1	; 0x1
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    713c:	e5953000 	ldr	r3, [r5]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    7140:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    7144:	159f3028 	ldrne	r3, [pc, #40]	; 7174 <_ZN9Cyg_Mutex7trylockEv+0x9c>
    7148:	15830000 	strne	r0, [r3]
    714c:	0a000002 	beq	715c <_ZN9Cyg_Mutex7trylockEv+0x84>
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();
    
    CYG_REPORT_RETVAL(result);
    return result;    
}
    7150:	e1a00004 	mov	r0, r4
    7154:	e28dd004 	add	sp, sp, #4	; 0x4
    7158:	e8bd8030 	pop	{r4, r5, pc}
    715c:	ebfffa2e 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    7160:	eafffffa 	b	7150 <_ZN9Cyg_Mutex7trylockEv+0x78>

#endif
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

        IF_PROTOCOL_CEILING
            self->set_priority_ceiling(ceiling);
    7164:	e280001c 	add	r0, r0, #28	; 0x1c
    7168:	e5921010 	ldr	r1, [r2, #16]
    716c:	ebfff9fc 	bl	5964 <_ZN15Cyg_SchedThread20set_priority_ceilingEi>
    7170:	eafffff1 	b	713c <_ZN9Cyg_Mutex7trylockEv+0x64>
    7174:	400007c8 	.word	0x400007c8
    7178:	40002538 	.word	0x40002538

0000717c <_ZN9Cyg_Mutex12set_protocolENS_11cyg_protcolE>:

// -------------------------------------------------------------------------
// Set priority inversion protocol

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DYNAMIC
void Cyg_Mutex::set_protocol( cyg_protcol new_protocol )
    717c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    7180:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    7184:	e59f202c 	ldr	r2, [pc, #44]	; 71b8 <_ZN9Cyg_Mutex12set_protocolENS_11cyg_protcolE+0x3c>
    7188:	e5923000 	ldr	r3, [r2]
    718c:	e2833001 	add	r3, r3, #1	; 0x1
    7190:	e5823000 	str	r3, [r2]
    CYG_REPORT_FUNCTION();

    // Prevent preemption
    Cyg_Scheduler::lock();
    
    protocol = new_protocol;
    7194:	e5c0100c 	strb	r1, [r0, #12]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    7198:	e5923000 	ldr	r3, [r2]
    719c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    71a0:	15820000 	strne	r0, [r2]
    71a4:	0a000001 	beq	71b0 <_ZN9Cyg_Mutex12set_protocolENS_11cyg_protcolE+0x34>
    
    // Unlock the scheduler
    Cyg_Scheduler::unlock();
    
    CYG_REPORT_RETURN();    
}
    71a8:	e28dd004 	add	sp, sp, #4	; 0x4
    71ac:	e8bd8000 	pop	{pc}
    71b0:	ebfffa19 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    71b4:	eafffffb 	b	71a8 <_ZN9Cyg_Mutex12set_protocolENS_11cyg_protcolE+0x2c>
    71b8:	400007c8 	.word	0x400007c8

000071bc <_ZN9Cyg_Mutex11set_ceilingEi>:
// -------------------------------------------------------------------------
// Set ceiling priority for priority ceiling protocol

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

void Cyg_Mutex::set_ceiling( cyg_priority priority )
    71bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    71c0:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    71c4:	e59f202c 	ldr	r2, [pc, #44]	; 71f8 <_ZN9Cyg_Mutex11set_ceilingEi+0x3c>
    71c8:	e5923000 	ldr	r3, [r2]
    71cc:	e2833001 	add	r3, r3, #1	; 0x1
    71d0:	e5823000 	str	r3, [r2]
//    CYG_ASSERT( priority <=  CYG_THREAD_MIN_PRIORITY, "Priority out of range");
    
    // Prevent preemption
    Cyg_Scheduler::lock();

    ceiling = priority;
    71d4:	e5801010 	str	r1, [r0, #16]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    71d8:	e5923000 	ldr	r3, [r2]
    71dc:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    71e0:	15820000 	strne	r0, [r2]
    71e4:	0a000001 	beq	71f0 <_ZN9Cyg_Mutex11set_ceilingEi+0x34>
    
    // Unlock the scheduler
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();    
}
    71e8:	e28dd004 	add	sp, sp, #4	; 0x4
    71ec:	e8bd8000 	pop	{pc}
    71f0:	ebfffa09 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    71f4:	eafffffb 	b	71e8 <_ZN9Cyg_Mutex11set_ceilingEi+0x2c>
    71f8:	400007c8 	.word	0x400007c8

000071fc <_ZN22Cyg_Condition_Variable9broadcastEv>:

// -------------------------------------------------------------------------
// Set cond true, wake all threads

void
Cyg_Condition_Variable::broadcast(void)
    71fc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    7200:	e1a04000 	mov	r4, r0
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    7204:	e59f8060 	ldr	r8, [pc, #96]	; 726c <_ZN22Cyg_Condition_Variable9broadcastEv+0x70>
    7208:	e5983000 	ldr	r3, [r8]
    720c:	e2833001 	add	r3, r3, #1	; 0x1
    7210:	e5883000 	str	r3, [r8]
    CYG_INSTRUMENT_CONDVAR(BROADCAST, this, 0);
    
    // Grab all the threads from the queue and let them
    // go.
    
    while( !queue.empty() )
    7214:	e5903004 	ldr	r3, [r0, #4]
    7218:	e3530000 	cmp	r3, #0	; 0x0
    721c:	0a00000a 	beq	724c <_ZN22Cyg_Condition_Variable9broadcastEv+0x50>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    7220:	e2805004 	add	r5, r0, #4	; 0x4

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    7224:	e3a07000 	mov	r7, #0	; 0x0
    wake_reason = reason;
    7228:	e3a06007 	mov	r6, #7	; 0x7

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    722c:	e1a00005 	mov	r0, r5
    7230:	ebfff8a0 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    7234:	e5c06081 	strb	r6, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    7238:	e5c07080 	strb	r7, [r0, #128]

        CYG_ASSERTCLASS( thread, "Bad thread pointer");
        
        thread->set_wake_reason( Cyg_Thread::DONE );
        
        thread->wake();
    723c:	ebfff3f2 	bl	420c <_ZN10Cyg_Thread4wakeEv>
    CYG_INSTRUMENT_CONDVAR(BROADCAST, this, 0);
    
    // Grab all the threads from the queue and let them
    // go.
    
    while( !queue.empty() )
    7240:	e5943004 	ldr	r3, [r4, #4]
    7244:	e3530000 	cmp	r3, #0	; 0x0
    7248:	1afffff7 	bne	722c <_ZN22Cyg_Condition_Variable9broadcastEv+0x30>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    724c:	e5983000 	ldr	r3, [r8]
    7250:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    7254:	159f3010 	ldrne	r3, [pc, #16]	; 726c <_ZN22Cyg_Condition_Variable9broadcastEv+0x70>
    7258:	15830000 	strne	r0, [r3]
    725c:	0a000000 	beq	7264 <_ZN22Cyg_Condition_Variable9broadcastEv+0x68>
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();    

    CYG_REPORT_RETURN();
}
    7260:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    7264:	ebfff9ec 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    7268:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    726c:	400007c8 	.word	0x400007c8

00007270 <_ZN22Cyg_Condition_Variable6signalEv>:

// -------------------------------------------------------------------------
// Wake one thread

void
Cyg_Condition_Variable::signal(void)
    7270:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    7274:	e59f4050 	ldr	r4, [pc, #80]	; 72cc <_ZN22Cyg_Condition_Variable6signalEv+0x5c>
    7278:	e5943000 	ldr	r3, [r4]
    727c:	e2833001 	add	r3, r3, #1	; 0x1
    7280:	e5843000 	str	r3, [r4]
    // Prevent preemption
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_CONDVAR(SIGNAL, this, 0);
    
    if( !queue.empty() )
    7284:	e5903004 	ldr	r3, [r0, #4]
    7288:	e3530000 	cmp	r3, #0	; 0x0
    728c:	0a000006 	beq	72ac <_ZN22Cyg_Condition_Variable6signalEv+0x3c>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    7290:	e2800004 	add	r0, r0, #4	; 0x4
    7294:	ebfff887 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    7298:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    729c:	e3a01000 	mov	r1, #0	; 0x0
    wake_reason = reason;
    72a0:	e5c02081 	strb	r2, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    72a4:	e5c01080 	strb	r1, [r0, #128]

        CYG_ASSERTCLASS( thread, "Bad thread pointer");
        
        thread->set_wake_reason( Cyg_Thread::DONE );
        
        thread->wake();
    72a8:	ebfff3d7 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    72ac:	e5943000 	ldr	r3, [r4]
    72b0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    72b4:	159f3010 	ldrne	r3, [pc, #16]	; 72cc <_ZN22Cyg_Condition_Variable6signalEv+0x5c>
    72b8:	15830000 	strne	r0, [r3]
    72bc:	0a000000 	beq	72c4 <_ZN22Cyg_Condition_Variable6signalEv+0x54>

    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    72c0:	e8bd8010 	pop	{r4, pc}
    72c4:	ebfff9d4 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    72c8:	e8bd8010 	pop	{r4, pc}
    72cc:	400007c8 	.word	0x400007c8

000072d0 <_ZN9Cyg_Mutex7releaseEv>:
}

// -------------------------------------------------------------------------
// Release all waiting threads.

void Cyg_Mutex::release()
    72d0:	e92d4070 	push	{r4, r5, r6, lr}
    72d4:	e1a05000 	mov	r5, r0
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    72d8:	e59f6050 	ldr	r6, [pc, #80]	; 7330 <_ZN9Cyg_Mutex7releaseEv+0x60>
    72dc:	e5963000 	ldr	r3, [r6]
    72e0:	e2833001 	add	r3, r3, #1	; 0x1
    72e4:	e5863000 	str	r3, [r6]

    CYG_INSTRUMENT_MUTEX(RELEASE, this, 0);

    CYG_ASSERTCLASS( this, "Bad this pointer");
        
    while( !queue.empty() )
    72e8:	e5903008 	ldr	r3, [r0, #8]
    72ec:	e3530000 	cmp	r3, #0	; 0x0
    72f0:	0a000006 	beq	7310 <_ZN9Cyg_Mutex7releaseEv+0x40>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    72f4:	e2804008 	add	r4, r0, #8	; 0x8
    72f8:	e1a00004 	mov	r0, r4
    72fc:	ebfff86d 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>

        Cyg_Thread *thread = queue.dequeue();

        CYG_ASSERTCLASS( thread, "Bad thread pointer");

        thread->release();
    7300:	ebfff5e1 	bl	4a8c <_ZN10Cyg_Thread7releaseEv>

    CYG_INSTRUMENT_MUTEX(RELEASE, this, 0);

    CYG_ASSERTCLASS( this, "Bad this pointer");
        
    while( !queue.empty() )
    7304:	e5953008 	ldr	r3, [r5, #8]
    7308:	e3530000 	cmp	r3, #0	; 0x0
    730c:	1afffff9 	bne	72f8 <_ZN9Cyg_Mutex7releaseEv+0x28>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    7310:	e5963000 	ldr	r3, [r6]
    7314:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    7318:	159f3010 	ldrne	r3, [pc, #16]	; 7330 <_ZN9Cyg_Mutex7releaseEv+0x60>
    731c:	15830000 	strne	r0, [r3]
    7320:	0a000000 	beq	7328 <_ZN9Cyg_Mutex7releaseEv+0x58>
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    7324:	e8bd8070 	pop	{r4, r5, r6, pc}
    7328:	ebfff9bb 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    732c:	e8bd8070 	pop	{r4, r5, r6, pc}
    7330:	400007c8 	.word	0x400007c8

00007334 <_ZN9Cyg_Mutex6unlockEv>:

// -------------------------------------------------------------------------
// unlock

void
Cyg_Mutex::unlock(void)
    7334:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    7338:	e1a04000 	mov	r4, r0
    733c:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    7340:	e59f70e0 	ldr	r7, [pc, #224]	; 7428 <_ZN9Cyg_Mutex6unlockEv+0xf4>
    7344:	e5973000 	ldr	r3, [r7]
    7348:	e2833001 	add	r3, r3, #1	; 0x1
    734c:	e5873000 	str	r3, [r7]

    CYG_ASSERTCLASS( this, "Bad this pointer");
    CYG_ASSERT( locked, "Unlock mutex that is not locked");
    CYG_ASSERT( owner == Cyg_Thread::self(), "Unlock mutex I do not own");
        
    if( !queue.empty() ) {
    7350:	e5903008 	ldr	r3, [r0, #8]
    7354:	e3530000 	cmp	r3, #0	; 0x0
    7358:	0a00000c 	beq	7390 <_ZN9Cyg_Mutex6unlockEv+0x5c>
    735c:	e2806008 	add	r6, r0, #8	; 0x8
    7360:	e1a00006 	mov	r0, r6
    7364:	ebfff853 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT

        // Give the owner-to-be a chance to inherit from the remaining
        // queue or the relinquishing thread:

        IF_PROTOCOL_INHERIT
    7368:	e5d4300c 	ldrb	r3, [r4, #12]
    736c:	e3530001 	cmp	r3, #1	; 0x1
    7370:	e1a05000 	mov	r5, r0
    7374:	0a000026 	beq	7414 <_ZN9Cyg_Mutex6unlockEv+0xe0>

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    7378:	e3a03000 	mov	r3, #0	; 0x0
    wake_reason = reason;
    737c:	e3a02007 	mov	r2, #7	; 0x7

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    7380:	e5c53080 	strb	r3, [r5, #128]
    wake_reason = reason;
    7384:	e5c52081 	strb	r2, [r5, #129]

#endif

        thread->set_wake_reason( Cyg_Thread::DONE );
        
        thread->wake();
    7388:	e1a00005 	mov	r0, r5
    738c:	ebfff39e 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        
    }

#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL

    IF_PROTOCOL_ACTIVE
    7390:	e5d4200c 	ldrb	r2, [r4, #12]
    7394:	e3520000 	cmp	r2, #0	; 0x0
    7398:	0a000007 	beq	73bc <_ZN9Cyg_Mutex6unlockEv+0x88>
	owner->uncount_mutex();
    739c:	e5940004 	ldr	r0, [r4, #4]
    void uncount_mutex() { mutex_count--; };
    73a0:	e5903030 	ldr	r3, [r0, #48]

#endif    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT

    IF_PROTOCOL_INHERIT
    73a4:	e3520001 	cmp	r2, #1	; 0x1
    73a8:	e2433001 	sub	r3, r3, #1	; 0x1
    73ac:	e5803030 	str	r3, [r0, #48]
    73b0:	0a000011 	beq	73fc <_ZN9Cyg_Mutex6unlockEv+0xc8>
        owner->disinherit_priority();
    
#endif
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

    IF_PROTOCOL_CEILING
    73b4:	e3520002 	cmp	r2, #2	; 0x2
    73b8:	0a00000b 	beq	73ec <_ZN9Cyg_Mutex6unlockEv+0xb8>
        owner->clear_priority_ceiling();
        
#endif
    
    locked      = false;
    73bc:	e3a03000 	mov	r3, #0	; 0x0
    owner       = NULL;
    73c0:	e5843004 	str	r3, [r4, #4]
    IF_PROTOCOL_CEILING
        owner->clear_priority_ceiling();
        
#endif
    
    locked      = false;
    73c4:	e5c43000 	strb	r3, [r4]
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    73c8:	e5973000 	ldr	r3, [r7]
    73cc:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    73d0:	159f3050 	ldrne	r3, [pc, #80]	; 7428 <_ZN9Cyg_Mutex6unlockEv+0xf4>
    73d4:	15830000 	strne	r0, [r3]
    73d8:	0a000001 	beq	73e4 <_ZN9Cyg_Mutex6unlockEv+0xb0>
    
    // Unlock the scheduler and maybe switch threads
    Cyg_Scheduler::unlock();

    CYG_REPORT_RETURN();
}
    73dc:	e28dd004 	add	sp, sp, #4	; 0x4
    73e0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    73e4:	ebfff98c 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    73e8:	eafffffb 	b	73dc <_ZN9Cyg_Mutex6unlockEv+0xa8>
    
#endif
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

    IF_PROTOCOL_CEILING
        owner->clear_priority_ceiling();
    73ec:	e5940004 	ldr	r0, [r4, #4]
    73f0:	e280001c 	add	r0, r0, #28	; 0x1c
    73f4:	ebfff949 	bl	5920 <_ZN15Cyg_SchedThread22clear_priority_ceilingEv>
    73f8:	eaffffef 	b	73bc <_ZN9Cyg_Mutex6unlockEv+0x88>

#endif    
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT

    IF_PROTOCOL_INHERIT
        owner->disinherit_priority();
    73fc:	e280001c 	add	r0, r0, #28	; 0x1c
    7400:	ebfff947 	bl	5924 <_ZN15Cyg_SchedThread19disinherit_priorityEv>
    7404:	e5d4200c 	ldrb	r2, [r4, #12]
    
#endif
#ifdef CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING

    IF_PROTOCOL_CEILING
    7408:	e3520002 	cmp	r2, #2	; 0x2
    740c:	1affffea 	bne	73bc <_ZN9Cyg_Mutex6unlockEv+0x88>
    7410:	eafffff5 	b	73ec <_ZN9Cyg_Mutex6unlockEv+0xb8>

        // Give the owner-to-be a chance to inherit from the remaining
        // queue or the relinquishing thread:

        IF_PROTOCOL_INHERIT
            thread->relay_priority(owner, &queue);
    7414:	e1a02006 	mov	r2, r6
    7418:	e280001c 	add	r0, r0, #28	; 0x1c
    741c:	e5941004 	ldr	r1, [r4, #4]
    7420:	ebfff95a 	bl	5990 <_ZN15Cyg_SchedThread14relay_priorityEP10Cyg_ThreadP15Cyg_ThreadQueue>
    7424:	eaffffd3 	b	7378 <_ZN9Cyg_Mutex6unlockEv+0x44>
    7428:	400007c8 	.word	0x400007c8

0000742c <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy>:
// Optional timed wait on a CV

#if defined(CYGMFN_KERNEL_SYNCH_CONDVAR_TIMED_WAIT)

cyg_bool
Cyg_Condition_Variable::wait_inner( Cyg_Mutex *mx, cyg_tick_count timeout )
    742c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
// -------------------------------------------------------------------------
// Simple inline accessor functions

inline Cyg_Thread *Cyg_Scheduler_Base::get_current_thread()
{
    return current_thread[CYG_KERNEL_CPU_THIS()];
    7430:	e59f90f4 	ldr	r9, [pc, #244]	; 752c <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0x100>
    7434:	e24dd014 	sub	sp, sp, #20	; 0x14
    7438:	e58d000c 	str	r0, [sp, #12]
    743c:	e1a0a001 	mov	sl, r1
    7440:	e1a06002 	mov	r6, r2
    7444:	e1a07003 	mov	r7, r3
    7448:	e5998000 	ldr	r8, [r9]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    744c:	e59fb0dc 	ldr	fp, [pc, #220]	; 7530 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0x104>
    7450:	e59b3000 	ldr	r3, [fp]
    7454:	e2833001 	add	r3, r3, #1	; 0x1
    7458:	e58b3000 	str	r3, [fp]
    // Prevent preemption
    Cyg_Scheduler::lock();

    CYG_INSTRUMENT_CONDVAR(TIMED_WAIT, this, 0 );
    
    mx->unlock();
    745c:	e1a00001 	mov	r0, r1
    7460:	ebffffb3 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>

    // The ordering of sleep() and set_timer() here are
    // important. If the timeout is in the past, the thread
    // will be woken up immediately and will not sleep.
    
    self->sleep();
    7464:	ebfff26b 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
    7468:	e5991000 	ldr	r1, [r9]
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    746c:	e599c000 	ldr	ip, [r9]
    7470:	e5990000 	ldr	r0, [r9]
    7474:	e3a03003 	mov	r3, #3	; 0x3
    self()->wake_reason = NONE;
    7478:	e3a02000 	mov	r2, #0	; 0x0
    cyg_tick_count      trigger,
    cyg_reason          reason
)
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->sleep_reason = reason;
    747c:	e5c13080 	strb	r3, [r1, #128]
    self()->wake_reason = NONE;
    7480:	e5cc2081 	strb	r2, [ip, #129]
    self()->timer.initialize( trigger);
    7484:	e1a03007 	mov	r3, r7
    7488:	e2800050 	add	r0, r0, #80	; 0x50
    748c:	e1a02006 	mov	r2, r6
    7490:	e3a04000 	mov	r4, #0	; 0x0
    7494:	e3a05000 	mov	r5, #0	; 0x0
    7498:	e88d0030 	stm	sp, {r4, r5}
    749c:	eb001e93 	bl	eef0 <_ZN9Cyg_Alarm10initializeEyy>
        
    // Set the timer and sleep reason
    self->set_timer( timeout, Cyg_Thread::TIMEOUT );

    // Only enqueue if the timeout has not already fired.
    if( self->get_wake_reason() == Cyg_Thread::NONE )
    74a0:	e5d83081 	ldrb	r3, [r8, #129]
    74a4:	e3530000 	cmp	r3, #0	; 0x0
    74a8:	0a00001a 	beq	7518 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0xec>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    74ac:	e59b0000 	ldr	r0, [fp]
    // lock is being decremented to a non-zero value, it is more or less
    // equivalent to reschedule() followed by unlock().
    
    CYG_INSTRUMENT_SCHED(UNLOCK,get_sched_lock(),0);
    
    unlock_inner( get_sched_lock() - 1 );
    74b0:	e2400001 	sub	r0, r0, #1	; 0x1
    74b4:	ebfff958 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    74b8:	e5990000 	ldr	r0, [r9]
// -------------------------------------------------------------------------

inline void Cyg_Thread::clear_timer()
{
#ifdef CYGFUN_KERNEL_THREADS_TIMER
    self()->timer.disable();
    74bc:	e2800050 	add	r0, r0, #80	; 0x50
    74c0:	eb001f21 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    
    self->clear_timer();

    CYG_INSTRUMENT_CONDVAR(WOKE, this, self->get_wake_reason());
    
    switch( self->get_wake_reason() )
    74c4:	e5d81081 	ldrb	r1, [r8, #129]
    74c8:	e3510003 	cmp	r1, #3	; 0x3
    74cc:	3a00000b 	bcc	7500 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0xd4>
    74d0:	e3510005 	cmp	r1, #5	; 0x5
    74d4:	93a04000 	movls	r4, #0	; 0x0
    74d8:	8a000006 	bhi	74f8 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0xcc>
    // it is essential to release the mutex and queue on the CV
    // atomically relative to other threads, to avoid races, it is not
    // necessary for us to re-acquire the mutex in the same atomic
    // action. Hence we can do it after unlocking the scheduler.

    while ( !mx->lock() )
    74dc:	e1a0000a 	mov	r0, sl
    74e0:	ebfffe9b 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    74e4:	e3500000 	cmp	r0, #0	; 0x0
    74e8:	0afffffb 	beq	74dc <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0xb0>
    CYG_ASSERTCLASS( mx, "Corrupt mutex");

    CYG_REPORT_RETVAL(result);
    
    return result;
}
    74ec:	e1a00004 	mov	r0, r4
    74f0:	e28dd014 	add	sp, sp, #20	; 0x14
    74f4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    
    self->clear_timer();

    CYG_INSTRUMENT_CONDVAR(WOKE, this, self->get_wake_reason());
    
    switch( self->get_wake_reason() )
    74f8:	e3510006 	cmp	r1, #6	; 0x6
    case Cyg_Thread::BREAK:
        result = false;
        break;
            
    case Cyg_Thread::EXIT:            
        self->exit();
    74fc:	0bfff15a 	bleq	3a6c <_ZN10Cyg_Thread4exitEv>
    // it is essential to release the mutex and queue on the CV
    // atomically relative to other threads, to avoid races, it is not
    // necessary for us to re-acquire the mutex in the same atomic
    // action. Hence we can do it after unlocking the scheduler.

    while ( !mx->lock() )
    7500:	e1a0000a 	mov	r0, sl
    7504:	ebfffe92 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    7508:	e3500000 	cmp	r0, #0	; 0x0
    case Cyg_Thread::BREAK:
        result = false;
        break;
            
    case Cyg_Thread::EXIT:            
        self->exit();
    750c:	e3a04001 	mov	r4, #1	; 0x1
    // it is essential to release the mutex and queue on the CV
    // atomically relative to other threads, to avoid races, it is not
    // necessary for us to re-acquire the mutex in the same atomic
    // action. Hence we can do it after unlocking the scheduler.

    while ( !mx->lock() )
    7510:	0afffff1 	beq	74dc <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0xb0>
    7514:	eafffff4 	b	74ec <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0xc0>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    7518:	e59d300c 	ldr	r3, [sp, #12]
    751c:	e1a01008 	mov	r1, r8
    7520:	e2830004 	add	r0, r3, #4	; 0x4
    7524:	ebfff7d3 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
    7528:	eaffffdf 	b	74ac <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutexy+0x80>
    752c:	40002538 	.word	0x40002538
    7530:	400007c8 	.word	0x400007c8

00007534 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex>:
// suspend DSR processing) then there is no need to take the lock.  Also
// in this case, exit with the scheduler locked, which allows this function
// to be used in a totally thread-safe manner.

cyg_bool
Cyg_Condition_Variable::wait_inner( Cyg_Mutex *mx )
    7534:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    7538:	e59f40b0 	ldr	r4, [pc, #176]	; 75f0 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0xbc>
    753c:	e24dd004 	sub	sp, sp, #4	; 0x4
    7540:	e1a07000 	mov	r7, r0
    7544:	e1a08001 	mov	r8, r1
    7548:	e5946000 	ldr	r6, [r4]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    754c:	e59f50a0 	ldr	r5, [pc, #160]	; 75f4 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0xc0>
    7550:	e5953000 	ldr	r3, [r5]
    7554:	e2833001 	add	r3, r3, #1	; 0x1
    7558:	e5853000 	str	r3, [r5]
    CYG_ASSERTCLASS( mx, "Corrupt mutex");
    CYG_ASSERTCLASS( self, "Bad self thread");

    CYG_INSTRUMENT_CONDVAR(WAIT, this, 0);
    
    mx->unlock();
    755c:	e1a00001 	mov	r0, r1
    7560:	ebffff73 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7564:	e5943000 	ldr	r3, [r4]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    7568:	e5942000 	ldr	r2, [r4]
    756c:	e3a0a001 	mov	sl, #1	; 0x1
    self()->wake_reason = NONE;
    7570:	e3a04000 	mov	r4, #0	; 0x0

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_sleep_reason( cyg_reason reason)
{
    self()->sleep_reason = reason;
    7574:	e5c3a080 	strb	sl, [r3, #128]
    self()->wake_reason = NONE;
    7578:	e5c24081 	strb	r4, [r2, #129]

    self->set_sleep_reason( Cyg_Thread::WAIT );
        
    self->sleep();
    757c:	ebfff225 	bl	3e18 <_ZN10Cyg_Thread5sleepEv>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    7580:	e2870004 	add	r0, r7, #4	; 0x4
    7584:	e1a01006 	mov	r1, r6
    7588:	ebfff7ba 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    758c:	e5950000 	ldr	r0, [r5]
    7590:	e2400001 	sub	r0, r0, #1	; 0x1
    7594:	ebfff920 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    CYG_INSTRUMENT_CONDVAR(WOKE, this, self->get_wake_reason());

    CYG_ASSERTCLASS( this, "Bad this pointer");
    CYG_ASSERTCLASS( mx, "Corrupt mutex");

    switch( self->get_wake_reason() )
    7598:	e5d63081 	ldrb	r3, [r6, #129]
    759c:	e3530004 	cmp	r3, #4	; 0x4
    75a0:	2a000007 	bcs	75c4 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0x90>
    75a4:	e3a04001 	mov	r4, #1	; 0x1
    // action. Hence we can do it after unlocking the scheduler.
    // We need to loop here in case the thread is released while waiting
    // for the mutex. It is essential that we exit this function with the
    // mutex claimed.

    while ( !mx->lock() )
    75a8:	e1a00008 	mov	r0, r8
    75ac:	ebfffe68 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    75b0:	e3500000 	cmp	r0, #0	; 0x0
    75b4:	0afffffb 	beq	75a8 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0x74>
    CYG_ASSERT( mx->owner == self, "Not mutex owner");

    CYG_REPORT_RETURN();

    return result;
}
    75b8:	e1a00004 	mov	r0, r4
    75bc:	e28dd004 	add	sp, sp, #4	; 0x4
    75c0:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    CYG_INSTRUMENT_CONDVAR(WOKE, this, self->get_wake_reason());

    CYG_ASSERTCLASS( this, "Bad this pointer");
    CYG_ASSERTCLASS( mx, "Corrupt mutex");

    switch( self->get_wake_reason() )
    75c4:	e3530005 	cmp	r3, #5	; 0x5
    75c8:	9afffff6 	bls	75a8 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0x74>
    75cc:	e3530006 	cmp	r3, #6	; 0x6
    75d0:	1afffff3 	bne	75a4 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0x70>
    case Cyg_Thread::BREAK:
        result = false;
        break;
            
    case Cyg_Thread::EXIT:            
        self->exit();
    75d4:	ebfff124 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
    // action. Hence we can do it after unlocking the scheduler.
    // We need to loop here in case the thread is released while waiting
    // for the mutex. It is essential that we exit this function with the
    // mutex claimed.

    while ( !mx->lock() )
    75d8:	e1a00008 	mov	r0, r8
    75dc:	ebfffe5c 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    75e0:	e3500000 	cmp	r0, #0	; 0x0
    case Cyg_Thread::BREAK:
        result = false;
        break;
            
    case Cyg_Thread::EXIT:            
        self->exit();
    75e4:	e1a0400a 	mov	r4, sl
    // action. Hence we can do it after unlocking the scheduler.
    // We need to loop here in case the thread is released while waiting
    // for the mutex. It is essential that we exit this function with the
    // mutex claimed.

    while ( !mx->lock() )
    75e8:	0affffee 	beq	75a8 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0x74>
    75ec:	eafffff1 	b	75b8 <_ZN22Cyg_Condition_Variable10wait_innerEP9Cyg_Mutex+0x84>
    75f0:	40002538 	.word	0x40002538
    75f4:	400007c8 	.word	0x400007c8

000075f8 <_Z41__static_initialization_and_destruction_0ii>:
#ifdef CYGSEM_LIBC_MAIN_STACK_FROM_SYSTEM
                CYGNUM_LIBC_MAIN_DEFAULT_STACK_SIZE
#else
                cyg_libc_main_stack_size
#endif
              );
    75f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    75fc:	e3500001 	cmp	r0, #1	; 0x1
    7600:	e24dd014 	sub	sp, sp, #20	; 0x14
    7604:	0a000007 	beq	7628 <_Z41__static_initialization_and_destruction_0ii+0x30>

// GLOBALS

// let the main thread be global so people can play with it (e.g. suspend
// or resume etc.) if that's what they want to do
Cyg_Thread cyg_libc_main_thread CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_LIBC) =
    7608:	e3500000 	cmp	r0, #0	; 0x0
    760c:	1a000003 	bne	7620 <_Z41__static_initialization_and_destruction_0ii+0x28>
    7610:	e3a03cda 	mov	r3, #55808	; 0xda00
    7614:	e28330c0 	add	r3, r3, #192	; 0xc0
    7618:	e1510003 	cmp	r1, r3
    761c:	0a000011 	beq	7668 <_Z41__static_initialization_and_destruction_0ii+0x70>
#ifdef CYGSEM_LIBC_MAIN_STACK_FROM_SYSTEM
                CYGNUM_LIBC_MAIN_DEFAULT_STACK_SIZE
#else
                cyg_libc_main_stack_size
#endif
              );
    7620:	e28dd014 	add	sp, sp, #20	; 0x14
    7624:	e8bd8000 	pop	{pc}
    7628:	e3a03cda 	mov	r3, #55808	; 0xda00
    762c:	e28330c0 	add	r3, r3, #192	; 0xc0
    7630:	e1510003 	cmp	r1, r3
    7634:	1afffff9 	bne	7620 <_Z41__static_initialization_and_destruction_0ii+0x28>
    7638:	e59fc038 	ldr	ip, [pc, #56]	; 7678 <_Z41__static_initialization_and_destruction_0ii+0x80>
    763c:	e59fe038 	ldr	lr, [pc, #56]	; 767c <_Z41__static_initialization_and_destruction_0ii+0x84>
    7640:	e58dc000 	str	ip, [sp]
    7644:	e3a0100a 	mov	r1, #10	; 0xa
    7648:	e3a0ca02 	mov	ip, #8192	; 0x2000
    764c:	e59f202c 	ldr	r2, [pc, #44]	; 7680 <_Z41__static_initialization_and_destruction_0ii+0x88>
    7650:	e3a03000 	mov	r3, #0	; 0x0
    7654:	e59f0028 	ldr	r0, [pc, #40]	; 7684 <_Z41__static_initialization_and_destruction_0ii+0x8c>
    7658:	e58de004 	str	lr, [sp, #4]
    765c:	e58dc008 	str	ip, [sp, #8]
    7660:	ebfff14d 	bl	3b9c <_ZN10Cyg_ThreadC1EjPFvjEjPcjj>
    7664:	eaffffed 	b	7620 <_Z41__static_initialization_and_destruction_0ii+0x28>

// GLOBALS

// let the main thread be global so people can play with it (e.g. suspend
// or resume etc.) if that's what they want to do
Cyg_Thread cyg_libc_main_thread CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_LIBC) =
    7668:	e59f0014 	ldr	r0, [pc, #20]	; 7684 <_Z41__static_initialization_and_destruction_0ii+0x8c>
#ifdef CYGSEM_LIBC_MAIN_STACK_FROM_SYSTEM
                CYGNUM_LIBC_MAIN_DEFAULT_STACK_SIZE
#else
                cyg_libc_main_stack_size
#endif
              );
    766c:	e28dd014 	add	sp, sp, #20	; 0x14
    7670:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)

// GLOBALS

// let the main thread be global so people can play with it (e.g. suspend
// or resume etc.) if that's what they want to do
Cyg_Thread cyg_libc_main_thread CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_LIBC) =
    7674:	eafff375 	b	4450 <_ZN10Cyg_ThreadD1Ev>
    7678:	00012a5c 	.word	0x00012a5c
    767c:	40002670 	.word	0x40002670
    7680:	0000f724 	.word	0x0000f724
    7684:	400025c8 	.word	0x400025c8

00007688 <_GLOBAL__D.56000_cyg_libc_main_thread>:
#ifdef CYGSEM_LIBC_MAIN_STACK_FROM_SYSTEM
                CYGNUM_LIBC_MAIN_DEFAULT_STACK_SIZE
#else
                cyg_libc_main_stack_size
#endif
              );
    7688:	e3a01cda 	mov	r1, #55808	; 0xda00
    768c:	e28110c0 	add	r1, r1, #192	; 0xc0
    7690:	e3a00000 	mov	r0, #0	; 0x0
    7694:	eaffffd7 	b	75f8 <_Z41__static_initialization_and_destruction_0ii>

00007698 <_GLOBAL__I.56000_cyg_libc_main_thread>:
    7698:	e3a01cda 	mov	r1, #55808	; 0xda00
    769c:	e28110c0 	add	r1, r1, #192	; 0xc0
    76a0:	e3a00001 	mov	r0, #1	; 0x1
    76a4:	eaffffd3 	b	75f8 <_Z41__static_initialization_and_destruction_0ii>

000076a8 <vscanf>:

// Other non-ANSI functions

#ifdef CYGFUN_LIBC_STDIO_ungetc
externC int
vscanf( const char *format, va_list arg ) __THROW
    76a8:	e1a02001 	mov	r2, r1
{
    return vfscanf( stdin, format, arg );
    76ac:	e59f100c 	ldr	r1, [pc, #12]	; 76c0 <vscanf+0x18>

// Other non-ANSI functions

#ifdef CYGFUN_LIBC_STDIO_ungetc
externC int
vscanf( const char *format, va_list arg ) __THROW
    76b0:	e1a03000 	mov	r3, r0
{
    return vfscanf( stdin, format, arg );
    76b4:	e5910000 	ldr	r0, [r1]
    76b8:	e1a01003 	mov	r1, r3
    76bc:	ea000481 	b	88c8 <vfscanf>
    76c0:	00013194 	.word	0x00013194

000076c4 <perror>:
//===========================================================================

// 7.9.10 Error-handling functions

externC void
perror( const char *s ) __THROW
    76c4:	e92d4030 	push	{r4, r5, lr}
{
    if (s && *s)
    76c8:	e2505000 	subs	r5, r0, #0	; 0x0
//===========================================================================

// 7.9.10 Error-handling functions

externC void
perror( const char *s ) __THROW
    76cc:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    if (s && *s)
    76d0:	0a000002 	beq	76e0 <perror+0x1c>
    76d4:	e5d53000 	ldrb	r3, [r5]
    76d8:	e3530000 	cmp	r3, #0	; 0x0
    76dc:	1a000007 	bne	7700 <perror+0x3c>
        fprintf( stderr, "%s: %s\n", s, strerror(errno) );
    else
        fputs( strerror(errno), stderr );
    76e0:	eb0018a2 	bl	d970 <cyg_error_get_errno_p>
    76e4:	e5900000 	ldr	r0, [r0]
    76e8:	eb001670 	bl	d0b0 <__strerror>
    76ec:	e59f303c 	ldr	r3, [pc, #60]	; 7730 <perror+0x6c>
    76f0:	e5931000 	ldr	r1, [r3]

} // perror()
    76f4:	e28dd004 	add	sp, sp, #4	; 0x4
    76f8:	e8bd4030 	pop	{r4, r5, lr}
perror( const char *s ) __THROW
{
    if (s && *s)
        fprintf( stderr, "%s: %s\n", s, strerror(errno) );
    else
        fputs( strerror(errno), stderr );
    76fc:	ea0009fa 	b	9eec <fputs>

externC void
perror( const char *s ) __THROW
{
    if (s && *s)
        fprintf( stderr, "%s: %s\n", s, strerror(errno) );
    7700:	e59f3028 	ldr	r3, [pc, #40]	; 7730 <perror+0x6c>
    7704:	e5934000 	ldr	r4, [r3]
    7708:	eb001898 	bl	d970 <cyg_error_get_errno_p>
    770c:	e5900000 	ldr	r0, [r0]
    7710:	eb001666 	bl	d0b0 <__strerror>
    7714:	e59f1018 	ldr	r1, [pc, #24]	; 7734 <perror+0x70>
    7718:	e1a03000 	mov	r3, r0
    771c:	e1a02005 	mov	r2, r5
    7720:	e1a00004 	mov	r0, r4
    else
        fputs( strerror(errno), stderr );

} // perror()
    7724:	e28dd004 	add	sp, sp, #4	; 0x4
    7728:	e8bd4030 	pop	{r4, r5, lr}

externC void
perror( const char *s ) __THROW
{
    if (s && *s)
        fprintf( stderr, "%s: %s\n", s, strerror(errno) );
    772c:	ea0009b7 	b	9e10 <fprintf>
    7730:	00013190 	.word	0x00013190
    7734:	00012a64 	.word	0x00012a64

00007738 <puts>:
//===========================================================================

// 7.9.7 Character input/output functions

externC int
puts( const char *s ) __THROW
    7738:	e92d4010 	push	{r4, lr}
{
    int rc;

    rc = fputs( s, stdout );
    773c:	e59f401c 	ldr	r4, [pc, #28]	; 7760 <puts+0x28>
    7740:	e5941000 	ldr	r1, [r4]
    7744:	eb0009e8 	bl	9eec <fputs>

    if (rc >= 0)
    7748:	e3500000 	cmp	r0, #0	; 0x0
    774c:	b8bd8010 	poplt	{r4, pc}
        rc = fputc('\n', stdout );
    7750:	e5941000 	ldr	r1, [r4]
    7754:	e3a0000a 	mov	r0, #10	; 0xa

    return rc;
} // puts()
    7758:	e8bd4010 	pop	{r4, lr}
    int rc;

    rc = fputs( s, stdout );

    if (rc >= 0)
        rc = fputc('\n', stdout );
    775c:	ea0009b4 	b	9e34 <fputc>
    7760:	00012a6c 	.word	0x00012a6c

00007764 <vsprintf>:
    return vfnprintf( stdout, INT_MAX, format, arg );
} // vprintf()


externC int
vsprintf( char *s, const char *format, va_list arg ) __THROW
    7764:	e1a03002 	mov	r3, r2
{
    return vsnprintf(s, INT_MAX, format, arg);
    7768:	e1a02001 	mov	r2, r1
    776c:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
    7770:	ea00041a 	b	87e0 <vsnprintf>

00007774 <vprintf>:
    return vfnprintf(stream, INT_MAX, format, arg);
} // vfprintf()


externC int
vprintf( const char *format, va_list arg) __THROW
    7774:	e1a03001 	mov	r3, r1
{
    return vfnprintf( stdout, INT_MAX, format, arg );
    7778:	e59f100c 	ldr	r1, [pc, #12]	; 778c <vprintf+0x18>
    return vfnprintf(stream, INT_MAX, format, arg);
} // vfprintf()


externC int
vprintf( const char *format, va_list arg) __THROW
    777c:	e1a02000 	mov	r2, r0
{
    return vfnprintf( stdout, INT_MAX, format, arg );
    7780:	e5910000 	ldr	r0, [r1]
    7784:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
    7788:	ea000a4c 	b	a0c0 <vfnprintf>
    778c:	00012a6c 	.word	0x00012a6c

00007790 <vfprintf>:

// 7.9.6 Formatted input/output functions


externC int
vfprintf( FILE *stream, const char *format, va_list arg ) __THROW
    7790:	e1a03002 	mov	r3, r2
{
    return vfnprintf(stream, INT_MAX, format, arg);
    7794:	e1a02001 	mov	r2, r1
    7798:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
    779c:	ea000a47 	b	a0c0 <vfnprintf>

000077a0 <setbuf>:
// 7.9.5 File access functions

externC void
setbuf( FILE *stream, char *buf ) __THROW
{
    if (buf == NULL)
    77a0:	e2513000 	subs	r3, r1, #0	; 0x0
    77a4:	0a000002 	beq	77b4 <setbuf+0x14>
        setvbuf( stream, NULL, _IONBF, 0 );
    else
        // NB: Should use full buffering by default ordinarily, but in
        // the current system we're always connected to an interactive
        // terminal, so use line buffering
        setvbuf( stream, buf, _IOLBF, BUFSIZ ); 
    77a8:	e3e02003 	mvn	r2, #3	; 0x3
    77ac:	e3a03c01 	mov	r3, #256	; 0x100
    77b0:	ea002060 	b	f938 <setvbuf>

externC void
setbuf( FILE *stream, char *buf ) __THROW
{
    if (buf == NULL)
        setvbuf( stream, NULL, _IONBF, 0 );
    77b4:	e3e02007 	mvn	r2, #7	; 0x7
    77b8:	ea00205e 	b	f938 <setvbuf>

000077bc <_Z41__static_initialization_and_destruction_0ii>:
static cyg_libc_dummy_stdout_init_class cyg_libc_dummy_stdout_init
                                             CYGBLD_ATTRIB_INIT_PRI(PRIO);

// and finally stdout itself
__externC Cyg_StdioStream * const stdout;
Cyg_StdioStream * const stdout=&cyg_libc_stdio_stdout;
    77bc:	e92d4070 	push	{r4, r5, r6, lr}
    77c0:	e3500001 	cmp	r0, #1	; 0x1
    77c4:	e24dd010 	sub	sp, sp, #16	; 0x10
    77c8:	e1a04000 	mov	r4, r0
    77cc:	0a000007 	beq	77f0 <_Z41__static_initialization_and_destruction_0ii+0x34>
    }
};

// And here's an instance of the class just to make the code run
static cyg_libc_dummy_stdout_init_class cyg_libc_dummy_stdout_init
                                             CYGBLD_ATTRIB_INIT_PRI(PRIO);
    77d0:	e3500000 	cmp	r0, #0	; 0x0
    77d4:	1a000003 	bne	77e8 <_Z41__static_initialization_and_destruction_0ii+0x2c>
    77d8:	e3a03cdb 	mov	r3, #56064	; 0xdb00
    77dc:	e243303f 	sub	r3, r3, #63	; 0x3f
    77e0:	e1510003 	cmp	r1, r3
    77e4:	0a00001a 	beq	7854 <_Z41__static_initialization_and_destruction_0ii+0x98>

// and finally stdout itself
__externC Cyg_StdioStream * const stdout;
Cyg_StdioStream * const stdout=&cyg_libc_stdio_stdout;
    77e8:	e28dd010 	add	sp, sp, #16	; 0x10
    77ec:	e8bd8070 	pop	{r4, r5, r6, pc}
    77f0:	e3a03cdb 	mov	r3, #56064	; 0xdb00
    77f4:	e243303f 	sub	r3, r3, #63	; 0x3f
    77f8:	e1510003 	cmp	r1, r3
    77fc:	1afffff9 	bne	77e8 <_Z41__static_initialization_and_destruction_0ii+0x2c>
Cyg_StdioStream
cyg_libc_stdio_stdout CYGBLD_ATTRIB_INIT_PRI(PRIO) = Cyg_StdioStream(
    Cyg_libc_stdio_find_filename(CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE,
                                 Cyg_StdioStream::CYG_STREAM_WRITE,
                                 false, false),
    Cyg_StdioStream::CYG_STREAM_WRITE, false, false, _IOLBF );
    7800:	e3a02000 	mov	r2, #0	; 0x0
    7804:	e1a03002 	mov	r3, r2
    7808:	e1a01000 	mov	r1, r0
    780c:	e59f00c0 	ldr	r0, [pc, #192]	; 78d4 <_Z41__static_initialization_and_destruction_0ii+0x118>
    7810:	eb002141 	bl	fd1c <Cyg_libc_stdio_find_filename>
    7814:	e59f60bc 	ldr	r6, [pc, #188]	; 78d8 <_Z41__static_initialization_and_destruction_0ii+0x11c>
    7818:	e3a05000 	mov	r5, #0	; 0x0
    781c:	e1a01000 	mov	r1, r0
    7820:	e1a02004 	mov	r2, r4
    7824:	e1a03005 	mov	r3, r5
    7828:	e3e0c003 	mvn	ip, #3	; 0x3
    782c:	e1a00006 	mov	r0, r6
    7830:	e28440ff 	add	r4, r4, #255	; 0xff
    7834:	e58dc004 	str	ip, [sp, #4]
    7838:	e58d4008 	str	r4, [sp, #8]
    783c:	e58d5000 	str	r5, [sp]
    7840:	e58d500c 	str	r5, [sp, #12]
    7844:	eb000329 	bl	84f0 <_ZN15Cyg_StdioStreamC1EPvNS_8OpenModeEiiijPh>
Cyg_libc_stdio_files::set_file_stream( fd_t fd, Cyg_StdioStream *stream )
{
    CYG_PRECONDITION( (fd < FOPEN_MAX),
                  "Attempt to set larger file descriptor than FOPEN_MAX!" );

    files[fd] = stream;
    7848:	e59f308c 	ldr	r3, [pc, #140]	; 78dc <_Z41__static_initialization_and_destruction_0ii+0x120>
    784c:	e5836004 	str	r6, [r3, #4]
    7850:	eaffffe4 	b	77e8 <_Z41__static_initialization_and_destruction_0ii+0x2c>
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    7854:	e59f507c 	ldr	r5, [pc, #124]	; 78d8 <_Z41__static_initialization_and_destruction_0ii+0x11c>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    7858:	e5953008 	ldr	r3, [r5, #8]
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    785c:	e59f207c 	ldr	r2, [pc, #124]	; 78e0 <_Z41__static_initialization_and_destruction_0ii+0x124>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    7860:	e3530000 	cmp	r3, #0	; 0x0
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    7864:	e5852000 	str	r2, [r5]
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    7868:	0a00000b 	beq	789c <_Z41__static_initialization_and_destruction_0ii+0xe0>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    786c:	e2850030 	add	r0, r5, #48	; 0x30
    7870:	ebfffdb7 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline Cyg_ErrNo
Cyg_StdioStream::close()
{
    Cyg_ErrNo err = ENOERR;
    
    if (!lock_me())
    7874:	e3500000 	cmp	r0, #0	; 0x0
    7878:	0a000007 	beq	789c <_Z41__static_initialization_and_destruction_0ii+0xe0>
        return EBADF;

    if( my_device != CYG_STDIO_HANDLE_NULL )
    787c:	e5953008 	ldr	r3, [r5, #8]
    7880:	e3530000 	cmp	r3, #0	; 0x0
    7884:	0a000002 	beq	7894 <_Z41__static_initialization_and_destruction_0ii+0xd8>
    {
        flush_output_unlocked();
    7888:	e1a00005 	mov	r0, r5
    788c:	eb00003c 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        err = cyg_stdio_close( my_device );
    
        if( err == ENOERR )
            my_device = CYG_STDIO_HANDLE_NULL;
    7890:	e5854008 	str	r4, [r5, #8]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7894:	e59f0048 	ldr	r0, [pc, #72]	; 78e4 <_Z41__static_initialization_and_destruction_0ii+0x128>
    7898:	ebfffea5 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        close();
    
#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0xbadbad;
#endif
} // Cyg_StdioStream destructor
    789c:	e59f0040 	ldr	r0, [pc, #64]	; 78e4 <_Z41__static_initialization_and_destruction_0ii+0x128>
    78a0:	ebfffd6b 	bl	6e54 <_ZN9Cyg_MutexD1Ev>

inline
Cyg_StdioStreamBuffer::~Cyg_StdioStreamBuffer()
{
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
    if ((buffer_bottom != NULL) && call_free)
    78a4:	e5950014 	ldr	r0, [r5, #20]
    78a8:	e3500000 	cmp	r0, #0	; 0x0
    78ac:	0a000003 	beq	78c0 <_Z41__static_initialization_and_destruction_0ii+0x104>
    78b0:	e59f3020 	ldr	r3, [pc, #32]	; 78d8 <_Z41__static_initialization_and_destruction_0ii+0x11c>
    78b4:	e5932010 	ldr	r2, [r3, #16]
    78b8:	e3520000 	cmp	r2, #0	; 0x0
    78bc:	1a000002 	bne	78cc <_Z41__static_initialization_and_destruction_0ii+0x110>
class Cyg_OutputStream
{
public:

    // Provide empty virtual destructor
    virtual ~Cyg_OutputStream() {}
    78c0:	e59f3020 	ldr	r3, [pc, #32]	; 78e8 <_Z41__static_initialization_and_destruction_0ii+0x12c>
    78c4:	e5853000 	str	r3, [r5]
    78c8:	eaffffc6 	b	77e8 <_Z41__static_initialization_and_destruction_0ii+0x2c>
        free( buffer_bottom );
    78cc:	eb001e67 	bl	f270 <free>
    78d0:	eafffffa 	b	78c0 <_Z41__static_initialization_and_destruction_0ii+0x104>
    78d4:	00012954 	.word	0x00012954
    78d8:	40004670 	.word	0x40004670
    78dc:	40004b94 	.word	0x40004b94
    78e0:	00012a78 	.word	0x00012a78
    78e4:	400046a0 	.word	0x400046a0
    78e8:	00012a90 	.word	0x00012a90

000078ec <_GLOBAL__D.56001_cyg_libc_stdio_stdout>:
static cyg_libc_dummy_stdout_init_class cyg_libc_dummy_stdout_init
                                             CYGBLD_ATTRIB_INIT_PRI(PRIO);

// and finally stdout itself
__externC Cyg_StdioStream * const stdout;
Cyg_StdioStream * const stdout=&cyg_libc_stdio_stdout;
    78ec:	e3a01cdb 	mov	r1, #56064	; 0xdb00
    78f0:	e241103f 	sub	r1, r1, #63	; 0x3f
    78f4:	e3a00000 	mov	r0, #0	; 0x0
    78f8:	eaffffaf 	b	77bc <_Z41__static_initialization_and_destruction_0ii>

000078fc <_GLOBAL__I.56001_cyg_libc_stdio_stdout>:
    78fc:	e3a01cdb 	mov	r1, #56064	; 0xdb00
    7900:	e241103f 	sub	r1, r1, #63	; 0x3f
    7904:	e3a00001 	mov	r0, #1	; 0x1
    7908:	eaffffab 	b	77bc <_Z41__static_initialization_and_destruction_0ii>

0000790c <_ZN16Cyg_OutputStreamD1Ev>:
    790c:	e59f3004 	ldr	r3, [pc, #4]	; 7918 <_ZN16Cyg_OutputStreamD1Ev+0xc>
    7910:	e5803000 	str	r3, [r0]
    7914:	e12fff1e 	bx	lr
    7918:	00012a90 	.word	0x00012a90

0000791c <_ZN16Cyg_OutputStream5writeEPKhjPj>:
Cyg_OutputStream::write( const cyg_uint8 *buffer, cyg_ucount32 buffer_length,
    cyg_ucount32 *bytes_written )
{
    CYG_FAIL("Cyg_OutputStream::write(): pure virtual called");
    return ENOSYS;
}
    791c:	e3a00026 	mov	r0, #38	; 0x26
    7920:	e12fff1e 	bx	lr

00007924 <_ZN16Cyg_OutputStream9get_errorEv>:
Cyg_ErrNo
Cyg_OutputStream::get_error( void )
{
    CYG_FAIL("Cyg_OutputStream::get_error(): pure virtual called");
    return ENOSYS;
}
    7924:	e3a00026 	mov	r0, #38	; 0x26
    7928:	e12fff1e 	bx	lr

0000792c <_ZN16Cyg_OutputStreamD0Ev>:
    792c:	e59f3014 	ldr	r3, [pc, #20]	; 7948 <_ZN16Cyg_OutputStreamD0Ev+0x1c>
    7930:	e92d4010 	push	{r4, lr}
    7934:	e5803000 	str	r3, [r0]
    7938:	e1a04000 	mov	r4, r0
    793c:	eb001950 	bl	de84 <_ZdlPv>
    7940:	e1a00004 	mov	r0, r4
    7944:	e8bd8010 	pop	{r4, pc}
    7948:	00012a90 	.word	0x00012a90

0000794c <_ZN15Cyg_StdioStream9get_errorEv>:
} // flush_output()


// get error status for this file
inline Cyg_ErrNo
Cyg_StdioStream::get_error( void )
    794c:	e92d4030 	push	{r4, r5, lr}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    7950:	e2804030 	add	r4, r0, #48	; 0x30
} // flush_output()


// get error status for this file
inline Cyg_ErrNo
Cyg_StdioStream::get_error( void )
    7954:	e24dd004 	sub	sp, sp, #4	; 0x4
    7958:	e1a05000 	mov	r5, r0
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    795c:	e1a00004 	mov	r0, r4
    7960:	ebfffd7b 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
{
    Cyg_ErrNo err_temp;
    
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    7964:	e3500000 	cmp	r0, #0	; 0x0
    7968:	03a04009 	moveq	r4, #9	; 0x9
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    796c:	11a00004 	movne	r0, r4
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
        return EBADF;     // well, we've certainly got an error now!
    
    err_temp = error;
    7970:	15954004 	ldrne	r4, [r5, #4]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7974:	1bfffe6e 	blne	7334 <_ZN9Cyg_Mutex6unlockEv>
    err_temp = error;

    unlock_me();

    return err_temp;
} // get_error()
    7978:	e1a00004 	mov	r0, r4
    797c:	e28dd004 	add	sp, sp, #4	; 0x4
    7980:	e8bd8030 	pop	{r4, r5, pc}

00007984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>:
    return err;
} // peek_byte()


Cyg_ErrNo
Cyg_StdioStream::flush_output_unlocked( void )
    7984:	e92d4030 	push	{r4, r5, lr}
    cyg_uint8 *buffer;
    cyg_uint32 len;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if ( flags.last_buffer_op_was_read )
    7988:	e5d03028 	ldrb	r3, [r0, #40]
    798c:	e1b023a3 	lsrs	r2, r3, #7
    return err;
} // peek_byte()


Cyg_ErrNo
Cyg_StdioStream::flush_output_unlocked( void )
    7990:	e24dd00c 	sub	sp, sp, #12	; 0xc
    7994:	e1a04000 	mov	r4, r0
    cyg_uint8 *buffer;
    cyg_uint32 len;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if ( flags.last_buffer_op_was_read )
    7998:	1a000013 	bne	79ec <_ZN15Cyg_StdioStream21flush_output_unlockedEv+0x68>
        return ENOERR;

    // first just check that we _can_ write to the device!
    if ( !flags.opened_for_write )
    799c:	e3130004 	tst	r3, #4	; 0x4
    79a0:	03a05016 	moveq	r5, #22	; 0x16
    79a4:	0a00000d 	beq	79e0 <_ZN15Cyg_StdioStream21flush_output_unlockedEv+0x5c>


inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_space_used( void )
{
    return (buffer_top - current_buffer_position);
    79a8:	e590301c 	ldr	r3, [r0, #28]
    79ac:	e5901020 	ldr	r1, [r0, #32]
        return EINVAL;

    // shortcut if nothing to do
    if (io_buf.get_buffer_space_used() == 0)
    79b0:	e1530001 	cmp	r3, r1
    79b4:	0a00000c 	beq	79ec <_ZN15Cyg_StdioStream21flush_output_unlockedEv+0x68>
        return ENOERR;
        
    len = io_buf.get_buffer_addr_to_read( (cyg_uint8 **)&buffer );
    79b8:	e0613003 	rsb	r3, r1, r3
    79bc:	e28d2008 	add	r2, sp, #8	; 0x8
    79c0:	e5223004 	str	r3, [r2, #-4]!
}

inline Cyg_ErrNo cyg_stdio_write( cyg_stdio_handle_t dev,
                                 const void *buffer, cyg_uint32 *len )
{
    return cyg_io_write( dev, buffer, len );    
    79c4:	e5900008 	ldr	r0, [r0, #8]
    79c8:	ebffe8a8 	bl	1c70 <cyg_io_write>

    write_err = cyg_stdio_write(my_device, buffer, &len);

    // since we're doing a concerted flush, we tell the I/O layer to
    // flush too, otherwise output may just sit there forever
    if (!write_err)
    79cc:	e2505000 	subs	r5, r0, #0	; 0x0
    79d0:	0a000007 	beq	79f4 <_ZN15Cyg_StdioStream21flush_output_unlockedEv+0x70>


inline void
Cyg_StdioStreamBuffer::drain_buffer( void )
{
    buffer_top = current_buffer_position = &buffer_bottom[0];
    79d4:	e5943014 	ldr	r3, [r4, #20]
    79d8:	e584301c 	str	r3, [r4, #28]
    79dc:	e5843020 	str	r3, [r4, #32]
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    return ENOERR;

#endif // ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
} // flush_output_unlocked()
    79e0:	e1a00005 	mov	r0, r5
    79e4:	e28dd00c 	add	sp, sp, #12	; 0xc
    79e8:	e8bd8030 	pop	{r4, r5, pc}
        cyg_stdio_flush( my_device );
    
        // we've just read it all, so just wipe it out
    io_buf.drain_buffer();

    return write_err;
    79ec:	e3a05000 	mov	r5, #0	; 0x0
    79f0:	eafffffa 	b	79e0 <_ZN15Cyg_StdioStream21flush_output_unlockedEv+0x5c>

inline Cyg_ErrNo cyg_stdio_flush( cyg_stdio_handle_t dev )
{
    return cyg_io_get_config(dev,
                             CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN,
                             NULL, NULL);
    79f4:	e3a01c01 	mov	r1, #256	; 0x100
    79f8:	e2811002 	add	r1, r1, #2	; 0x2
    79fc:	e5940008 	ldr	r0, [r4, #8]
    7a00:	e1a02005 	mov	r2, r5
    7a04:	e1a03005 	mov	r3, r5
    7a08:	ebffe8e6 	bl	1da8 <cyg_io_get_config>
    7a0c:	eafffff0 	b	79d4 <_ZN15Cyg_StdioStream21flush_output_unlockedEv+0x50>

00007a10 <_ZN15Cyg_StdioStreamD0Ev>:
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    7a10:	e92d4030 	push	{r4, r5, lr}
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    7a14:	e5903008 	ldr	r3, [r0, #8]
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    7a18:	e59f2090 	ldr	r2, [pc, #144]	; 7ab0 <_ZN15Cyg_StdioStreamD0Ev+0xa0>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    7a1c:	e3530000 	cmp	r3, #0	; 0x0
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    7a20:	e24dd004 	sub	sp, sp, #4	; 0x4
    7a24:	e1a04000 	mov	r4, r0
    7a28:	e5802000 	str	r2, [r0]
    7a2c:	02805030 	addeq	r5, r0, #48	; 0x30
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    7a30:	0a00000d 	beq	7a6c <_ZN15Cyg_StdioStreamD0Ev+0x5c>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    7a34:	e2805030 	add	r5, r0, #48	; 0x30
    7a38:	e1a00005 	mov	r0, r5
    7a3c:	ebfffd44 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline Cyg_ErrNo
Cyg_StdioStream::close()
{
    Cyg_ErrNo err = ENOERR;
    
    if (!lock_me())
    7a40:	e3500000 	cmp	r0, #0	; 0x0
    7a44:	0a000008 	beq	7a6c <_ZN15Cyg_StdioStreamD0Ev+0x5c>
        return EBADF;

    if( my_device != CYG_STDIO_HANDLE_NULL )
    7a48:	e5943008 	ldr	r3, [r4, #8]
    7a4c:	e3530000 	cmp	r3, #0	; 0x0
    7a50:	0a000003 	beq	7a64 <_ZN15Cyg_StdioStreamD0Ev+0x54>
    {
        flush_output_unlocked();
    7a54:	e1a00004 	mov	r0, r4
    7a58:	ebffffc9 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        err = cyg_stdio_close( my_device );
    
        if( err == ENOERR )
            my_device = CYG_STDIO_HANDLE_NULL;
    7a5c:	e3a03000 	mov	r3, #0	; 0x0
    7a60:	e5843008 	str	r3, [r4, #8]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7a64:	e1a00005 	mov	r0, r5
    7a68:	ebfffe31 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        close();
    
#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0xbadbad;
#endif
} // Cyg_StdioStream destructor
    7a6c:	e1a00005 	mov	r0, r5
    7a70:	ebfffcf7 	bl	6e54 <_ZN9Cyg_MutexD1Ev>

inline
Cyg_StdioStreamBuffer::~Cyg_StdioStreamBuffer()
{
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
    if ((buffer_bottom != NULL) && call_free)
    7a74:	e5940014 	ldr	r0, [r4, #20]
    7a78:	e3500000 	cmp	r0, #0	; 0x0
    7a7c:	0a000002 	beq	7a8c <_ZN15Cyg_StdioStreamD0Ev+0x7c>
    7a80:	e5943010 	ldr	r3, [r4, #16]
    7a84:	e3530000 	cmp	r3, #0	; 0x0
    7a88:	1a000006 	bne	7aa8 <_ZN15Cyg_StdioStreamD0Ev+0x98>
    7a8c:	e59f3020 	ldr	r3, [pc, #32]	; 7ab4 <_ZN15Cyg_StdioStreamD0Ev+0xa4>
    7a90:	e1a00004 	mov	r0, r4
    7a94:	e5843000 	str	r3, [r4]
    7a98:	eb0018f9 	bl	de84 <_ZdlPv>
    7a9c:	e1a00004 	mov	r0, r4
    7aa0:	e28dd004 	add	sp, sp, #4	; 0x4
    7aa4:	e8bd8030 	pop	{r4, r5, pc}
        free( buffer_bottom );
    7aa8:	eb001df0 	bl	f270 <free>
    7aac:	eafffff6 	b	7a8c <_ZN15Cyg_StdioStreamD0Ev+0x7c>
    7ab0:	00012a78 	.word	0x00012a78
    7ab4:	00012a90 	.word	0x00012a90

00007ab8 <_ZN15Cyg_StdioStream5writeEPKhjPj>:


Cyg_ErrNo
Cyg_StdioStream::write( const cyg_uint8 *buffer,
                        cyg_ucount32 buffer_length,
                        cyg_ucount32 *bytes_written )
    7ab8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    7abc:	e1a08003 	mov	r8, r3
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    7ac0:	e2809030 	add	r9, r0, #48	; 0x30
{
    Cyg_ErrNo write_err = ENOERR;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    *bytes_written = 0;
    7ac4:	e3a03000 	mov	r3, #0	; 0x0


Cyg_ErrNo
Cyg_StdioStream::write( const cyg_uint8 *buffer,
                        cyg_ucount32 buffer_length,
                        cyg_ucount32 *bytes_written )
    7ac8:	e24dd008 	sub	sp, sp, #8	; 0x8
    7acc:	e1a05000 	mov	r5, r0
{
    Cyg_ErrNo write_err = ENOERR;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    *bytes_written = 0;
    7ad0:	e5883000 	str	r3, [r8]
    7ad4:	e1a00009 	mov	r0, r9


Cyg_ErrNo
Cyg_StdioStream::write( const cyg_uint8 *buffer,
                        cyg_ucount32 buffer_length,
                        cyg_ucount32 *bytes_written )
    7ad8:	e1a06001 	mov	r6, r1
    7adc:	e1a07002 	mov	r7, r2
    7ae0:	ebfffd1b 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    *bytes_written = 0;

    if (!lock_me())
    7ae4:	e3500000 	cmp	r0, #0	; 0x0
    7ae8:	03a04009 	moveq	r4, #9	; 0x9
    7aec:	0a000049 	beq	7c18 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x160>
        return EBADF;  // assume file is now invalid

    // first just check that we _can_ write to the device!
    if ( !flags.opened_for_write ) {
    7af0:	e5d52028 	ldrb	r2, [r5, #40]
    7af4:	e3120004 	tst	r2, #4	; 0x4
    7af8:	0a000049 	beq	7c24 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x16c>
        unlock_me();
        return EINVAL;
    }

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.last_buffer_op_was_read == true) {
    7afc:	e1b033a2 	lsrs	r3, r2, #7


inline void
Cyg_StdioStreamBuffer::drain_buffer( void )
{
    buffer_top = current_buffer_position = &buffer_bottom[0];
    7b00:	15953014 	ldrne	r3, [r5, #20]
    7b04:	1585301c 	strne	r3, [r5, #28]
    7b08:	15853020 	strne	r3, [r5, #32]
#else
        io_buf.drain_buffer();  // nuke input bytes to prevent confusion
#endif
    }

    flags.last_buffer_op_was_read = false;
    7b0c:	e3c23080 	bic	r3, r2, #128	; 0x80
    7b10:	e5c53028 	strb	r3, [r5, #40]

    if (!flags.buffering) {
    7b14:	e5d52028 	ldrb	r2, [r5, #40]
    7b18:	e3120020 	tst	r2, #32	; 0x20
    7b1c:	0a000033 	beq	7bf0 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x138>
        cyg_ucount32 bytes_to_write;
        cyg_ucount32 newline_pos;
        cyg_uint8 *write_addr;
        cyg_bool must_flush = false;
        
        while ( buffer_length > 0 ) {
    7b20:	e3570000 	cmp	r7, #0	; 0x0
    7b24:	1595001c 	ldrne	r0, [r5, #28]
#endif
        cyg_uint32 len = buffer_length;

        write_err = cyg_stdio_write(my_device, buffer, &len);

        *bytes_written = len;
    7b28:	13a0a000 	movne	sl, #0	; 0x0
        cyg_ucount32 bytes_to_write;
        cyg_ucount32 newline_pos;
        cyg_uint8 *write_addr;
        cyg_bool must_flush = false;
        
        while ( buffer_length > 0 ) {
    7b2c:	0a000052 	beq	7c7c <_ZN15Cyg_StdioStream5writeEPKhjPj+0x1c4>


inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_write( cyg_uint8 **buffer )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    7b30:	e5953014 	ldr	r3, [r5, #20]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    7b34:	e3530000 	cmp	r3, #0	; 0x0
    7b38:	15952018 	ldrne	r2, [r5, #24]
    7b3c:	03e02000 	mvneq	r2, #0	; 0x0
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    
    *buffer = buffer_top;
    
    return (buffer_max - buffer_top);
    7b40:	e0832002 	add	r2, r3, r2
            bytes_available =
                io_buf.get_buffer_addr_to_write( &write_addr );
            
            // we need to flush if we've no room or the buffer has an up
            // and coming newline
            if ( !bytes_available || must_flush ) {
    7b44:	e1500002 	cmp	r0, r2
    7b48:	11a0300a 	movne	r3, sl
    7b4c:	038a3001 	orreq	r3, sl, #1	; 0x1
    7b50:	e3530000 	cmp	r3, #0	; 0x0
    7b54:	e0602002 	rsb	r2, r0, r2
    7b58:	1a000035 	bne	7c34 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x17c>
                : buffer_length;
        
            // if we're line buffered, we may want want to flush if there's
            // a newline character, so lets find out
        
            if (flags.line_buffering) {
    7b5c:	e5d53028 	ldrb	r3, [r5, #40]
                            "write buffer" );
            } // if
            
            if (write_err) {
                unlock_me();
                return write_err;
    7b60:	e1520007 	cmp	r2, r7
    7b64:	31a04002 	movcc	r4, r2
    7b68:	21a04007 	movcs	r4, r7
                : buffer_length;
        
            // if we're line buffered, we may want want to flush if there's
            // a newline character, so lets find out
        
            if (flags.line_buffering) {
    7b6c:	e3130040 	tst	r3, #64	; 0x40
    7b70:	0a00000e 	beq	7bb0 <_ZN15Cyg_StdioStream5writeEPKhjPj+0xf8>
                for (newline_pos=0;
    7b74:	e3540000 	cmp	r4, #0	; 0x0
    7b78:	0a00000c 	beq	7bb0 <_ZN15Cyg_StdioStream5writeEPKhjPj+0xf8>
                     newline_pos<bytes_to_write;
                     newline_pos++) {
                    if (buffer[newline_pos] == '\n') {
    7b7c:	e5d63000 	ldrb	r3, [r6]
    7b80:	e353000a 	cmp	r3, #10	; 0xa
    7b84:	13a02000 	movne	r2, #0	; 0x0
    7b88:	1a000003 	bne	7b9c <_ZN15Cyg_StdioStream5writeEPKhjPj+0xe4>
    7b8c:	ea000040 	b	7c94 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x1dc>
    7b90:	e7d63002 	ldrb	r3, [r6, r2]
    7b94:	e353000a 	cmp	r3, #10	; 0xa
    7b98:	0a000032 	beq	7c68 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x1b0>
        
            // if we're line buffered, we may want want to flush if there's
            // a newline character, so lets find out
        
            if (flags.line_buffering) {
                for (newline_pos=0;
    7b9c:	e2822001 	add	r2, r2, #1	; 0x1
    7ba0:	e1520004 	cmp	r2, r4
    7ba4:	3afffff9 	bcc	7b90 <_ZN15Cyg_StdioStream5writeEPKhjPj+0xd8>
                    if (buffer[newline_pos] == '\n') {
                        break;
                    } // if
                } // for
                // if we didn't reach the end
                if (newline_pos != bytes_to_write) {
    7ba8:	e1540002 	cmp	r4, r2
    7bac:	1a00002d 	bne	7c68 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x1b0>
                    bytes_to_write = newline_pos + 1;
                    must_flush = true;
                } // if
            } // if
            
            memcpy( write_addr, buffer, bytes_to_write );
    7bb0:	e1a01006 	mov	r1, r6
    7bb4:	e1a02004 	mov	r2, r4
    7bb8:	eb00186b 	bl	dd6c <_memcpy>
            
            *bytes_written += bytes_to_write;
    7bbc:	e5983000 	ldr	r3, [r8]
    7bc0:	e0833004 	add	r3, r3, r4
    7bc4:	e5883000 	str	r3, [r8]


inline void
Cyg_StdioStreamBuffer::set_bytes_written( cyg_ucount32 bytes )
{
    buffer_top += bytes;
    7bc8:	e595001c 	ldr	r0, [r5, #28]
            buffer += bytes_to_write;
            buffer_length -= bytes_to_write;
            io_buf.set_bytes_written( bytes_to_write );

            position += bytes_to_write;
    7bcc:	e595302c 	ldr	r3, [r5, #44]
    7bd0:	e0800004 	add	r0, r0, r4
    7bd4:	e0833004 	add	r3, r3, r4
        cyg_ucount32 bytes_to_write;
        cyg_ucount32 newline_pos;
        cyg_uint8 *write_addr;
        cyg_bool must_flush = false;
        
        while ( buffer_length > 0 ) {
    7bd8:	e0577004 	subs	r7, r7, r4
            *bytes_written += bytes_to_write;
            buffer += bytes_to_write;
            buffer_length -= bytes_to_write;
            io_buf.set_bytes_written( bytes_to_write );

            position += bytes_to_write;
    7bdc:	e585302c 	str	r3, [r5, #44]
    7be0:	e585001c 	str	r0, [r5, #28]
        cyg_ucount32 bytes_to_write;
        cyg_ucount32 newline_pos;
        cyg_uint8 *write_addr;
        cyg_bool must_flush = false;
        
        while ( buffer_length > 0 ) {
    7be4:	0a000022 	beq	7c74 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x1bc>
            } // if
            
            memcpy( write_addr, buffer, bytes_to_write );
            
            *bytes_written += bytes_to_write;
            buffer += bytes_to_write;
    7be8:	e0866004 	add	r6, r6, r4
    7bec:	eaffffcf 	b	7b30 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x78>

    flags.last_buffer_op_was_read = false;

    if (!flags.buffering) {
#endif
        cyg_uint32 len = buffer_length;
    7bf0:	e28d2008 	add	r2, sp, #8	; 0x8
    7bf4:	e5227004 	str	r7, [r2, #-4]!
}

inline Cyg_ErrNo cyg_stdio_write( cyg_stdio_handle_t dev,
                                 const void *buffer, cyg_uint32 *len )
{
    return cyg_io_write( dev, buffer, len );    
    7bf8:	e5950008 	ldr	r0, [r5, #8]
    7bfc:	e1a01006 	mov	r1, r6
    7c00:	ebffe81a 	bl	1c70 <cyg_io_write>

        write_err = cyg_stdio_write(my_device, buffer, &len);

        *bytes_written = len;
    7c04:	e59d3004 	ldr	r3, [sp, #4]
    7c08:	e5883000 	str	r3, [r8]
    7c0c:	e1a04000 	mov	r4, r0
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7c10:	e1a00009 	mov	r0, r9
    7c14:	ebfffdc6 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
#endif // ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    unlock_me();

    return write_err;
} // write()
    7c18:	e1a00004 	mov	r0, r4
    7c1c:	e28dd008 	add	sp, sp, #8	; 0x8
    7c20:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    7c24:	e1a00009 	mov	r0, r9
    7c28:	ebfffdc1 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7c2c:	e3a04016 	mov	r4, #22	; 0x16
    7c30:	eafffff8 	b	7c18 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x160>
                io_buf.get_buffer_addr_to_write( &write_addr );
            
            // we need to flush if we've no room or the buffer has an up
            // and coming newline
            if ( !bytes_available || must_flush ) {
                write_err = flush_output_unlocked();
    7c34:	e1a00005 	mov	r0, r5
    7c38:	ebffff51 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>


inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_write( cyg_uint8 **buffer )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    7c3c:	e5953014 	ldr	r3, [r5, #20]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    7c40:	e3530000 	cmp	r3, #0	; 0x0
    7c44:	03e02000 	mvneq	r2, #0	; 0x0
    7c48:	15952018 	ldrne	r2, [r5, #24]
                CYG_ASSERT( bytes_available > 0,
                            "Help! still no bytes available in "
                            "write buffer" );
            } // if
            
            if (write_err) {
    7c4c:	e3500000 	cmp	r0, #0	; 0x0
                io_buf.get_buffer_addr_to_write( &write_addr );
            
            // we need to flush if we've no room or the buffer has an up
            // and coming newline
            if ( !bytes_available || must_flush ) {
                write_err = flush_output_unlocked();
    7c50:	e1a04000 	mov	r4, r0
inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_write( cyg_uint8 **buffer )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    
    *buffer = buffer_top;
    7c54:	e595001c 	ldr	r0, [r5, #28]
                CYG_ASSERT( bytes_available > 0,
                            "Help! still no bytes available in "
                            "write buffer" );
            } // if
            
            if (write_err) {
    7c58:	1affffec 	bne	7c10 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x158>
    
    return (buffer_max - buffer_top);
    7c5c:	e0833002 	add	r3, r3, r2
    7c60:	e0602003 	rsb	r2, r0, r3
    7c64:	eaffffbc 	b	7b5c <_ZN15Cyg_StdioStream5writeEPKhjPj+0xa4>
                    if (buffer[newline_pos] == '\n') {
                        break;
                    } // if
                } // for
                // if we didn't reach the end
                if (newline_pos != bytes_to_write) {
    7c68:	e2824001 	add	r4, r2, #1	; 0x1
    7c6c:	e3a0a001 	mov	sl, #1	; 0x1
    7c70:	eaffffce 	b	7bb0 <_ZN15Cyg_StdioStream5writeEPKhjPj+0xf8>

            position += bytes_to_write;
            
        } // while
        
        if ( must_flush ) {
    7c74:	e35a0000 	cmp	sl, #0	; 0x0
    7c78:	1a000001 	bne	7c84 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x1cc>
            write_err = flush_output_unlocked();
    7c7c:	e3a04000 	mov	r4, #0	; 0x0
    7c80:	eaffffe2 	b	7c10 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x158>
    7c84:	e1a00005 	mov	r0, r5
    7c88:	ebffff3d 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>
    7c8c:	e1a04000 	mov	r4, r0
    7c90:	eaffffde 	b	7c10 <_ZN15Cyg_StdioStream5writeEPKhjPj+0x158>
    7c94:	e3a04001 	mov	r4, #1	; 0x1
                    if (buffer[newline_pos] == '\n') {
                        break;
                    } // if
                } // for
                // if we didn't reach the end
                if (newline_pos != bytes_to_write) {
    7c98:	e3a0a001 	mov	sl, #1	; 0x1
    7c9c:	eaffffc3 	b	7bb0 <_ZN15Cyg_StdioStream5writeEPKhjPj+0xf8>

00007ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>:
    return err;
} // read_byte()


Cyg_ErrNo
Cyg_StdioStream::peek_byte( cyg_uint8 *c )
    7ca0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    7ca4:	e2806030 	add	r6, r0, #48	; 0x30
    7ca8:	e24dd004 	sub	sp, sp, #4	; 0x4
    7cac:	e1a05000 	mov	r5, r0
    7cb0:	e1a00006 	mov	r0, r6
    7cb4:	e1a07001 	mov	r7, r1
    7cb8:	ebfffca5 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
{
    Cyg_ErrNo err=ENOERR;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    7cbc:	e3500000 	cmp	r0, #0	; 0x0
    7cc0:	03a04009 	moveq	r4, #9	; 0x9
    7cc4:	0a000016 	beq	7d24 <_ZN15Cyg_StdioStream9peek_byteEPh+0x84>
        return EBADF;  // assume file is now invalid

    if (!flags.opened_for_read) {
    7cc8:	e5d53028 	ldrb	r3, [r5, #40]
    7ccc:	e3130002 	tst	r3, #2	; 0x2
    7cd0:	0a000016 	beq	7d30 <_ZN15Cyg_StdioStream9peek_byteEPh+0x90>
    }

    // this should really only be called after refill_read_buffer, but just
    // in case
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering)
    7cd4:	e3130020 	tst	r3, #32	; 0x20
    7cd8:	1a000018 	bne	7d40 <_ZN15Cyg_StdioStream9peek_byteEPh+0xa0>

    if (err != ENOERR)
        return err;

    // we're now reading
    flags.last_buffer_op_was_read = true;
    7cdc:	e3833080 	orr	r3, r3, #128	; 0x80
    7ce0:	e5c53028 	strb	r3, [r5, #40]
#endif

# ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use) {
    7ce4:	e5d52028 	ldrb	r2, [r5, #40]
    7ce8:	e1a03222 	lsr	r3, r2, #4
    7cec:	e2131001 	ands	r1, r3, #1	; 0x1
    7cf0:	1a000020 	bne	7d78 <_ZN15Cyg_StdioStream9peek_byteEPh+0xd8>
        return ENOERR;
    } // if
# endif // ifdef CYGFUN_LIBC_STDIO_ungetc

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering) {
    7cf4:	e1a032a2 	lsr	r3, r2, #5
    7cf8:	e2130001 	ands	r0, r3, #1	; 0x1
    7cfc:	0a000015 	beq	7d58 <_ZN15Cyg_StdioStream9peek_byteEPh+0xb8>
        cyg_uint8 *buff_to_read_from;
        cyg_ucount32 bytes_available;
    
        bytes_available=io_buf.get_buffer_addr_to_read(&buff_to_read_from);

        if (bytes_available) {
    7d00:	e595301c 	ldr	r3, [r5, #28]


inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_read( cyg_uint8 **buffer )
{
    *buffer = current_buffer_position;
    7d04:	e5950020 	ldr	r0, [r5, #32]
    7d08:	e1500003 	cmp	r0, r3
    7d0c:	0a000017 	beq	7d70 <_ZN15Cyg_StdioStream9peek_byteEPh+0xd0>
            *c = *buff_to_read_from;
    7d10:	e5d03000 	ldrb	r3, [r0]
    7d14:	e5c73000 	strb	r3, [r7]
    7d18:	e1a04001 	mov	r4, r1
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7d1c:	e1a00006 	mov	r0, r6
    7d20:	ebfffd83 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        err = EAGAIN;

    unlock_me();

    return err;
} // peek_byte()
    7d24:	e1a00004 	mov	r0, r4
    7d28:	e28dd004 	add	sp, sp, #4	; 0x4
    7d2c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    7d30:	e1a00006 	mov	r0, r6
    7d34:	ebfffd7e 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7d38:	e3a04016 	mov	r4, #22	; 0x16
    7d3c:	eafffff8 	b	7d24 <_ZN15Cyg_StdioStream9peek_byteEPh+0x84>

    // this should really only be called after refill_read_buffer, but just
    // in case
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering)
        err = flush_output_unlocked();
    7d40:	e1a00005 	mov	r0, r5
    7d44:	ebffff0e 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

    if (err != ENOERR)
    7d48:	e2504000 	subs	r4, r0, #0	; 0x0
    7d4c:	1afffff4 	bne	7d24 <_ZN15Cyg_StdioStream9peek_byteEPh+0x84>
    7d50:	e5d53028 	ldrb	r3, [r5, #40]
    7d54:	eaffffe0 	b	7cdc <_ZN15Cyg_StdioStream9peek_byteEPh+0x3c>
    else
    
#endif


    if (flags.readbuf_char_in_use) {
    7d58:	e5d53029 	ldrb	r3, [r5, #41]
    7d5c:	e3130001 	tst	r3, #1	; 0x1
        *c = readbuf_char;
    7d60:	15d53024 	ldrbne	r3, [r5, #36]
    7d64:	11a04000 	movne	r4, r0
    7d68:	15c73000 	strbne	r3, [r7]
    7d6c:	1affffea 	bne	7d1c <_ZN15Cyg_StdioStream9peek_byteEPh+0x7c>
    7d70:	e3a0400b 	mov	r4, #11	; 0xb
    7d74:	eaffffe8 	b	7d1c <_ZN15Cyg_StdioStream9peek_byteEPh+0x7c>
    flags.last_buffer_op_was_read = true;
#endif

# ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use) {
        *c = unread_char_buf;
    7d78:	e5d5300c 	ldrb	r3, [r5, #12]
    7d7c:	e1a00006 	mov	r0, r6
    7d80:	e5c73000 	strb	r3, [r7]
    7d84:	ebfffd6a 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7d88:	e3a04000 	mov	r4, #0	; 0x0
    7d8c:	eaffffe4 	b	7d24 <_ZN15Cyg_StdioStream9peek_byteEPh+0x84>

00007d90 <_ZN15Cyg_StdioStream9read_byteEPh>:
    return read_err;
} // read()


Cyg_ErrNo
Cyg_StdioStream::read_byte( cyg_uint8 *c )
    7d90:	e92d40f0 	push	{r4, r5, r6, r7, lr}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    7d94:	e2807030 	add	r7, r0, #48	; 0x30
    7d98:	e24dd004 	sub	sp, sp, #4	; 0x4
    7d9c:	e1a05000 	mov	r5, r0
    7da0:	e1a00007 	mov	r0, r7
    7da4:	e1a06001 	mov	r6, r1
    7da8:	ebfffc69 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
{
    Cyg_ErrNo err=ENOERR;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    7dac:	e3500000 	cmp	r0, #0	; 0x0
    7db0:	03a04009 	moveq	r4, #9	; 0x9
    7db4:	0a00002d 	beq	7e70 <_ZN15Cyg_StdioStream9read_byteEPh+0xe0>
        return EBADF;  // assume file is now invalid

    if (!flags.opened_for_read) {
    7db8:	e5d52028 	ldrb	r2, [r5, #40]
    7dbc:	e3120002 	tst	r2, #2	; 0x2
    7dc0:	0a00002d 	beq	7e7c <_ZN15Cyg_StdioStream9read_byteEPh+0xec>
        unlock_me();
        return EINVAL;
    }

# ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use) {
    7dc4:	e3120010 	tst	r2, #16	; 0x10
    7dc8:	1a00002f 	bne	7e8c <_ZN15Cyg_StdioStream9read_byteEPh+0xfc>
        return ENOERR;
    } // if
# endif // ifdef CYGFUN_LIBC_STDIO_ungetc

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering) {
    7dcc:	e1a032a2 	lsr	r3, r2, #5
    7dd0:	e2130001 	ands	r0, r3, #1	; 0x1
    7dd4:	0a000017 	beq	7e38 <_ZN15Cyg_StdioStream9read_byteEPh+0xa8>
        // need to flush output if we were writing before
        if (!flags.last_buffer_op_was_read)
    7dd8:	e1b023a2 	lsrs	r2, r2, #7
    7ddc:	0a000038 	beq	7ec4 <_ZN15Cyg_StdioStream9read_byteEPh+0x134>
    7de0:	e5952020 	ldr	r2, [r5, #32]
        cyg_uint8 *buff_to_read_from;
        cyg_ucount32 bytes_available;
    
        bytes_available=io_buf.get_buffer_addr_to_read(&buff_to_read_from);

        if (bytes_available) {
    7de4:	e595301c 	ldr	r3, [r5, #28]
    7de8:	e1520003 	cmp	r2, r3
    7dec:	0a000032 	beq	7ebc <_ZN15Cyg_StdioStream9read_byteEPh+0x12c>
            *c = *buff_to_read_from;
    7df0:	e5d23000 	ldrb	r3, [r2]
    7df4:	e5c63000 	strb	r3, [r6]
} // get_buffer_addr_to_read()

inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    7df8:	e5951014 	ldr	r1, [r5, #20]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    7dfc:	e3510000 	cmp	r1, #0	; 0x0
inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];

    current_buffer_position += bytes;
    7e00:	e5953020 	ldr	r3, [r5, #32]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    7e04:	15952018 	ldrne	r2, [r5, #24]
    7e08:	03e02000 	mvneq	r2, #0	; 0x0
inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];

    current_buffer_position += bytes;
    7e0c:	e2833001 	add	r3, r3, #1	; 0x1
    // INT_MAX is used by some callers to mean infinite.
    CYG_ASSERT( (current_buffer_position <= buffer_top)
                || (get_buffer_size() == INT_MAX),
                "read too many bytes from buffer" );

    if (current_buffer_position == buffer_max)
    7e10:	e0812002 	add	r2, r1, r2
    7e14:	e1530002 	cmp	r3, r2
inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];

    current_buffer_position += bytes;
    7e18:	e5853020 	str	r3, [r5, #32]
            io_buf.set_bytes_read(1);
            position++;
    7e1c:	e595302c 	ldr	r3, [r5, #44]
    7e20:	e2833001 	add	r3, r3, #1	; 0x1
    CYG_ASSERT( (current_buffer_position <= buffer_top)
                || (get_buffer_size() == INT_MAX),
                "read too many bytes from buffer" );

    if (current_buffer_position == buffer_max)
        current_buffer_position = buffer_top = &buffer_bottom[0];
    7e24:	05851020 	streq	r1, [r5, #32]
    7e28:	0585101c 	streq	r1, [r5, #28]
    7e2c:	e585302c 	str	r3, [r5, #44]
    7e30:	e3a04000 	mov	r4, #0	; 0x0
    7e34:	ea00000b 	b	7e68 <_ZN15Cyg_StdioStream9read_byteEPh+0xd8>
    else
    
#endif


    if (flags.readbuf_char_in_use) {
    7e38:	e5d53029 	ldrb	r3, [r5, #41]
    7e3c:	e3130001 	tst	r3, #1	; 0x1
    7e40:	0a00001d 	beq	7ebc <_ZN15Cyg_StdioStream9read_byteEPh+0x12c>
        *c = readbuf_char;
    7e44:	e5d53024 	ldrb	r3, [r5, #36]
    7e48:	e5c63000 	strb	r3, [r6]
        flags.readbuf_char_in_use = false;
    7e4c:	e5d52029 	ldrb	r2, [r5, #41]
        position++;
    7e50:	e595302c 	ldr	r3, [r5, #44]
#endif


    if (flags.readbuf_char_in_use) {
        *c = readbuf_char;
        flags.readbuf_char_in_use = false;
    7e54:	e3c22001 	bic	r2, r2, #1	; 0x1
        position++;
    7e58:	e2833001 	add	r3, r3, #1	; 0x1
    7e5c:	e585302c 	str	r3, [r5, #44]
#endif


    if (flags.readbuf_char_in_use) {
        *c = readbuf_char;
        flags.readbuf_char_in_use = false;
    7e60:	e5c52029 	strb	r2, [r5, #41]
        position++;
    7e64:	e1a04000 	mov	r4, r0
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7e68:	e1a00007 	mov	r0, r7
    7e6c:	ebfffd30 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        err = EAGAIN;

    unlock_me();

    return err;
} // read_byte()
    7e70:	e1a00004 	mov	r0, r4
    7e74:	e28dd004 	add	sp, sp, #4	; 0x4
    7e78:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    7e7c:	e1a00007 	mov	r0, r7
    7e80:	ebfffd2b 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7e84:	e3a04016 	mov	r4, #22	; 0x16
    7e88:	eafffff8 	b	7e70 <_ZN15Cyg_StdioStream9read_byteEPh+0xe0>
        return EINVAL;
    }

# ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use) {
        *c = unread_char_buf;
    7e8c:	e5d5300c 	ldrb	r3, [r5, #12]
    7e90:	e5c63000 	strb	r3, [r6]
        flags.unread_char_buf_in_use = false;
    7e94:	e5d52028 	ldrb	r2, [r5, #40]
        position++;
    7e98:	e595302c 	ldr	r3, [r5, #44]
    }

# ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use) {
        *c = unread_char_buf;
        flags.unread_char_buf_in_use = false;
    7e9c:	e3c22010 	bic	r2, r2, #16	; 0x10
        position++;
    7ea0:	e2833001 	add	r3, r3, #1	; 0x1
    7ea4:	e585302c 	str	r3, [r5, #44]
    }

# ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use) {
        *c = unread_char_buf;
        flags.unread_char_buf_in_use = false;
    7ea8:	e5c52028 	strb	r2, [r5, #40]
    7eac:	e1a00007 	mov	r0, r7
    7eb0:	ebfffd1f 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7eb4:	e3a04000 	mov	r4, #0	; 0x0
    7eb8:	eaffffec 	b	7e70 <_ZN15Cyg_StdioStream9read_byteEPh+0xe0>


    if (flags.readbuf_char_in_use) {
        *c = readbuf_char;
        flags.readbuf_char_in_use = false;
        position++;
    7ebc:	e3a0400b 	mov	r4, #11	; 0xb
    7ec0:	eaffffe8 	b	7e68 <_ZN15Cyg_StdioStream9read_byteEPh+0xd8>

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering) {
        // need to flush output if we were writing before
        if (!flags.last_buffer_op_was_read)
            err = flush_output_unlocked();
    7ec4:	e1a00005 	mov	r0, r5
    7ec8:	ebfffead 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        if (ENOERR != err) {
    7ecc:	e2504000 	subs	r4, r0, #0	; 0x0
    7ed0:	1affffe4 	bne	7e68 <_ZN15Cyg_StdioStream9read_byteEPh+0xd8>
    7ed4:	eaffffc1 	b	7de0 <_ZN15Cyg_StdioStream9read_byteEPh+0x50>

00007ed8 <_ZN15Cyg_StdioStream4readEPhjPj>:
} // refill_read_buffer()


Cyg_ErrNo
Cyg_StdioStream::read( cyg_uint8 *user_buffer, cyg_ucount32 buffer_length,
                       cyg_ucount32 *bytes_read )
    7ed8:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    7edc:	e1a06003 	mov	r6, r3
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    7ee0:	e2808030 	add	r8, r0, #48	; 0x30
{
    Cyg_ErrNo read_err=ENOERR;
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    *bytes_read = 0;
    7ee4:	e3a03000 	mov	r3, #0	; 0x0
} // refill_read_buffer()


Cyg_ErrNo
Cyg_StdioStream::read( cyg_uint8 *user_buffer, cyg_ucount32 buffer_length,
                       cyg_ucount32 *bytes_read )
    7ee8:	e24dd00c 	sub	sp, sp, #12	; 0xc
    7eec:	e1a05000 	mov	r5, r0
{
    Cyg_ErrNo read_err=ENOERR;
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    *bytes_read = 0;
    7ef0:	e5863000 	str	r3, [r6]
    7ef4:	e1a00008 	mov	r0, r8
} // refill_read_buffer()


Cyg_ErrNo
Cyg_StdioStream::read( cyg_uint8 *user_buffer, cyg_ucount32 buffer_length,
                       cyg_ucount32 *bytes_read )
    7ef8:	e1a0a001 	mov	sl, r1
    7efc:	e1a07002 	mov	r7, r2
    7f00:	ebfffc13 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    Cyg_ErrNo read_err=ENOERR;
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    *bytes_read = 0;

    if (!lock_me())
    7f04:	e3500000 	cmp	r0, #0	; 0x0
    7f08:	03a04009 	moveq	r4, #9	; 0x9
    7f0c:	0a00002d 	beq	7fc8 <_ZN15Cyg_StdioStream4readEPhjPj+0xf0>
        return EBADF;  // assume file is now invalid

    if (!flags.opened_for_read) {
    7f10:	e5d52028 	ldrb	r2, [r5, #40]
    7f14:	e3120002 	tst	r2, #2	; 0x2
    7f18:	0a00002d 	beq	7fd4 <_ZN15Cyg_StdioStream4readEPhjPj+0xfc>
        unlock_me();
        return EINVAL;
    }

#ifdef CYGFUN_LIBC_STDIO_ungetc
    if (flags.unread_char_buf_in_use && buffer_length) {
    7f1c:	e2573000 	subs	r3, r7, #0	; 0x0
    7f20:	13a03001 	movne	r3, #1	; 0x1
    7f24:	e0133222 	ands	r3, r3, r2, lsr #4
    7f28:	0a000009 	beq	7f54 <_ZN15Cyg_StdioStream4readEPhjPj+0x7c>
        *user_buffer++ = unread_char_buf;
    7f2c:	e5d5300c 	ldrb	r3, [r5, #12]
    7f30:	e4ca3001 	strb	r3, [sl], #1
        ++*bytes_read;
    7f34:	e5962000 	ldr	r2, [r6]
    7f38:	e2822001 	add	r2, r2, #1	; 0x1
    7f3c:	e5862000 	str	r2, [r6]
        flags.unread_char_buf_in_use = false;
    7f40:	e5d53028 	ldrb	r3, [r5, #40]
    7f44:	e3c33010 	bic	r3, r3, #16	; 0x10
    7f48:	e5c53028 	strb	r3, [r5, #40]
    7f4c:	e5d52028 	ldrb	r2, [r5, #40]
        --buffer_length;
    7f50:	e2477001 	sub	r7, r7, #1	; 0x1
    } // if

#endif // ifdef CYGFUN_LIBC_STDIO_ungetc

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering) {
    7f54:	e3120020 	tst	r2, #32	; 0x20
    7f58:	1a000021 	bne	7fe4 <_ZN15Cyg_StdioStream4readEPhjPj+0x10c>
    } // if
    else
        
#endif

    if (flags.readbuf_char_in_use && buffer_length) {
    7f5c:	e5d53029 	ldrb	r3, [r5, #41]
    7f60:	e3570000 	cmp	r7, #0	; 0x0
    7f64:	03a03000 	moveq	r3, #0	; 0x0
    7f68:	12033001 	andne	r3, r3, #1	; 0x1
    7f6c:	e3530000 	cmp	r3, #0	; 0x0
    7f70:	05961000 	ldreq	r1, [r6]
    7f74:	01a02001 	moveq	r2, r1
    7f78:	0a000037 	beq	805c <_ZN15Cyg_StdioStream4readEPhjPj+0x184>
        *user_buffer = readbuf_char;
    7f7c:	e5d53024 	ldrb	r3, [r5, #36]
        *bytes_read = 1;
    7f80:	e3a02001 	mov	r2, #1	; 0x1
    else
        
#endif

    if (flags.readbuf_char_in_use && buffer_length) {
        *user_buffer = readbuf_char;
    7f84:	e5ca3000 	strb	r3, [sl]
        *bytes_read = 1;
    7f88:	e5862000 	str	r2, [r6]
        flags.readbuf_char_in_use = false;
    7f8c:	e5d53029 	ldrb	r3, [r5, #41]
    7f90:	e3c33001 	bic	r3, r3, #1	; 0x1
    7f94:	e5c53029 	strb	r3, [r5, #41]
    7f98:	e5961000 	ldr	r1, [r6]
    7f9c:	e1a02001 	mov	r2, r1
    // if we are unbuffered, we read as much as we can directly from the 
    // file system at this point.
    //
    // unless we do this, we could end up reading byte-by-byte from the filing system
    // due to the readbuf_char scheme.
    if (
    7fa0:	e5d53028 	ldrb	r3, [r5, #40]
    7fa4:	e3130020 	tst	r3, #32	; 0x20
    7fa8:	11a02001 	movne	r2, r1
    7fac:	13a04000 	movne	r4, #0	; 0x0
    7fb0:	0a000029 	beq	805c <_ZN15Cyg_StdioStream4readEPhjPj+0x184>
        len=buffer_length-*bytes_read;
        read_err = cyg_stdio_read(my_device, user_buffer + *bytes_read, &len);      
        *bytes_read+=len;
    }
    
    position += *bytes_read;
    7fb4:	e595302c 	ldr	r3, [r5, #44]
    7fb8:	e0833002 	add	r3, r3, r2
    7fbc:	e585302c 	str	r3, [r5, #44]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    7fc0:	e1a00008 	mov	r0, r8
    7fc4:	ebfffcda 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    
    unlock_me();

    return read_err;
} // read()
    7fc8:	e1a00004 	mov	r0, r4
    7fcc:	e28dd00c 	add	sp, sp, #12	; 0xc
    7fd0:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    7fd4:	e1a00008 	mov	r0, r8
    7fd8:	ebfffcd5 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    7fdc:	e3a04016 	mov	r4, #22	; 0x16
    7fe0:	eafffff8 	b	7fc8 <_ZN15Cyg_StdioStream4readEPhjPj+0xf0>

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering) {

        // need to flush output if we were writing before
        if (!flags.last_buffer_op_was_read) {
    7fe4:	e1b023a2 	lsrs	r2, r2, #7
    7fe8:	0a00002a 	beq	8098 <_ZN15Cyg_StdioStream4readEPhjPj+0x1c0>


inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_read( cyg_uint8 **buffer )
{
    *buffer = current_buffer_position;
    7fec:	e285201c 	add	r2, r5, #28	; 0x1c
    7ff0:	e892000c 	ldm	r2, {r2, r3}
    7ff4:	e0423003 	sub	r3, r2, r3
    7ff8:	e1570003 	cmp	r7, r3
    7ffc:	31a04007 	movcc	r4, r7
    8000:	21a04003 	movcs	r4, r3
              (cyg_uint8 **)&buff_to_read_from );
        
        cyg_ucount32 count =
            (bytes_available < buffer_length) ? bytes_available : buffer_length;

        if (count) {
    8004:	e3540000 	cmp	r4, #0	; 0x0
    8008:	e5951020 	ldr	r1, [r5, #32]
    800c:	0affffe1 	beq	7f98 <_ZN15Cyg_StdioStream4readEPhjPj+0xc0>
            memcpy( user_buffer, buff_to_read_from, count );
    8010:	e1a02004 	mov	r2, r4
    8014:	e1a0000a 	mov	r0, sl
    8018:	eb001753 	bl	dd6c <_memcpy>
} // get_buffer_addr_to_read()

inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    801c:	e5951014 	ldr	r1, [r5, #20]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    8020:	e3510000 	cmp	r1, #0	; 0x0
    8024:	15952018 	ldrne	r2, [r5, #24]
inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];

    current_buffer_position += bytes;
    8028:	e5953020 	ldr	r3, [r5, #32]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    802c:	03e02000 	mvneq	r2, #0	; 0x0
    // INT_MAX is used by some callers to mean infinite.
    CYG_ASSERT( (current_buffer_position <= buffer_top)
                || (get_buffer_size() == INT_MAX),
                "read too many bytes from buffer" );

    if (current_buffer_position == buffer_max)
    8030:	e0812002 	add	r2, r1, r2
inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];

    current_buffer_position += bytes;
    8034:	e0833004 	add	r3, r3, r4
    // INT_MAX is used by some callers to mean infinite.
    CYG_ASSERT( (current_buffer_position <= buffer_top)
                || (get_buffer_size() == INT_MAX),
                "read too many bytes from buffer" );

    if (current_buffer_position == buffer_max)
    8038:	e1530002 	cmp	r3, r2
inline void
Cyg_StdioStreamBuffer::set_bytes_read( cyg_ucount32 bytes )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];

    current_buffer_position += bytes;
    803c:	e5853020 	str	r3, [r5, #32]
    CYG_ASSERT( (current_buffer_position <= buffer_top)
                || (get_buffer_size() == INT_MAX),
                "read too many bytes from buffer" );

    if (current_buffer_position == buffer_max)
        current_buffer_position = buffer_top = &buffer_bottom[0];
    8040:	0585101c 	streq	r1, [r5, #28]
    8044:	05851020 	streq	r1, [r5, #32]
            io_buf.set_bytes_read( count );
            *bytes_read += count;
    8048:	e5961000 	ldr	r1, [r6]
    804c:	e0842001 	add	r2, r4, r1
    8050:	e5862000 	str	r2, [r6]
    8054:	e1a01002 	mov	r1, r2
    8058:	eaffffd0 	b	7fa0 <_ZN15Cyg_StdioStream4readEPhjPj+0xc8>
    // if we are unbuffered, we read as much as we can directly from the 
    // file system at this point.
    //
    // unless we do this, we could end up reading byte-by-byte from the filing system
    // due to the readbuf_char scheme.
    if (
    805c:	e1570002 	cmp	r7, r2
    8060:	93a04000 	movls	r4, #0	; 0x0
    8064:	9affffd2 	bls	7fb4 <_ZN15Cyg_StdioStream4readEPhjPj+0xdc>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
        !flags.buffering &&
#endif
        (*bytes_read<buffer_length)) {
        cyg_uint32 len;
        len=buffer_length-*bytes_read;
    8068:	e0623007 	rsb	r3, r2, r7
    806c:	e28d2008 	add	r2, sp, #8	; 0x8
    8070:	e5223004 	str	r3, [r2, #-4]!
}

inline Cyg_ErrNo cyg_stdio_read( cyg_stdio_handle_t dev,
                                 void *buffer, cyg_uint32 *len )
{
    return cyg_io_read( dev, buffer, len );
    8074:	e08a1001 	add	r1, sl, r1
    8078:	e5950008 	ldr	r0, [r5, #8]
    807c:	ebffe70d 	bl	1cb8 <cyg_io_read>
        read_err = cyg_stdio_read(my_device, user_buffer + *bytes_read, &len);      
        *bytes_read+=len;
    8080:	e5962000 	ldr	r2, [r6]
    8084:	e59d3004 	ldr	r3, [sp, #4]
    8088:	e0822003 	add	r2, r2, r3
    808c:	e1a04000 	mov	r4, r0
    8090:	e5862000 	str	r2, [r6]
    8094:	eaffffc6 	b	7fb4 <_ZN15Cyg_StdioStream4readEPhjPj+0xdc>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering) {

        // need to flush output if we were writing before
        if (!flags.last_buffer_op_was_read) {
            Cyg_ErrNo err = flush_output_unlocked();
    8098:	e1a00005 	mov	r0, r5
    809c:	ebfffe38 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

            if (ENOERR != err) {
    80a0:	e2504000 	subs	r4, r0, #0	; 0x0
    80a4:	0affffd0 	beq	7fec <_ZN15Cyg_StdioStream4readEPhjPj+0x114>
    80a8:	eaffffc4 	b	7fc0 <_ZN15Cyg_StdioStream4readEPhjPj+0xe8>

000080ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>:
    }
}


Cyg_ErrNo
Cyg_StdioStream::refill_read_buffer( void )
    80ac:	e92d4070 	push	{r4, r5, r6, lr}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    80b0:	e2806030 	add	r6, r0, #48	; 0x30
    80b4:	e24dd008 	sub	sp, sp, #8	; 0x8
    80b8:	e1a04000 	mov	r4, r0
    80bc:	e1a00006 	mov	r0, r6
    80c0:	ebfffba3 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    cyg_uint8 *buffer;
    cyg_uint32 len;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    80c4:	e3500000 	cmp	r0, #0	; 0x0
    80c8:	03a05009 	moveq	r5, #9	; 0x9
    80cc:	0a000023 	beq	8160 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xb4>
        return EBADF;  // assume file is now invalid

    // first just check that we _can_ read this device!
    if (!flags.opened_for_read) {
    80d0:	e5d43028 	ldrb	r3, [r4, #40]
    80d4:	e3130002 	tst	r3, #2	; 0x2
    80d8:	0a000023 	beq	816c <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xc0>
    }
    
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    // If there is pending output to write, then this will check and
    // write it
    if (flags.buffering) {
    80dc:	e1a032a3 	lsr	r3, r3, #5
    80e0:	e2135001 	ands	r5, r3, #1	; 0x1
    80e4:	1a000024 	bne	817c <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xd0>
        } // if
    }
    else
#endif

    if (!flags.readbuf_char_in_use) {
    80e8:	e5d43029 	ldrb	r3, [r4, #41]
    80ec:	e3130001 	tst	r3, #1	; 0x1
        len = 1;
    80f0:	03a03001 	moveq	r3, #1	; 0x1
    80f4:	058d3004 	streq	r3, [sp, #4]
        buffer = &readbuf_char;
    80f8:	02841024 	addeq	r1, r4, #36	; 0x24
        } // if
    }
    else
#endif

    if (!flags.readbuf_char_in_use) {
    80fc:	1a000025 	bne	8198 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xec>
    8100:	e5940008 	ldr	r0, [r4, #8]
    8104:	e28d2004 	add	r2, sp, #4	; 0x4
    8108:	ebffe6ea 	bl	1cb8 <cyg_io_read>

    read_err = cyg_stdio_read(my_device, buffer, &len);


#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering)
    810c:	e5d43028 	ldrb	r3, [r4, #40]
    8110:	e3130020 	tst	r3, #32	; 0x20
    8114:	e1a05000 	mov	r5, r0
    8118:	0a000021 	beq	81a4 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xf8>


inline void
Cyg_StdioStreamBuffer::set_bytes_written( cyg_ucount32 bytes )
{
    buffer_top += bytes;
    811c:	e594301c 	ldr	r3, [r4, #28]
    8120:	e59d2004 	ldr	r2, [sp, #4]
    8124:	e0833002 	add	r3, r3, r2
    8128:	e584301c 	str	r3, [r4, #28]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    812c:	e1a00006 	mov	r0, r6
    8130:	ebfffc7f 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
#endif
        flags.readbuf_char_in_use = len ? 1 : 0;

    unlock_me();

    if (read_err == ENOERR) {
    8134:	e3550000 	cmp	r5, #0	; 0x0
    8138:	1a000008 	bne	8160 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xb4>
        if (len == 0) {
    813c:	e59d3004 	ldr	r3, [sp, #4]
    8140:	e3530000 	cmp	r3, #0	; 0x0
            read_err = EAGAIN;
            flags.at_eof = true;
    8144:	05d43028 	ldrbeq	r3, [r4, #40]
        }
        else
            flags.at_eof = false;
    8148:	15d43028 	ldrbne	r3, [r4, #40]
    unlock_me();

    if (read_err == ENOERR) {
        if (len == 0) {
            read_err = EAGAIN;
            flags.at_eof = true;
    814c:	03833001 	orreq	r3, r3, #1	; 0x1
        }
        else
            flags.at_eof = false;
    8150:	13c33001 	bicne	r3, r3, #1	; 0x1
    unlock_me();

    if (read_err == ENOERR) {
        if (len == 0) {
            read_err = EAGAIN;
            flags.at_eof = true;
    8154:	05c43028 	strbeq	r3, [r4, #40]
        }
        else
            flags.at_eof = false;
    8158:	15c43028 	strbne	r3, [r4, #40]
    unlock_me();

    if (read_err == ENOERR) {
        if (len == 0) {
            read_err = EAGAIN;
            flags.at_eof = true;
    815c:	0285500b 	addeq	r5, r5, #11	; 0xb
        else
            flags.at_eof = false;
    } // if
    
    return read_err;
} // refill_read_buffer()
    8160:	e1a00005 	mov	r0, r5
    8164:	e28dd008 	add	sp, sp, #8	; 0x8
    8168:	e8bd8070 	pop	{r4, r5, r6, pc}
    816c:	e1a00006 	mov	r0, r6
    8170:	ebfffc6f 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    8174:	e3a05016 	mov	r5, #22	; 0x16
    8178:	eafffff8 	b	8160 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xb4>
    
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    // If there is pending output to write, then this will check and
    // write it
    if (flags.buffering) {
        read_err = flush_output_unlocked();
    817c:	e1a00004 	mov	r0, r4
    8180:	ebfffdff 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        // we're now reading
        flags.last_buffer_op_was_read = true;
    8184:	e5d43028 	ldrb	r3, [r4, #40]

        // flush ALL streams
        if (read_err == ENOERR)
    8188:	e2505000 	subs	r5, r0, #0	; 0x0
    // write it
    if (flags.buffering) {
        read_err = flush_output_unlocked();

        // we're now reading
        flags.last_buffer_op_was_read = true;
    818c:	e3833080 	orr	r3, r3, #128	; 0x80
    8190:	e5c43028 	strb	r3, [r4, #40]

        // flush ALL streams
        if (read_err == ENOERR)
    8194:	0a000009 	beq	81c0 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0x114>
    8198:	e1a00006 	mov	r0, r6
    819c:	ebfffc64 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    81a0:	eaffffee 	b	8160 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xb4>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    if (flags.buffering)
        io_buf.set_bytes_written( len );
    else
#endif
        flags.readbuf_char_in_use = len ? 1 : 0;
    81a4:	e5d43029 	ldrb	r3, [r4, #41]
    81a8:	e59d2004 	ldr	r2, [sp, #4]
    81ac:	e3c33001 	bic	r3, r3, #1	; 0x1
    81b0:	e3520000 	cmp	r2, #0	; 0x0
    81b4:	13833001 	orrne	r3, r3, #1	; 0x1
    81b8:	e5c43029 	strb	r3, [r4, #41]
    81bc:	eaffffda 	b	812c <_ZN15Cyg_StdioStream18refill_read_bufferEv+0x80>
        // we're now reading
        flags.last_buffer_op_was_read = true;

        // flush ALL streams
        if (read_err == ENOERR)
            read_err = cyg_libc_stdio_flush_all_but(this);
    81c0:	e1a00004 	mov	r0, r4
    81c4:	eb001d60 	bl	f74c <cyg_libc_stdio_flush_all_but>

        if (read_err != ENOERR) {
    81c8:	e2505000 	subs	r5, r0, #0	; 0x0
    81cc:	1afffff1 	bne	8198 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xec>


inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_write( cyg_uint8 **buffer )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    81d0:	e5942014 	ldr	r2, [r4, #20]

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    81d4:	e3520000 	cmp	r2, #0	; 0x0
    81d8:	15943018 	ldrne	r3, [r4, #24]
    81dc:	03e03000 	mvneq	r3, #0	; 0x0
inline cyg_ucount32
Cyg_StdioStreamBuffer::get_buffer_addr_to_write( cyg_uint8 **buffer )
{
    cyg_uint8 *buffer_max = &buffer_bottom[ get_buffer_size() ];
    
    *buffer = buffer_top;
    81e0:	e594101c 	ldr	r1, [r4, #28]
    
    return (buffer_max - buffer_top);
    81e4:	e0823003 	add	r3, r2, r3
    81e8:	e0613003 	rsb	r3, r1, r3
            unlock_me();
            return read_err;
        } // if

        len = io_buf.get_buffer_addr_to_write( (cyg_uint8**)&buffer );
        if (!len) { // no buffer space available
    81ec:	e3530000 	cmp	r3, #0	; 0x0
        if (read_err != ENOERR) {
            unlock_me();
            return read_err;
        } // if

        len = io_buf.get_buffer_addr_to_write( (cyg_uint8**)&buffer );
    81f0:	e58d3004 	str	r3, [sp, #4]
        if (!len) { // no buffer space available
    81f4:	1affffc1 	bne	8100 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0x54>
    81f8:	eaffffe6 	b	8198 <_ZN15Cyg_StdioStream18refill_read_bufferEv+0xec>

000081fc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh>:

void Cyg_StdioStream::initialize(cyg_stdio_handle_t dev,
                                 OpenMode open_mode,
                                 cyg_bool append, cyg_bool binary,
                                 int buffer_mode, cyg_ucount32 buffer_size,
                                 cyg_uint8 *buffer_addr )
    81fc:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)

#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0xbadbad;
#endif

    my_device = dev;
    8200:	e5801008 	str	r1, [r0, #8]

    // Clear all flags
    memset( &flags, 0, sizeof(flags) );
    8204:	e3a01000 	mov	r1, #0	; 0x0
    8208:	e5801028 	str	r1, [r0, #40]

void Cyg_StdioStream::initialize(cyg_stdio_handle_t dev,
                                 OpenMode open_mode,
                                 cyg_bool append, cyg_bool binary,
                                 int buffer_mode, cyg_ucount32 buffer_size,
                                 cyg_uint8 *buffer_addr )
    820c:	e1a0c003 	mov	ip, r3
    8210:	e59d1008 	ldr	r1, [sp, #8]
    my_device = dev;

    // Clear all flags
    memset( &flags, 0, sizeof(flags) );

    switch (open_mode) {
    8214:	e3520003 	cmp	r2, #3	; 0x3
    8218:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
    821c:	ea000024 	b	82b4 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0xb8>
    8220:	000082d8 	.word	0x000082d8
    8224:	000082c4 	.word	0x000082c4
    8228:	00008230 	.word	0x00008230
    822c:	00008230 	.word	0x00008230
    case CYG_STREAM_WRITE:
        flags.opened_for_write = true;
        break;
    case CYG_STREAM_READWRITE_NOCREATE:
    case CYG_STREAM_READWRITE_CREATE:
        flags.opened_for_read = true;
    8230:	e5d03028 	ldrb	r3, [r0, #40]
    8234:	e3833002 	orr	r3, r3, #2	; 0x2
    8238:	e5c03028 	strb	r3, [r0, #40]
        flags.opened_for_write = true;
    823c:	e5d02028 	ldrb	r2, [r0, #40]
    8240:	e3822004 	orr	r2, r2, #4	; 0x4
    8244:	e5c02028 	strb	r2, [r0, #40]
    8248:	e5d03028 	ldrb	r3, [r0, #40]
            error = EDEVNOSUPP;
            return;
        } // if
#endif
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
        flags.last_buffer_op_was_read = false;
    824c:	e3c33080 	bic	r3, r3, #128	; 0x80
    8250:	e5c03028 	strb	r3, [r0, #40]
#endif
    } // if


    if (flags.opened_for_read) {
    8254:	e5d03028 	ldrb	r3, [r0, #40]
    8258:	e3130002 	tst	r3, #2	; 0x2
    825c:	1a000023 	bne	82f0 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0xf4>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
        flags.last_buffer_op_was_read = true;
#endif
    } // if

    flags.binary = binary ? 1 : 0;
    8260:	e59d4004 	ldr	r4, [sp, #4]
    8264:	e3540000 	cmp	r4, #0	; 0x0
    8268:	13a02008 	movne	r2, #8	; 0x8
    826c:	03a02000 	moveq	r2, #0	; 0x0
    8270:	e3c33008 	bic	r3, r3, #8	; 0x8
    8274:	e1823003 	orr	r3, r2, r3
    8278:	e5c03028 	strb	r3, [r0, #40]
    error = ENOERR;
    
    // in due course we would do an equivalent to fseek(...,0, SEEK_END);
    // when appending. for now, there's nothing, except set eof
    
    flags.at_eof = append ? 1 : 0;
    827c:	e5d03028 	ldrb	r3, [r0, #40]
    8280:	e3c33001 	bic	r3, r3, #1	; 0x1
    8284:	e35c0000 	cmp	ip, #0	; 0x0
    8288:	13833001 	orrne	r3, r3, #1	; 0x1
#endif
    } // if

    flags.binary = binary ? 1 : 0;

    error = ENOERR;
    828c:	e3a02000 	mov	r2, #0	; 0x0

    position = 0;

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    switch (buffer_mode) {
    8290:	e3710004 	cmn	r1, #4	; 0x4
    error = ENOERR;
    
    // in due course we would do an equivalent to fseek(...,0, SEEK_END);
    // when appending. for now, there's nothing, except set eof
    
    flags.at_eof = append ? 1 : 0;
    8294:	e5c03028 	strb	r3, [r0, #40]

    position = 0;
    8298:	e580202c 	str	r2, [r0, #44]
#endif
    } // if

    flags.binary = binary ? 1 : 0;

    error = ENOERR;
    829c:	e5802004 	str	r2, [r0, #4]

    position = 0;

#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    switch (buffer_mode) {
    82a0:	0a00002f 	beq	8364 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x168>
    82a4:	e3710002 	cmn	r1, #2	; 0x2
    82a8:	0a00001b 	beq	831c <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x120>
    82ac:	e3710008 	cmn	r1, #8	; 0x8
    82b0:	0a000012 	beq	8300 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x104>
    case _IOFBF:
        flags.buffering = true;
        flags.line_buffering = false;
        break;
    default:
        error = EINVAL;
    82b4:	e3a03016 	mov	r3, #22	; 0x16
    82b8:	e5803004 	str	r3, [r0, #4]

#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0x7b4321ce;
#endif
    
} // Cyg_StdioStream constructor
    82bc:	e8bd0010 	pop	{r4}
    82c0:	e12fff1e 	bx	lr
    switch (open_mode) {
    case CYG_STREAM_READ:
        flags.opened_for_read = true;
        break;
    case CYG_STREAM_WRITE:
        flags.opened_for_write = true;
    82c4:	e5d03028 	ldrb	r3, [r0, #40]
    82c8:	e3833004 	orr	r3, r3, #4	; 0x4
    82cc:	e5c03028 	strb	r3, [r0, #40]
    82d0:	e5d03028 	ldrb	r3, [r0, #40]
    82d4:	eaffffdc 	b	824c <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x50>
    // Clear all flags
    memset( &flags, 0, sizeof(flags) );

    switch (open_mode) {
    case CYG_STREAM_READ:
        flags.opened_for_read = true;
    82d8:	e5d03028 	ldrb	r3, [r0, #40]
    82dc:	e3833002 	orr	r3, r3, #2	; 0x2
    82e0:	e5c03028 	strb	r3, [r0, #40]
        error=EINVAL;
        return;
    } // switch
        
    
    if (flags.opened_for_write) {
    82e4:	e5d03028 	ldrb	r3, [r0, #40]
    82e8:	e3130004 	tst	r3, #4	; 0x4
    82ec:	1affffd6 	bne	824c <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x50>
        } // if
#endif

        // NB also if opened for read AND write, then say last op was read
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
        flags.last_buffer_op_was_read = true;
    82f0:	e3833080 	orr	r3, r3, #128	; 0x80
    82f4:	e5c03028 	strb	r3, [r0, #40]
    82f8:	e5d03028 	ldrb	r3, [r0, #40]
    82fc:	eaffffd7 	b	8260 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x64>

    switch (buffer_mode) {
    case _IONBF:
        CYG_ASSERT( (buffer_size == 0) && (buffer_addr == NULL),
                    "No buffering wanted but size/address specified!" );
        flags.buffering = flags.line_buffering = false;
    8300:	e5d03028 	ldrb	r3, [r0, #40]
    8304:	e3c33040 	bic	r3, r3, #64	; 0x40
    8308:	e5c03028 	strb	r3, [r0, #40]
    830c:	e5d02028 	ldrb	r2, [r0, #40]
    8310:	e3c22020 	bic	r2, r2, #32	; 0x20
    8314:	e5c02028 	strb	r2, [r0, #40]
    8318:	eaffffe7 	b	82bc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0xc0>
    case _IOLBF:
        flags.buffering = true;
        flags.line_buffering = true;
        break;
    case _IOFBF:
        flags.buffering = true;
    831c:	e5d03028 	ldrb	r3, [r0, #40]
    8320:	e3833020 	orr	r3, r3, #32	; 0x20
    8324:	e5c03028 	strb	r3, [r0, #40]
        flags.line_buffering = false;
    8328:	e5d02028 	ldrb	r2, [r0, #40]
    832c:	e3c22040 	bic	r2, r2, #64	; 0x40
    8330:	e5c02028 	strb	r2, [r0, #40]
        error = EINVAL;
        return;
    } // switch

    // one way of checking the buffer was set up correctly
    if (flags.buffering && io_buf.get_buffer_size()==-1) {
    8334:	e5d03028 	ldrb	r3, [r0, #40]
    8338:	e3130020 	tst	r3, #32	; 0x20
    833c:	0affffde 	beq	82bc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0xc0>

inline cyg_count32
Cyg_StdioStreamBuffer::get_buffer_size( void )
{
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    if (buffer_bottom==NULL)
    8340:	e5903014 	ldr	r3, [r0, #20]
    8344:	e3530000 	cmp	r3, #0	; 0x0
    8348:	0a000002 	beq	8358 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x15c>
    834c:	e5903018 	ldr	r3, [r0, #24]
    8350:	e3730001 	cmn	r3, #1	; 0x1
    8354:	1affffd8 	bne	82bc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0xc0>
        error = ENOMEM;
    8358:	e3a0300c 	mov	r3, #12	; 0xc
    835c:	e5803004 	str	r3, [r0, #4]
    8360:	eaffffd5 	b	82bc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0xc0>
        CYG_ASSERT( (buffer_size == 0) && (buffer_addr == NULL),
                    "No buffering wanted but size/address specified!" );
        flags.buffering = flags.line_buffering = false;
        break;
    case _IOLBF:
        flags.buffering = true;
    8364:	e5d03028 	ldrb	r3, [r0, #40]
    8368:	e3833020 	orr	r3, r3, #32	; 0x20
    836c:	e5c03028 	strb	r3, [r0, #40]
        flags.line_buffering = true;
    8370:	e5d02028 	ldrb	r2, [r0, #40]
    8374:	e3822040 	orr	r2, r2, #64	; 0x40
    8378:	e5c02028 	strb	r2, [r0, #40]
    837c:	eaffffec 	b	8334 <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh+0x138>

00008380 <_ZN15Cyg_StdioStreamC1ENS_8OpenModeEjPh>:
} // Cyg_StdioStream constructor


Cyg_StdioStream::Cyg_StdioStream( OpenMode open_mode,
                                 cyg_ucount32 buffer_size,
                                  cyg_uint8 *buffer_addr )
    8380:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    8384:	e1a05003 	mov	r5, r3
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8388:	e59f30a4 	ldr	r3, [pc, #164]	; 8434 <_ZN15Cyg_StdioStreamC1ENS_8OpenModeEjPh+0xb4>
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    838c:	e3a04000 	mov	r4, #0	; 0x0
} // Cyg_StdioStream constructor


Cyg_StdioStream::Cyg_StdioStream( OpenMode open_mode,
                                 cyg_ucount32 buffer_size,
                                  cyg_uint8 *buffer_addr )
    8390:	e24dd010 	sub	sp, sp, #16	; 0x10
    8394:	e1a06000 	mov	r6, r0
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8398:	e5803000 	str	r3, [r0]
} // Cyg_StdioStream constructor


Cyg_StdioStream::Cyg_StdioStream( OpenMode open_mode,
                                 cyg_ucount32 buffer_size,
                                  cyg_uint8 *buffer_addr )
    839c:	e1a08002 	mov	r8, r2
    83a0:	e1a07001 	mov	r7, r1
    83a4:	e5804010 	str	r4, [r0, #16]
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    83a8:	e1a01002 	mov	r1, r2
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    83ac:	e5804014 	str	r4, [r0, #20]
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    83b0:	e1a02005 	mov	r2, r5
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    83b4:	e5804018 	str	r4, [r0, #24]
    83b8:	e580401c 	str	r4, [r0, #28]
    83bc:	e5804020 	str	r4, [r0, #32]
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    83c0:	e2800010 	add	r0, r0, #16	; 0x10
    83c4:	eb0000b7 	bl	86a8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    83c8:	e2860030 	add	r0, r6, #48	; 0x30
    83cc:	ebfffa79 	bl	6db8 <_ZN9Cyg_MutexC1Ev>
#endif
{
    initialize( CYG_STDIO_HANDLE_NULL, open_mode, false, false, _IOFBF,
                buffer_size, buffer_addr );
    83d0:	e1a03004 	mov	r3, r4
    83d4:	e3e0c001 	mvn	ip, #1	; 0x1
    83d8:	e1a01004 	mov	r1, r4
    83dc:	e1a00006 	mov	r0, r6
    83e0:	e1a02007 	mov	r2, r7
    83e4:	e58dc004 	str	ip, [sp, #4]
    83e8:	e58d500c 	str	r5, [sp, #12]
    83ec:	e58d4000 	str	r4, [sp]
    83f0:	e58d8008 	str	r8, [sp, #8]
    83f4:	ebffff80 	bl	81fc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh>

    if( error != ENOERR )
    83f8:	e5963004 	ldr	r3, [r6, #4]
    83fc:	e1530004 	cmp	r3, r4
    8400:	1a000004 	bne	8418 <_ZN15Cyg_StdioStreamC1ENS_8OpenModeEjPh+0x98>
        return;
    
    switch( open_mode )
    8404:	e1570004 	cmp	r7, r4


inline void
Cyg_StdioStreamBuffer::set_bytes_written( cyg_ucount32 bytes )
{
    buffer_top += bytes;
    8408:	0596301c 	ldreq	r3, [r6, #28]
    840c:	00833008 	addeq	r3, r3, r8
    8410:	0586301c 	streq	r3, [r6, #28]
    8414:	1a000002 	bne	8424 <_ZN15Cyg_StdioStreamC1ENS_8OpenModeEjPh+0xa4>

    default:
        error = EINVAL;
        return;
    }
}
    8418:	e1a00006 	mov	r0, r6
    841c:	e28dd010 	add	sp, sp, #16	; 0x10
    8420:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                buffer_size, buffer_addr );

    if( error != ENOERR )
        return;
    
    switch( open_mode )
    8424:	e3570001 	cmp	r7, #1	; 0x1
        // Fix up the stream so it looks like the buffer is ready to accept
        // new data.
        break;

    default:
        error = EINVAL;
    8428:	13a03016 	movne	r3, #22	; 0x16
    842c:	15863004 	strne	r3, [r6, #4]
    8430:	eafffff8 	b	8418 <_ZN15Cyg_StdioStreamC1ENS_8OpenModeEjPh+0x98>
    8434:	00012a78 	.word	0x00012a78

00008438 <_ZN15Cyg_StdioStreamC2ENS_8OpenModeEjPh>:
} // Cyg_StdioStream constructor


Cyg_StdioStream::Cyg_StdioStream( OpenMode open_mode,
                                 cyg_ucount32 buffer_size,
                                  cyg_uint8 *buffer_addr )
    8438:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    843c:	e1a05003 	mov	r5, r3
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8440:	e59f30a4 	ldr	r3, [pc, #164]	; 84ec <_ZN15Cyg_StdioStreamC2ENS_8OpenModeEjPh+0xb4>
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    8444:	e3a04000 	mov	r4, #0	; 0x0
} // Cyg_StdioStream constructor


Cyg_StdioStream::Cyg_StdioStream( OpenMode open_mode,
                                 cyg_ucount32 buffer_size,
                                  cyg_uint8 *buffer_addr )
    8448:	e24dd010 	sub	sp, sp, #16	; 0x10
    844c:	e1a06000 	mov	r6, r0
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8450:	e5803000 	str	r3, [r0]
} // Cyg_StdioStream constructor


Cyg_StdioStream::Cyg_StdioStream( OpenMode open_mode,
                                 cyg_ucount32 buffer_size,
                                  cyg_uint8 *buffer_addr )
    8454:	e1a08002 	mov	r8, r2
    8458:	e1a07001 	mov	r7, r1
    845c:	e5804010 	str	r4, [r0, #16]
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    8460:	e1a01002 	mov	r1, r2
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    8464:	e5804014 	str	r4, [r0, #20]
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    8468:	e1a02005 	mov	r2, r5
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    846c:	e5804018 	str	r4, [r0, #24]
    8470:	e580401c 	str	r4, [r0, #28]
    8474:	e5804020 	str	r4, [r0, #32]
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    8478:	e2800010 	add	r0, r0, #16	; 0x10
    847c:	eb000089 	bl	86a8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8480:	e2860030 	add	r0, r6, #48	; 0x30
    8484:	ebfffa4b 	bl	6db8 <_ZN9Cyg_MutexC1Ev>
#endif
{
    initialize( CYG_STDIO_HANDLE_NULL, open_mode, false, false, _IOFBF,
                buffer_size, buffer_addr );
    8488:	e1a03004 	mov	r3, r4
    848c:	e3e0c001 	mvn	ip, #1	; 0x1
    8490:	e1a01004 	mov	r1, r4
    8494:	e1a00006 	mov	r0, r6
    8498:	e1a02007 	mov	r2, r7
    849c:	e58dc004 	str	ip, [sp, #4]
    84a0:	e58d500c 	str	r5, [sp, #12]
    84a4:	e58d4000 	str	r4, [sp]
    84a8:	e58d8008 	str	r8, [sp, #8]
    84ac:	ebffff52 	bl	81fc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh>

    if( error != ENOERR )
    84b0:	e5963004 	ldr	r3, [r6, #4]
    84b4:	e1530004 	cmp	r3, r4
    84b8:	1a000004 	bne	84d0 <_ZN15Cyg_StdioStreamC2ENS_8OpenModeEjPh+0x98>
        return;
    
    switch( open_mode )
    84bc:	e1570004 	cmp	r7, r4


inline void
Cyg_StdioStreamBuffer::set_bytes_written( cyg_ucount32 bytes )
{
    buffer_top += bytes;
    84c0:	0596301c 	ldreq	r3, [r6, #28]
    84c4:	00833008 	addeq	r3, r3, r8
    84c8:	0586301c 	streq	r3, [r6, #28]
    84cc:	1a000002 	bne	84dc <_ZN15Cyg_StdioStreamC2ENS_8OpenModeEjPh+0xa4>

    default:
        error = EINVAL;
        return;
    }
}
    84d0:	e1a00006 	mov	r0, r6
    84d4:	e28dd010 	add	sp, sp, #16	; 0x10
    84d8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                buffer_size, buffer_addr );

    if( error != ENOERR )
        return;
    
    switch( open_mode )
    84dc:	e3570001 	cmp	r7, #1	; 0x1
        // Fix up the stream so it looks like the buffer is ready to accept
        // new data.
        break;

    default:
        error = EINVAL;
    84e0:	13a03016 	movne	r3, #22	; 0x16
    84e4:	15863004 	strne	r3, [r6, #4]
    84e8:	eafffff8 	b	84d0 <_ZN15Cyg_StdioStreamC2ENS_8OpenModeEjPh+0x98>
    84ec:	00012a78 	.word	0x00012a78

000084f0 <_ZN15Cyg_StdioStreamC1EPvNS_8OpenModeEiiijPh>:

Cyg_StdioStream::Cyg_StdioStream(cyg_stdio_handle_t dev,
                                 OpenMode open_mode,
                                 cyg_bool append, cyg_bool binary,
                                 int buffer_mode, cyg_ucount32 buffer_size,
                                 cyg_uint8 *buffer_addr )
    84f0:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    84f4:	e24dd014 	sub	sp, sp, #20	; 0x14
    84f8:	e1a05000 	mov	r5, r0
    84fc:	e28d8038 	add	r8, sp, #56	; 0x38
    8500:	e8980500 	ldm	r8, {r8, sl}
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8504:	e59f006c 	ldr	r0, [pc, #108]	; 8578 <_ZN15Cyg_StdioStreamC1EPvNS_8OpenModeEiiijPh+0x88>
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    8508:	e3a0c000 	mov	ip, #0	; 0x0
    850c:	e585c020 	str	ip, [r5, #32]
    8510:	e585c010 	str	ip, [r5, #16]
    8514:	e585c014 	str	ip, [r5, #20]
    8518:	e585c018 	str	ip, [r5, #24]
    851c:	e585c01c 	str	ip, [r5, #28]
    8520:	e5850000 	str	r0, [r5]

Cyg_StdioStream::Cyg_StdioStream(cyg_stdio_handle_t dev,
                                 OpenMode open_mode,
                                 cyg_bool append, cyg_bool binary,
                                 int buffer_mode, cyg_ucount32 buffer_size,
                                 cyg_uint8 *buffer_addr )
    8524:	e1a06001 	mov	r6, r1
    8528:	e1a07002 	mov	r7, r2
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    852c:	e1a01008 	mov	r1, r8
    8530:	e1a0200a 	mov	r2, sl
    8534:	e2850010 	add	r0, r5, #16	; 0x10
    8538:	e1a04003 	mov	r4, r3
    853c:	eb000059 	bl	86a8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8540:	e2850030 	add	r0, r5, #48	; 0x30
    8544:	ebfffa1b 	bl	6db8 <_ZN9Cyg_MutexC1Ev>
#endif
{
    initialize( dev, open_mode, append, binary, buffer_mode,
                buffer_size, buffer_addr);
    8548:	e1a03004 	mov	r3, r4
    854c:	e59dc030 	ldr	ip, [sp, #48]
    8550:	e59d4034 	ldr	r4, [sp, #52]
    8554:	e1a00005 	mov	r0, r5
    8558:	e1a01006 	mov	r1, r6
    855c:	e1a02007 	mov	r2, r7
    8560:	e58dc000 	str	ip, [sp]
    8564:	e98d0510 	stmib	sp, {r4, r8, sl}
    8568:	ebffff23 	bl	81fc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh>
}
    856c:	e1a00005 	mov	r0, r5
    8570:	e28dd014 	add	sp, sp, #20	; 0x14
    8574:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    8578:	00012a78 	.word	0x00012a78

0000857c <_ZN15Cyg_StdioStreamC2EPvNS_8OpenModeEiiijPh>:

Cyg_StdioStream::Cyg_StdioStream(cyg_stdio_handle_t dev,
                                 OpenMode open_mode,
                                 cyg_bool append, cyg_bool binary,
                                 int buffer_mode, cyg_ucount32 buffer_size,
                                 cyg_uint8 *buffer_addr )
    857c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
    8580:	e24dd014 	sub	sp, sp, #20	; 0x14
    8584:	e1a05000 	mov	r5, r0
    8588:	e28d8038 	add	r8, sp, #56	; 0x38
    858c:	e8980500 	ldm	r8, {r8, sl}
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    8590:	e59f006c 	ldr	r0, [pc, #108]	; 8604 <_ZN15Cyg_StdioStreamC2EPvNS_8OpenModeEiiijPh+0x88>
#else
    buffer_bottom( static_buffer ),
    buffer_size(sizeof(static_buffer)),    
#endif    
    buffer_top(NULL),
    current_buffer_position(NULL)
    8594:	e3a0c000 	mov	ip, #0	; 0x0
    8598:	e585c020 	str	ip, [r5, #32]
    859c:	e585c010 	str	ip, [r5, #16]
    85a0:	e585c014 	str	ip, [r5, #20]
    85a4:	e585c018 	str	ip, [r5, #24]
    85a8:	e585c01c 	str	ip, [r5, #28]
    85ac:	e5850000 	str	r0, [r5]

Cyg_StdioStream::Cyg_StdioStream(cyg_stdio_handle_t dev,
                                 OpenMode open_mode,
                                 cyg_bool append, cyg_bool binary,
                                 int buffer_mode, cyg_ucount32 buffer_size,
                                 cyg_uint8 *buffer_addr )
    85b0:	e1a06001 	mov	r6, r1
    85b4:	e1a07002 	mov	r7, r2
{
    // NB Many of the above members in the initialisation list may seem
    // unnecessary, but it is to ensure a defined state if e.g. the malloc
    // in set_buffer() should fail

    (void)set_buffer(size, new_buffer);
    85b8:	e1a01008 	mov	r1, r8
    85bc:	e1a0200a 	mov	r2, sl
    85c0:	e2850010 	add	r0, r5, #16	; 0x10
    85c4:	e1a04003 	mov	r4, r3
    85c8:	eb000036 	bl	86a8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh>
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
    : io_buf( buffer_size, buffer_addr )
    85cc:	e2850030 	add	r0, r5, #48	; 0x30
    85d0:	ebfff9f8 	bl	6db8 <_ZN9Cyg_MutexC1Ev>
#endif
{
    initialize( dev, open_mode, append, binary, buffer_mode,
                buffer_size, buffer_addr);
    85d4:	e1a03004 	mov	r3, r4
    85d8:	e59dc030 	ldr	ip, [sp, #48]
    85dc:	e59d4034 	ldr	r4, [sp, #52]
    85e0:	e1a00005 	mov	r0, r5
    85e4:	e1a01006 	mov	r1, r6
    85e8:	e1a02007 	mov	r2, r7
    85ec:	e58dc000 	str	ip, [sp]
    85f0:	e98d0510 	stmib	sp, {r4, r8, sl}
    85f4:	ebffff00 	bl	81fc <_ZN15Cyg_StdioStream10initializeEPvNS_8OpenModeEiiijPh>
}
    85f8:	e1a00005 	mov	r0, r5
    85fc:	e28dd014 	add	sp, sp, #20	; 0x14
    8600:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
    8604:	00012a78 	.word	0x00012a78

00008608 <_ZN15Cyg_StdioStreamD1Ev>:
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    8608:	e92d4030 	push	{r4, r5, lr}
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    860c:	e5903008 	ldr	r3, [r0, #8]
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    8610:	e59f2088 	ldr	r2, [pc, #136]	; 86a0 <_ZN15Cyg_StdioStreamD1Ev+0x98>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    8614:	e3530000 	cmp	r3, #0	; 0x0
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    8618:	e24dd004 	sub	sp, sp, #4	; 0x4
    861c:	e1a04000 	mov	r4, r0
    8620:	e5802000 	str	r2, [r0]
    8624:	02805030 	addeq	r5, r0, #48	; 0x30
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    8628:	0a00000d 	beq	8664 <_ZN15Cyg_StdioStreamD1Ev+0x5c>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    862c:	e2805030 	add	r5, r0, #48	; 0x30
    8630:	e1a00005 	mov	r0, r5
    8634:	ebfffa46 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline Cyg_ErrNo
Cyg_StdioStream::close()
{
    Cyg_ErrNo err = ENOERR;
    
    if (!lock_me())
    8638:	e3500000 	cmp	r0, #0	; 0x0
    863c:	0a000008 	beq	8664 <_ZN15Cyg_StdioStreamD1Ev+0x5c>
        return EBADF;

    if( my_device != CYG_STDIO_HANDLE_NULL )
    8640:	e5943008 	ldr	r3, [r4, #8]
    8644:	e3530000 	cmp	r3, #0	; 0x0
    8648:	0a000003 	beq	865c <_ZN15Cyg_StdioStreamD1Ev+0x54>
    {
        flush_output_unlocked();
    864c:	e1a00004 	mov	r0, r4
    8650:	ebfffccb 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        err = cyg_stdio_close( my_device );
    
        if( err == ENOERR )
            my_device = CYG_STDIO_HANDLE_NULL;
    8654:	e3a03000 	mov	r3, #0	; 0x0
    8658:	e5843008 	str	r3, [r4, #8]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    865c:	e1a00005 	mov	r0, r5
    8660:	ebfffb33 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        close();
    
#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0xbadbad;
#endif
} // Cyg_StdioStream destructor
    8664:	e1a00005 	mov	r0, r5
    8668:	ebfff9f9 	bl	6e54 <_ZN9Cyg_MutexD1Ev>

inline
Cyg_StdioStreamBuffer::~Cyg_StdioStreamBuffer()
{
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
    if ((buffer_bottom != NULL) && call_free)
    866c:	e5940014 	ldr	r0, [r4, #20]
    8670:	e3500000 	cmp	r0, #0	; 0x0
    8674:	0a000002 	beq	8684 <_ZN15Cyg_StdioStreamD1Ev+0x7c>
    8678:	e5943010 	ldr	r3, [r4, #16]
    867c:	e3530000 	cmp	r3, #0	; 0x0
    8680:	1a000004 	bne	8698 <_ZN15Cyg_StdioStreamD1Ev+0x90>
    8684:	e59f3018 	ldr	r3, [pc, #24]	; 86a4 <_ZN15Cyg_StdioStreamD1Ev+0x9c>
    8688:	e1a00004 	mov	r0, r4
    868c:	e5843000 	str	r3, [r4]
    8690:	e28dd004 	add	sp, sp, #4	; 0x4
    8694:	e8bd8030 	pop	{r4, r5, pc}
        free( buffer_bottom );
    8698:	eb001af4 	bl	f270 <free>
    869c:	eafffff8 	b	8684 <_ZN15Cyg_StdioStreamD1Ev+0x7c>
    86a0:	00012a78 	.word	0x00012a78
    86a4:	00012a90 	.word	0x00012a90

000086a8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh>:

// FUNCTIONS
    
Cyg_ErrNo
Cyg_StdioStreamBuffer::set_buffer( cyg_ucount32 size,
                                   cyg_uint8 *new_buffer )
    86a8:	e92d4070 	push	{r4, r5, r6, lr}
{
    
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    
    // user-supplied buffer?
    if (new_buffer != NULL) {
    86ac:	e2526000 	subs	r6, r2, #0	; 0x0

// FUNCTIONS
    
Cyg_ErrNo
Cyg_StdioStreamBuffer::set_buffer( cyg_ucount32 size,
                                   cyg_uint8 *new_buffer )
    86b0:	e1a04000 	mov	r4, r0
    86b4:	e1a05001 	mov	r5, r1
{
    
#ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    
    // user-supplied buffer?
    if (new_buffer != NULL) {
    86b8:	0a00000e 	beq	86f8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x50>
        CYG_CHECK_DATA_PTR(new_buffer, "new_buffer not valid");
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
        // first check if we were responsible for the old buffer
        if (call_free) {
    86bc:	e5903000 	ldr	r3, [r0]
    86c0:	e3530000 	cmp	r3, #0	; 0x0
    86c4:	1a000006 	bne	86e4 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x3c>
            free(buffer_bottom);
            call_free = false;
        }
#endif        
        buffer_bottom = new_buffer;
    86c8:	e5846004 	str	r6, [r4, #4]
    if ( (new_buffer != NULL) || (size > sizeof(static_buffer)) )
        return EINVAL;
    
#endif // ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    
    buffer_top = current_buffer_position = &buffer_bottom[0];
    86cc:	e5943004 	ldr	r3, [r4, #4]
    buffer_size = size;
    86d0:	e5845008 	str	r5, [r4, #8]
    if ( (new_buffer != NULL) || (size > sizeof(static_buffer)) )
        return EINVAL;
    
#endif // ifdef CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
    
    buffer_top = current_buffer_position = &buffer_bottom[0];
    86d4:	e584300c 	str	r3, [r4, #12]
    86d8:	e5843010 	str	r3, [r4, #16]
    buffer_size = size;
    86dc:	e3a00000 	mov	r0, #0	; 0x0
    
    return ENOERR;
    
} // set_buffer()
    86e0:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (new_buffer != NULL) {
        CYG_CHECK_DATA_PTR(new_buffer, "new_buffer not valid");
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
        // first check if we were responsible for the old buffer
        if (call_free) {
            free(buffer_bottom);
    86e4:	e5900004 	ldr	r0, [r0, #4]
    86e8:	eb001ae0 	bl	f270 <free>
            call_free = false;
    86ec:	e3a03000 	mov	r3, #0	; 0x0
    86f0:	e5843000 	str	r3, [r4]
    86f4:	eafffff3 	b	86c8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x20>
        }
#endif        
        buffer_bottom = new_buffer;
    }
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC    
    else if ( size != buffer_size ) { // as long as its different from
    86f8:	e5903008 	ldr	r3, [r0, #8]
    86fc:	e1530001 	cmp	r3, r1
    8700:	0afffff1 	beq	86cc <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x24>
                                      // what we've got now
        cyg_uint8 *malloced_buf;

        malloced_buf = (cyg_uint8 * )malloc( size );
    8704:	e1a00001 	mov	r0, r1
    8708:	eb001b1f 	bl	f38c <malloc>
        if (malloced_buf == NULL)
    870c:	e2506000 	subs	r6, r0, #0	; 0x0
    8710:	0280000c 	addeq	r0, r0, #12	; 0xc
    8714:	08bd8070 	popeq	{r4, r5, r6, pc}
            return ENOMEM;

        // should the old buffer be freed? This waits till after we know
        // whether the malloc succeeded
        if (call_free)
    8718:	e5943000 	ldr	r3, [r4]
    871c:	e3530000 	cmp	r3, #0	; 0x0
    8720:	1a000002 	bne	8730 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x88>
            free( buffer_bottom );
        
        buffer_bottom = malloced_buf;

        call_free=true;
    8724:	e3a03001 	mov	r3, #1	; 0x1
        // should the old buffer be freed? This waits till after we know
        // whether the malloc succeeded
        if (call_free)
            free( buffer_bottom );
        
        buffer_bottom = malloced_buf;
    8728:	e8840048 	stm	r4, {r3, r6}
    872c:	eaffffe6 	b	86cc <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x24>
            return ENOMEM;

        // should the old buffer be freed? This waits till after we know
        // whether the malloc succeeded
        if (call_free)
            free( buffer_bottom );
    8730:	e5940004 	ldr	r0, [r4, #4]
    8734:	eb001acd 	bl	f270 <free>
    8738:	eafffff9 	b	8724 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh+0x7c>

0000873c <_ZN19Cyg_VsnprintfStreamD1Ev>:
class Cyg_VsnprintfStream: public Cyg_OutputStream
{
public:
    Cyg_VsnprintfStream(char* s): s_(s) {}

    virtual ~Cyg_VsnprintfStream() { *s_ = '\0'; }
    873c:	e5901004 	ldr	r1, [r0, #4]
    8740:	e59f200c 	ldr	r2, [pc, #12]	; 8754 <_ZN19Cyg_VsnprintfStreamD1Ev+0x18>
    8744:	e3a03000 	mov	r3, #0	; 0x0
    8748:	e5c13000 	strb	r3, [r1]
    874c:	e5802000 	str	r2, [r0]
    8750:	e12fff1e 	bx	lr
    8754:	00012a90 	.word	0x00012a90

00008758 <_ZN19Cyg_VsnprintfStream9get_errorEv>:

    virtual Cyg_ErrNo write( const cyg_uint8 *buffer,
        cyg_ucount32 buffer_length, cyg_ucount32 *bytes_written );

    virtual Cyg_ErrNo get_error( void ) { return ENOERR; }
    8758:	e3a00000 	mov	r0, #0	; 0x0
    875c:	e12fff1e 	bx	lr

00008760 <_ZN19Cyg_VsnprintfStream5writeEPKhjPj>:

Cyg_ErrNo
Cyg_VsnprintfStream::write(
    const cyg_uint8 *buffer,
    cyg_ucount32 buffer_length,
    cyg_ucount32 *bytes_written )
    8760:	e92d0070 	push	{r4, r5, r6}
{
    char *dest = s_;
    char const *src = (char const *)buffer;
    char const *end = src + buffer_length;
    8764:	e0814002 	add	r4, r1, r2
    while(src < end)
    8768:	e1510004 	cmp	r1, r4

Cyg_ErrNo
Cyg_VsnprintfStream::write(
    const cyg_uint8 *buffer,
    cyg_ucount32 buffer_length,
    cyg_ucount32 *bytes_written )
    876c:	e1a05002 	mov	r5, r2
    8770:	e1a06003 	mov	r6, r3
{
    char *dest = s_;
    8774:	e5902004 	ldr	r2, [r0, #4]
    char const *src = (char const *)buffer;
    char const *end = src + buffer_length;
    while(src < end)
    8778:	2a000008 	bcs	87a0 <_ZN19Cyg_VsnprintfStream5writeEPKhjPj+0x40>
    877c:	e3a0c000 	mov	ip, #0	; 0x0
        *dest++ = *src++;
    8780:	e7d1300c 	ldrb	r3, [r1, ip]
    8784:	e7c2300c 	strb	r3, [r2, ip]
    8788:	e28cc001 	add	ip, ip, #1	; 0x1
    cyg_ucount32 *bytes_written )
{
    char *dest = s_;
    char const *src = (char const *)buffer;
    char const *end = src + buffer_length;
    while(src < end)
    878c:	e081300c 	add	r3, r1, ip
    8790:	e1540003 	cmp	r4, r3
    8794:	8afffff9 	bhi	8780 <_ZN19Cyg_VsnprintfStream5writeEPKhjPj+0x20>
    8798:	e0613004 	rsb	r3, r1, r4
    879c:	e0822003 	add	r2, r2, r3
        *dest++ = *src++;
    s_ = dest;
    87a0:	e5802004 	str	r2, [r0, #4]
    *bytes_written = buffer_length;
    87a4:	e5865000 	str	r5, [r6]
    return ENOERR;
}
    87a8:	e3a00000 	mov	r0, #0	; 0x0
    87ac:	e8bd0070 	pop	{r4, r5, r6}
    87b0:	e12fff1e 	bx	lr

000087b4 <_ZN19Cyg_VsnprintfStreamD0Ev>:
class Cyg_VsnprintfStream: public Cyg_OutputStream
{
public:
    Cyg_VsnprintfStream(char* s): s_(s) {}

    virtual ~Cyg_VsnprintfStream() { *s_ = '\0'; }
    87b4:	e5901004 	ldr	r1, [r0, #4]
    87b8:	e59f201c 	ldr	r2, [pc, #28]	; 87dc <_ZN19Cyg_VsnprintfStreamD0Ev+0x28>
    87bc:	e3a03000 	mov	r3, #0	; 0x0
    87c0:	e92d4010 	push	{r4, lr}
    87c4:	e1a04000 	mov	r4, r0
    87c8:	e5c13000 	strb	r3, [r1]
    87cc:	e5802000 	str	r2, [r0]
    87d0:	eb0015ab 	bl	de84 <_ZdlPv>
    87d4:	e1a00004 	mov	r0, r4
    87d8:	e8bd8010 	pop	{r4, pc}
    87dc:	00012a90 	.word	0x00012a90

000087e0 <vsnprintf>:
    *bytes_written = buffer_length;
    return ENOERR;
}

externC int
vsnprintf( char *s, size_t size, const char *format, va_list arg ) __THROW
    87e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
// FUNCTIONS

class Cyg_VsnprintfStream: public Cyg_OutputStream
{
public:
    Cyg_VsnprintfStream(char* s): s_(s) {}
    87e4:	e59fe028 	ldr	lr, [pc, #40]	; 8814 <vsnprintf+0x34>
    *bytes_written = buffer_length;
    return ENOERR;
}

externC int
vsnprintf( char *s, size_t size, const char *format, va_list arg ) __THROW
    87e8:	e24dd00c 	sub	sp, sp, #12	; 0xc
// FUNCTIONS

class Cyg_VsnprintfStream: public Cyg_OutputStream
{
public:
    Cyg_VsnprintfStream(char* s): s_(s) {}
    87ec:	e28dc008 	add	ip, sp, #8	; 0x8
    87f0:	e58d0004 	str	r0, [sp, #4]

externC int
vsnprintf( char *s, size_t size, const char *format, va_list arg ) __THROW
{
    Cyg_VsnprintfStream stream(s);
    return vfnprintf( (FILE *)(void *)&stream, size, format, arg );
    87f4:	e1a0000d 	mov	r0, sp
// FUNCTIONS

class Cyg_VsnprintfStream: public Cyg_OutputStream
{
public:
    Cyg_VsnprintfStream(char* s): s_(s) {}
    87f8:	e52ce008 	str	lr, [ip, #-8]!

externC int
vsnprintf( char *s, size_t size, const char *format, va_list arg ) __THROW
{
    Cyg_VsnprintfStream stream(s);
    return vfnprintf( (FILE *)(void *)&stream, size, format, arg );
    87fc:	eb00062f 	bl	a0c0 <vfnprintf>
class Cyg_VsnprintfStream: public Cyg_OutputStream
{
public:
    Cyg_VsnprintfStream(char* s): s_(s) {}

    virtual ~Cyg_VsnprintfStream() { *s_ = '\0'; }
    8800:	e59d3004 	ldr	r3, [sp, #4]
    8804:	e3a02000 	mov	r2, #0	; 0x0
    8808:	e5c32000 	strb	r2, [r3]
externC int
vsnprintf( char *s, size_t size, const char *format, va_list arg ) __THROW
{
    Cyg_VsnprintfStream stream(s);
    return vfnprintf( (FILE *)(void *)&stream, size, format, arg );
} // vsnprintf()
    880c:	e28dd00c 	add	sp, sp, #12	; 0xc
    8810:	e8bd8000 	pop	{pc}
    8814:	00012aa8 	.word	0x00012aa8

00008818 <_ZN15Cyg_StdioStream12set_positionEii>:
} // get_position()


// set absolute position
inline Cyg_ErrNo
Cyg_StdioStream::set_position( fpos_t pos, int whence )
    8818:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    // this will be corrected when we decide the true filesystem interface

    Cyg_ErrNo err;
    cyg_uint8 c;

    if ((whence != SEEK_CUR) || pos < 0)
    881c:	e2522001 	subs	r2, r2, #1	; 0x1
    8820:	13a02001 	movne	r2, #1	; 0x1
    8824:	e1922fa1 	orrs	r2, r2, r1, lsr #31
} // get_position()


// set absolute position
inline Cyg_ErrNo
Cyg_StdioStream::set_position( fpos_t pos, int whence )
    8828:	e24dd008 	sub	sp, sp, #8	; 0x8
    882c:	e1a05001 	mov	r5, r1
    8830:	e1a06000 	mov	r6, r0
    // this will be corrected when we decide the true filesystem interface

    Cyg_ErrNo err;
    cyg_uint8 c;

    if ((whence != SEEK_CUR) || pos < 0)
    8834:	13a04026 	movne	r4, #38	; 0x26
    8838:	0a000002 	beq	8848 <_ZN15Cyg_StdioStream12set_positionEii+0x30>
    unlock_me();

    return err;
#endif    
    
} // set_position()
    883c:	e1a00004 	mov	r0, r4
    8840:	e28dd008 	add	sp, sp, #8	; 0x8
    8844:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    8848:	e2808030 	add	r8, r0, #48	; 0x30
    884c:	e1a00008 	mov	r0, r8
    8850:	ebfff9bf 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    cyg_uint8 c;

    if ((whence != SEEK_CUR) || pos < 0)
        return ENOSYS;

    if (!lock_me())
    8854:	e3500000 	cmp	r0, #0	; 0x0
    8858:	03a04009 	moveq	r4, #9	; 0x9
    885c:	0afffff6 	beq	883c <_ZN15Cyg_StdioStream12set_positionEii+0x24>
        return EBADF; // assume file is now invalid

    // Drain read buffer
    
    for ( ; pos > 0 ; pos-- ) {
    8860:	e3550000 	cmp	r5, #0	; 0x0
    8864:	0a000013 	beq	88b8 <_ZN15Cyg_StdioStream12set_positionEii+0xa0>
    8868:	e28d7007 	add	r7, sp, #7	; 0x7
    886c:	ea000003 	b	8880 <_ZN15Cyg_StdioStream12set_positionEii+0x68>
        err = read_byte( &c );
        if (err == EAGAIN)
            err=refill_read_buffer();

        // if read_byte retured error, or refill_read_buffer returned error
        if (err) {
    8870:	e3540000 	cmp	r4, #0	; 0x0
    8874:	1a00000c 	bne	88ac <_ZN15Cyg_StdioStream12set_positionEii+0x94>
    if (!lock_me())
        return EBADF; // assume file is now invalid

    // Drain read buffer
    
    for ( ; pos > 0 ; pos-- ) {
    8878:	e2555001 	subs	r5, r5, #1	; 0x1
    887c:	0a00000d 	beq	88b8 <_ZN15Cyg_StdioStream12set_positionEii+0xa0>
        err = read_byte( &c );
    8880:	e1a01007 	mov	r1, r7
    8884:	e1a00006 	mov	r0, r6
    8888:	ebfffd40 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
        if (err == EAGAIN)
    888c:	e350000b 	cmp	r0, #11	; 0xb
        return EBADF; // assume file is now invalid

    // Drain read buffer
    
    for ( ; pos > 0 ; pos-- ) {
        err = read_byte( &c );
    8890:	e1a04000 	mov	r4, r0
        if (err == EAGAIN)
    8894:	1afffff5 	bne	8870 <_ZN15Cyg_StdioStream12set_positionEii+0x58>
            err=refill_read_buffer();
    8898:	e1a00006 	mov	r0, r6
    889c:	ebfffe02 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    88a0:	e1a04000 	mov	r4, r0

        // if read_byte retured error, or refill_read_buffer returned error
        if (err) {
    88a4:	e3540000 	cmp	r4, #0	; 0x0
    88a8:	0afffff2 	beq	8878 <_ZN15Cyg_StdioStream12set_positionEii+0x60>
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    88ac:	e1a00008 	mov	r0, r8
    88b0:	ebfffa9f 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    88b4:	eaffffe0 	b	883c <_ZN15Cyg_StdioStream12set_positionEii+0x24>
    88b8:	e1a00008 	mov	r0, r8
    88bc:	ebfffa9c 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    88c0:	e3a04000 	mov	r4, #0	; 0x0
    88c4:	eaffffdc 	b	883c <_ZN15Cyg_StdioStream12set_positionEii+0x24>

000088c8 <vfscanf>:
typedef int (*mbtowc_fn_type)(wchar_t *, const char *, size_t, int *);
externC mbtowc_fn_type __get_current_locale_mbtowc_fn();
#endif

externC int
vfscanf (FILE *fp, const char *fmt0, va_list ap) __THROW
    88c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    88cc:	e24ddf9d 	sub	sp, sp, #628	; 0x274
            if (--width > sizeof (buf) - 2)
                width = sizeof (buf) - 2;
            width++;
#endif // ifdef hardway

            flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
    88d0:	e28d902c 	add	r9, sp, #44	; 0x2c
    88d4:	e2499003 	sub	r9, r9, #3	; 0x3
    long long *ll;
#endif
    char ccltab[256];           /* character class table for %[...] */
    char buf[BUF];              /* buffer for numeric conversions */

    Cyg_StdioStream *file = (Cyg_StdioStream *)fp;
    88d8:	e3a08000 	mov	r8, #0	; 0x0
typedef int (*mbtowc_fn_type)(wchar_t *, const char *, size_t, int *);
externC mbtowc_fn_type __get_current_locale_mbtowc_fn();
#endif

externC int
vfscanf (FILE *fp, const char *fmt0, va_list ap) __THROW
    88dc:	e1a05000 	mov	r5, r0
                    break;

                    /* x ok iff flag still set & 2nd char */
                case 'x':
                case 'X':
                    if (flags & PFXOK && p == buf + 1)
    88e0:	e2890001 	add	r0, r9, #1	; 0x1
        {
            for (;;)
            {
                if (BufferEmpty)
                    return nassigned;
                if (!isspace (*CURR_POS))
    88e4:	e28d6f9b 	add	r6, sp, #620	; 0x26c
typedef int (*mbtowc_fn_type)(wchar_t *, const char *, size_t, int *);
externC mbtowc_fn_type __get_current_locale_mbtowc_fn();
#endif

externC int
vfscanf (FILE *fp, const char *fmt0, va_list ap) __THROW
    88e8:	e58d2004 	str	r2, [sp, #4]
    long long *ll;
#endif
    char ccltab[256];           /* character class table for %[...] */
    char buf[BUF];              /* buffer for numeric conversions */

    Cyg_StdioStream *file = (Cyg_StdioStream *)fp;
    88ec:	e58d800c 	str	r8, [sp, #12]
    88f0:	e58d8010 	str	r8, [sp, #16]
    88f4:	e58d8014 	str	r8, [sp, #20]
                    break;

                    /* x ok iff flag still set & 2nd char */
                case 'x':
                case 'X':
                    if (flags & PFXOK && p == buf + 1)
    88f8:	e58d0000 	str	r0, [sp]
#endif

externC int
vfscanf (FILE *fp, const char *fmt0, va_list ap) __THROW
{
    u_char *fmt = (u_char *) fmt0;
    88fc:	e1a07001 	mov	r7, r1
    long long *ll;
#endif
    char ccltab[256];           /* character class table for %[...] */
    char buf[BUF];              /* buffer for numeric conversions */

    Cyg_StdioStream *file = (Cyg_StdioStream *)fp;
    8900:	e1a04008 	mov	r4, r8
        {
            for (;;)
            {
                if (BufferEmpty)
                    return nassigned;
                if (!isspace (*CURR_POS))
    8904:	e2866003 	add	r6, r6, #3	; 0x3
    nassigned = 0;
    nread = 0;
    for (;;)
    {
#ifndef CYGINT_LIBC_I18N_MB_REQUIRED
        wc = *fmt;
    8908:	e5d70000 	ldrb	r0, [r7]
#else
        nbytes = mbtowc_fn (&wc, fmt, MB_CUR_MAX, &state);
#endif
        fmt += nbytes;

        if (wc == 0)
    890c:	e3500000 	cmp	r0, #0	; 0x0
    8910:	0a000046 	beq	8a30 <vfscanf+0x168>

CYGPRI_LIBC_I18N_CTYPE_INLINE int
isspace( int c )
{
    return ( (c == ' ') || (c == '\f') || (c == '\n') || (c == '\r') ||
             (c == '\t') || (c == '\v') );
    8914:	e350000c 	cmp	r0, #12	; 0xc
    8918:	13500020 	cmpne	r0, #32	; 0x20
#ifndef CYGINT_LIBC_I18N_MB_REQUIRED
        wc = *fmt;
#else
        nbytes = mbtowc_fn (&wc, fmt, MB_CUR_MAX, &state);
#endif
        fmt += nbytes;
    891c:	e2877001 	add	r7, r7, #1	; 0x1
    8920:	0a000007 	beq	8944 <vfscanf+0x7c>
    8924:	e350000d 	cmp	r0, #13	; 0xd
    8928:	1350000a 	cmpne	r0, #10	; 0xa
    892c:	0a000004 	beq	8944 <vfscanf+0x7c>
    8930:	e350000b 	cmp	r0, #11	; 0xb
    8934:	13500009 	cmpne	r0, #9	; 0x9
    8938:	13a01000 	movne	r1, #0	; 0x0
    893c:	03a01001 	moveq	r1, #1	; 0x1
    8940:	1a000041 	bne	8a4c <vfscanf+0x184>
    8944:	e5d52028 	ldrb	r2, [r5, #40]
    8948:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    894c:	e3120020 	tst	r2, #32	; 0x20
    8950:	e2031001 	and	r1, r3, #1	; 0x1
    8954:	0a000016 	beq	89b4 <vfscanf+0xec>
        if (flags.last_buffer_op_was_read == true)
    8958:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    895c:	1285201c 	addne	r2, r5, #28	; 0x1c
    8960:	1892000c 	ldmne	r2, {r2, r3}
    8964:	10423003 	subne	r3, r2, r3
    8968:	10811003 	addne	r1, r1, r3
           return nassigned;
        if (nbytes == 1 && isspace (wc))
        {
            for (;;)
            {
                if (BufferEmpty)
    896c:	e3510000 	cmp	r1, #0	; 0x0
    8970:	0a000020 	beq	89f8 <vfscanf+0x130>
                    return nassigned;
                if (!isspace (*CURR_POS))
    8974:	e1a00005 	mov	r0, r5
    8978:	e1a01006 	mov	r1, r6
    897c:	ebfffcc7 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    8980:	e5dd326f 	ldrb	r3, [sp, #623]
    8984:	e353000c 	cmp	r3, #12	; 0xc
    8988:	13530020 	cmpne	r3, #32	; 0x20
    898c:	1a000012 	bne	89dc <vfscanf+0x114>
                    break;
                nread++, INC_CURR_POS;
    8990:	e1a01006 	mov	r1, r6
    8994:	e1a00005 	mov	r0, r5
    8998:	ebfffcfc 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
    899c:	e5d52028 	ldrb	r2, [r5, #40]
    89a0:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    89a4:	e3120020 	tst	r2, #32	; 0x20
    89a8:	e2844001 	add	r4, r4, #1	; 0x1
    89ac:	e2031001 	and	r1, r3, #1	; 0x1
    89b0:	1affffe8 	bne	8958 <vfscanf+0x90>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    89b4:	e5d53029 	ldrb	r3, [r5, #41]
    89b8:	e3130001 	tst	r3, #1	; 0x1
    89bc:	0affffea 	beq	896c <vfscanf+0xa4>
        {
            for (;;)
            {
                if (BufferEmpty)
                    return nassigned;
                if (!isspace (*CURR_POS))
    89c0:	e1a00005 	mov	r0, r5
    89c4:	e1a01006 	mov	r1, r6
    89c8:	ebfffcb4 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    89cc:	e5dd326f 	ldrb	r3, [sp, #623]
    89d0:	e353000c 	cmp	r3, #12	; 0xc
    89d4:	13530020 	cmpne	r3, #32	; 0x20
    89d8:	0affffec 	beq	8990 <vfscanf+0xc8>
    89dc:	e353000d 	cmp	r3, #13	; 0xd
    89e0:	1353000a 	cmpne	r3, #10	; 0xa
    89e4:	0affffe9 	beq	8990 <vfscanf+0xc8>
    89e8:	e353000b 	cmp	r3, #11	; 0xb
    89ec:	13530009 	cmpne	r3, #9	; 0x9
    89f0:	1affffc4 	bne	8908 <vfscanf+0x40>
    89f4:	eaffffe5 	b	8990 <vfscanf+0xc8>
           return nassigned;
        if (nbytes == 1 && isspace (wc))
        {
            for (;;)
            {
                if (BufferEmpty)
    89f8:	e1a00005 	mov	r0, r5
    89fc:	ebfffdaa 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    8a00:	e5d52028 	ldrb	r2, [r5, #40]
    8a04:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    8a08:	e3120020 	tst	r2, #32	; 0x20
    8a0c:	e2031001 	and	r1, r3, #1	; 0x1
    8a10:	0a000009 	beq	8a3c <vfscanf+0x174>
        if (flags.last_buffer_op_was_read == true)
    8a14:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    8a18:	1285001c 	addne	r0, r5, #28	; 0x1c
    8a1c:	18900009 	ldmne	r0, {r0, r3}
    8a20:	10403003 	subne	r3, r0, r3
    8a24:	10811003 	addne	r1, r1, r3
    8a28:	e3510000 	cmp	r1, #0	; 0x0
    8a2c:	1affffd0 	bne	8974 <vfscanf+0xac>

input_failure:
    return nassigned ? nassigned : -1;
match_failure:
    return nassigned;
} // vfscanf()
    8a30:	e1a00008 	mov	r0, r8
    8a34:	e28ddf9d 	add	sp, sp, #628	; 0x274
    8a38:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    8a3c:	e5d53029 	ldrb	r3, [r5, #41]
    8a40:	e3130001 	tst	r3, #1	; 0x1
    8a44:	1affffca 	bne	8974 <vfscanf+0xac>
    8a48:	eafffff6 	b	8a28 <vfscanf+0x160>
                    break;
                nread++, INC_CURR_POS;
            }
            continue;
        }
        if (wc != '%')
    8a4c:	e3500025 	cmp	r0, #37	; 0x25
            goto literal;
    8a50:	058d1008 	streq	r1, [sp, #8]
    8a54:	01a0a001 	moveq	sl, r1
                    break;
                nread++, INC_CURR_POS;
            }
            continue;
        }
        if (wc != '%')
    8a58:	0a000032 	beq	8b28 <vfscanf+0x260>
        c = *fmt++;
        
        switch (c)
        {
        case '%':
literal:
    8a5c:	e5d52028 	ldrb	r2, [r5, #40]
    8a60:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    8a64:	e3120020 	tst	r2, #32	; 0x20
    8a68:	e2031001 	and	r1, r3, #1	; 0x1
    8a6c:	0a000012 	beq	8abc <vfscanf+0x1f4>
        if (flags.last_buffer_op_was_read == true)
    8a70:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    8a74:	1285201c 	addne	r2, r5, #28	; 0x1c
    8a78:	1892000c 	ldmne	r2, {r2, r3}
    8a7c:	10423003 	subne	r3, r2, r3
    8a80:	10811003 	addne	r1, r1, r3
            lptr = fmt - nbytes;
            for (n = 0; n < nbytes; ++n)
              {
		if (BufferEmpty)
    8a84:	e3510000 	cmp	r1, #0	; 0x0
    8a88:	0a000010 	beq	8ad0 <vfscanf+0x208>
		  goto input_failure;
		if (*CURR_POS != *lptr)
    8a8c:	e1a00005 	mov	r0, r5
    8a90:	e1a01006 	mov	r1, r6
    8a94:	ebfffc81 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    8a98:	e5dd226f 	ldrb	r2, [sp, #623]
    8a9c:	e5573001 	ldrb	r3, [r7, #-1]
    8aa0:	e1520003 	cmp	r2, r3
    8aa4:	1affffe1 	bne	8a30 <vfscanf+0x168>
		  goto match_failure;
		INC_CURR_POS;
    8aa8:	e1a00005 	mov	r0, r5
    8aac:	e1a01006 	mov	r1, r6
    8ab0:	ebfffcb6 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
		nread++;
    8ab4:	e2844001 	add	r4, r4, #1	; 0x1
    8ab8:	eaffff92 	b	8908 <vfscanf+0x40>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    8abc:	e5d53029 	ldrb	r3, [r5, #41]
    8ac0:	e3130001 	tst	r3, #1	; 0x1
    8ac4:	1afffff0 	bne	8a8c <vfscanf+0x1c4>
        case '%':
literal:
            lptr = fmt - nbytes;
            for (n = 0; n < nbytes; ++n)
              {
		if (BufferEmpty)
    8ac8:	e3510000 	cmp	r1, #0	; 0x0
    8acc:	1affffee 	bne	8a8c <vfscanf+0x1c4>
    8ad0:	e1a00005 	mov	r0, r5
    8ad4:	ebfffd74 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    8ad8:	e5d52028 	ldrb	r2, [r5, #40]
    8adc:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    8ae0:	e3120020 	tst	r2, #32	; 0x20
    8ae4:	e2031001 	and	r1, r3, #1	; 0x1
    8ae8:	0a000009 	beq	8b14 <vfscanf+0x24c>
        if (flags.last_buffer_op_was_read == true)
    8aec:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    8af0:	1285001c 	addne	r0, r5, #28	; 0x1c
    8af4:	18900009 	ldmne	r0, {r0, r3}
    8af8:	10403003 	subne	r3, r0, r3
    8afc:	10811003 	addne	r1, r1, r3
    8b00:	e3510000 	cmp	r1, #0	; 0x0
    8b04:	1affffe0 	bne	8a8c <vfscanf+0x1c4>
            break;
        }
    }

input_failure:
    return nassigned ? nassigned : -1;
    8b08:	e3580000 	cmp	r8, #0	; 0x0
    8b0c:	03e08000 	mvneq	r8, #0	; 0x0
    8b10:	eaffffc6 	b	8a30 <vfscanf+0x168>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    8b14:	e5d53029 	ldrb	r3, [r5, #41]
    8b18:	e3130001 	tst	r3, #1	; 0x1
    8b1c:	1affffda 	bne	8a8c <vfscanf+0x1c4>
    8b20:	eafffff6 	b	8b00 <vfscanf+0x238>
        case 'L':
            flags |= LONGDBL;
            goto again;
#endif
        case 'h':
            flags |= SHORT;
    8b24:	e38aa004 	orr	sl, sl, #4	; 0x4
         * switch on the format.  continue if done; break once format
         * type is derived.
         */
        
again:
        c = *fmt++;
    8b28:	e4d71001 	ldrb	r1, [r7], #1
        
        switch (c)
    8b2c:	e3510078 	cmp	r1, #120	; 0x78
    8b30:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    8b34:	ea000332 	b	9804 <vfscanf+0xf3c>
    8b38:	000097fc 	.word	0x000097fc
    8b3c:	00009804 	.word	0x00009804
    8b40:	00009804 	.word	0x00009804
    8b44:	00009804 	.word	0x00009804
    8b48:	00009804 	.word	0x00009804
    8b4c:	00009804 	.word	0x00009804
    8b50:	00009804 	.word	0x00009804
    8b54:	00009804 	.word	0x00009804
    8b58:	00009804 	.word	0x00009804
    8b5c:	00009804 	.word	0x00009804
    8b60:	00009804 	.word	0x00009804
    8b64:	00009804 	.word	0x00009804
    8b68:	00009804 	.word	0x00009804
    8b6c:	00009804 	.word	0x00009804
    8b70:	00009804 	.word	0x00009804
    8b74:	00009804 	.word	0x00009804
    8b78:	00009804 	.word	0x00009804
    8b7c:	00009804 	.word	0x00009804
    8b80:	00009804 	.word	0x00009804
    8b84:	00009804 	.word	0x00009804
    8b88:	00009804 	.word	0x00009804
    8b8c:	00009804 	.word	0x00009804
    8b90:	00009804 	.word	0x00009804
    8b94:	00009804 	.word	0x00009804
    8b98:	00009804 	.word	0x00009804
    8b9c:	00009804 	.word	0x00009804
    8ba0:	00009804 	.word	0x00009804
    8ba4:	00009804 	.word	0x00009804
    8ba8:	00009804 	.word	0x00009804
    8bac:	00009804 	.word	0x00009804
    8bb0:	00009804 	.word	0x00009804
    8bb4:	00009804 	.word	0x00009804
    8bb8:	00009804 	.word	0x00009804
    8bbc:	00009804 	.word	0x00009804
    8bc0:	00009804 	.word	0x00009804
    8bc4:	00009804 	.word	0x00009804
    8bc8:	00009804 	.word	0x00009804
    8bcc:	00008a5c 	.word	0x00008a5c
    8bd0:	00009804 	.word	0x00009804
    8bd4:	00009804 	.word	0x00009804
    8bd8:	00009804 	.word	0x00009804
    8bdc:	00009804 	.word	0x00009804
    8be0:	000097f4 	.word	0x000097f4
    8be4:	00009804 	.word	0x00009804
    8be8:	00009804 	.word	0x00009804
    8bec:	00009804 	.word	0x00009804
    8bf0:	00009804 	.word	0x00009804
    8bf4:	00009804 	.word	0x00009804
    8bf8:	000097d4 	.word	0x000097d4
    8bfc:	000097d4 	.word	0x000097d4
    8c00:	000097d4 	.word	0x000097d4
    8c04:	000097d4 	.word	0x000097d4
    8c08:	000097d4 	.word	0x000097d4
    8c0c:	000097d4 	.word	0x000097d4
    8c10:	000097d4 	.word	0x000097d4
    8c14:	000097d4 	.word	0x000097d4
    8c18:	000097d4 	.word	0x000097d4
    8c1c:	000097d4 	.word	0x000097d4
    8c20:	00009804 	.word	0x00009804
    8c24:	00009804 	.word	0x00009804
    8c28:	00009804 	.word	0x00009804
    8c2c:	00009804 	.word	0x00009804
    8c30:	00009804 	.word	0x00009804
    8c34:	00009804 	.word	0x00009804
    8c38:	00009804 	.word	0x00009804
    8c3c:	00009804 	.word	0x00009804
    8c40:	00009804 	.word	0x00009804
    8c44:	00009804 	.word	0x00009804
    8c48:	00009528 	.word	0x00009528
    8c4c:	00009880 	.word	0x00009880
    8c50:	00009804 	.word	0x00009804
    8c54:	00009880 	.word	0x00009880
    8c58:	00009804 	.word	0x00009804
    8c5c:	00009804 	.word	0x00009804
    8c60:	00009804 	.word	0x00009804
    8c64:	00009804 	.word	0x00009804
    8c68:	00009878 	.word	0x00009878
    8c6c:	00009804 	.word	0x00009804
    8c70:	00009804 	.word	0x00009804
    8c74:	00008d1c 	.word	0x00008d1c
    8c78:	00009804 	.word	0x00009804
    8c7c:	00009804 	.word	0x00009804
    8c80:	00009804 	.word	0x00009804
    8c84:	00009804 	.word	0x00009804
    8c88:	00009804 	.word	0x00009804
    8c8c:	00009804 	.word	0x00009804
    8c90:	00009804 	.word	0x00009804
    8c94:	00009804 	.word	0x00009804
    8c98:	000097a4 	.word	0x000097a4
    8c9c:	00009804 	.word	0x00009804
    8ca0:	00009804 	.word	0x00009804
    8ca4:	0000974c 	.word	0x0000974c
    8ca8:	00009804 	.word	0x00009804
    8cac:	00009804 	.word	0x00009804
    8cb0:	00009804 	.word	0x00009804
    8cb4:	00009804 	.word	0x00009804
    8cb8:	00009804 	.word	0x00009804
    8cbc:	00009804 	.word	0x00009804
    8cc0:	00009804 	.word	0x00009804
    8cc4:	00009740 	.word	0x00009740
    8cc8:	0000952c 	.word	0x0000952c
    8ccc:	00009880 	.word	0x00009880
    8cd0:	00009880 	.word	0x00009880
    8cd4:	00009880 	.word	0x00009880
    8cd8:	00008b24 	.word	0x00008b24
    8cdc:	000096dc 	.word	0x000096dc
    8ce0:	00009804 	.word	0x00009804
    8ce4:	00009804 	.word	0x00009804
    8ce8:	000096c8 	.word	0x000096c8
    8cec:	00009804 	.word	0x00009804
    8cf0:	000096a0 	.word	0x000096a0
    8cf4:	00008d20 	.word	0x00008d20
    8cf8:	0000985c 	.word	0x0000985c
    8cfc:	00009804 	.word	0x00009804
    8d00:	00009804 	.word	0x00009804
    8d04:	00009854 	.word	0x00009854
    8d08:	00009804 	.word	0x00009804
    8d0c:	00009828 	.word	0x00009828
    8d10:	00009804 	.word	0x00009804
    8d14:	00009804 	.word	0x00009804
    8d18:	000097a4 	.word	0x000097a4
#endif
            base = 0;
            break;

        case 'O':               /* compat */
            flags |= LONG;
    8d1c:	e38aa001 	orr	sl, sl, #1	; 0x1
            /* FALLTHROUGH */
        case 'o':
            c = CT_INT;
            ccfn = strtoul;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    8d20:	e59f3fd8 	ldr	r3, [pc, #4056]	; 9d00 <vfscanf+0x1438>
    8d24:	e59d2014 	ldr	r2, [sp, #20]
    8d28:	e31a0002 	tst	sl, #2	; 0x2
    8d2c:	e59f0fd0 	ldr	r0, [pc, #4048]	; 9d04 <vfscanf+0x143c>
    8d30:	11a02003 	movne	r2, r3
    8d34:	e3a03008 	mov	r3, #8	; 0x8
    8d38:	e58d2014 	str	r2, [sp, #20]
    8d3c:	e58d300c 	str	r3, [sp, #12]
    8d40:	e58d0010 	str	r0, [sp, #16]
    8d44:	e3a0b003 	mov	fp, #3	; 0x3

        default:                /* compat */
            if (isupper (c))
                flags |= LONG;
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    8d48:	e5d52028 	ldrb	r2, [r5, #40]
    8d4c:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    8d50:	e3120020 	tst	r2, #32	; 0x20
    8d54:	e2031001 	and	r1, r3, #1	; 0x1
    8d58:	0a0002cf 	beq	989c <vfscanf+0xfd4>
        if (flags.last_buffer_op_was_read == true)
    8d5c:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    8d60:	1285001c 	addne	r0, r5, #28	; 0x1c
    8d64:	18900009 	ldmne	r0, {r0, r3}
    8d68:	10403003 	subne	r3, r0, r3
    8d6c:	10811003 	addne	r1, r1, r3
        }

        /*
         * We have a conversion that requires input.
         */
        if (BufferEmpty)
    8d70:	e3510000 	cmp	r1, #0	; 0x0
    8d74:	0a0002cc 	beq	98ac <vfscanf+0xfe4>

        /*
         * Consume leading white space, except for formats that
         * suppress this.
         */
        if ((flags & NOSKIP) == 0)
    8d78:	e31a0020 	tst	sl, #32	; 0x20
    8d7c:	0a00000c 	beq	8db4 <vfscanf+0x4ec>
        }

        /*
         * Do the conversion.
         */
        switch (c)
    8d80:	e35b0004 	cmp	fp, #4	; 0x4
    8d84:	979ff10b 	ldrls	pc, [pc, fp, lsl #2]
    8d88:	eafffede 	b	8908 <vfscanf+0x40>
    8d8c:	00009350 	.word	0x00009350
    8d90:	00009190 	.word	0x00009190
    8d94:	000093f4 	.word	0x000093f4
    8d98:	00008ff8 	.word	0x00008ff8
    8d9c:	00008e2c 	.word	0x00008e2c
            {
                nread++;
                INC_CURR_POS;
                if (SPACE_LEFT == 0)
#ifndef REDHAT_NEC
                    if (REFILL)
    8da0:	e1a00005 	mov	r0, r5
    8da4:	ebfffcc0 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    8da8:	e3500000 	cmp	r0, #0	; 0x0
    8dac:	1affff55 	bne	8b08 <vfscanf+0x240>
         */
        if ((flags & NOSKIP) == 0)
        {
            while (isspace (*CURR_POS))
            {
                nread++;
    8db0:	e2844001 	add	r4, r4, #1	; 0x1
         * Consume leading white space, except for formats that
         * suppress this.
         */
        if ((flags & NOSKIP) == 0)
        {
            while (isspace (*CURR_POS))
    8db4:	e1a00005 	mov	r0, r5
    8db8:	e1a01006 	mov	r1, r6
    8dbc:	ebfffbb7 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    8dc0:	e5dd326f 	ldrb	r3, [sp, #623]
    8dc4:	e353000c 	cmp	r3, #12	; 0xc
    8dc8:	13530020 	cmpne	r3, #32	; 0x20
    8dcc:	0a000005 	beq	8de8 <vfscanf+0x520>
    8dd0:	e353000d 	cmp	r3, #13	; 0xd
    8dd4:	1353000a 	cmpne	r3, #10	; 0xa
    8dd8:	0a000002 	beq	8de8 <vfscanf+0x520>
    8ddc:	e353000b 	cmp	r3, #11	; 0xb
    8de0:	13530009 	cmpne	r3, #9	; 0x9
    8de4:	1affffe5 	bne	8d80 <vfscanf+0x4b8>
            {
                nread++;
                INC_CURR_POS;
    8de8:	e1a01006 	mov	r1, r6
    8dec:	e1a00005 	mov	r0, r5
    8df0:	ebfffbe6 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
    8df4:	e5d52028 	ldrb	r2, [r5, #40]
    8df8:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    8dfc:	e3120020 	tst	r2, #32	; 0x20
    8e00:	e2031001 	and	r1, r3, #1	; 0x1
    8e04:	0a00029f 	beq	9888 <vfscanf+0xfc0>
        if (flags.last_buffer_op_was_read == true)
    8e08:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    8e0c:	1285001c 	addne	r0, r5, #28	; 0x1c
    8e10:	18900009 	ldmne	r0, {r0, r3}
    8e14:	10403003 	subne	r3, r0, r3
    8e18:	10811003 	addne	r1, r1, r3
                if (SPACE_LEFT == 0)
    8e1c:	e3510000 	cmp	r1, #0	; 0x0
    8e20:	0affffde 	beq	8da0 <vfscanf+0x4d8>
         */
        if ((flags & NOSKIP) == 0)
        {
            while (isspace (*CURR_POS))
            {
                nread++;
    8e24:	e2844001 	add	r4, r4, #1	; 0x1
    8e28:	eaffffe1 	b	8db4 <vfscanf+0x4ec>
#ifdef hardway
            if (width == 0 || width > sizeof (buf) - 1)
                width = sizeof (buf) - 1;
#else
            /* size_t is unsigned, hence this optimisation */
            if (--width > sizeof (buf) - 2)
    8e2c:	e59d0008 	ldr	r0, [sp, #8]
    8e30:	e2403001 	sub	r3, r0, #1	; 0x1
    8e34:	e3530f51 	cmp	r3, #324	; 0x144
    8e38:	23a03f51 	movcs	r3, #324	; 0x144
                width = sizeof (buf) - 2;
            width++;
#endif // ifdef hardway

            flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
    8e3c:	e58d9020 	str	r9, [sp, #32]
                width = sizeof (buf) - 1;
#else
            /* size_t is unsigned, hence this optimisation */
            if (--width > sizeof (buf) - 2)
                width = sizeof (buf) - 2;
            width++;
    8e40:	e283b001 	add	fp, r3, #1	; 0x1
#endif // ifdef hardway

            flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
    8e44:	e38aad0f 	orr	sl, sl, #960	; 0x3c0
            for (p = buf; width; width--)
            {
                c = *CURR_POS;
    8e48:	e1a00005 	mov	r0, r5
    8e4c:	e1a01006 	mov	r1, r6
    8e50:	ebfffb92 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    8e54:	e5dd226f 	ldrb	r2, [sp, #623]
                /*
                 * This code mimicks the integer conversion
                 * code, but is much simpler.
                 */
                switch (c)
    8e58:	e242302b 	sub	r3, r2, #43	; 0x2b
    8e5c:	e353003a 	cmp	r3, #58	; 0x3a
    8e60:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    8e64:	ea000051 	b	8fb0 <vfscanf+0x6e8>
    8e68:	00009518 	.word	0x00009518
    8e6c:	00008fb0 	.word	0x00008fb0
    8e70:	00009518 	.word	0x00009518
    8e74:	00008f54 	.word	0x00008f54
    8e78:	00008fb0 	.word	0x00008fb0
    8e7c:	00009188 	.word	0x00009188
    8e80:	00009188 	.word	0x00009188
    8e84:	00009188 	.word	0x00009188
    8e88:	00009188 	.word	0x00009188
    8e8c:	00009188 	.word	0x00009188
    8e90:	00009188 	.word	0x00009188
    8e94:	00009188 	.word	0x00009188
    8e98:	00009188 	.word	0x00009188
    8e9c:	00009188 	.word	0x00009188
    8ea0:	00009188 	.word	0x00009188
    8ea4:	00008fb0 	.word	0x00008fb0
    8ea8:	00008fb0 	.word	0x00008fb0
    8eac:	00008fb0 	.word	0x00008fb0
    8eb0:	00008fb0 	.word	0x00008fb0
    8eb4:	00008fb0 	.word	0x00008fb0
    8eb8:	00008fb0 	.word	0x00008fb0
    8ebc:	00008fb0 	.word	0x00008fb0
    8ec0:	00008fb0 	.word	0x00008fb0
    8ec4:	00008fb0 	.word	0x00008fb0
    8ec8:	00008fb0 	.word	0x00008fb0
    8ecc:	00008fb0 	.word	0x00008fb0
    8ed0:	00009170 	.word	0x00009170
    8ed4:	00008fb0 	.word	0x00008fb0
    8ed8:	00008fb0 	.word	0x00008fb0
    8edc:	00008fb0 	.word	0x00008fb0
    8ee0:	00008fb0 	.word	0x00008fb0
    8ee4:	00008fb0 	.word	0x00008fb0
    8ee8:	00008fb0 	.word	0x00008fb0
    8eec:	00008fb0 	.word	0x00008fb0
    8ef0:	00008fb0 	.word	0x00008fb0
    8ef4:	00008fb0 	.word	0x00008fb0
    8ef8:	00008fb0 	.word	0x00008fb0
    8efc:	00008fb0 	.word	0x00008fb0
    8f00:	00008fb0 	.word	0x00008fb0
    8f04:	00008fb0 	.word	0x00008fb0
    8f08:	00008fb0 	.word	0x00008fb0
    8f0c:	00008fb0 	.word	0x00008fb0
    8f10:	00008fb0 	.word	0x00008fb0
    8f14:	00008fb0 	.word	0x00008fb0
    8f18:	00008fb0 	.word	0x00008fb0
    8f1c:	00008fb0 	.word	0x00008fb0
    8f20:	00008fb0 	.word	0x00008fb0
    8f24:	00008fb0 	.word	0x00008fb0
    8f28:	00008fb0 	.word	0x00008fb0
    8f2c:	00008fb0 	.word	0x00008fb0
    8f30:	00008fb0 	.word	0x00008fb0
    8f34:	00008fb0 	.word	0x00008fb0
    8f38:	00008fb0 	.word	0x00008fb0
    8f3c:	00008fb0 	.word	0x00008fb0
    8f40:	00008fb0 	.word	0x00008fb0
    8f44:	00008fb0 	.word	0x00008fb0
    8f48:	00008fb0 	.word	0x00008fb0
    8f4c:	00008fb0 	.word	0x00008fb0
    8f50:	00009170 	.word	0x00009170
                        flags &= ~SIGNOK;
                        goto fok;
                    }
                    break;
                case '.':
                    if (flags & DPTOK)
    8f54:	e31a0c01 	tst	sl, #256	; 0x100
    8f58:	0a000014 	beq	8fb0 <vfscanf+0x6e8>
                    {
                        flags &= ~(SIGNOK | DPTOK);
    8f5c:	e3caad05 	bic	sl, sl, #320	; 0x140
                    }
                    break;
                }
                break;
            fok:
                *p++ = c;
    8f60:	e59d3020 	ldr	r3, [sp, #32]
    8f64:	e4c32001 	strb	r2, [r3], #1
                INC_CURR_POS;
    8f68:	e1a01006 	mov	r1, r6
    8f6c:	e1a00005 	mov	r0, r5
                    }
                    break;
                }
                break;
            fok:
                *p++ = c;
    8f70:	e58d3020 	str	r3, [sp, #32]
                INC_CURR_POS;
    8f74:	ebfffb85 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
    8f78:	e5d52028 	ldrb	r2, [r5, #40]
    8f7c:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    8f80:	e3120020 	tst	r2, #32	; 0x20
    8f84:	e2031001 	and	r1, r3, #1	; 0x1
    8f88:	0a00025a 	beq	98f8 <vfscanf+0x1030>
        if (flags.last_buffer_op_was_read == true)
    8f8c:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    8f90:	1285001c 	addne	r0, r5, #28	; 0x1c
    8f94:	18900009 	ldmne	r0, {r0, r3}
    8f98:	10403003 	subne	r3, r0, r3
    8f9c:	10811003 	addne	r1, r1, r3
                if (SPACE_LEFT == 0)
    8fa0:	e3510000 	cmp	r1, #0	; 0x0
    8fa4:	0a000257 	beq	9908 <vfscanf+0x1040>
                width = sizeof (buf) - 2;
            width++;
#endif // ifdef hardway

            flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
            for (p = buf; width; width--)
    8fa8:	e25bb001 	subs	fp, fp, #1	; 0x1
    8fac:	1affffa5 	bne	8e48 <vfscanf+0x580>
            /*
             * If no digits, might be missing exponent digits
             * (just give back the exponent) or might be missing
             * regular digits, but had sign and/or decimal point.
             */
            if (flags & NDIGITS)
    8fb0:	e31a0080 	tst	sl, #128	; 0x80
    8fb4:	0a000009 	beq	8fe0 <vfscanf+0x718>
            {
                if (flags & EXPOK)
    8fb8:	e31a0c02 	tst	sl, #512	; 0x200
    8fbc:	1a00031f 	bne	9c40 <vfscanf+0x1378>
                    while (p > buf)
                        ungetc (*(u_char *)-- p, fp);
                    goto match_failure;
                }
                /* just a bad exponent (e and maybe sign) */
                c = *(u_char *)-- p;
    8fc0:	e59d2020 	ldr	r2, [sp, #32]
    8fc4:	e5720001 	ldrb	r0, [r2, #-1]!
                if (c != 'e' && c != 'E')
    8fc8:	e3500065 	cmp	r0, #101	; 0x65
    8fcc:	13500045 	cmpne	r0, #69	; 0x45
                    while (p > buf)
                        ungetc (*(u_char *)-- p, fp);
                    goto match_failure;
                }
                /* just a bad exponent (e and maybe sign) */
                c = *(u_char *)-- p;
    8fd0:	e58d2020 	str	r2, [sp, #32]
                if (c != 'e' && c != 'E')
    8fd4:	1a000313 	bne	9c28 <vfscanf+0x1360>
                {
                    _CAST_VOID ungetc (c, fp); /* sign */
                    c = *(u_char *)-- p;
                }
                _CAST_VOID ungetc (c, fp);
    8fd8:	e1a01005 	mov	r1, r5
    8fdc:	eb001b57 	bl	fd40 <ungetc>
            }
            if ((flags & SUPPRESS) == 0)
    8fe0:	e21a3008 	ands	r3, sl, #8	; 0x8
    8fe4:	0a0002f2 	beq	9bb4 <vfscanf+0x12ec>
                    flp = va_arg (ap, float *);
                    *flp = res;
                }
                nassigned++;
            }
            nread += p - buf;
    8fe8:	e59d0020 	ldr	r0, [sp, #32]
    8fec:	e0693004 	rsb	r3, r9, r4
    8ff0:	e0804003 	add	r4, r0, r3
    8ff4:	eafffe43 	b	8908 <vfscanf+0x40>
#ifdef hardway
            if (width == 0 || width > sizeof (buf) - 1)
                width = sizeof (buf) - 1;
#else
            /* size_t is unsigned, hence this optimisation */
            if (--width > sizeof (buf) - 2)
    8ff8:	e59d1008 	ldr	r1, [sp, #8]
    8ffc:	e2413001 	sub	r3, r1, #1	; 0x1
    9000:	e3530f51 	cmp	r3, #324	; 0x144
    9004:	23a03f51 	movcs	r3, #324	; 0x144
                width = sizeof (buf) - 2;
            width++;
    9008:	e2833001 	add	r3, r3, #1	; 0x1
    900c:	e58d3024 	str	r3, [sp, #36]
#endif
            flags |= SIGNOK | NDIGITS | NZDIGITS;
    9010:	e38aad0b 	orr	sl, sl, #704	; 0x2c0
    9014:	e1a0b009 	mov	fp, r9
            for (p = buf; width; width--)
            {
                c = *CURR_POS;
    9018:	e1a00005 	mov	r0, r5
    901c:	e1a01006 	mov	r1, r6
    9020:	ebfffb1e 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    9024:	e5dd226f 	ldrb	r2, [sp, #623]
                /*
                 * Switch on the character; `goto ok' if we
                 * accept it as a part of number.
                 */
                switch (c)
    9028:	e242302b 	sub	r3, r2, #43	; 0x2b
    902c:	e353004d 	cmp	r3, #77	; 0x4d
    9030:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    9034:	ea000161 	b	95c0 <vfscanf+0xcf8>
    9038:	00009690 	.word	0x00009690
    903c:	000095c0 	.word	0x000095c0
    9040:	00009690 	.word	0x00009690
    9044:	000095c0 	.word	0x000095c0
    9048:	000095c0 	.word	0x000095c0
    904c:	0000966c 	.word	0x0000966c
    9050:	00009558 	.word	0x00009558
    9054:	00009558 	.word	0x00009558
    9058:	00009558 	.word	0x00009558
    905c:	00009558 	.word	0x00009558
    9060:	00009558 	.word	0x00009558
    9064:	00009558 	.word	0x00009558
    9068:	00009558 	.word	0x00009558
    906c:	0000964c 	.word	0x0000964c
    9070:	964c      	.short	0x964c
    9072:	00          	.byte	0x00
    9073:	00          	.byte	0x00
    9074:	000095c0 	.word	0x000095c0
    9078:	000095c0 	.word	0x000095c0
    907c:	000095c0 	.word	0x000095c0
    9080:	000095c0 	.word	0x000095c0
    9084:	000095c0 	.word	0x000095c0
    9088:	000095c0 	.word	0x000095c0
    908c:	000095c0 	.word	0x000095c0
    9090:	00009730 	.word	0x00009730
    9094:	00009730 	.word	0x00009730
    9098:	00009730 	.word	0x00009730
    909c:	00009730 	.word	0x00009730
    90a0:	00009730 	.word	0x00009730
    90a4:	00009730 	.word	0x00009730
    90a8:	000095c0 	.word	0x000095c0
    90ac:	000095c0 	.word	0x000095c0
    90b0:	c0          	.byte	0xc0
    90b1:	95          	.byte	0x95
    90b2:	0000      	.short	0x0000
    90b4:	000095c0 	.word	0x000095c0
    90b8:	000095c0 	.word	0x000095c0
    90bc:	000095c0 	.word	0x000095c0
    90c0:	000095c0 	.word	0x000095c0
    90c4:	000095c0 	.word	0x000095c0
    90c8:	000095c0 	.word	0x000095c0
    90cc:	000095c0 	.word	0x000095c0
    90d0:	000095c0 	.word	0x000095c0
    90d4:	000095c0 	.word	0x000095c0
    90d8:	000095c0 	.word	0x000095c0
    90dc:	000095c0 	.word	0x000095c0
    90e0:	000095c0 	.word	0x000095c0
    90e4:	000095c0 	.word	0x000095c0
    90e8:	000095c0 	.word	0x000095c0
    90ec:	0000970c 	.word	0x0000970c
    90f0:	000095c0 	.word	0x000095c0
    90f4:	000095c0 	.word	0x000095c0
    90f8:	000095c0 	.word	0x000095c0
    90fc:	000095c0 	.word	0x000095c0
    9100:	000095c0 	.word	0x000095c0
    9104:	000095c0 	.word	0x000095c0
    9108:	000095c0 	.word	0x000095c0
    910c:	000095c0 	.word	0x000095c0
    9110:	00009730 	.word	0x00009730
    9114:	00009730 	.word	0x00009730
    9118:	00009730 	.word	0x00009730
    911c:	00009730 	.word	0x00009730
    9120:	00009730 	.word	0x00009730
    9124:	00009730 	.word	0x00009730
    9128:	000095c0 	.word	0x000095c0
    912c:	000095c0 	.word	0x000095c0
    9130:	000095c0 	.word	0x000095c0
    9134:	000095c0 	.word	0x000095c0
    9138:	000095c0 	.word	0x000095c0
    913c:	95c0      	.short	0x95c0
    913e:	0000      	.short	0x0000
    9140:	000095c0 	.word	0x000095c0
    9144:	000095c0 	.word	0x000095c0
    9148:	000095c0 	.word	0x000095c0
    914c:	000095c0 	.word	0x000095c0
    9150:	000095c0 	.word	0x000095c0
    9154:	000095c0 	.word	0x000095c0
    9158:	000095c0 	.word	0x000095c0
    915c:	000095c0 	.word	0x000095c0
    9160:	000095c0 	.word	0x000095c0
    9164:	000095c0 	.word	0x000095c0
    9168:	000095c0 	.word	0x000095c0
    916c:	0000970c 	.word	0x0000970c
                    }
                    break;
                case 'e':
                case 'E':
                    /* no exponent without some digits */
                    if ((flags & (NDIGITS | EXPOK)) == EXPOK)
    9170:	e20a3d0a 	and	r3, sl, #640	; 0x280
    9174:	e3530c02 	cmp	r3, #512	; 0x200
    9178:	1affff8c 	bne	8fb0 <vfscanf+0x6e8>
                    {
                        flags =
                            (flags & ~(EXPOK | DPTOK)) |
                            SIGNOK | NDIGITS;
    917c:	e3ca3d0f 	bic	r3, sl, #960	; 0x3c0
    9180:	e383a0c0 	orr	sl, r3, #192	; 0xc0
    9184:	eaffff75 	b	8f60 <vfscanf+0x698>
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    flags &= ~(SIGNOK | NDIGITS);
    9188:	e3caa0c0 	bic	sl, sl, #192	; 0xc0
    918c:	eaffff73 	b	8f60 <vfscanf+0x698>
            }
            break;

        case CT_CCL:
            /* scan a (nonempty) character class (sets NOSKIP) */
            if (width == 0)
    9190:	e59d1008 	ldr	r1, [sp, #8]
    9194:	e3510000 	cmp	r1, #0	; 0x0
    9198:	03e01000 	mvneq	r1, #0	; 0x0
                width = ~0;             /* `infinity' */
            /* take only those things in the class */
            if (flags & SUPPRESS)
    919c:	e31a0008 	tst	sl, #8	; 0x8
            }
            break;

        case CT_CCL:
            /* scan a (nonempty) character class (sets NOSKIP) */
            if (width == 0)
    91a0:	e58d1008 	str	r1, [sp, #8]
                while (ccltab[(int)*CURR_POS])
                {
                    n++, INC_CURR_POS;
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
    91a4:	13a0a000 	movne	sl, #0	; 0x0
        case CT_CCL:
            /* scan a (nonempty) character class (sets NOSKIP) */
            if (width == 0)
                width = ~0;             /* `infinity' */
            /* take only those things in the class */
            if (flags & SUPPRESS)
    91a8:	1a00004b 	bne	92dc <vfscanf+0xa14>
                if (n == 0)
                    goto match_failure;
            }
            else
            {
                p0 = p = va_arg (ap, char *);
    91ac:	e59d1004 	ldr	r1, [sp, #4]
    91b0:	e591a000 	ldr	sl, [r1]
    91b4:	e1a0b00a 	mov	fp, sl
                while (ccltab[(int)*CURR_POS])
    91b8:	e1a01006 	mov	r1, r6
    91bc:	e1a00005 	mov	r0, r5
    91c0:	ebfffab6 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    91c4:	e5dd326f 	ldrb	r3, [sp, #623]
    91c8:	e28d0e27 	add	r0, sp, #624	; 0x270
    91cc:	e0802003 	add	r2, r0, r3
    91d0:	e5521101 	ldrb	r1, [r2, #-257]
    91d4:	e3510000 	cmp	r1, #0	; 0x0
    91d8:	0a000027 	beq	927c <vfscanf+0x9b4>
                {
                    *p++ = *CURR_POS;
    91dc:	e1a01006 	mov	r1, r6
    91e0:	e1a00005 	mov	r0, r5
    91e4:	ebfffaad 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    91e8:	e5dd326f 	ldrb	r3, [sp, #623]
                    INC_CURR_POS;
    91ec:	e1a00005 	mov	r0, r5
            else
            {
                p0 = p = va_arg (ap, char *);
                while (ccltab[(int)*CURR_POS])
                {
                    *p++ = *CURR_POS;
    91f0:	e4cb3001 	strb	r3, [fp], #1
                    INC_CURR_POS;
    91f4:	e1a01006 	mov	r1, r6
    91f8:	ebfffae4 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
                    if (--width == 0)
    91fc:	e59d2008 	ldr	r2, [sp, #8]
    9200:	e2522001 	subs	r2, r2, #1	; 0x1
    9204:	e58d2008 	str	r2, [sp, #8]
    9208:	0a00001b 	beq	927c <vfscanf+0x9b4>
                        break;
    920c:	e5d52028 	ldrb	r2, [r5, #40]
    9210:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    9214:	e3120020 	tst	r2, #32	; 0x20
    9218:	e2031001 	and	r1, r3, #1	; 0x1
    921c:	0a0001ca 	beq	994c <vfscanf+0x1084>
        if (flags.last_buffer_op_was_read == true)
    9220:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    9224:	1285001c 	addne	r0, r5, #28	; 0x1c
    9228:	18900009 	ldmne	r0, {r0, r3}
    922c:	10403003 	subne	r3, r0, r3
    9230:	10811003 	addne	r1, r1, r3
                    if (BufferEmpty)
    9234:	e3510000 	cmp	r1, #0	; 0x0
    9238:	1affffde 	bne	91b8 <vfscanf+0x8f0>
    923c:	e1a00005 	mov	r0, r5
    9240:	ebfffb99 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    9244:	e5d52028 	ldrb	r2, [r5, #40]
    9248:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    924c:	e3120020 	tst	r2, #32	; 0x20
    9250:	e2031001 	and	r1, r3, #1	; 0x1
    9254:	0a0001f5 	beq	9a30 <vfscanf+0x1168>
        if (flags.last_buffer_op_was_read == true)
    9258:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    925c:	1285201c 	addne	r2, r5, #28	; 0x1c
    9260:	1892000c 	ldmne	r2, {r2, r3}
    9264:	10423003 	subne	r3, r2, r3
    9268:	10811003 	addne	r1, r1, r3
    926c:	e3510000 	cmp	r1, #0	; 0x0
    9270:	1affffd0 	bne	91b8 <vfscanf+0x8f0>
                    {
                        if (p == p0)
    9274:	e15a000b 	cmp	sl, fp
    9278:	0afffe22 	beq	8b08 <vfscanf+0x240>
                            goto input_failure;
                        break;
                    }
                }
                n = p - p0;
                if (n == 0)
    927c:	e05ba00a 	subs	sl, fp, sl
    9280:	0afffdea 	beq	8a30 <vfscanf+0x168>
                    goto match_failure;
                *p = 0;
    9284:	e3a01000 	mov	r1, #0	; 0x0
    9288:	e5cb1000 	strb	r1, [fp]
                if (n == 0)
                    goto match_failure;
            }
            else
            {
                p0 = p = va_arg (ap, char *);
    928c:	e59d2004 	ldr	r2, [sp, #4]
    9290:	e2822004 	add	r2, r2, #4	; 0x4
    9294:	e58d2004 	str	r2, [sp, #4]
                }
                n = p - p0;
                if (n == 0)
                    goto match_failure;
                *p = 0;
                nassigned++;
    9298:	e2888001 	add	r8, r8, #1	; 0x1
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
                        break;
                }
                nread += n;
    929c:	e08a4004 	add	r4, sl, r4
    92a0:	eafffd98 	b	8908 <vfscanf+0x40>
                while (ccltab[(int)*CURR_POS])
                {
                    n++, INC_CURR_POS;
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
    92a4:	e1a00005 	mov	r0, r5
    92a8:	ebfffb7f 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    92ac:	e5d52028 	ldrb	r2, [r5, #40]
    92b0:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    92b4:	e3120020 	tst	r2, #32	; 0x20
    92b8:	e2031001 	and	r1, r3, #1	; 0x1
    92bc:	0a00024c 	beq	9bf4 <vfscanf+0x132c>
        if (flags.last_buffer_op_was_read == true)
    92c0:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    92c4:	1285201c 	addne	r2, r5, #28	; 0x1c
    92c8:	1892000c 	ldmne	r2, {r2, r3}
    92cc:	10423003 	subne	r3, r2, r3
    92d0:	10811003 	addne	r1, r1, r3
    92d4:	e3510000 	cmp	r1, #0	; 0x0
    92d8:	0affffef 	beq	929c <vfscanf+0x9d4>
                width = ~0;             /* `infinity' */
            /* take only those things in the class */
            if (flags & SUPPRESS)
            {
                n = 0;
                while (ccltab[(int)*CURR_POS])
    92dc:	e1a01006 	mov	r1, r6
    92e0:	e1a00005 	mov	r0, r5
    92e4:	ebfffa6d 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    92e8:	e5dd326f 	ldrb	r3, [sp, #623]
    92ec:	e28d0e27 	add	r0, sp, #624	; 0x270
    92f0:	e0802003 	add	r2, r0, r3
    92f4:	e5521101 	ldrb	r1, [r2, #-257]
    92f8:	e3510000 	cmp	r1, #0	; 0x0
    92fc:	0a000284 	beq	9d14 <vfscanf+0x144c>
                {
                    n++, INC_CURR_POS;
    9300:	e1a00005 	mov	r0, r5
    9304:	e1a01006 	mov	r1, r6
    9308:	ebfffaa0 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
                    if (--width == 0)
    930c:	e59d2008 	ldr	r2, [sp, #8]
            if (flags & SUPPRESS)
            {
                n = 0;
                while (ccltab[(int)*CURR_POS])
                {
                    n++, INC_CURR_POS;
    9310:	e28aa001 	add	sl, sl, #1	; 0x1
                    if (--width == 0)
    9314:	e152000a 	cmp	r2, sl
    9318:	0affffdf 	beq	929c <vfscanf+0x9d4>
                        break;
    931c:	e5d52028 	ldrb	r2, [r5, #40]
    9320:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    9324:	e3120020 	tst	r2, #32	; 0x20
    9328:	e2031001 	and	r1, r3, #1	; 0x1
    932c:	0a000182 	beq	993c <vfscanf+0x1074>
        if (flags.last_buffer_op_was_read == true)
    9330:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    9334:	1285001c 	addne	r0, r5, #28	; 0x1c
    9338:	18900009 	ldmne	r0, {r0, r3}
    933c:	10403003 	subne	r3, r0, r3
    9340:	10811003 	addne	r1, r1, r3
                    if (BufferEmpty)
    9344:	e3510000 	cmp	r1, #0	; 0x0
    9348:	1affffe3 	bne	92dc <vfscanf+0xa14>
    934c:	eaffffd4 	b	92a4 <vfscanf+0x9dc>
        switch (c)
        {

        case CT_CHAR:
            /* scan arbitrary characters (sets NOSKIP) */
            if (width == 0)
    9350:	e59d1008 	ldr	r1, [sp, #8]
    9354:	e3510000 	cmp	r1, #0	; 0x0
    9358:	03a02001 	moveq	r2, #1	; 0x1
    935c:	058d2008 	streq	r2, [sp, #8]
    9360:	01a0b002 	moveq	fp, r2
    9364:	159db008 	ldrne	fp, [sp, #8]
                width = 1;
            if (flags & SUPPRESS)
    9368:	e31a0008 	tst	sl, #8	; 0x8
    936c:	0a0001bc 	beq	9a64 <vfscanf+0x119c>
    9370:	e3a0b000 	mov	fp, #0	; 0x0
    9374:	e5d52028 	ldrb	r2, [r5, #40]
    9378:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    937c:	e3120020 	tst	r2, #32	; 0x20
    9380:	e203a001 	and	sl, r3, #1	; 0x1
    9384:	0a000157 	beq	98e8 <vfscanf+0x1020>
        if (flags.last_buffer_op_was_read == true)
    9388:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    938c:	1285001c 	addne	r0, r5, #28	; 0x1c
    9390:	18900009 	ldmne	r0, {r0, r3}
    9394:	10403003 	subne	r3, r0, r3
    9398:	108aa003 	addne	sl, sl, r3
            {
                size_t sum = 0;

                for (;;)
                {
                    if ((n = SPACE_LEFT) < (signed)width)
    939c:	e59d3008 	ldr	r3, [sp, #8]
    93a0:	e15a0003 	cmp	sl, r3
                    {
                        sum += n;
                        width -= n;
                        MOVE_CURR_POS(n-1);
    93a4:	e3a02001 	mov	r2, #1	; 0x1
    93a8:	e1a00005 	mov	r0, r5
    93ac:	e24a1001 	sub	r1, sl, #1	; 0x1
            {
                size_t sum = 0;

                for (;;)
                {
                    if ((n = SPACE_LEFT) < (signed)width)
    93b0:	aa00028a 	bge	9de0 <vfscanf+0x1518>
                    {
                        sum += n;
                        width -= n;
                        MOVE_CURR_POS(n-1);
    93b4:	ebfffd17 	bl	8818 <_ZN15Cyg_StdioStream12set_positionEii>
                        INC_CURR_POS;
    93b8:	e1a01006 	mov	r1, r6
    93bc:	e1a00005 	mov	r0, r5
    93c0:	ebfffa72 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
#ifndef REDHAT_NEC
                        if (REFILL)
    93c4:	e1a00005 	mov	r0, r5
    93c8:	ebfffb37 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    93cc:	e3500000 	cmp	r0, #0	; 0x0
                for (;;)
                {
                    if ((n = SPACE_LEFT) < (signed)width)
                    {
                        sum += n;
                        width -= n;
    93d0:	e59d0008 	ldr	r0, [sp, #8]
    93d4:	e06a0000 	rsb	r0, sl, r0
    93d8:	e58d0008 	str	r0, [sp, #8]

                for (;;)
                {
                    if ((n = SPACE_LEFT) < (signed)width)
                    {
                        sum += n;
    93dc:	e08bb00a 	add	fp, fp, sl
                        width -= n;
                        MOVE_CURR_POS(n-1);
                        INC_CURR_POS;
#ifndef REDHAT_NEC
                        if (REFILL)
    93e0:	0affffe3 	beq	9374 <vfscanf+0xaac>
                        {
#endif
                            if (sum == 0)
    93e4:	e35b0000 	cmp	fp, #0	; 0x0
    93e8:	0afffdc6 	beq	8b08 <vfscanf+0x240>
                        MOVE_CURR_POS(width - 1);
                        INC_CURR_POS;
                        break;
                    }
                }
                nread += sum;
    93ec:	e08b4004 	add	r4, fp, r4
    93f0:	eafffd44 	b	8908 <vfscanf+0x40>
            nread += n;
            break;

        case CT_STRING:
            /* like CCL, but zero-length string OK, & no NOSKIP */
            if (width == 0)
    93f4:	e59d3008 	ldr	r3, [sp, #8]
    93f8:	e3530000 	cmp	r3, #0	; 0x0
    93fc:	03e03000 	mvneq	r3, #0	; 0x0
                width = ~0;
            if (flags & SUPPRESS)
    9400:	e31a0008 	tst	sl, #8	; 0x8
            nread += n;
            break;

        case CT_STRING:
            /* like CCL, but zero-length string OK, & no NOSKIP */
            if (width == 0)
    9404:	e58d3008 	str	r3, [sp, #8]
                while (!isspace (*CURR_POS))
                {
                    n++, INC_CURR_POS;
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
    9408:	13a0a000 	movne	sl, #0	; 0x0

        case CT_STRING:
            /* like CCL, but zero-length string OK, & no NOSKIP */
            if (width == 0)
                width = ~0;
            if (flags & SUPPRESS)
    940c:	1a000020 	bne	9494 <vfscanf+0xbcc>
                }
                nread += n;
            }
            else
            {
                p0 = p = va_arg (ap, char *);
    9410:	e59d3004 	ldr	r3, [sp, #4]
    9414:	e593b000 	ldr	fp, [r3]
    9418:	e1a0a00b 	mov	sl, fp
                while (!isspace (*CURR_POS))
    941c:	e1a00005 	mov	r0, r5
    9420:	e1a01006 	mov	r1, r6
    9424:	ebfffa1d 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    9428:	e5dd326f 	ldrb	r3, [sp, #623]
    942c:	e353000c 	cmp	r3, #12	; 0xc
    9430:	13530020 	cmpne	r3, #32	; 0x20
    9434:	1a000148 	bne	995c <vfscanf+0x1094>
                        break;
                    if (BufferEmpty)
                        break;
                }
                *p = 0;
                nread += p - p0;
    9438:	e06b3004 	rsb	r3, fp, r4
    943c:	e08a4003 	add	r4, sl, r3
                }
                nread += n;
            }
            else
            {
                p0 = p = va_arg (ap, char *);
    9440:	e59d3004 	ldr	r3, [sp, #4]
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
                        break;
                }
                *p = 0;
    9444:	e3a00000 	mov	r0, #0	; 0x0
                }
                nread += n;
            }
            else
            {
                p0 = p = va_arg (ap, char *);
    9448:	e2833004 	add	r3, r3, #4	; 0x4
    944c:	e58d3004 	str	r3, [sp, #4]
                    if (BufferEmpty)
                        break;
                }
                *p = 0;
                nread += p - p0;
                nassigned++;
    9450:	e2888001 	add	r8, r8, #1	; 0x1
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
                        break;
                }
                *p = 0;
    9454:	e5ca0000 	strb	r0, [sl]
    9458:	eafffd2a 	b	8908 <vfscanf+0x40>
                while (!isspace (*CURR_POS))
                {
                    n++, INC_CURR_POS;
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
    945c:	e1a00005 	mov	r0, r5
    9460:	ebfffb11 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    9464:	e5d52028 	ldrb	r2, [r5, #40]
    9468:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    946c:	e3120020 	tst	r2, #32	; 0x20
    9470:	e2031001 	and	r1, r3, #1	; 0x1
    9474:	0a0001c6 	beq	9b94 <vfscanf+0x12cc>
        if (flags.last_buffer_op_was_read == true)
    9478:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    947c:	1285201c 	addne	r2, r5, #28	; 0x1c
    9480:	1892000c 	ldmne	r2, {r2, r3}
    9484:	10423003 	subne	r3, r2, r3
    9488:	10811003 	addne	r1, r1, r3
    948c:	e3510000 	cmp	r1, #0	; 0x0
    9490:	0affff81 	beq	929c <vfscanf+0x9d4>
            if (width == 0)
                width = ~0;
            if (flags & SUPPRESS)
            {
                n = 0;
                while (!isspace (*CURR_POS))
    9494:	e1a00005 	mov	r0, r5
    9498:	e1a01006 	mov	r1, r6
    949c:	ebfff9ff 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    94a0:	e5dd326f 	ldrb	r3, [sp, #623]
    94a4:	e353000c 	cmp	r3, #12	; 0xc
    94a8:	13530020 	cmpne	r3, #32	; 0x20
    94ac:	0affff7a 	beq	929c <vfscanf+0x9d4>
    94b0:	e353000d 	cmp	r3, #13	; 0xd
    94b4:	1353000a 	cmpne	r3, #10	; 0xa
    94b8:	0affff77 	beq	929c <vfscanf+0x9d4>
    94bc:	e353000b 	cmp	r3, #11	; 0xb
    94c0:	13530009 	cmpne	r3, #9	; 0x9
    94c4:	0affff74 	beq	929c <vfscanf+0x9d4>
                {
                    n++, INC_CURR_POS;
    94c8:	e1a00005 	mov	r0, r5
    94cc:	e1a01006 	mov	r1, r6
    94d0:	ebfffa2e 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
                    if (--width == 0)
    94d4:	e59d2008 	ldr	r2, [sp, #8]
            if (flags & SUPPRESS)
            {
                n = 0;
                while (!isspace (*CURR_POS))
                {
                    n++, INC_CURR_POS;
    94d8:	e28aa001 	add	sl, sl, #1	; 0x1
                    if (--width == 0)
    94dc:	e152000a 	cmp	r2, sl
    94e0:	0affff6d 	beq	929c <vfscanf+0x9d4>

        case CT_STRING:
            /* like CCL, but zero-length string OK, & no NOSKIP */
            if (width == 0)
                width = ~0;
            if (flags & SUPPRESS)
    94e4:	e5d52028 	ldrb	r2, [r5, #40]
    94e8:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    94ec:	e3120020 	tst	r2, #32	; 0x20
    94f0:	e2031001 	and	r1, r3, #1	; 0x1
    94f4:	0a000145 	beq	9a10 <vfscanf+0x1148>
        if (flags.last_buffer_op_was_read == true)
    94f8:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    94fc:	1285001c 	addne	r0, r5, #28	; 0x1c
    9500:	18900009 	ldmne	r0, {r0, r3}
    9504:	10403003 	subne	r3, r0, r3
    9508:	10811003 	addne	r1, r1, r3
                while (!isspace (*CURR_POS))
                {
                    n++, INC_CURR_POS;
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
    950c:	e3510000 	cmp	r1, #0	; 0x0
    9510:	1affffdf 	bne	9494 <vfscanf+0xbcc>
    9514:	eaffffd0 	b	945c <vfscanf+0xb94>
                    flags &= ~(SIGNOK | NDIGITS);
                    goto fok;

                case '+':
                case '-':
                    if (flags & SIGNOK)
    9518:	e31a0040 	tst	sl, #64	; 0x40
    951c:	0afffea3 	beq	8fb0 <vfscanf+0x6e8>
                    {
                        flags &= ~SIGNOK;
    9520:	e3caa040 	bic	sl, sl, #64	; 0x40
    9524:	eafffe8d 	b	8f60 <vfscanf+0x698>
             * (According to ANSI, E and X formats are supposed to
             * the same as e and x.  Sorry about that.)
             */

        case 'D':               /* compat */
            flags |= LONG;
    9528:	e38aa001 	orr	sl, sl, #1	; 0x1
            /* FALLTHROUGH */
        case 'd':
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    952c:	e59d0014 	ldr	r0, [sp, #20]
    9530:	e59f37d0 	ldr	r3, [pc, #2000]	; 9d08 <vfscanf+0x1440>
    9534:	e31a0002 	tst	sl, #2	; 0x2
        case 'D':               /* compat */
            flags |= LONG;
            /* FALLTHROUGH */
        case 'd':
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    9538:	e59f17cc 	ldr	r1, [pc, #1996]	; 9d0c <vfscanf+0x1444>
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    953c:	11a00003 	movne	r0, r3
    9540:	e3a0200a 	mov	r2, #10	; 0xa
    9544:	e58d0014 	str	r0, [sp, #20]
        case 'D':               /* compat */
            flags |= LONG;
            /* FALLTHROUGH */
        case 'd':
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    9548:	e58d1010 	str	r1, [sp, #16]
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    954c:	e3a0b003 	mov	fp, #3	; 0x3
    9550:	e58d200c 	str	r2, [sp, #12]
    9554:	eafffdfb 	b	8d48 <vfscanf+0x480>
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    base = basefix[base];
    9558:	e59d100c 	ldr	r1, [sp, #12]
    955c:	e59f07ac 	ldr	r0, [pc, #1964]	; 9d10 <vfscanf+0x1448>
    9560:	e1a03081 	lsl	r3, r1, #1
    9564:	e19030f3 	ldrsh	r3, [r0, r3]
    9568:	e58d300c 	str	r3, [sp, #12]
                    flags &= ~(SIGNOK | PFXOK | NDIGITS);
    956c:	e3caad07 	bic	sl, sl, #448	; 0x1c0
            ok:
                /*
                 * c is legal: store it and look at the next.
                 */
                *p++ = c;
                INC_CURR_POS;
    9570:	e1a01006 	mov	r1, r6
                break;
            ok:
                /*
                 * c is legal: store it and look at the next.
                 */
                *p++ = c;
    9574:	e4cb2001 	strb	r2, [fp], #1
                INC_CURR_POS;
    9578:	e1a00005 	mov	r0, r5
    957c:	ebfffa03 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
    9580:	e5d52028 	ldrb	r2, [r5, #40]
    9584:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    9588:	e3120020 	tst	r2, #32	; 0x20
    958c:	e2031001 	and	r1, r3, #1	; 0x1
    9590:	0a0000e1 	beq	991c <vfscanf+0x1054>
        if (flags.last_buffer_op_was_read == true)
    9594:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    9598:	1285201c 	addne	r2, r5, #28	; 0x1c
    959c:	1892000c 	ldmne	r2, {r2, r3}
    95a0:	10423003 	subne	r3, r2, r3
    95a4:	10811003 	addne	r1, r1, r3
                if (SPACE_LEFT == 0)
    95a8:	e3510000 	cmp	r1, #0	; 0x0
    95ac:	0a000127 	beq	9a50 <vfscanf+0x1188>
            if (--width > sizeof (buf) - 2)
                width = sizeof (buf) - 2;
            width++;
#endif
            flags |= SIGNOK | NDIGITS | NZDIGITS;
            for (p = buf; width; width--)
    95b0:	e59d3024 	ldr	r3, [sp, #36]
    95b4:	e2533001 	subs	r3, r3, #1	; 0x1
    95b8:	e58d3024 	str	r3, [sp, #36]
    95bc:	1afffe95 	bne	9018 <vfscanf+0x750>
            /*
             * If we had only a sign, it is no good; push back the sign.
             * If the number ends in `x', it was [sign] '0' 'x', so push
             * back the x and treat it as [sign] '0'.
             */
            if (flags & NDIGITS)
    95c0:	e31a0080 	tst	sl, #128	; 0x80
    95c4:	1a0001b6 	bne	9ca4 <vfscanf+0x13dc>
            {
                if (p > buf)
                    _CAST_VOID ungetc (*(u_char *)-- p, fp);
                goto match_failure;
            }
            c = ((u_char *) p)[-1];
    95c8:	e55b0001 	ldrb	r0, [fp, #-1]
    95cc:	e24b1001 	sub	r1, fp, #1	; 0x1
            if (c == 'x' || c == 'X')
    95d0:	e3500058 	cmp	r0, #88	; 0x58
    95d4:	13500078 	cmpne	r0, #120	; 0x78
            {
                if (p > buf)
                    _CAST_VOID ungetc (*(u_char *)-- p, fp);
                goto match_failure;
            }
            c = ((u_char *) p)[-1];
    95d8:	e58d101c 	str	r1, [sp, #28]
            if (c == 'x' || c == 'X')
    95dc:	158db01c 	strne	fp, [sp, #28]
            {
                --p;
                /*(void)*/ ungetc (c, fp);
    95e0:	01a01005 	moveq	r1, r5
    95e4:	0b0019d5 	bleq	fd40 <ungetc>
            }
            if ((flags & SUPPRESS) == 0)
    95e8:	e21a1008 	ands	r1, sl, #8	; 0x8
    95ec:	1a000012 	bne	963c <vfscanf+0xd74>
                u_long_long res;
#else
                u_long res;
#endif

                *p = 0;
    95f0:	e59d201c 	ldr	r2, [sp, #28]
		
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
		if (flags & LONGDBL)
    95f4:	e21ab002 	ands	fp, sl, #2	; 0x2
                u_long_long res;
#else
                u_long res;
#endif

                *p = 0;
    95f8:	e5c21000 	strb	r1, [r2]
		
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
		if (flags & LONGDBL)
    95fc:	0a0001d3 	beq	9d50 <vfscanf+0x1488>
		  res = (*ccfnL) (buf, (char **) NULL, base);
    9600:	e1a00009 	mov	r0, r9
    9604:	e59d200c 	ldr	r2, [sp, #12]
    9608:	e59d3014 	ldr	r3, [sp, #20]
    960c:	e1a0e00f 	mov	lr, pc
    9610:	e12fff13 	bx	r3
		else
#endif
		  res = (*ccfn) (buf, (char **) NULL, base);

                if (flags & POINTER)
    9614:	e31a0010 	tst	sl, #16	; 0x10
    9618:	1a0001df 	bne	9d9c <vfscanf+0x14d4>
                    *(va_arg (ap, char **)) = (char *) (CYG_ADDRESS) res;
                else if (flags & SHORT)
    961c:	e31a0004 	tst	sl, #4	; 0x4
    9620:	0a0001d2 	beq	9d70 <vfscanf+0x14a8>
                {
                    sp = va_arg (ap, short *);
                    *sp = res;
    9624:	e59d2004 	ldr	r2, [sp, #4]
    9628:	e5923000 	ldr	r3, [r2]
    962c:	e2822004 	add	r2, r2, #4	; 0x4
    9630:	e1c300b0 	strh	r0, [r3]
    9634:	e58d2004 	str	r2, [sp, #4]
                else
                {
                    ip = va_arg (ap, int *);
                    *ip = res;
                }
                nassigned++;
    9638:	e2888001 	add	r8, r8, #1	; 0x1
            }
            nread += p - buf;
    963c:	e59d201c 	ldr	r2, [sp, #28]
    9640:	e0693004 	rsb	r3, r9, r4
    9644:	e0824003 	add	r4, r2, r3
    9648:	eafffcae 	b	8908 <vfscanf+0x40>
                    goto ok;

                    /* digits 8 and 9 ok iff decimal or hex */
                case '8':
                case '9':
                    base = basefix[base];
    964c:	e59d100c 	ldr	r1, [sp, #12]
    9650:	e59f06b8 	ldr	r0, [pc, #1720]	; 9d10 <vfscanf+0x1448>
    9654:	e1a03081 	lsl	r3, r1, #1
    9658:	e19030f3 	ldrsh	r3, [r0, r3]
                    if (base <= 8)
    965c:	e3530008 	cmp	r3, #8	; 0x8
                    goto ok;

                    /* digits 8 and 9 ok iff decimal or hex */
                case '8':
                case '9':
                    base = basefix[base];
    9660:	e58d300c 	str	r3, [sp, #12]
                    if (base <= 8)
    9664:	caffffc0 	bgt	956c <vfscanf+0xca4>
    9668:	eaffffd4 	b	95c0 <vfscanf+0xcf8>
                     * before this, do not turn off prefixing (someone else
                     * will turn it off if we have scanned any nonzero
                     * digits).
                     */
                case '0':
                    if (base == 0)
    966c:	e59d300c 	ldr	r3, [sp, #12]
    9670:	e3530000 	cmp	r3, #0	; 0x0
                    {
                        base = 8;
                        flags |= PFXOK;
    9674:	038aac01 	orreq	sl, sl, #256	; 0x100
    9678:	03a00008 	moveq	r0, #8	; 0x8
    967c:	058d000c 	streq	r0, [sp, #12]
                    }
                    if (flags & NZDIGITS)
    9680:	e31a0c02 	tst	sl, #512	; 0x200
                        flags &= ~(SIGNOK | NZDIGITS | NDIGITS);
    9684:	13caad0b 	bicne	sl, sl, #704	; 0x2c0
                    if (base == 0)
                    {
                        base = 8;
                        flags |= PFXOK;
                    }
                    if (flags & NZDIGITS)
    9688:	1affffb8 	bne	9570 <vfscanf+0xca8>
    968c:	eaffffb6 	b	956c <vfscanf+0xca4>
                    goto ok;

                    /* sign ok only as first character */
                case '+':
                case '-':
                    if (flags & SIGNOK)
    9690:	e31a0040 	tst	sl, #64	; 0x40
    9694:	0affffc9 	beq	95c0 <vfscanf+0xcf8>
                    {
                        flags &= ~SIGNOK;
    9698:	e3caa040 	bic	sl, sl, #64	; 0x40
    969c:	eaffffb3 	b	9570 <vfscanf+0xca8>
            ccfn = strtoul;
            base = 16;
            break;

        case 'n':
            if (flags & SUPPRESS)       /* ??? */
    96a0:	e31a0008 	tst	sl, #8	; 0x8
    96a4:	1afffc97 	bne	8908 <vfscanf+0x40>
                continue;
            if (flags & SHORT)
    96a8:	e31a0004 	tst	sl, #4	; 0x4
    96ac:	0a00019b 	beq	9d20 <vfscanf+0x1458>
            {
                sp = va_arg (ap, short *);
                *sp = nread;
    96b0:	e59d2004 	ldr	r2, [sp, #4]
    96b4:	e5923000 	ldr	r3, [r2]
    96b8:	e2822004 	add	r2, r2, #4	; 0x4
    96bc:	e1c340b0 	strh	r4, [r3]
    96c0:	e58d2004 	str	r2, [sp, #4]
    96c4:	eafffc8f 	b	8908 <vfscanf+0x40>
        case 'l':
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    // check if we are using long long 'll'
	    if (flags & LONG) {
	      // change to long long
	      flags &= ~LONG;
    96c8:	e3ca3001 	bic	r3, sl, #1	; 0x1
            flags |= SUPPRESS;
            goto again;
        case 'l':
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    // check if we are using long long 'll'
	    if (flags & LONG) {
    96cc:	e31a0001 	tst	sl, #1	; 0x1
	      // change to long long
	      flags &= ~LONG;
	      flags |= LONGDBL;
    96d0:	1383a002 	orrne	sl, r3, #2	; 0x2
	    }
	    else
#endif
	      flags |= LONG;
    96d4:	038aa001 	orreq	sl, sl, #1	; 0x1
    96d8:	eafffd12 	b	8b28 <vfscanf+0x260>

        case 'i':
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    96dc:	e20a2002 	and	r2, sl, #2	; 0x2
    96e0:	e59d0014 	ldr	r0, [sp, #20]
    96e4:	e59f361c 	ldr	r3, [pc, #1564]	; 9d08 <vfscanf+0x1440>
    96e8:	e3520000 	cmp	r2, #0	; 0x0
            base = 10;
            break;

        case 'i':
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    96ec:	e59f1618 	ldr	r1, [pc, #1560]	; 9d0c <vfscanf+0x1444>
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    96f0:	11a00003 	movne	r0, r3
    96f4:	13a02000 	movne	r2, #0	; 0x0
    96f8:	e58d0014 	str	r0, [sp, #20]
    96fc:	e58d200c 	str	r2, [sp, #12]
            base = 10;
            break;

        case 'i':
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    9700:	e58d1010 	str	r1, [sp, #16]
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    9704:	e3a0b003 	mov	fp, #3	; 0x3
    9708:	eafffd8e 	b	8d48 <vfscanf+0x480>
                    break;

                    /* x ok iff flag still set & 2nd char */
                case 'x':
                case 'X':
                    if (flags & PFXOK && p == buf + 1)
    970c:	e31a0c01 	tst	sl, #256	; 0x100
    9710:	0affffaa 	beq	95c0 <vfscanf+0xcf8>
    9714:	e59d3000 	ldr	r3, [sp]
    9718:	e15b0003 	cmp	fp, r3
    971c:	1affffa7 	bne	95c0 <vfscanf+0xcf8>
                    {
                        base = 16;/* if %i */
                        flags &= ~PFXOK;
    9720:	e3a00010 	mov	r0, #16	; 0x10
    9724:	e3caac01 	bic	sl, sl, #256	; 0x100
    9728:	e58d000c 	str	r0, [sp, #12]
    972c:	eaffff8f 	b	9570 <vfscanf+0xca8>
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                    /* no need to fix base here */
                    if (base <= 10)
    9730:	e59d100c 	ldr	r1, [sp, #12]
    9734:	e351000a 	cmp	r1, #10	; 0xa
    9738:	caffff8b 	bgt	956c <vfscanf+0xca4>
    973c:	eaffff9f 	b	95c0 <vfscanf+0xcf8>
            flags |= NOSKIP;
            c = CT_CCL;
            break;

        case 'c':
            flags |= NOSKIP;
    9740:	e38aa020 	orr	sl, sl, #32	; 0x20
    9744:	e3a0b000 	mov	fp, #0	; 0x0
    9748:	eafffd7e 	b	8d48 <vfscanf+0x480>
__sccl (char *tab, u_char *fmt)
{
    int c, n, v;

    /* first `clear' the whole table */
    c = *fmt++;                 /* first char hat => negated scanset */
    974c:	e4d71001 	ldrb	r1, [r7], #1
    if (c == '^')
    9750:	e351005e 	cmp	r1, #94	; 0x5e
    9754:	13a0c000 	movne	ip, #0	; 0x0
    {
        v = 1;                  /* default => accept */
        c = *fmt++;             /* get new first char */
    9758:	03a0c001 	moveq	ip, #1	; 0x1
    975c:	e28d0e17 	add	r0, sp, #368	; 0x170
    9760:	04d71001 	ldrbeq	r1, [r7], #1
{
    int c, n, v;

    /* first `clear' the whole table */
    c = *fmt++;                 /* first char hat => negated scanset */
    if (c == '^')
    9764:	11a0200c 	movne	r2, ip
    {
        v = 1;                  /* default => accept */
        c = *fmt++;             /* get new first char */
    9768:	01a0200c 	moveq	r2, ip
    976c:	e2400001 	sub	r0, r0, #1	; 0x1
    9770:	e3a03000 	mov	r3, #0	; 0x0
    }
    else
        v = 0;                  /* default => reject */
    /* should probably use memset here */
    for (n = 0; n < 256; n++)
        tab[n] = v;
    9774:	e7c02003 	strb	r2, [r0, r3]
        c = *fmt++;             /* get new first char */
    }
    else
        v = 0;                  /* default => reject */
    /* should probably use memset here */
    for (n = 0; n < 256; n++)
    9778:	e2833001 	add	r3, r3, #1	; 0x1
    977c:	e3530c01 	cmp	r3, #256	; 0x100
    9780:	1afffffb 	bne	9774 <vfscanf+0xeac>
        tab[n] = v;
    if (c == 0)
    9784:	e3510000 	cmp	r1, #0	; 0x0
        return fmt - 1;         /* format ended before closing ] */
    9788:	122cc001 	eorne	ip, ip, #1	; 0x1
    978c:	02477001 	subeq	r7, r7, #1	; 0x1
    9790:	158dc018 	strne	ip, [sp, #24]
    else
        v = 0;                  /* default => reject */
    /* should probably use memset here */
    for (n = 0; n < 256; n++)
        tab[n] = v;
    if (c == 0)
    9794:	1a0000f1 	bne	9b60 <vfscanf+0x1298>
            c = CT_STRING;
            break;

        case '[':
            fmt = __sccl (ccltab, fmt);
            flags |= NOSKIP;
    9798:	e38aa020 	orr	sl, sl, #32	; 0x20
    979c:	e3a0b001 	mov	fp, #1	; 0x1
    97a0:	eafffd68 	b	8d48 <vfscanf+0x480>
        case 'x':
            flags |= PFXOK;     /* enable 0x prefixing */
            c = CT_INT;
            ccfn = strtoul;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    97a4:	e59d0014 	ldr	r0, [sp, #20]
            base = 10;
            break;

        case 'X':               /* compat   XXX */
        case 'x':
            flags |= PFXOK;     /* enable 0x prefixing */
    97a8:	e38aac01 	orr	sl, sl, #256	; 0x100
            c = CT_INT;
            ccfn = strtoul;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    97ac:	e59f354c 	ldr	r3, [pc, #1356]	; 9d00 <vfscanf+0x1438>
    97b0:	e31a0002 	tst	sl, #2	; 0x2
    97b4:	e59f2548 	ldr	r2, [pc, #1352]	; 9d04 <vfscanf+0x143c>
    97b8:	11a00003 	movne	r0, r3
    97bc:	e3a01010 	mov	r1, #16	; 0x10
    97c0:	e58d0014 	str	r0, [sp, #20]
    97c4:	e3a0b003 	mov	fp, #3	; 0x3
    97c8:	e58d100c 	str	r1, [sp, #12]
    97cc:	e58d2010 	str	r2, [sp, #16]
    97d0:	eafffd5c 	b	8d48 <vfscanf+0x480>
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            width = width * 10 + c - '0';
    97d4:	e59d2008 	ldr	r2, [sp, #8]
    97d8:	e1a03182 	lsl	r3, r2, #3
    97dc:	e1a02082 	lsl	r2, r2, #1
    97e0:	e0822003 	add	r2, r2, r3
    97e4:	e2411030 	sub	r1, r1, #48	; 0x30
    97e8:	e0811002 	add	r1, r1, r2
    97ec:	e58d1008 	str	r1, [sp, #8]
    97f0:	eafffccc 	b	8b28 <vfscanf+0x260>
		++lptr;
	      }
        continue;

        case '*':
            flags |= SUPPRESS;
    97f4:	e38aa008 	orr	sl, sl, #8	; 0x8
    97f8:	eafffcca 	b	8b28 <vfscanf+0x260>
         */
        
again:
        c = *fmt++;
        
        switch (c)
    97fc:	e3e08000 	mvn	r8, #0	; 0x0
    9800:	eafffc8a 	b	8a30 <vfscanf+0x168>
             */
        case '\0':              /* compat */
            return EOF;

        default:                /* compat */
            if (isupper (c))
    9804:	e2413041 	sub	r3, r1, #65	; 0x41
                flags |= LONG;
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    9808:	e59f24fc 	ldr	r2, [pc, #1276]	; 9d0c <vfscanf+0x1444>
             */
        case '\0':              /* compat */
            return EOF;

        default:                /* compat */
            if (isupper (c))
    980c:	e3530019 	cmp	r3, #25	; 0x19
                flags |= LONG;
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    9810:	e3a0300a 	mov	r3, #10	; 0xa
        case '\0':              /* compat */
            return EOF;

        default:                /* compat */
            if (isupper (c))
                flags |= LONG;
    9814:	938aa001 	orrls	sl, sl, #1	; 0x1
            c = CT_INT;
            ccfn = (strtoul_t)strtol;
    9818:	e58d2010 	str	r2, [sp, #16]
    981c:	e3a0b003 	mov	fp, #3	; 0x3
    9820:	e58d300c 	str	r3, [sp, #12]
    9824:	eafffd47 	b	8d48 <vfscanf+0x480>

        case 'u':
            c = CT_INT;
            ccfn = strtoul;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    9828:	e59f34d0 	ldr	r3, [pc, #1232]	; 9d00 <vfscanf+0x1438>
    982c:	e59d1014 	ldr	r1, [sp, #20]
    9830:	e31a0002 	tst	sl, #2	; 0x2
    9834:	11a01003 	movne	r1, r3
    9838:	e59f34c4 	ldr	r3, [pc, #1220]	; 9d04 <vfscanf+0x143c>
    983c:	e3a0200a 	mov	r2, #10	; 0xa
    9840:	e58d1014 	str	r1, [sp, #20]
    9844:	e3a0b003 	mov	fp, #3	; 0x3
    9848:	e58d200c 	str	r2, [sp, #12]
    984c:	e58d3010 	str	r3, [sp, #16]
    9850:	eafffd3c 	b	8d48 <vfscanf+0x480>
        case 'x':
            flags |= PFXOK;     /* enable 0x prefixing */
            c = CT_INT;
            ccfn = strtoul;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
	    if (flags & LONGDBL)
    9854:	e3a0b002 	mov	fp, #2	; 0x2
    9858:	eafffd3a 	b	8d48 <vfscanf+0x480>
            flags |= NOSKIP;
            c = CT_CHAR;
            break;

        case 'p':               /* pointer format is like hex */
            flags |= POINTER | PFXOK;
    985c:	e59f14a0 	ldr	r1, [pc, #1184]	; 9d04 <vfscanf+0x143c>
    9860:	e3a00010 	mov	r0, #16	; 0x10
    9864:	e38aae11 	orr	sl, sl, #272	; 0x110
    9868:	e3a0b003 	mov	fp, #3	; 0x3
    986c:	e58d000c 	str	r0, [sp, #12]
    9870:	e58d1010 	str	r1, [sp, #16]
    9874:	eafffd33 	b	8d48 <vfscanf+0x480>
	      flags |= LONG;
	    
            goto again;
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
        case 'L':
            flags |= LONGDBL;
    9878:	e38aa002 	orr	sl, sl, #2	; 0x2
    987c:	eafffca9 	b	8b28 <vfscanf+0x260>
         */
        
again:
        c = *fmt++;
        
        switch (c)
    9880:	e3a0b004 	mov	fp, #4	; 0x4
    9884:	eafffd2f 	b	8d48 <vfscanf+0x480>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    9888:	e5d53029 	ldrb	r3, [r5, #41]
    988c:	e3130001 	tst	r3, #1	; 0x1
    9890:	0afffd61 	beq	8e1c <vfscanf+0x554>
         */
        if ((flags & NOSKIP) == 0)
        {
            while (isspace (*CURR_POS))
            {
                nread++;
    9894:	e2844001 	add	r4, r4, #1	; 0x1
    9898:	eafffd45 	b	8db4 <vfscanf+0x4ec>
    989c:	e5d53029 	ldrb	r3, [r5, #41]
    98a0:	e3130001 	tst	r3, #1	; 0x1
    98a4:	1afffd33 	bne	8d78 <vfscanf+0x4b0>
    98a8:	eafffd30 	b	8d70 <vfscanf+0x4a8>
        }

        /*
         * We have a conversion that requires input.
         */
        if (BufferEmpty)
    98ac:	e1a00005 	mov	r0, r5
    98b0:	ebfff9fd 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    98b4:	e5d52028 	ldrb	r2, [r5, #40]
    98b8:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    98bc:	e3120020 	tst	r2, #32	; 0x20
    98c0:	e2031001 	and	r1, r3, #1	; 0x1
    98c4:	0a000018 	beq	992c <vfscanf+0x1064>
        if (flags.last_buffer_op_was_read == true)
    98c8:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    98cc:	1285201c 	addne	r2, r5, #28	; 0x1c
    98d0:	1892000c 	ldmne	r2, {r2, r3}
    98d4:	10423003 	subne	r3, r2, r3
    98d8:	10811003 	addne	r1, r1, r3
    98dc:	e3510000 	cmp	r1, #0	; 0x0
    98e0:	0afffc88 	beq	8b08 <vfscanf+0x240>
    98e4:	eafffd23 	b	8d78 <vfscanf+0x4b0>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    98e8:	e5d53029 	ldrb	r3, [r5, #41]
    98ec:	e3130001 	tst	r3, #1	; 0x1
        ++bytes;
    98f0:	128aa001 	addne	sl, sl, #1	; 0x1
    98f4:	eafffea8 	b	939c <vfscanf+0xad4>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    98f8:	e5d53029 	ldrb	r3, [r5, #41]
    98fc:	e3130001 	tst	r3, #1	; 0x1
    9900:	1afffda8 	bne	8fa8 <vfscanf+0x6e0>
    9904:	eafffda5 	b	8fa0 <vfscanf+0x6d8>
            fok:
                *p++ = c;
                INC_CURR_POS;
                if (SPACE_LEFT == 0)
#ifndef REDHAT_NEC
                    if (REFILL)
    9908:	e1a00005 	mov	r0, r5
    990c:	ebfff9e6 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    9910:	e3500000 	cmp	r0, #0	; 0x0
    9914:	0afffda3 	beq	8fa8 <vfscanf+0x6e0>
    9918:	eafffda4 	b	8fb0 <vfscanf+0x6e8>
    991c:	e5d53029 	ldrb	r3, [r5, #41]
    9920:	e3130001 	tst	r3, #1	; 0x1
    9924:	1affff21 	bne	95b0 <vfscanf+0xce8>
    9928:	eaffff1e 	b	95a8 <vfscanf+0xce0>
    992c:	e5d53029 	ldrb	r3, [r5, #41]
    9930:	e3130001 	tst	r3, #1	; 0x1
    9934:	1afffd0f 	bne	8d78 <vfscanf+0x4b0>
    9938:	eaffffe7 	b	98dc <vfscanf+0x1014>
    993c:	e5d53029 	ldrb	r3, [r5, #41]
    9940:	e3130001 	tst	r3, #1	; 0x1
    9944:	1afffe64 	bne	92dc <vfscanf+0xa14>
    9948:	eafffe7d 	b	9344 <vfscanf+0xa7c>
    994c:	e5d53029 	ldrb	r3, [r5, #41]
    9950:	e3130001 	tst	r3, #1	; 0x1
    9954:	1afffe17 	bne	91b8 <vfscanf+0x8f0>
    9958:	eafffe35 	b	9234 <vfscanf+0x96c>
    995c:	e353000d 	cmp	r3, #13	; 0xd
    9960:	1353000a 	cmpne	r3, #10	; 0xa
    9964:	0afffeb3 	beq	9438 <vfscanf+0xb70>
    9968:	e353000b 	cmp	r3, #11	; 0xb
    996c:	13530009 	cmpne	r3, #9	; 0x9
    9970:	0afffeb0 	beq	9438 <vfscanf+0xb70>
            else
            {
                p0 = p = va_arg (ap, char *);
                while (!isspace (*CURR_POS))
                {
                    *p++ = *CURR_POS;
    9974:	e1a01006 	mov	r1, r6
    9978:	e1a00005 	mov	r0, r5
    997c:	ebfff8c7 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    9980:	e5dd326f 	ldrb	r3, [sp, #623]
                    INC_CURR_POS;
    9984:	e1a00005 	mov	r0, r5
            else
            {
                p0 = p = va_arg (ap, char *);
                while (!isspace (*CURR_POS))
                {
                    *p++ = *CURR_POS;
    9988:	e4ca3001 	strb	r3, [sl], #1
                    INC_CURR_POS;
    998c:	e1a01006 	mov	r1, r6
    9990:	ebfff8fe 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
                    if (--width == 0)
    9994:	e59d3008 	ldr	r3, [sp, #8]
    9998:	e2533001 	subs	r3, r3, #1	; 0x1
    999c:	e58d3008 	str	r3, [sp, #8]
    99a0:	0afffea4 	beq	9438 <vfscanf+0xb70>
                nread += n;
            }
            else
            {
                p0 = p = va_arg (ap, char *);
                while (!isspace (*CURR_POS))
    99a4:	e5d52028 	ldrb	r2, [r5, #40]
    99a8:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    99ac:	e3120020 	tst	r2, #32	; 0x20
    99b0:	e2031001 	and	r1, r3, #1	; 0x1
    99b4:	0a000019 	beq	9a20 <vfscanf+0x1158>
        if (flags.last_buffer_op_was_read == true)
    99b8:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    99bc:	1285001c 	addne	r0, r5, #28	; 0x1c
    99c0:	18900009 	ldmne	r0, {r0, r3}
    99c4:	10403003 	subne	r3, r0, r3
    99c8:	10811003 	addne	r1, r1, r3
                {
                    *p++ = *CURR_POS;
                    INC_CURR_POS;
                    if (--width == 0)
                        break;
                    if (BufferEmpty)
    99cc:	e3510000 	cmp	r1, #0	; 0x0
    99d0:	1afffe91 	bne	941c <vfscanf+0xb54>
    99d4:	e1a00005 	mov	r0, r5
    99d8:	ebfff9b3 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    99dc:	e5d52028 	ldrb	r2, [r5, #40]
    99e0:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    99e4:	e3120020 	tst	r2, #32	; 0x20
    99e8:	e2031001 	and	r1, r3, #1	; 0x1
    99ec:	0a000013 	beq	9a40 <vfscanf+0x1178>
        if (flags.last_buffer_op_was_read == true)
    99f0:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    99f4:	1285201c 	addne	r2, r5, #28	; 0x1c
    99f8:	1892000c 	ldmne	r2, {r2, r3}
    99fc:	10423003 	subne	r3, r2, r3
    9a00:	10811003 	addne	r1, r1, r3
    9a04:	e3510000 	cmp	r1, #0	; 0x0
    9a08:	0afffe8a 	beq	9438 <vfscanf+0xb70>
    9a0c:	eafffe82 	b	941c <vfscanf+0xb54>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    9a10:	e5d53029 	ldrb	r3, [r5, #41]
    9a14:	e3130001 	tst	r3, #1	; 0x1
    9a18:	1afffe9d 	bne	9494 <vfscanf+0xbcc>
    9a1c:	eafffeba 	b	950c <vfscanf+0xc44>
    9a20:	e5d53029 	ldrb	r3, [r5, #41]
    9a24:	e3130001 	tst	r3, #1	; 0x1
    9a28:	1afffe7b 	bne	941c <vfscanf+0xb54>
    9a2c:	eaffffe6 	b	99cc <vfscanf+0x1104>
    9a30:	e5d53029 	ldrb	r3, [r5, #41]
    9a34:	e3130001 	tst	r3, #1	; 0x1
    9a38:	1afffdde 	bne	91b8 <vfscanf+0x8f0>
    9a3c:	eafffe0a 	b	926c <vfscanf+0x9a4>
    9a40:	e5d53029 	ldrb	r3, [r5, #41]
    9a44:	e3130001 	tst	r3, #1	; 0x1
    9a48:	1afffe73 	bne	941c <vfscanf+0xb54>
    9a4c:	eaffffec 	b	9a04 <vfscanf+0x113c>
                 */
                *p++ = c;
                INC_CURR_POS;
                if (SPACE_LEFT == 0)
#ifndef REDHAT_NEC
                    if (REFILL)
    9a50:	e1a00005 	mov	r0, r5
    9a54:	ebfff994 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    9a58:	e3500000 	cmp	r0, #0	; 0x0
    9a5c:	0afffed3 	beq	95b0 <vfscanf+0xce8>
    9a60:	eafffed6 	b	95c0 <vfscanf+0xcf8>
                nread += sum;
            }
            else
            {
                /* Kludge city for the moment */
                char *dest = va_arg (ap, char *);
    9a64:	e5d52028 	ldrb	r2, [r5, #40]
    9a68:	e59d0004 	ldr	r0, [sp, #4]
    9a6c:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    9a70:	e3120020 	tst	r2, #32	; 0x20
    9a74:	e2031001 	and	r1, r3, #1	; 0x1
    9a78:	e590a000 	ldr	sl, [r0]
    9a7c:	0a0000d3 	beq	9dd0 <vfscanf+0x1508>
        if (flags.last_buffer_op_was_read == true)
    9a80:	e1b033a2 	lsrs	r3, r2, #7
            bytes += io_buf.get_buffer_space_used();
    9a84:	1285001c 	addne	r0, r5, #28	; 0x1c
    9a88:	18900009 	ldmne	r0, {r0, r3}
    9a8c:	10403003 	subne	r3, r0, r3
    9a90:	10811003 	addne	r1, r1, r3
                int n = width;
                if (SPACE_LEFT == 0)
    9a94:	e3510000 	cmp	r1, #0	; 0x0
    9a98:	0a0000c6 	beq	9db8 <vfscanf+0x14f0>
    9a9c:	e1a03222 	lsr	r3, r2, #4
    9aa0:	e2033001 	and	r3, r3, #1	; 0x1
#endif
                        goto input_failure;

                while (n && !BufferEmpty)
                {
                    *dest++ = *CURR_POS;
    9aa4:	e064a00a 	rsb	sl, r4, sl
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    9aa8:	e3120020 	tst	r2, #32	; 0x20
                /* Kludge city for the moment */
                char *dest = va_arg (ap, char *);
                int n = width;
                if (SPACE_LEFT == 0)
#ifndef REDHAT_NEC
                    if (REFILL)
    9aac:	e1a01003 	mov	r1, r3
    9ab0:	0a000016 	beq	9b10 <vfscanf+0x1248>
        if (flags.last_buffer_op_was_read == true)
    9ab4:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    9ab8:	1285201c 	addne	r2, r5, #28	; 0x1c
    9abc:	1892000c 	ldmne	r2, {r2, r3}
    9ac0:	10423003 	subne	r3, r2, r3
    9ac4:	10811003 	addne	r1, r1, r3
#endif
                        goto input_failure;

                while (n && !BufferEmpty)
    9ac8:	e3510000 	cmp	r1, #0	; 0x0
    9acc:	0a000013 	beq	9b20 <vfscanf+0x1258>
                {
                    *dest++ = *CURR_POS;
    9ad0:	e1a01006 	mov	r1, r6
    9ad4:	e1a00005 	mov	r0, r5
    9ad8:	ebfff870 	bl	7ca0 <_ZN15Cyg_StdioStream9peek_byteEPh>
    9adc:	e5dd326f 	ldrb	r3, [sp, #623]
                    INC_CURR_POS;
    9ae0:	e1a00005 	mov	r0, r5
#endif
                        goto input_failure;

                while (n && !BufferEmpty)
                {
                    *dest++ = *CURR_POS;
    9ae4:	e7ca3004 	strb	r3, [sl, r4]
                    INC_CURR_POS;
    9ae8:	e1a01006 	mov	r1, r6
    9aec:	ebfff8a7 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
#ifndef REDHAT_NEC
                    if (REFILL)
#endif
                        goto input_failure;

                while (n && !BufferEmpty)
    9af0:	e25bb001 	subs	fp, fp, #1	; 0x1
                {
                    *dest++ = *CURR_POS;
                    INC_CURR_POS;
                    n--;
                    nread++;
    9af4:	e2844001 	add	r4, r4, #1	; 0x1
#ifndef REDHAT_NEC
                    if (REFILL)
#endif
                        goto input_failure;

                while (n && !BufferEmpty)
    9af8:	1a000065 	bne	9c94 <vfscanf+0x13cc>
                nread += sum;
            }
            else
            {
                /* Kludge city for the moment */
                char *dest = va_arg (ap, char *);
    9afc:	e59d1004 	ldr	r1, [sp, #4]
    9b00:	e2811004 	add	r1, r1, #4	; 0x4
    9b04:	e58d1004 	str	r1, [sp, #4]
                    *dest++ = *CURR_POS;
                    INC_CURR_POS;
                    n--;
                    nread++;
                }
                nassigned++;
    9b08:	e2888001 	add	r8, r8, #1	; 0x1
    9b0c:	eafffb7d 	b	8908 <vfscanf+0x40>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    9b10:	e5d53029 	ldrb	r3, [r5, #41]
    9b14:	e3130001 	tst	r3, #1	; 0x1
    9b18:	1affffec 	bne	9ad0 <vfscanf+0x1208>
    9b1c:	eaffffe9 	b	9ac8 <vfscanf+0x1200>
#ifndef REDHAT_NEC
                    if (REFILL)
#endif
                        goto input_failure;

                while (n && !BufferEmpty)
    9b20:	e1a00005 	mov	r0, r5
    9b24:	ebfff960 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    9b28:	e5d52028 	ldrb	r2, [r5, #40]
    9b2c:	e1a03222 	lsr	r3, r2, #4
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

    // either the last operation was a read, which attempted to read bytes
    // into the buffer, or there are no bytes in the buffer

    if (flags.buffering) {
    9b30:	e3120020 	tst	r2, #32	; 0x20
    9b34:	e2031001 	and	r1, r3, #1	; 0x1
    9b38:	0a000019 	beq	9ba4 <vfscanf+0x12dc>
        if (flags.last_buffer_op_was_read == true)
    9b3c:	e1b023a2 	lsrs	r2, r2, #7
            bytes += io_buf.get_buffer_space_used();
    9b40:	1285001c 	addne	r0, r5, #28	; 0x1c
    9b44:	18900009 	ldmne	r0, {r0, r3}
    9b48:	10403003 	subne	r3, r0, r3
    9b4c:	10811003 	addne	r1, r1, r3
    9b50:	e3510000 	cmp	r1, #0	; 0x0
    9b54:	0affffe8 	beq	9afc <vfscanf+0x1234>
    9b58:	eaffffdc 	b	9ad0 <vfscanf+0x1208>
        v = 0;                  /* default => reject */
    /* should probably use memset here */
    for (n = 0; n < 256; n++)
        tab[n] = v;
    if (c == 0)
        return fmt - 1;         /* format ended before closing ] */
    9b5c:	e1a0100c 	mov	r1, ip
     */

    v = 1 - v;
    for (;;)
    {
        tab[c] = v;             /* take character c */
    9b60:	e59d3018 	ldr	r3, [sp, #24]
    9b64:	e7c03001 	strb	r3, [r0, r1]
    9b68:	e1a0b007 	mov	fp, r7
    doswitch:
        n = *fmt++;             /* and examine the next */
    9b6c:	e1a0700b 	mov	r7, fp
    9b70:	e4d7c001 	ldrb	ip, [r7], #1
        switch (n)
    9b74:	e35c002d 	cmp	ip, #45	; 0x2d
    9b78:	0a000051 	beq	9cc4 <vfscanf+0x13fc>
    9b7c:	e35c005d 	cmp	ip, #93	; 0x5d
    9b80:	0affff04 	beq	9798 <vfscanf+0xed0>
    9b84:	e35c0000 	cmp	ip, #0	; 0x0
    9b88:	1afffff3 	bne	9b5c <vfscanf+0x1294>
    9b8c:	e1a0700b 	mov	r7, fp
    9b90:	eaffff00 	b	9798 <vfscanf+0xed0>
    }
    else

#endif

    if (flags.readbuf_char_in_use)
    9b94:	e5d53029 	ldrb	r3, [r5, #41]
    9b98:	e3130001 	tst	r3, #1	; 0x1
    9b9c:	1afffe3c 	bne	9494 <vfscanf+0xbcc>
    9ba0:	eafffe39 	b	948c <vfscanf+0xbc4>
    9ba4:	e5d53029 	ldrb	r3, [r5, #41]
    9ba8:	e3130001 	tst	r3, #1	; 0x1
    9bac:	1affffc7 	bne	9ad0 <vfscanf+0x1208>
    9bb0:	eaffffe6 	b	9b50 <vfscanf+0x1288>
                _CAST_VOID ungetc (c, fp);
            }
            if ((flags & SUPPRESS) == 0)
            {
                double res;
                *p = 0;
    9bb4:	e59d2020 	ldr	r2, [sp, #32]
#ifdef CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
                res = strtod( buf, NULL );
    9bb8:	e1a01003 	mov	r1, r3
    9bbc:	e1a00009 	mov	r0, r9
                _CAST_VOID ungetc (c, fp);
            }
            if ((flags & SUPPRESS) == 0)
            {
                double res;
                *p = 0;
    9bc0:	e5c23000 	strb	r3, [r2]
#ifdef CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
                res = strtod( buf, NULL );
    9bc4:	eb000950 	bl	c10c <strtod>
#else
                res = 0.0;
#endif
                if (flags & LONG)
    9bc8:	e31a0001 	tst	sl, #1	; 0x1
            if ((flags & SUPPRESS) == 0)
            {
                double res;
                *p = 0;
#ifdef CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
                res = strtod( buf, NULL );
    9bcc:	e1a0b000 	mov	fp, r0
    9bd0:	e1a0c001 	mov	ip, r1
#else
                res = 0.0;
#endif
                if (flags & LONG)
    9bd4:	0a00000a 	beq	9c04 <vfscanf+0x133c>
                {
                    dp = va_arg (ap, double *);
                    *dp = res;
    9bd8:	e59d0004 	ldr	r0, [sp, #4]
    9bdc:	e5903000 	ldr	r3, [r0]
    9be0:	e2800004 	add	r0, r0, #4	; 0x4
    9be4:	e8831800 	stm	r3, {fp, ip}
    9be8:	e58d0004 	str	r0, [sp, #4]
                else
                {
                    flp = va_arg (ap, float *);
                    *flp = res;
                }
                nassigned++;
    9bec:	e2888001 	add	r8, r8, #1	; 0x1
    9bf0:	eafffcfc 	b	8fe8 <vfscanf+0x720>
    9bf4:	e5d53029 	ldrb	r3, [r5, #41]
    9bf8:	e3130001 	tst	r3, #1	; 0x1
    9bfc:	1afffdb6 	bne	92dc <vfscanf+0xa14>
    9c00:	eafffdb3 	b	92d4 <vfscanf+0xa0c>
                {
                    dp = va_arg (ap, double *);
                    *dp = res;
                }
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
                else if (flags & LONGDBL)
    9c04:	e31a0002 	tst	sl, #2	; 0x2
    9c08:	0a000019 	beq	9c74 <vfscanf+0x13ac>
                {
                    ldp = va_arg (ap, long double *);
                    *ldp = res;
    9c0c:	e59d1004 	ldr	r1, [sp, #4]
    9c10:	e5913000 	ldr	r3, [r1]
    9c14:	e2811004 	add	r1, r1, #4	; 0x4
    9c18:	e8831800 	stm	r3, {fp, ip}
    9c1c:	e58d1004 	str	r1, [sp, #4]
                else
                {
                    flp = va_arg (ap, float *);
                    *flp = res;
                }
                nassigned++;
    9c20:	e2888001 	add	r8, r8, #1	; 0x1
    9c24:	eafffcef 	b	8fe8 <vfscanf+0x720>
                }
                /* just a bad exponent (e and maybe sign) */
                c = *(u_char *)-- p;
                if (c != 'e' && c != 'E')
                {
                    _CAST_VOID ungetc (c, fp); /* sign */
    9c28:	e1a01005 	mov	r1, r5
    9c2c:	eb001843 	bl	fd40 <ungetc>
                    c = *(u_char *)-- p;
    9c30:	e59d3020 	ldr	r3, [sp, #32]
    9c34:	e5730001 	ldrb	r0, [r3, #-1]!
    9c38:	e58d3020 	str	r3, [sp, #32]
    9c3c:	eafffce5 	b	8fd8 <vfscanf+0x710>
            if (flags & NDIGITS)
            {
                if (flags & EXPOK)
                {
                    /* no digits at all */
                    while (p > buf)
    9c40:	e28d302c 	add	r3, sp, #44	; 0x2c
    9c44:	e59d1020 	ldr	r1, [sp, #32]
    9c48:	e2433003 	sub	r3, r3, #3	; 0x3
    9c4c:	e1510003 	cmp	r1, r3
    9c50:	9afffb76 	bls	8a30 <vfscanf+0x168>
    9c54:	e1a04001 	mov	r4, r1
    9c58:	e1a06003 	mov	r6, r3
                        ungetc (*(u_char *)-- p, fp);
    9c5c:	e5740001 	ldrb	r0, [r4, #-1]!
    9c60:	e1a01005 	mov	r1, r5
    9c64:	eb001835 	bl	fd40 <ungetc>
            if (flags & NDIGITS)
            {
                if (flags & EXPOK)
                {
                    /* no digits at all */
                    while (p > buf)
    9c68:	e1560004 	cmp	r6, r4
    9c6c:	3afffffa 	bcc	9c5c <vfscanf+0x1394>
    9c70:	eafffb6e 	b	8a30 <vfscanf+0x168>
                }
#endif
                else
                {
                    flp = va_arg (ap, float *);
                    *flp = res;
    9c74:	eb002043 	bl	11d88 <__aeabi_d2f>
    9c78:	e59d2004 	ldr	r2, [sp, #4]
    9c7c:	e5923000 	ldr	r3, [r2]
                    *ldp = res;
                }
#endif
                else
                {
                    flp = va_arg (ap, float *);
    9c80:	e2822004 	add	r2, r2, #4	; 0x4
                    *flp = res;
    9c84:	e5830000 	str	r0, [r3]
    9c88:	e58d2004 	str	r2, [sp, #4]
                }
                nassigned++;
    9c8c:	e2888001 	add	r8, r8, #1	; 0x1
    9c90:	eafffcd4 	b	8fe8 <vfscanf+0x720>
                /* Kludge city for the moment */
                char *dest = va_arg (ap, char *);
                int n = width;
                if (SPACE_LEFT == 0)
#ifndef REDHAT_NEC
                    if (REFILL)
    9c94:	e5d52028 	ldrb	r2, [r5, #40]
    9c98:	e1a03222 	lsr	r3, r2, #4
    9c9c:	e2033001 	and	r3, r3, #1	; 0x1
    9ca0:	eaffff80 	b	9aa8 <vfscanf+0x11e0>
             * If the number ends in `x', it was [sign] '0' 'x', so push
             * back the x and treat it as [sign] '0'.
             */
            if (flags & NDIGITS)
            {
                if (p > buf)
    9ca4:	e28d302c 	add	r3, sp, #44	; 0x2c
    9ca8:	e2433003 	sub	r3, r3, #3	; 0x3
    9cac:	e15b0003 	cmp	fp, r3
    9cb0:	9afffb5e 	bls	8a30 <vfscanf+0x168>
                    _CAST_VOID ungetc (*(u_char *)-- p, fp);
    9cb4:	e55b0001 	ldrb	r0, [fp, #-1]
    9cb8:	e1a01005 	mov	r1, r5
    9cbc:	eb00181f 	bl	fd40 <ungetc>
    9cc0:	eafffb5a 	b	8a30 <vfscanf+0x168>
             * For compatibility, the `-' is not considerd to define a
             * range if the character following it is either a close
             * bracket (required by ANSI) or is not numerically greater
             * than the character we just stored in the table (c).
             */
            n = *fmt;
    9cc4:	e5db2001 	ldrb	r2, [fp, #1]
            if (n == ']' || n < c)
    9cc8:	e1520001 	cmp	r2, r1
    9ccc:	a3a03000 	movge	r3, #0	; 0x0
    9cd0:	b3a03001 	movlt	r3, #1	; 0x1
    9cd4:	e352005d 	cmp	r2, #93	; 0x5d
    9cd8:	03833001 	orreq	r3, r3, #1	; 0x1
    9cdc:	e3530000 	cmp	r3, #0	; 0x0
    9ce0:	1affff9d 	bne	9b5c <vfscanf+0x1294>
                break;          /* resume the for(;;) */
            }
            fmt++;
            do
            {                   /* fill in the range */
                tab[++c] = v;
    9ce4:	e2811001 	add	r1, r1, #1	; 0x1
    9ce8:	e59d3018 	ldr	r3, [sp, #24]
            {
                c = '-';
                break;          /* resume the for(;;) */
            }
            fmt++;
            do
    9cec:	e1520001 	cmp	r2, r1
            {                   /* fill in the range */
                tab[++c] = v;
    9cf0:	e7c03001 	strb	r3, [r0, r1]
            {
                c = '-';
                break;          /* resume the for(;;) */
            }
            fmt++;
            do
    9cf4:	cafffffa 	bgt	9ce4 <vfscanf+0x141c>
typedef int (*mbtowc_fn_type)(wchar_t *, const char *, size_t, int *);
externC mbtowc_fn_type __get_current_locale_mbtowc_fn();
#endif

externC int
vfscanf (FILE *fp, const char *fmt0, va_list ap) __THROW
    9cf8:	e28bb002 	add	fp, fp, #2	; 0x2
    9cfc:	eaffff9a 	b	9b6c <vfscanf+0x12a4>
    9d00:	0000cac0 	.word	0x0000cac0
    9d04:	0000c640 	.word	0x0000c640
    9d08:	0000c81c 	.word	0x0000c81c
    9d0c:	0000c45c 	.word	0x0000c45c
    9d10:	00012ab8 	.word	0x00012ab8
                        if (n == 0)
                            goto input_failure;
                        break;
                    }
                }
                if (n == 0)
    9d14:	e35a0000 	cmp	sl, #0	; 0x0
    9d18:	0afffb44 	beq	8a30 <vfscanf+0x168>
    9d1c:	eafffd5e 	b	929c <vfscanf+0x9d4>
            if (flags & SHORT)
            {
                sp = va_arg (ap, short *);
                *sp = nread;
            }
            else if (flags & LONG)
    9d20:	e31a0001 	tst	sl, #1	; 0x1
            {
                lp = va_arg (ap, long *);
                *lp = nread;
    9d24:	159d0004 	ldrne	r0, [sp, #4]
            }
            else
            {
                ip = va_arg (ap, int *);
                *ip = nread;
    9d28:	059d1004 	ldreq	r1, [sp, #4]
                *sp = nread;
            }
            else if (flags & LONG)
            {
                lp = va_arg (ap, long *);
                *lp = nread;
    9d2c:	15903000 	ldrne	r3, [r0]
            }
            else
            {
                ip = va_arg (ap, int *);
                *ip = nread;
    9d30:	05913000 	ldreq	r3, [r1]
                *sp = nread;
            }
            else if (flags & LONG)
            {
                lp = va_arg (ap, long *);
                *lp = nread;
    9d34:	12800004 	addne	r0, r0, #4	; 0x4
            }
            else
            {
                ip = va_arg (ap, int *);
                *ip = nread;
    9d38:	02811004 	addeq	r1, r1, #4	; 0x4
                *sp = nread;
            }
            else if (flags & LONG)
            {
                lp = va_arg (ap, long *);
                *lp = nread;
    9d3c:	15834000 	strne	r4, [r3]
    9d40:	158d0004 	strne	r0, [sp, #4]
            }
            else
            {
                ip = va_arg (ap, int *);
                *ip = nread;
    9d44:	05834000 	streq	r4, [r3]
    9d48:	058d1004 	streq	r1, [sp, #4]
    9d4c:	eafffaed 	b	8908 <vfscanf+0x40>
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
		if (flags & LONGDBL)
		  res = (*ccfnL) (buf, (char **) NULL, base);
		else
#endif
		  res = (*ccfn) (buf, (char **) NULL, base);
    9d50:	e1a0100b 	mov	r1, fp
    9d54:	e1a00009 	mov	r0, r9
    9d58:	e28d200c 	add	r2, sp, #12	; 0xc
    9d5c:	e892000c 	ldm	r2, {r2, r3}
    9d60:	e1a0e00f 	mov	lr, pc
    9d64:	e12fff13 	bx	r3
    9d68:	e1a0100b 	mov	r1, fp
    9d6c:	eafffe28 	b	9614 <vfscanf+0xd4c>
                else if (flags & SHORT)
                {
                    sp = va_arg (ap, short *);
                    *sp = res;
                }
                else if (flags & LONG)
    9d70:	e31a0001 	tst	sl, #1	; 0x1
    9d74:	1a000008 	bne	9d9c <vfscanf+0x14d4>
                {
                    lp = va_arg (ap, long *);
                    *lp = res;
                }
#ifdef CYGFUN_LIBC_STDIO_LONGLONG
                else if (flags & LONGDBL)
    9d78:	e35b0000 	cmp	fp, #0	; 0x0
    9d7c:	0a000006 	beq	9d9c <vfscanf+0x14d4>
                {
                    ll = va_arg (ap, long long *);
                    *ll = res;
    9d80:	e59d2004 	ldr	r2, [sp, #4]
    9d84:	e5923000 	ldr	r3, [r2]
    9d88:	e2822004 	add	r2, r2, #4	; 0x4
    9d8c:	e8830003 	stm	r3, {r0, r1}
    9d90:	e58d2004 	str	r2, [sp, #4]
                else
                {
                    ip = va_arg (ap, int *);
                    *ip = res;
                }
                nassigned++;
    9d94:	e2888001 	add	r8, r8, #1	; 0x1
    9d98:	eafffe27 	b	963c <vfscanf+0xd74>
                }
#endif
                else
                {
                    ip = va_arg (ap, int *);
                    *ip = res;
    9d9c:	e59d1004 	ldr	r1, [sp, #4]
    9da0:	e5913000 	ldr	r3, [r1]
    9da4:	e2811004 	add	r1, r1, #4	; 0x4
    9da8:	e5830000 	str	r0, [r3]
                }
                nassigned++;
    9dac:	e2888001 	add	r8, r8, #1	; 0x1
                }
#endif
                else
                {
                    ip = va_arg (ap, int *);
                    *ip = res;
    9db0:	e58d1004 	str	r1, [sp, #4]
    9db4:	eafffe20 	b	963c <vfscanf+0xd74>
                /* Kludge city for the moment */
                char *dest = va_arg (ap, char *);
                int n = width;
                if (SPACE_LEFT == 0)
#ifndef REDHAT_NEC
                    if (REFILL)
    9db8:	e1a00005 	mov	r0, r5
    9dbc:	ebfff8ba 	bl	80ac <_ZN15Cyg_StdioStream18refill_read_bufferEv>
    9dc0:	e3500000 	cmp	r0, #0	; 0x0
    9dc4:	1afffb4f 	bne	8b08 <vfscanf+0x240>
    9dc8:	e5d52028 	ldrb	r2, [r5, #40]
    9dcc:	eaffff32 	b	9a9c <vfscanf+0x11d4>
    9dd0:	e5d53029 	ldrb	r3, [r5, #41]
    9dd4:	e3130001 	tst	r3, #1	; 0x1
    9dd8:	1affff2f 	bne	9a9c <vfscanf+0x11d4>
    9ddc:	eaffff2c 	b	9a94 <vfscanf+0x11cc>
#endif
                    }
                    else
                    {
                        sum += width;
                        MOVE_CURR_POS(width - 1);
    9de0:	e59d2008 	ldr	r2, [sp, #8]
    9de4:	e1a00005 	mov	r0, r5
    9de8:	e2421001 	sub	r1, r2, #1	; 0x1
    9dec:	e3a02001 	mov	r2, #1	; 0x1
    9df0:	ebfffa88 	bl	8818 <_ZN15Cyg_StdioStream12set_positionEii>
                        }
#endif
                    }
                    else
                    {
                        sum += width;
    9df4:	e59d3008 	ldr	r3, [sp, #8]
                        MOVE_CURR_POS(width - 1);
                        INC_CURR_POS;
    9df8:	e1a00005 	mov	r0, r5
                        }
#endif
                    }
                    else
                    {
                        sum += width;
    9dfc:	e08bb003 	add	fp, fp, r3
                        MOVE_CURR_POS(width - 1);
                        INC_CURR_POS;
    9e00:	e1a01006 	mov	r1, r6
    9e04:	ebfff7e1 	bl	7d90 <_ZN15Cyg_StdioStream9read_byteEPh>
                        break;
                    }
                }
                nread += sum;
    9e08:	e08b4004 	add	r4, fp, r4
    9e0c:	eafffabd 	b	8908 <vfscanf+0x40>

00009e10 <fprintf>:
#include <limits.h>                 // INT_MAX

// FUNCTIONS

externC int
fprintf( FILE *stream, const char *format, ... ) __THROW
    9e10:	e92d000e 	push	{r1, r2, r3}
    9e14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    int rc;      // return code
    va_list ap;  // for variable args

    va_start(ap, format); // init specifying last non-var arg

    rc = vfnprintf(stream, INT_MAX, format, ap);
    9e18:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
    9e1c:	e59d2004 	ldr	r2, [sp, #4]
    9e20:	e28d3008 	add	r3, sp, #8	; 0x8
    9e24:	eb0000a5 	bl	a0c0 <vfnprintf>

    va_end(ap); // end var args

    return rc;
} // fprintf()
    9e28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
    9e2c:	e28dd00c 	add	sp, sp, #12	; 0xc
    9e30:	e12fff1e 	bx	lr

00009e34 <fputc>:
#include <cyg/libc/stdio/stream.hxx>// Cyg_StdioStream

// FUNCTIONS

externC int
fputc( int c, FILE *stream ) __THROW
    9e34:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    9e38:	e24dd00c 	sub	sp, sp, #12	; 0xc
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;
    cyg_uint8 real_c = (cyg_uint8) c;
    9e3c:	e20050ff 	and	r5, r0, #255	; 0xff
    CYG_REPORT_FUNCNAMETYPE("fputc", "wrote char %d");
    CYG_REPORT_FUNCARG2( "c = %d, stream=%08x", c, stream );
    
    CYG_CHECK_DATA_PTR( stream, "stream is not a valid pointer" );

    err = real_stream->write_byte( real_c );
    9e40:	e28d3008 	add	r3, sp, #8	; 0x8
    9e44:	e5635001 	strb	r5, [r3, #-1]!
#include <cyg/libc/stdio/stream.hxx>// Cyg_StdioStream

// FUNCTIONS

externC int
fputc( int c, FILE *stream ) __THROW
    9e48:	e1a04001 	mov	r4, r1
    cyg_ucount32 dummy_bytes_written;
    Cyg_ErrNo err;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    err = write( &c, 1, &dummy_bytes_written );
    9e4c:	e594c000 	ldr	ip, [r4]
    9e50:	e1a01003 	mov	r1, r3
    9e54:	e1a00004 	mov	r0, r4
    9e58:	e3a02001 	mov	r2, #1	; 0x1
    9e5c:	e1a0300d 	mov	r3, sp
    9e60:	e1a0e00f 	mov	lr, pc
    9e64:	e59cf008 	ldr	pc, [ip, #8]
    
    CYG_CHECK_DATA_PTR( stream, "stream is not a valid pointer" );

    err = real_stream->write_byte( real_c );

    if (err)
    9e68:	e2506000 	subs	r6, r0, #0	; 0x0
        CYG_REPORT_RETVAL(EOF);
        return EOF;
    } // if
    
    CYG_REPORT_RETVAL((int)real_c);
    return (int)real_c;
    9e6c:	01a00005 	moveq	r0, r5
    
    CYG_CHECK_DATA_PTR( stream, "stream is not a valid pointer" );

    err = real_stream->write_byte( real_c );

    if (err)
    9e70:	1a000001 	bne	9e7c <fputc+0x48>
    } // if
    
    CYG_REPORT_RETVAL((int)real_c);
    return (int)real_c;

} // fputc()
    9e74:	e28dd00c 	add	sp, sp, #12	; 0xc
    9e78:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    9e7c:	e2847030 	add	r7, r4, #48	; 0x30
    9e80:	e1a00007 	mov	r0, r7
    9e84:	ebfff432 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline void
Cyg_StdioStream::set_error( Cyg_ErrNo errno_to_set )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    9e88:	e3500000 	cmp	r0, #0	; 0x0
    9e8c:	1a000006 	bne	9eac <fputc+0x78>
    {
        errno = EBADF; // best we can do - we can't trust error to be there
    9e90:	eb000eb6 	bl	d970 <cyg_error_get_errno_p>
    9e94:	e3a03009 	mov	r3, #9	; 0x9
    9e98:	e5803000 	str	r3, [r0]
    9e9c:	e1a05000 	mov	r5, r0
    err = real_stream->write_byte( real_c );

    if (err)
    {
        real_stream->set_error( err );
        errno = err;
    9ea0:	e5856000 	str	r6, [r5]
    9ea4:	e3e00000 	mvn	r0, #0	; 0x0
    9ea8:	eafffff1 	b	9e74 <fputc+0x40>
        return;
    } // if
    
    errno = error = errno_to_set;
    9eac:	eb000eaf 	bl	d970 <cyg_error_get_errno_p>
    9eb0:	e5846004 	str	r6, [r4, #4]
    9eb4:	e5806000 	str	r6, [r0]

    if ( EEOF == error )
    9eb8:	e5943004 	ldr	r3, [r4, #4]
    9ebc:	e35300c8 	cmp	r3, #200	; 0xc8
        flags.at_eof = 1;
    9ec0:	05d43028 	ldrbeq	r3, [r4, #40]
    9ec4:	03833001 	orreq	r3, r3, #1	; 0x1
    {
        errno = EBADF; // best we can do - we can't trust error to be there
        return;
    } // if
    
    errno = error = errno_to_set;
    9ec8:	e1a05000 	mov	r5, r0

    if ( EEOF == error )
        flags.at_eof = 1;
    9ecc:	05c43028 	strbeq	r3, [r4, #40]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    9ed0:	e1a00007 	mov	r0, r7
    9ed4:	ebfff516 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    9ed8:	eafffff0 	b	9ea0 <fputc+0x6c>

00009edc <putchar>:
#undef putchar

externC int
putchar( int c ) __THROW
{
    return fputc( c, stdout );
    9edc:	e59f3004 	ldr	r3, [pc, #4]	; 9ee8 <putchar+0xc>
    9ee0:	e5931000 	ldr	r1, [r3]
    9ee4:	eaffffd2 	b	9e34 <fputc>
    9ee8:	00012a6c 	.word	0x00012a6c

00009eec <fputs>:
#include <string.h>                 // strlen()

// FUNCTIONS

externC int
fputs( const char *s, FILE *stream ) __THROW
    9eec:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    9ef0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    9ef4:	e1a05001 	mov	r5, r1
    9ef8:	e1a04000 	mov	r4, r0
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    cyg_ucount32 size = strlen(s);
    9efc:	eb000bfe 	bl	cefc <__strlen>
    cyg_ucount32 written;
    Cyg_ErrNo err;
    
    err = real_stream->write( (cyg_uint8 *)s, size, &written );
    9f00:	e1a01004 	mov	r1, r4

externC int
fputs( const char *s, FILE *stream ) __THROW
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    cyg_ucount32 size = strlen(s);
    9f04:	e1a02000 	mov	r2, r0
    cyg_ucount32 written;
    Cyg_ErrNo err;
    
    err = real_stream->write( (cyg_uint8 *)s, size, &written );
    9f08:	e595c000 	ldr	ip, [r5]
    9f0c:	e1a00005 	mov	r0, r5
    9f10:	e28d3004 	add	r3, sp, #4	; 0x4
    9f14:	e1a0e00f 	mov	lr, pc
    9f18:	e59cf008 	ldr	pc, [ip, #8]

    if (err) {
    9f1c:	e2504000 	subs	r4, r0, #0	; 0x0
        errno = err;
        return EOF;
    } // if
    
    
    return written;
    9f20:	059d0004 	ldreq	r0, [sp, #4]
    cyg_ucount32 written;
    Cyg_ErrNo err;
    
    err = real_stream->write( (cyg_uint8 *)s, size, &written );

    if (err) {
    9f24:	1a000001 	bne	9f30 <fputs+0x44>
    } // if
    
    
    return written;

} // fputs()
    9f28:	e28dd00c 	add	sp, sp, #12	; 0xc
    9f2c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    9f30:	e2857030 	add	r7, r5, #48	; 0x30
    9f34:	e1a00007 	mov	r0, r7
    9f38:	ebfff405 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline void
Cyg_StdioStream::set_error( Cyg_ErrNo errno_to_set )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    9f3c:	e3500000 	cmp	r0, #0	; 0x0
    9f40:	1a000006 	bne	9f60 <fputs+0x74>
    {
        errno = EBADF; // best we can do - we can't trust error to be there
    9f44:	eb000e89 	bl	d970 <cyg_error_get_errno_p>
    9f48:	e3a03009 	mov	r3, #9	; 0x9
    9f4c:	e5803000 	str	r3, [r0]
    9f50:	e1a06000 	mov	r6, r0
    
    err = real_stream->write( (cyg_uint8 *)s, size, &written );

    if (err) {
        real_stream->set_error( err );
        errno = err;
    9f54:	e5864000 	str	r4, [r6]
    9f58:	e3e00000 	mvn	r0, #0	; 0x0
    9f5c:	eafffff1 	b	9f28 <fputs+0x3c>
        return;
    } // if
    
    errno = error = errno_to_set;
    9f60:	eb000e82 	bl	d970 <cyg_error_get_errno_p>
    9f64:	e5854004 	str	r4, [r5, #4]
    9f68:	e5804000 	str	r4, [r0]

    if ( EEOF == error )
    9f6c:	e5953004 	ldr	r3, [r5, #4]
    9f70:	e35300c8 	cmp	r3, #200	; 0xc8
        flags.at_eof = 1;
    9f74:	05d53028 	ldrbeq	r3, [r5, #40]
    9f78:	03833001 	orreq	r3, r3, #1	; 0x1
    {
        errno = EBADF; // best we can do - we can't trust error to be there
        return;
    } // if
    
    errno = error = errno_to_set;
    9f7c:	e1a06000 	mov	r6, r0

    if ( EEOF == error )
        flags.at_eof = 1;
    9f80:	05c53028 	strbeq	r3, [r5, #40]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    9f84:	e1a00007 	mov	r0, r7
    9f88:	ebfff4e9 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    9f8c:	eafffff0 	b	9f54 <fputs+0x68>

00009f90 <_ZL5rounddPiPcS0_cS0_>:


#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT

static char *
round(double fract, int *exp, char *start, char *end, char ch, char *signp)
    9f90:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    9f94:	e1a08002 	mov	r8, r2
    9f98:	e24dd008 	sub	sp, sp, #8	; 0x8
    9f9c:	e1a05003 	mov	r5, r3
{
        double tmp;

        if (fract)
    9fa0:	e3a02000 	mov	r2, #0	; 0x0
    9fa4:	e3a03000 	mov	r3, #0	; 0x0


#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT

static char *
round(double fract, int *exp, char *start, char *end, char ch, char *signp)
    9fa8:	e1a06000 	mov	r6, r0
    9fac:	e1a07001 	mov	r7, r1
{
        double tmp;

        if (fract)
    9fb0:	eb001f31 	bl	11c7c <__aeabi_dcmpeq>
    9fb4:	e3500000 	cmp	r0, #0	; 0x0


#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT

static char *
round(double fract, int *exp, char *start, char *end, char ch, char *signp)
    9fb8:	e59d4020 	ldr	r4, [sp, #32]
    9fbc:	e5dd0024 	ldrb	r0, [sp, #36]
{
        double tmp;

        if (fract)
    9fc0:	0a00002a 	beq	a070 <_ZL5rounddPiPcS0_cS0_+0xe0>
        (void)modf(fract * 10, &tmp);
        else
                tmp = to_digit(ch);
    9fc4:	e2400030 	sub	r0, r0, #48	; 0x30
    9fc8:	eb001d9b 	bl	1163c <__aeabi_i2d>
    9fcc:	e88d0003 	stm	sp, {r0, r1}
        if (tmp > 4)
    9fd0:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    9fd4:	e89d0003 	ldm	sp, {r0, r1}
    9fd8:	e3a02000 	mov	r2, #0	; 0x0
    9fdc:	e2833601 	add	r3, r3, #1048576	; 0x100000
    9fe0:	eb001f3d 	bl	11cdc <__aeabi_dcmpgt>
    9fe4:	e3500000 	cmp	r0, #0	; 0x0
    9fe8:	0a000010 	beq	a030 <_ZL5rounddPiPcS0_cS0_+0xa0>
                for (;; --end) {
                        if (*end == '.')
                                --end;
                        if (++*end <= '9')
                                break;
                        *end = '0';
    9fec:	e3a02030 	mov	r2, #48	; 0x30
    9ff0:	ea000003 	b	a004 <_ZL5rounddPiPcS0_cS0_+0x74>
                        if (end == start) {
    9ff4:	e1540005 	cmp	r4, r5
                for (;; --end) {
                        if (*end == '.')
                                --end;
                        if (++*end <= '9')
                                break;
                        *end = '0';
    9ff8:	e5c42000 	strb	r2, [r4]
        if (fract)
        (void)modf(fract * 10, &tmp);
        else
                tmp = to_digit(ch);
        if (tmp > 4)
                for (;; --end) {
    9ffc:	e2444001 	sub	r4, r4, #1	; 0x1
                        if (*end == '.')
                                --end;
                        if (++*end <= '9')
                                break;
                        *end = '0';
                        if (end == start) {
    a000:	0a000023 	beq	a094 <_ZL5rounddPiPcS0_cS0_+0x104>
        (void)modf(fract * 10, &tmp);
        else
                tmp = to_digit(ch);
        if (tmp > 4)
                for (;; --end) {
                        if (*end == '.')
    a004:	e5d43000 	ldrb	r3, [r4]
    a008:	e353002e 	cmp	r3, #46	; 0x2e
                                --end;
    a00c:	05743001 	ldrbeq	r3, [r4, #-1]!
                        if (++*end <= '9')
    a010:	e2833001 	add	r3, r3, #1	; 0x1
    a014:	e20330ff 	and	r3, r3, #255	; 0xff
    a018:	e3530039 	cmp	r3, #57	; 0x39
    a01c:	e5c43000 	strb	r3, [r4]
    a020:	8afffff3 	bhi	9ff4 <_ZL5rounddPiPcS0_cS0_+0x64>
                                break;
                        if (end == start)
                                *signp = 0;
                }
        return (start);
} // round()
    a024:	e1a00005 	mov	r0, r5
    a028:	e28dd008 	add	sp, sp, #8	; 0x8
    a02c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                                }
                                break;
                        }
                }
        /* ``"%.3f", (double)-0.0004'' gives you a negative 0. */
        else if (*signp == '-')
    a030:	e59d2028 	ldr	r2, [sp, #40]
    a034:	e5d23000 	ldrb	r3, [r2]
    a038:	e353002d 	cmp	r3, #45	; 0x2d
    a03c:	1afffff8 	bne	a024 <_ZL5rounddPiPcS0_cS0_+0x94>
                        if (*end == '.')
                                --end;
                        if (*end != '0')
                                break;
                        if (end == start)
                                *signp = 0;
    a040:	e3a02000 	mov	r2, #0	; 0x0
    a044:	ea000003 	b	a058 <_ZL5rounddPiPcS0_cS0_+0xc8>
                for (;; --end) {
                        if (*end == '.')
                                --end;
                        if (*end != '0')
                                break;
                        if (end == start)
    a048:	e1540005 	cmp	r4, r5
                                *signp = 0;
    a04c:	059d3028 	ldreq	r3, [sp, #40]
    a050:	05c32000 	strbeq	r2, [r3]
                                break;
                        }
                }
        /* ``"%.3f", (double)-0.0004'' gives you a negative 0. */
        else if (*signp == '-')
                for (;; --end) {
    a054:	e2444001 	sub	r4, r4, #1	; 0x1
                        if (*end == '.')
    a058:	e5d43000 	ldrb	r3, [r4]
    a05c:	e353002e 	cmp	r3, #46	; 0x2e
                                --end;
    a060:	05743001 	ldrbeq	r3, [r4, #-1]!
                        if (*end != '0')
    a064:	e3530030 	cmp	r3, #48	; 0x30
    a068:	0afffff6 	beq	a048 <_ZL5rounddPiPcS0_cS0_+0xb8>
    a06c:	eaffffec 	b	a024 <_ZL5rounddPiPcS0_cS0_+0x94>
round(double fract, int *exp, char *start, char *end, char ch, char *signp)
{
        double tmp;

        if (fract)
        (void)modf(fract * 10, &tmp);
    a070:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    a074:	e1a00006 	mov	r0, r6
    a078:	e1a01007 	mov	r1, r7
    a07c:	e3a02000 	mov	r2, #0	; 0x0
    a080:	e2833709 	add	r3, r3, #2359296	; 0x240000
    a084:	eb001da3 	bl	11718 <__aeabi_dmul>
    a088:	e1a0200d 	mov	r2, sp
    a08c:	eb000bc6 	bl	cfac <modf>
    a090:	eaffffce 	b	9fd0 <_ZL5rounddPiPcS0_cS0_+0x40>
                                --end;
                        if (++*end <= '9')
                                break;
                        *end = '0';
                        if (end == start) {
                                if (exp) {      /* e/E; increment exponent */
    a094:	e3580000 	cmp	r8, #0	; 0x0
                                        *end = '1';
    a098:	13a02031 	movne	r2, #49	; 0x31
    a09c:	15c52000 	strbne	r2, [r5]
                                        ++*exp;
    a0a0:	15983000 	ldrne	r3, [r8]
                                }
                                else {          /* f; add extra digit */
                                *--end = '1';
    a0a4:	03a03031 	moveq	r3, #49	; 0x31
                                break;
                        *end = '0';
                        if (end == start) {
                                if (exp) {      /* e/E; increment exponent */
                                        *end = '1';
                                        ++*exp;
    a0a8:	12833001 	addne	r3, r3, #1	; 0x1
                                }
                                else {          /* f; add extra digit */
                                *--end = '1';
    a0ac:	05453001 	strbeq	r3, [r5, #-1]
                                break;
                        *end = '0';
                        if (end == start) {
                                if (exp) {      /* e/E; increment exponent */
                                        *end = '1';
                                        ++*exp;
    a0b0:	15883000 	strne	r3, [r8]
                                }
                                else {          /* f; add extra digit */
                                *--end = '1';
    a0b4:	02455001 	subeq	r5, r5, #1	; 0x1
    a0b8:	eaffffd9 	b	a024 <_ZL5rounddPiPcS0_cS0_+0x94>
    a0bc:	00000000 	andeq	r0, r0, r0

0000a0c0 <vfnprintf>:
#define ZEROPAD         0x080           /* zero (as opposed to blank) pad */
#define FPT             0x100           /* Floating point number */
#define SIZET           0x200           /* size_t */

externC int 
vfnprintf ( FILE *stream, size_t n, const char *format, va_list arg) __THROW
    a0c0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a0c4:	e24ddfc3 	sub	sp, sp, #780	; 0x30c
            flags&SIZET ? va_arg(arg, size_t) : \
            (unsigned long)va_arg(arg, unsigned int))


        xdigs = NULL;  // stop compiler whinging
        fmt = (char *)format;
    a0c8:	e3a04000 	mov	r4, #0	; 0x0

                                case DEC:
                                        if (!(flags & QUADINT)) {
                                                /* many numbers are 1 digit */
                                                unsigned long v = (unsigned long)_uquad;
                                                while (v >= 10) {
    a0cc:	e28d5f6f 	add	r5, sp, #444	; 0x1bc
            flags&SIZET ? va_arg(arg, size_t) : \
            (unsigned long)va_arg(arg, unsigned int))


        xdigs = NULL;  // stop compiler whinging
        fmt = (char *)format;
    a0d0:	e58d4040 	str	r4, [sp, #64]
#define ZEROPAD         0x080           /* zero (as opposed to blank) pad */
#define FPT             0x100           /* Floating point number */
#define SIZET           0x200           /* size_t */

externC int 
vfnprintf ( FILE *stream, size_t n, const char *format, va_list arg) __THROW
    a0d4:	e58d1030 	str	r1, [sp, #48]
    a0d8:	e58d302c 	str	r3, [sp, #44]
            flags&SIZET ? va_arg(arg, size_t) : \
            (unsigned long)va_arg(arg, unsigned int))


        xdigs = NULL;  // stop compiler whinging
        fmt = (char *)format;
    a0dc:	e58d2058 	str	r2, [sp, #88]
    a0e0:	e58d4050 	str	r4, [sp, #80]

                                case DEC:
                                        if (!(flags & QUADINT)) {
                                                /* many numbers are 1 digit */
                                                unsigned long v = (unsigned long)_uquad;
                                                while (v >= 10) {
    a0e4:	e58d5014 	str	r5, [sp, #20]
#define ZEROPAD         0x080           /* zero (as opposed to blank) pad */
#define FPT             0x100           /* Floating point number */
#define SIZET           0x200           /* size_t */

externC int 
vfnprintf ( FILE *stream, size_t n, const char *format, va_list arg) __THROW
    a0e8:	e1a0a000 	mov	sl, r0
            flags&SIZET ? va_arg(arg, size_t) : \
            (unsigned long)va_arg(arg, unsigned int))


        xdigs = NULL;  // stop compiler whinging
        fmt = (char *)format;
    a0ec:	e59d4058 	ldr	r4, [sp, #88]
    a0f0:	ea000000 	b	a0f8 <vfnprintf+0x38>
		while ((x = ((wc = *fmt) != 0))) {
#else
                while ((x = mbtowc_fn (&wc, fmt, MB_CUR_MAX, &state)) > 0) {
#endif
                        fmt += x;
                        if (wc == '%') {
    a0f4:	e1a04002 	mov	r4, r2
         * Scan the format for conversions (`%' character).
         */
        for (;;) {
                cp = (char *)fmt;
#ifndef CYGINT_LIBC_I18N_MB_REQUIRED
		while ((x = ((wc = *fmt) != 0))) {
    a0f8:	e5d43000 	ldrb	r3, [r4]
    a0fc:	e3530000 	cmp	r3, #0	; 0x0
#else
                while ((x = mbtowc_fn (&wc, fmt, MB_CUR_MAX, &state)) > 0) {
#endif
                        fmt += x;
    a100:	e2842001 	add	r2, r4, #1	; 0x1
         * Scan the format for conversions (`%' character).
         */
        for (;;) {
                cp = (char *)fmt;
#ifndef CYGINT_LIBC_I18N_MB_REQUIRED
		while ((x = ((wc = *fmt) != 0))) {
    a104:	0a0000ab 	beq	a3b8 <vfnprintf+0x2f8>
#else
                while ((x = mbtowc_fn (&wc, fmt, MB_CUR_MAX, &state)) > 0) {
#endif
                        fmt += x;
                        if (wc == '%') {
    a108:	e3530025 	cmp	r3, #37	; 0x25
    a10c:	1afffff8 	bne	a0f4 <vfnprintf+0x34>
    a110:	e3a05001 	mov	r5, #1	; 0x1
                                fmt--;
                                break;
                        }
                }
                if ((y = fmt - cp) != 0) {
    a114:	e59dc058 	ldr	ip, [sp, #88]
    a118:	e054600c 	subs	r6, r4, ip
    a11c:	1a00008e 	bne	a35c <vfnprintf+0x29c>
                        PRINT(cp, y);
                        ret += y;
                }
                if ((x <= 0) || (ret >= (int)n))  // @@@ this check with n isn't good enough
    a120:	e59dc030 	ldr	ip, [sp, #48]
    a124:	e59de040 	ldr	lr, [sp, #64]
    a128:	e3550000 	cmp	r5, #0	; 0x0
    a12c:	115c000e 	cmpne	ip, lr
    a130:	c3a03000 	movgt	r3, #0	; 0x0
    a134:	d3a03001 	movle	r3, #1	; 0x1
    a138:	da00007e 	ble	a338 <vfnprintf+0x278>
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a13c:	e5cd3307 	strb	r3, [sp, #775]
    a140:	e58d303c 	str	r3, [sp, #60]
    a144:	e3e00000 	mvn	r0, #0	; 0x0
    a148:	e5d42001 	ldrb	r2, [r4, #1]
    a14c:	e59d502c 	ldr	r5, [sp, #44]
    a150:	e58d3044 	str	r3, [sp, #68]
    a154:	e58d005c 	str	r0, [sp, #92]
                        PRINT(cp, y);
                        ret += y;
                }
                if ((x <= 0) || (ret >= (int)n))  // @@@ this check with n isn't good enough
                        goto done;
                fmt++;          /* skip over '%' */
    a158:	e284c001 	add	ip, r4, #1	; 0x1
                        /* FALLTHROUGH */
                case '-':
                        flags |= LADJUST;
                        goto rflag;
                case '+':
                        sign = '+';
    a15c:	e3a0e02b 	mov	lr, #43	; 0x2b
                         * ``If the space and + flags both appear, the space
                         * flag will be ignored.''
                         *      -- ANSI X3J11
                         */
                        if (!sign)
                                sign = ' ';
    a160:	e3a04020 	mov	r4, #32	; 0x20
#endif
                width = 0;
                prec = -1;
                sign = '\0';

rflag:          ch = *fmt++;
    a164:	e28cc001 	add	ip, ip, #1	; 0x1
    a168:	e58d2038 	str	r2, [sp, #56]
    a16c:	e58dc058 	str	ip, [sp, #88]
reswitch:       switch (ch) {
    a170:	e59d2038 	ldr	r2, [sp, #56]
    a174:	e2423020 	sub	r3, r2, #32	; 0x20
    a178:	e353005a 	cmp	r3, #90	; 0x5a
    a17c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    a180:	ea000136 	b	a660 <vfnprintf+0x5a0>
    a184:	0000a6ac 	.word	0x0000a6ac
    a188:	0000a660 	.word	0x0000a660
    a18c:	0000a660 	.word	0x0000a660
    a190:	0000a6d0 	.word	0x0000a6d0
    a194:	0000a660 	.word	0x0000a660
    a198:	0000a660 	.word	0x0000a660
    a19c:	0000a660 	.word	0x0000a660
    a1a0:	0000a660 	.word	0x0000a660
    a1a4:	0000a660 	.word	0x0000a660
    a1a8:	0000a660 	.word	0x0000a660
    a1ac:	0000a6f0 	.word	0x0000a6f0
    a1b0:	0000a784 	.word	0x0000a784
    a1b4:	0000a660 	.word	0x0000a660
    a1b8:	0000a79c 	.word	0x0000a79c
    a1bc:	0000a7bc 	.word	0x0000a7bc
    a1c0:	0000a660 	.word	0x0000a660
    a1c4:	0000a82c 	.word	0x0000a82c
    a1c8:	0000a84c 	.word	0x0000a84c
    a1cc:	0000a84c 	.word	0x0000a84c
    a1d0:	0000a84c 	.word	0x0000a84c
    a1d4:	0000a84c 	.word	0x0000a84c
    a1d8:	0000a84c 	.word	0x0000a84c
    a1dc:	0000a84c 	.word	0x0000a84c
    a1e0:	0000a84c 	.word	0x0000a84c
    a1e4:	0000a84c 	.word	0x0000a84c
    a1e8:	0000a84c 	.word	0x0000a84c
    a1ec:	0000a660 	.word	0x0000a660
    a1f0:	0000a660 	.word	0x0000a660
    a1f4:	0000a660 	.word	0x0000a660
    a1f8:	0000a660 	.word	0x0000a660
    a1fc:	0000a660 	.word	0x0000a660
    a200:	0000a660 	.word	0x0000a660
    a204:	0000a660 	.word	0x0000a660
    a208:	0000a660 	.word	0x0000a660
    a20c:	0000a660 	.word	0x0000a660
    a210:	0000a660 	.word	0x0000a660
    a214:	0000a5d0 	.word	0x0000a5d0
    a218:	0000a890 	.word	0x0000a890
    a21c:	0000a660 	.word	0x0000a660
    a220:	0000a890 	.word	0x0000a890
    a224:	0000a660 	.word	0x0000a660
    a228:	0000a660 	.word	0x0000a660
    a22c:	0000a660 	.word	0x0000a660
    a230:	0000a660 	.word	0x0000a660
    a234:	0000a9d8 	.word	0x0000a9d8
    a238:	0000a660 	.word	0x0000a660
    a23c:	0000a660 	.word	0x0000a660
    a240:	0000a60c 	.word	0x0000a60c
    a244:	0000a660 	.word	0x0000a660
    a248:	0000a660 	.word	0x0000a660
    a24c:	0000a660 	.word	0x0000a660
    a250:	0000a660 	.word	0x0000a660
    a254:	0000a660 	.word	0x0000a660
    a258:	0000a3c0 	.word	0x0000a3c0
    a25c:	0000a660 	.word	0x0000a660
    a260:	0000a660 	.word	0x0000a660
    a264:	0000a9f8 	.word	0x0000a9f8
    a268:	0000a660 	.word	0x0000a660
    a26c:	0000a660 	.word	0x0000a660
    a270:	0000a660 	.word	0x0000a660
    a274:	0000a660 	.word	0x0000a660
    a278:	0000a660 	.word	0x0000a660
    a27c:	0000a660 	.word	0x0000a660
    a280:	0000a660 	.word	0x0000a660
    a284:	0000a660 	.word	0x0000a660
    a288:	0000a660 	.word	0x0000a660
    a28c:	0000a660 	.word	0x0000a660
    a290:	0000aa04 	.word	0x0000aa04
    a294:	0000a5dc 	.word	0x0000a5dc
    a298:	0000a890 	.word	0x0000a890
    a29c:	0000a890 	.word	0x0000a890
    a2a0:	0000a890 	.word	0x0000a890
    a2a4:	0000aa80 	.word	0x0000aa80
    a2a8:	0000a5dc 	.word	0x0000a5dc
    a2ac:	0000a660 	.word	0x0000a660
    a2b0:	0000a660 	.word	0x0000a660
    a2b4:	0000aa24 	.word	0x0000aa24
    a2b8:	0000a660 	.word	0x0000a660
    a2bc:	0000aa50 	.word	0x0000aa50
    a2c0:	0000a618 	.word	0x0000a618
    a2c4:	0000aa94 	.word	0x0000aa94
    a2c8:	0000a640 	.word	0x0000a640
    a2cc:	0000a660 	.word	0x0000a660
    a2d0:	0000aacc 	.word	0x0000aacc
    a2d4:	0000a660 	.word	0x0000a660
    a2d8:	0000a3cc 	.word	0x0000a3cc
    a2dc:	0000a660 	.word	0x0000a660
    a2e0:	0000a660 	.word	0x0000a660
    a2e4:	0000a714 	.word	0x0000a714
    a2e8:	0000a660 	.word	0x0000a660
    a2ec:	0000a764 	.word	0x0000a764
                PRINT(cp, size);
                ret += size;

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
    a2f0:	e1540006 	cmp	r4, r6
    a2f4:	31a02004 	movcc	r2, r4
    a2f8:	21a02006 	movcs	r2, r6
    a2fc:	e58d2300 	str	r2, [sp, #768]
    a300:	e59ac000 	ldr	ip, [sl]
    a304:	e1a0000a 	mov	r0, sl
    a308:	e59f1f64 	ldr	r1, [pc, #3940]	; b274 <vfnprintf+0x11b4>
    a30c:	e1a03007 	mov	r3, r7
    a310:	e1a0e00f 	mov	lr, pc
    a314:	e59cf008 	ldr	pc, [ip, #8]
    a318:	e3500000 	cmp	r0, #0	; 0x0
    a31c:	1a000005 	bne	a338 <vfnprintf+0x278>
    a320:	e59d3300 	ldr	r3, [sp, #768]
    a324:	e1540003 	cmp	r4, r3
    a328:	9a0002c8 	bls	ae50 <vfnprintf+0xd90>
    a32c:	e59d4040 	ldr	r4, [sp, #64]
    a330:	e0834004 	add	r4, r3, r4
    a334:	e58d4040 	str	r4, [sp, #64]
                }

        }
done:
error:
        return (((Cyg_OutputStream *) stream)->get_error() ? EOF : ret);
    a338:	e1a0000a 	mov	r0, sl
    a33c:	e59a3000 	ldr	r3, [sl]
    a340:	e1a0e00f 	mov	lr, pc
    a344:	e593f00c 	ldr	pc, [r3, #12]
    a348:	e3500000 	cmp	r0, #0	; 0x0
        /* NOTREACHED */
}
    a34c:	e59d0040 	ldr	r0, [sp, #64]
    a350:	13e00000 	mvnne	r0, #0	; 0x0
    a354:	e28ddfc3 	add	sp, sp, #780	; 0x30c
    a358:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                fmt--;
                                break;
                        }
                }
                if ((y = fmt - cp) != 0) {
                        PRINT(cp, y);
    a35c:	e59de030 	ldr	lr, [sp, #48]
    a360:	e59d0040 	ldr	r0, [sp, #64]
    a364:	e24e2001 	sub	r2, lr, #1	; 0x1
    a368:	e0602002 	rsb	r2, r0, r2
    a36c:	e1560002 	cmp	r6, r2
    a370:	31a02006 	movcc	r2, r6
    a374:	e28d7fc2 	add	r7, sp, #776	; 0x308
    a378:	e5272008 	str	r2, [r7, #-8]!
    a37c:	e1a0100c 	mov	r1, ip
    a380:	e1a03007 	mov	r3, r7
    a384:	e59ac000 	ldr	ip, [sl]
    a388:	e1a0000a 	mov	r0, sl
    a38c:	e1a0e00f 	mov	lr, pc
    a390:	e59cf008 	ldr	pc, [ip, #8]
    a394:	e3500000 	cmp	r0, #0	; 0x0
    a398:	1affffe6 	bne	a338 <vfnprintf+0x278>
    a39c:	e59d3300 	ldr	r3, [sp, #768]
    a3a0:	e1560003 	cmp	r6, r3
    a3a4:	8a0005bf 	bhi	baa8 <vfnprintf+0x19e8>
                        ret += y;
    a3a8:	e59d2040 	ldr	r2, [sp, #64]
    a3ac:	e0822006 	add	r2, r2, r6
    a3b0:	e58d2040 	str	r2, [sp, #64]
    a3b4:	eaffff59 	b	a120 <vfnprintf+0x60>
         * Scan the format for conversions (`%' character).
         */
        for (;;) {
                cp = (char *)fmt;
#ifndef CYGINT_LIBC_I18N_MB_REQUIRED
		while ((x = ((wc = *fmt) != 0))) {
    a3b8:	e1a05003 	mov	r5, r3
    a3bc:	eaffff54 	b	a114 <vfnprintf+0x54>
                        } else
                                size = strlen(cp);
                        sign = '\0';
                        break;
                case 'U':
                        flags |= LONGINT;
    a3c0:	e59d103c 	ldr	r1, [sp, #60]
    a3c4:	e3811010 	orr	r1, r1, #16	; 0x10
    a3c8:	e58d103c 	str	r1, [sp, #60]
                        /*FALLTHROUGH*/
                case 'u':
                        _uquad = UARG();
    a3cc:	e59d203c 	ldr	r2, [sp, #60]
    a3d0:	e3120020 	tst	r2, #32	; 0x20
    a3d4:	0a000322 	beq	b064 <vfnprintf+0xfa4>
    a3d8:	e2853007 	add	r3, r5, #7	; 0x7
    a3dc:	e3c33007 	bic	r3, r3, #7	; 0x7
    a3e0:	e89300c0 	ldm	r3, {r6, r7}
    a3e4:	e2833008 	add	r3, r3, #8	; 0x8
    a3e8:	e58d302c 	str	r3, [sp, #44]
    a3ec:	e3a0c001 	mov	ip, #1	; 0x1
                        /* leading 0x/X only if non-zero */
                        if (flags & ALT && _uquad != 0)
                                flags |= HEXPREFIX;

                        /* unsigned conversions */
nosign:                 sign = '\0';
    a3f0:	e3a0e000 	mov	lr, #0	; 0x0
    a3f4:	e5cde307 	strb	lr, [sp, #775]
                        /*
                         * ``... diouXx conversions ... if a precision is
                         * specified, the 0 flag will be ignored.''
                         *      -- ANSI X3J11
                         */
number:                 if ((dprec = prec) >= 0)
    a3f8:	e59d005c 	ldr	r0, [sp, #92]
    a3fc:	e3500000 	cmp	r0, #0	; 0x0
    a400:	ba00000c 	blt	a438 <vfnprintf+0x378>
                         * ``The result of converting a zero value with an
                         * explicit precision of zero is no characters.''
                         *      -- ANSI X3J11
                         */
                        cp = buf + BUF;
                        if (_uquad != 0 || prec != 0) {
    a404:	e1961007 	orrs	r1, r6, r7
    a408:	e59d405c 	ldr	r4, [sp, #92]
                         * ``... diouXx conversions ... if a precision is
                         * specified, the 0 flag will be ignored.''
                         *      -- ANSI X3J11
                         */
number:                 if ((dprec = prec) >= 0)
                                flags &= ~ZEROPAD;
    a40c:	e59d203c 	ldr	r2, [sp, #60]
                         * ``The result of converting a zero value with an
                         * explicit precision of zero is no characters.''
                         *      -- ANSI X3J11
                         */
                        cp = buf + BUF;
                        if (_uquad != 0 || prec != 0) {
    a410:	e3a03000 	mov	r3, #0	; 0x0
    a414:	13a03001 	movne	r3, #1	; 0x1
    a418:	e3540000 	cmp	r4, #0	; 0x0
    a41c:	13833001 	orrne	r3, r3, #1	; 0x1
    a420:	e21300ff 	ands	r0, r3, #255	; 0xff
                         * ``... diouXx conversions ... if a precision is
                         * specified, the 0 flag will be ignored.''
                         *      -- ANSI X3J11
                         */
number:                 if ((dprec = prec) >= 0)
                                flags &= ~ZEROPAD;
    a424:	e3c22080 	bic	r2, r2, #128	; 0x80
    a428:	e58d203c 	str	r2, [sp, #60]
                                        break;

                                default:
                                        cp = (char *)"bug in vfprintf: bad base";
                                        size = strlen(cp);
                                        goto skipsize;
    a42c:	01a0b000 	moveq	fp, r0
    a430:	028d9f6f 	addeq	r9, sp, #444	; 0x1bc
                         * ``The result of converting a zero value with an
                         * explicit precision of zero is no characters.''
                         *      -- ANSI X3J11
                         */
                        cp = buf + BUF;
                        if (_uquad != 0 || prec != 0) {
    a434:	0a000058 	beq	a59c <vfnprintf+0x4dc>
                                /*
                                 * Unsigned mod is hard, and unsigned mod
                                 * by a constant is easier than that by
                                 * a variable; hence this switch.
                                 */
                                switch (base) {
    a438:	e35c0001 	cmp	ip, #1	; 0x1
    a43c:	0a0002df 	beq	afc0 <vfnprintf+0xf00>
    a440:	328d9f6f 	addcc	r9, sp, #444	; 0x1bc
    a444:	3a00003e 	bcc	a544 <vfnprintf+0x484>
    a448:	e35c0002 	cmp	ip, #2	; 0x2
    a44c:	0a0002ca 	beq	af7c <vfnprintf+0xebc>
                                                _uquad >>= 4;
                                        } while (_uquad);
                                        break;

                                default:
                                        cp = (char *)"bug in vfprintf: bad base";
    a450:	e3a00000 	mov	r0, #0	; 0x0
    a454:	e3a0b019 	mov	fp, #25	; 0x19
    a458:	e59d805c 	ldr	r8, [sp, #92]
    a45c:	e59f9e14 	ldr	r9, [pc, #3604]	; b278 <vfnprintf+0x11b8>
    a460:	e58d0054 	str	r0, [sp, #84]
    a464:	e1a0200b 	mov	r2, fp
    a468:	e28d7c03 	add	r7, sp, #768	; 0x300
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
    a46c:	e5dd3307 	ldrb	r3, [sp, #775]
    a470:	e3530000 	cmp	r3, #0	; 0x0
                        fieldsz++;
    a474:	12822001 	addne	r2, r2, #1	; 0x1
    a478:	158d2048 	strne	r2, [sp, #72]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
    a47c:	0a000050 	beq	a5c4 <vfnprintf+0x504>
                        fieldsz++;
                else if (flags & HEXPREFIX)
                        fieldsz+= 2;
    a480:	e59d0048 	ldr	r0, [sp, #72]
                realsz = dprec > fieldsz ? dprec : fieldsz;

                /* right-adjusting blank padding */
                if ((flags & (LADJUST|ZEROPAD)) == 0) {
    a484:	e59d103c 	ldr	r1, [sp, #60]
                fieldsz = size;
#endif
                if (sign)
                        fieldsz++;
                else if (flags & HEXPREFIX)
                        fieldsz+= 2;
    a488:	e1500008 	cmp	r0, r8
    a48c:	b1a00008 	movlt	r0, r8
                realsz = dprec > fieldsz ? dprec : fieldsz;

                /* right-adjusting blank padding */
                if ((flags & (LADJUST|ZEROPAD)) == 0) {
    a490:	e2111084 	ands	r1, r1, #132	; 0x84
    a494:	159d2030 	ldrne	r2, [sp, #48]
    a498:	12422001 	subne	r2, r2, #1	; 0x1
                fieldsz = size;
#endif
                if (sign)
                        fieldsz++;
                else if (flags & HEXPREFIX)
                        fieldsz+= 2;
    a49c:	e58d004c 	str	r0, [sp, #76]
                realsz = dprec > fieldsz ? dprec : fieldsz;

                /* right-adjusting blank padding */
                if ((flags & (LADJUST|ZEROPAD)) == 0) {
    a4a0:	e58d1034 	str	r1, [sp, #52]
    a4a4:	158d2074 	strne	r2, [sp, #116]
    a4a8:	1a0001bc 	bne	aba0 <vfnprintf+0xae0>
                    if (width - realsz > 0) {
    a4ac:	e59d3044 	ldr	r3, [sp, #68]
    a4b0:	e59d404c 	ldr	r4, [sp, #76]
    a4b4:	e0646003 	rsb	r6, r4, r3
    a4b8:	e3560000 	cmp	r6, #0	; 0x0
    a4bc:	d59d5030 	ldrle	r5, [sp, #48]
    a4c0:	d2455001 	suble	r5, r5, #1	; 0x1
    a4c4:	d58d5074 	strle	r5, [sp, #116]
    a4c8:	da0001b4 	ble	aba0 <vfnprintf+0xae0>
                        PAD(width - realsz, blanks);
    a4cc:	e3560010 	cmp	r6, #16	; 0x10
    a4d0:	da000199 	ble	ab3c <vfnprintf+0xa7c>
    a4d4:	e59d0030 	ldr	r0, [sp, #48]
    a4d8:	e59d1040 	ldr	r1, [sp, #64]
    a4dc:	e2400001 	sub	r0, r0, #1	; 0x1
    a4e0:	e0611000 	rsb	r1, r1, r0
    a4e4:	e1a05001 	mov	r5, r1
    a4e8:	e58d0074 	str	r0, [sp, #116]
    a4ec:	e58d1070 	str	r1, [sp, #112]
    a4f0:	e3550010 	cmp	r5, #16	; 0x10
    a4f4:	23a05010 	movcs	r5, #16	; 0x10
    a4f8:	e1a04006 	mov	r4, r6
    a4fc:	ea000004 	b	a514 <vfnprintf+0x454>
    a500:	e59d3300 	ldr	r3, [sp, #768]
    a504:	e353000f 	cmp	r3, #15	; 0xf
    a508:	9a000297 	bls	af6c <vfnprintf+0xeac>
    a50c:	e3540010 	cmp	r4, #16	; 0x10
    a510:	da000190 	ble	ab58 <vfnprintf+0xa98>
    a514:	e58d5300 	str	r5, [sp, #768]
    a518:	e59ac000 	ldr	ip, [sl]
    a51c:	e1a0000a 	mov	r0, sl
    a520:	e59f1d54 	ldr	r1, [pc, #3412]	; b27c <vfnprintf+0x11bc>
    a524:	e1a02005 	mov	r2, r5
    a528:	e1a03007 	mov	r3, r7
    a52c:	e1a0e00f 	mov	lr, pc
    a530:	e59cf008 	ldr	pc, [ip, #8]
    a534:	e3500000 	cmp	r0, #0	; 0x0
    a538:	e2444010 	sub	r4, r4, #16	; 0x10
    a53c:	0affffef 	beq	a500 <vfnprintf+0x440>
    a540:	eaffff7c 	b	a338 <vfnprintf+0x278>
                                 */
                                switch (base) {
                                case OCT:
                                        do {
                                                *--cp = to_char(_uquad & 7);
                                                _uquad >>= 3;
    a544:	e1a021a6 	lsr	r2, r6, #3
    a548:	e1822e87 	orr	r2, r2, r7, lsl #29
    a54c:	e1a011a7 	lsr	r1, r7, #3
    a550:	e1a03002 	mov	r3, r2
                                 * a variable; hence this switch.
                                 */
                                switch (base) {
                                case OCT:
                                        do {
                                                *--cp = to_char(_uquad & 7);
    a554:	e2062007 	and	r2, r6, #7	; 0x7
    a558:	e2822030 	add	r2, r2, #48	; 0x30
                                 * by a constant is easier than that by
                                 * a variable; hence this switch.
                                 */
                                switch (base) {
                                case OCT:
                                        do {
    a55c:	e1935001 	orrs	r5, r3, r1
                                                *--cp = to_char(_uquad & 7);
                                                _uquad >>= 3;
    a560:	e1a04001 	mov	r4, r1
    a564:	e1a06003 	mov	r6, r3
    a568:	e1a07001 	mov	r7, r1
                                 * a variable; hence this switch.
                                 */
                                switch (base) {
                                case OCT:
                                        do {
                                                *--cp = to_char(_uquad & 7);
    a56c:	e5692001 	strb	r2, [r9, #-1]!
                                 * by a constant is easier than that by
                                 * a variable; hence this switch.
                                 */
                                switch (base) {
                                case OCT:
                                        do {
    a570:	1afffff3 	bne	a544 <vfnprintf+0x484>
                                                *--cp = to_char(_uquad & 7);
                                                _uquad >>= 3;
                                        } while (_uquad);
                                        /* handle octal leading 0 */
                                        if (flags & ALT && *cp != '0')
    a574:	e59dc03c 	ldr	ip, [sp, #60]
    a578:	e31c0001 	tst	ip, #1	; 0x1
    a57c:	0a00028c 	beq	afb4 <vfnprintf+0xef4>
    a580:	e3520030 	cmp	r2, #48	; 0x30
                                                *--cp = '0';
    a584:	13a03030 	movne	r3, #48	; 0x30
    a588:	15693001 	strbne	r3, [r9, #-1]!
                                        do {
                                                *--cp = to_char(_uquad & 7);
                                                _uquad >>= 3;
                                        } while (_uquad);
                                        /* handle octal leading 0 */
                                        if (flags & ALT && *cp != '0')
    a58c:	059d0014 	ldreq	r0, [sp, #20]
                                                *--cp = '0';
    a590:	159d1014 	ldrne	r1, [sp, #20]
                                        do {
                                                *--cp = to_char(_uquad & 7);
                                                _uquad >>= 3;
                                        } while (_uquad);
                                        /* handle octal leading 0 */
                                        if (flags & ALT && *cp != '0')
    a594:	0069b000 	rsbeq	fp, r9, r0
                                                *--cp = '0';
    a598:	1069b001 	rsbne	fp, r9, r1
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
    a59c:	e5dd3307 	ldrb	r3, [sp, #775]
                                        break;

                                default:
                                        cp = (char *)"bug in vfprintf: bad base";
                                        size = strlen(cp);
                                        goto skipsize;
    a5a0:	e1a0200b 	mov	r2, fp
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
    a5a4:	e3530000 	cmp	r3, #0	; 0x0
                                        break;

                                default:
                                        cp = (char *)"bug in vfprintf: bad base";
                                        size = strlen(cp);
                                        goto skipsize;
    a5a8:	e3a01000 	mov	r1, #0	; 0x0
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
                        fieldsz++;
    a5ac:	12822001 	addne	r2, r2, #1	; 0x1
                                        break;

                                default:
                                        cp = (char *)"bug in vfprintf: bad base";
                                        size = strlen(cp);
                                        goto skipsize;
    a5b0:	e59d805c 	ldr	r8, [sp, #92]
    a5b4:	e58d1054 	str	r1, [sp, #84]
    a5b8:	e28d7c03 	add	r7, sp, #768	; 0x300
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
                        fieldsz++;
    a5bc:	158d2048 	strne	r2, [sp, #72]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fieldsz = size + fpprec;
#else
                fieldsz = size;
#endif
                if (sign)
    a5c0:	1affffae 	bne	a480 <vfnprintf+0x3c0>
                        fieldsz++;
    a5c4:	e59d502c 	ldr	r5, [sp, #44]
    a5c8:	e58d2048 	str	r2, [sp, #72]
    a5cc:	ea00002f 	b	a690 <vfnprintf+0x5d0>
                        *(cp = buf) = va_arg(arg, int);
                        size = 1;
                        sign = '\0';
                        break;
                case 'D':
                        flags |= LONGINT;
    a5d0:	e59d403c 	ldr	r4, [sp, #60]
    a5d4:	e3844010 	orr	r4, r4, #16	; 0x10
    a5d8:	e58d403c 	str	r4, [sp, #60]
                        /*FALLTHROUGH*/
                case 'd':
                case 'i':
                        _uquad = SARG();
    a5dc:	e59dc03c 	ldr	ip, [sp, #60]
    a5e0:	e31c0020 	tst	ip, #32	; 0x20
    a5e4:	0a0002c9 	beq	b110 <vfnprintf+0x1050>
    a5e8:	e2853007 	add	r3, r5, #7	; 0x7
    a5ec:	e3c33007 	bic	r3, r3, #7	; 0x7
    a5f0:	e89300c0 	ldm	r3, {r6, r7}
    a5f4:	e2833008 	add	r3, r3, #8	; 0x8
    a5f8:	e58d302c 	str	r3, [sp, #44]
#ifndef _NO_LONGLONG
                        if ((quad_t)_uquad < 0)
    a5fc:	e3570000 	cmp	r7, #0	; 0x0
    a600:	ba000147 	blt	ab24 <vfnprintf+0xa64>
                        if ((long) _uquad < 0)
#endif
                        {

                                _uquad = -_uquad;
                                sign = '-';
    a604:	e3a0c001 	mov	ip, #1	; 0x1
    a608:	eaffff7a 	b	a3f8 <vfnprintf+0x338>
                                *va_arg(arg, size_t *) = ret;
                        else
                                *va_arg(arg, int *) = ret;
                        continue;       /* no output */
                case 'O':
                        flags |= LONGINT;
    a60c:	e59d303c 	ldr	r3, [sp, #60]
    a610:	e3833010 	orr	r3, r3, #16	; 0x10
    a614:	e58d303c 	str	r3, [sp, #60]
                        /*FALLTHROUGH*/
                case 'o':
                        _uquad = UARG();
    a618:	e59d403c 	ldr	r4, [sp, #60]
    a61c:	e214c020 	ands	ip, r4, #32	; 0x20
    a620:	0a0002a5 	beq	b0bc <vfnprintf+0xffc>
    a624:	e2853007 	add	r3, r5, #7	; 0x7
    a628:	e3c33007 	bic	r3, r3, #7	; 0x7
    a62c:	e89300c0 	ldm	r3, {r6, r7}
    a630:	e2833008 	add	r3, r3, #8	; 0x8
    a634:	e58d302c 	str	r3, [sp, #44]
    a638:	e3a0c000 	mov	ip, #0	; 0x0
    a63c:	eaffff6b 	b	a3f0 <vfnprintf+0x330>
                        } else {
                                flags |= LONGINT;
                        }
                        goto rflag;
                case 'q':
                        flags |= QUADINT;
    a640:	e59d203c 	ldr	r2, [sp, #60]
    a644:	e3822020 	orr	r2, r2, #32	; 0x20
    a648:	e58d203c 	str	r2, [sp, #60]
    a64c:	e59dc058 	ldr	ip, [sp, #88]
    a650:	e1a03005 	mov	r3, r5
    a654:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a658:	e1a05003 	mov	r5, r3
    a65c:	eafffec0 	b	a164 <vfnprintf+0xa4>
                        break;
                case 'z':
                        flags |= SIZET;
                        goto rflag;
                default:        /* "%?" prints ?, unless ? is NUL */
                        if (ch == '\0')
    a660:	e59d3038 	ldr	r3, [sp, #56]
    a664:	e3530000 	cmp	r3, #0	; 0x0
    a668:	0affff32 	beq	a338 <vfnprintf+0x278>
                                goto done;
                        /* pretend it was %c with argument ch */
                        cp = buf;
                        *cp = ch;
                        size = 1;
                        sign = '\0';
    a66c:	e3a04000 	mov	r4, #0	; 0x0
                default:        /* "%?" prints ?, unless ? is NUL */
                        if (ch == '\0')
                                goto done;
                        /* pretend it was %c with argument ch */
                        cp = buf;
                        *cp = ch;
    a670:	e5cd3078 	strb	r3, [sp, #120]
                        size = 1;
                        sign = '\0';
    a674:	e5cd4307 	strb	r4, [sp, #775]
    a678:	e28d9078 	add	r9, sp, #120	; 0x78
    a67c:	e3a0b001 	mov	fp, #1	; 0x1
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
                        for (; prec--; *t++ = '0');
                else if (dotrim) {
                        while (t > startp && *--t == '0');
                        if (*t != '.')
    a680:	e3a08000 	mov	r8, #0	; 0x0
    a684:	e58db048 	str	fp, [sp, #72]
    a688:	e58d8054 	str	r8, [sp, #84]
    a68c:	e28d7c03 	add	r7, sp, #768	; 0x300
#else
                fieldsz = size;
#endif
                if (sign)
                        fieldsz++;
                else if (flags & HEXPREFIX)
    a690:	e59dc03c 	ldr	ip, [sp, #60]
    a694:	e31c0002 	tst	ip, #2	; 0x2
                        fieldsz+= 2;
    a698:	159de048 	ldrne	lr, [sp, #72]
    a69c:	128ee002 	addne	lr, lr, #2	; 0x2
    a6a0:	158de048 	strne	lr, [sp, #72]
    a6a4:	e58d502c 	str	r5, [sp, #44]
    a6a8:	eaffff74 	b	a480 <vfnprintf+0x3c0>
                        /*
                         * ``If the space and + flags both appear, the space
                         * flag will be ignored.''
                         *      -- ANSI X3J11
                         */
                        if (!sign)
    a6ac:	e5dd3307 	ldrb	r3, [sp, #775]
    a6b0:	e3530000 	cmp	r3, #0	; 0x0
    a6b4:	1a00030d 	bne	b2f0 <vfnprintf+0x1230>
                                sign = ' ';
    a6b8:	e5cd4307 	strb	r4, [sp, #775]
    a6bc:	e59dc058 	ldr	ip, [sp, #88]
    a6c0:	e1a03005 	mov	r3, r5
    a6c4:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a6c8:	e1a05003 	mov	r5, r3
    a6cc:	eafffea4 	b	a164 <vfnprintf+0xa4>
                         */
                        if (!sign)
                                sign = ' ';
                        goto rflag;
                case '#':
                        flags |= ALT;
    a6d0:	e59d303c 	ldr	r3, [sp, #60]
    a6d4:	e3833001 	orr	r3, r3, #1	; 0x1
    a6d8:	e58d303c 	str	r3, [sp, #60]
    a6dc:	e59dc058 	ldr	ip, [sp, #88]
    a6e0:	e1a03005 	mov	r3, r5
    a6e4:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a6e8:	e1a05003 	mov	r5, r3
    a6ec:	eafffe9c 	b	a164 <vfnprintf+0xa4>
                         * ``A negative field width argument is taken as a
                         * - flag followed by a positive field width.''
                         *      -- ANSI X3J11
                         * They don't exclude field widths read from args.
                         */
                        if ((width = va_arg(arg, int)) >= 0)
    a6f0:	e595c000 	ldr	ip, [r5]
    a6f4:	e35c0000 	cmp	ip, #0	; 0x0
    a6f8:	e58dc044 	str	ip, [sp, #68]
    a6fc:	e2853004 	add	r3, r5, #4	; 0x4
    a700:	ba000491 	blt	b94c <vfnprintf+0x188c>
                case 'L':
                        flags |= LONGDBL;
                        goto rflag;
#endif
                case 'h':
                        flags |= SHORTINT;
    a704:	e59dc058 	ldr	ip, [sp, #88]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a708:	e1a05003 	mov	r5, r3
                case 'L':
                        flags |= LONGDBL;
                        goto rflag;
#endif
                case 'h':
                        flags |= SHORTINT;
    a70c:	e5dc2000 	ldrb	r2, [ip]
    a710:	eafffe93 	b	a164 <vfnprintf+0xa4>
                        goto nosign;
                case 'X':
                        xdigs = (char *)"0123456789ABCDEF";
                        goto hex;
                case 'x':
                        xdigs = (char *)"0123456789abcdef";
    a714:	e59f0b64 	ldr	r0, [pc, #2916]	; b280 <vfnprintf+0x11c0>
    a718:	e58d0050 	str	r0, [sp, #80]
hex:                    _uquad = UARG();
    a71c:	e59d103c 	ldr	r1, [sp, #60]
    a720:	e3110020 	tst	r1, #32	; 0x20
    a724:	0a00028d 	beq	b160 <vfnprintf+0x10a0>
    a728:	e2853007 	add	r3, r5, #7	; 0x7
    a72c:	e3c33007 	bic	r3, r3, #7	; 0x7
    a730:	e89300c0 	ldm	r3, {r6, r7}
    a734:	e2833008 	add	r3, r3, #8	; 0x8
    a738:	e58d302c 	str	r3, [sp, #44]
                        base = HEX;
                        /* leading 0x/X only if non-zero */
                        if (flags & ALT && _uquad != 0)
    a73c:	e59d503c 	ldr	r5, [sp, #60]
    a740:	e3150001 	tst	r5, #1	; 0x1
    a744:	0a000004 	beq	a75c <vfnprintf+0x69c>
    a748:	e196c007 	orrs	ip, r6, r7
                                flags |= HEXPREFIX;
    a74c:	13855002 	orrne	r5, r5, #2	; 0x2
    a750:	158d503c 	strne	r5, [sp, #60]
    a754:	13a0c002 	movne	ip, #2	; 0x2
                case 'x':
                        xdigs = (char *)"0123456789abcdef";
hex:                    _uquad = UARG();
                        base = HEX;
                        /* leading 0x/X only if non-zero */
                        if (flags & ALT && _uquad != 0)
    a758:	1affff24 	bne	a3f0 <vfnprintf+0x330>
                                flags |= HEXPREFIX;

                        /* unsigned conversions */
nosign:                 sign = '\0';
    a75c:	e3a0c002 	mov	ip, #2	; 0x2
    a760:	eaffff22 	b	a3f0 <vfnprintf+0x330>
                        }
                        size = buf + BUF - cp;
                skipsize:
                        break;
                case 'z':
                        flags |= SIZET;
    a764:	e59d203c 	ldr	r2, [sp, #60]
    a768:	e3822c02 	orr	r2, r2, #512	; 0x200
    a76c:	e58d203c 	str	r2, [sp, #60]
    a770:	e59dc058 	ldr	ip, [sp, #88]
    a774:	e1a03005 	mov	r3, r5
    a778:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a77c:	e1a05003 	mov	r5, r3
    a780:	eafffe77 	b	a164 <vfnprintf+0xa4>
                        /* FALLTHROUGH */
                case '-':
                        flags |= LADJUST;
                        goto rflag;
                case '+':
                        sign = '+';
    a784:	e5cde307 	strb	lr, [sp, #775]
    a788:	e59dc058 	ldr	ip, [sp, #88]
    a78c:	e1a03005 	mov	r3, r5
    a790:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a794:	e1a05003 	mov	r5, r3
    a798:	eafffe71 	b	a164 <vfnprintf+0xa4>

rflag:          ch = *fmt++;
reswitch:       switch (ch) {
    a79c:	e1a03005 	mov	r3, r5
                        if ((width = va_arg(arg, int)) >= 0)
                                goto rflag;
                        width = -width;
                        /* FALLTHROUGH */
                case '-':
                        flags |= LADJUST;
    a7a0:	e59d103c 	ldr	r1, [sp, #60]
    a7a4:	e3811004 	orr	r1, r1, #4	; 0x4
    a7a8:	e58d103c 	str	r1, [sp, #60]
    a7ac:	e59dc058 	ldr	ip, [sp, #88]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a7b0:	e1a05003 	mov	r5, r3
                        if ((width = va_arg(arg, int)) >= 0)
                                goto rflag;
                        width = -width;
                        /* FALLTHROUGH */
                case '-':
                        flags |= LADJUST;
    a7b4:	e5dc2000 	ldrb	r2, [ip]
    a7b8:	eafffe69 	b	a164 <vfnprintf+0xa4>
                        goto rflag;
                case '+':
                        sign = '+';
                        goto rflag;
                case '.':
                        if ((ch = *fmt++) == '*') {
    a7bc:	e59dc058 	ldr	ip, [sp, #88]
    a7c0:	e4dc2001 	ldrb	r2, [ip], #1
    a7c4:	e352002a 	cmp	r2, #42	; 0x2a
    a7c8:	e58d2038 	str	r2, [sp, #56]
    a7cc:	0a00061d 	beq	c048 <HAL_BREAKINST_THUMB+0x18a>
                                x = va_arg(arg, int);
                                prec = x < 0 ? -1 : x;
                                goto rflag;
                        }
                        x = 0;
                        while (is_digit(ch)) {
    a7d0:	e2420030 	sub	r0, r2, #48	; 0x30
    a7d4:	e3500009 	cmp	r0, #9	; 0x9
    a7d8:	83a03000 	movhi	r3, #0	; 0x0
    a7dc:	858d305c 	strhi	r3, [sp, #92]
    a7e0:	8a00000f 	bhi	a824 <vfnprintf+0x764>
                        goto rflag;
                case '.':
                        if ((ch = *fmt++) == '*') {
                                x = va_arg(arg, int);
                                prec = x < 0 ? -1 : x;
                                goto rflag;
    a7e4:	e59dc058 	ldr	ip, [sp, #88]
    a7e8:	e3a03000 	mov	r3, #0	; 0x0
    a7ec:	e28c1002 	add	r1, ip, #2	; 0x2
                        }
                        x = 0;
                        while (is_digit(ch)) {
                                x = 10 * x + to_digit(ch);
                                ch = *fmt++;
    a7f0:	e551c001 	ldrb	ip, [r1, #-1]
                                prec = x < 0 ? -1 : x;
                                goto rflag;
                        }
                        x = 0;
                        while (is_digit(ch)) {
                                x = 10 * x + to_digit(ch);
    a7f4:	e1a02183 	lsl	r2, r3, #3
    a7f8:	e1a03083 	lsl	r3, r3, #1
    a7fc:	e0833002 	add	r3, r3, r2
    a800:	e0833000 	add	r3, r3, r0
                                x = va_arg(arg, int);
                                prec = x < 0 ? -1 : x;
                                goto rflag;
                        }
                        x = 0;
                        while (is_digit(ch)) {
    a804:	e24c0030 	sub	r0, ip, #48	; 0x30
    a808:	e3500009 	cmp	r0, #9	; 0x9
                                x = 10 * x + to_digit(ch);
                                ch = *fmt++;
    a80c:	e58dc038 	str	ip, [sp, #56]
    a810:	e1a0c001 	mov	ip, r1
                                x = va_arg(arg, int);
                                prec = x < 0 ? -1 : x;
                                goto rflag;
                        }
                        x = 0;
                        while (is_digit(ch)) {
    a814:	e2811001 	add	r1, r1, #1	; 0x1
    a818:	9afffff4 	bls	a7f0 <vfnprintf+0x730>
    a81c:	e1833fc3 	orr	r3, r3, r3, asr #31
    a820:	e58d305c 	str	r3, [sp, #92]
#endif
                width = 0;
                prec = -1;
                sign = '\0';

rflag:          ch = *fmt++;
    a824:	e58dc058 	str	ip, [sp, #88]
    a828:	eafffe50 	b	a170 <vfnprintf+0xb0>
                        /*
                         * ``Note that 0 is taken as a flag, not as the
                         * beginning of a field width.''
                         *      -- ANSI X3J11
                         */
                        flags |= ZEROPAD;
    a82c:	e59d003c 	ldr	r0, [sp, #60]
    a830:	e3800080 	orr	r0, r0, #128	; 0x80
    a834:	e58d003c 	str	r0, [sp, #60]
    a838:	e59dc058 	ldr	ip, [sp, #88]
    a83c:	e1a03005 	mov	r3, r5
    a840:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a844:	e1a05003 	mov	r5, r3
    a848:	eafffe45 	b	a164 <vfnprintf+0xa4>
    a84c:	e59d1038 	ldr	r1, [sp, #56]
                         * ``Note that 0 is taken as a flag, not as the
                         * beginning of a field width.''
                         *      -- ANSI X3J11
                         */
                        flags |= ZEROPAD;
                        goto rflag;
    a850:	e3a03000 	mov	r3, #0	; 0x0
    a854:	e2410030 	sub	r0, r1, #48	; 0x30
                case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                        x = 0;
                        do {
                                x = 10 * x + to_digit(ch);
                                ch = *fmt++;
    a858:	e59dc058 	ldr	ip, [sp, #88]
                        goto rflag;
                case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                        x = 0;
                        do {
                                x = 10 * x + to_digit(ch);
    a85c:	e1a02183 	lsl	r2, r3, #3
                                ch = *fmt++;
    a860:	e4dc1001 	ldrb	r1, [ip], #1
                        goto rflag;
                case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                        x = 0;
                        do {
                                x = 10 * x + to_digit(ch);
    a864:	e1a03083 	lsl	r3, r3, #1
    a868:	e0833002 	add	r3, r3, r2
    a86c:	e0803003 	add	r3, r0, r3
                        flags |= ZEROPAD;
                        goto rflag;
                case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                        x = 0;
                        do {
    a870:	e2410030 	sub	r0, r1, #48	; 0x30
    a874:	e3500009 	cmp	r0, #9	; 0x9
                                x = 10 * x + to_digit(ch);
                                ch = *fmt++;
    a878:	e58d1038 	str	r1, [sp, #56]
                        flags |= ZEROPAD;
                        goto rflag;
                case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                        x = 0;
                        do {
    a87c:	e58dc058 	str	ip, [sp, #88]
    a880:	9afffff4 	bls	a858 <vfnprintf+0x798>
#endif
                width = 0;
                prec = -1;
                sign = '\0';

rflag:          ch = *fmt++;
    a884:	e58d3044 	str	r3, [sp, #68]
    a888:	e58dc058 	str	ip, [sp, #88]
    a88c:	eafffe37 	b	a170 <vfnprintf+0xb0>
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G':
                        _double = va_arg(arg, double);
    a890:	e2853007 	add	r3, r5, #7	; 0x7
                        /*
                         * don't do unrealistic precision; just pad it with
                         * zeroes later, so buffer size stays rational.
                         */
                        if (prec > MAXFRACT) {
    a894:	e59d205c 	ldr	r2, [sp, #92]
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G':
                        _double = va_arg(arg, double);
    a898:	e3c33007 	bic	r3, r3, #7	; 0x7
    a89c:	e2834008 	add	r4, r3, #8	; 0x8
                        /*
                         * don't do unrealistic precision; just pad it with
                         * zeroes later, so buffer size stays rational.
                         */
                        if (prec > MAXFRACT) {
    a8a0:	e352000f 	cmp	r2, #15	; 0xf
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G':
                        _double = va_arg(arg, double);
    a8a4:	e5938004 	ldr	r8, [r3, #4]
    a8a8:	e58d402c 	str	r4, [sp, #44]
    a8ac:	e5937000 	ldr	r7, [r3]
                        /*
                         * don't do unrealistic precision; just pad it with
                         * zeroes later, so buffer size stays rational.
                         */
                        if (prec > MAXFRACT) {
    a8b0:	ca00027e 	bgt	b2b0 <vfnprintf+0x11f0>
                                if ((ch != 'g' && ch != 'G') || (flags&ALT))
                                        fpprec = prec - MAXFRACT;
                                prec = MAXFRACT;
                        } else if (prec == -1)
    a8b4:	e59d205c 	ldr	r2, [sp, #92]
    a8b8:	e3720001 	cmn	r2, #1	; 0x1
    a8bc:	03a03006 	moveq	r3, #6	; 0x6
    a8c0:	03a04000 	moveq	r4, #0	; 0x0
    a8c4:	13a05000 	movne	r5, #0	; 0x0
    a8c8:	058d305c 	streq	r3, [sp, #92]
    a8cc:	058d4054 	streq	r4, [sp, #84]
    a8d0:	158d5054 	strne	r5, [sp, #84]
                         * if the first character is still NUL, it did.
                         * softsign avoids negative 0 if _double < 0 but
                         * no significant digits will be shown.
                         */
                        cp = buf;
                        *cp = '\0';
    a8d4:	e3a0c000 	mov	ip, #0	; 0x0
    Cyg_libm_ieee_double_shape_type ieeefp;
    char *t = startp;

    ieeefp.value = number;
    *signp = 0;
    if ( ieeefp.number.sign ){  // this checks for <0.0 and -0.0
    a8d8:	e3580000 	cmp	r8, #0	; 0x0
                         * if the first character is still NUL, it did.
                         * softsign avoids negative 0 if _double < 0 but
                         * no significant digits will be shown.
                         */
                        cp = buf;
                        *cp = '\0';
    a8dc:	e5cdc078 	strb	ip, [sp, #120]
{
    Cyg_libm_ieee_double_shape_type ieeefp;
    char *t = startp;

    ieeefp.value = number;
    *signp = 0;
    a8e0:	e5cdc306 	strb	ip, [sp, #774]
    if ( ieeefp.number.sign ){  // this checks for <0.0 and -0.0
        number = -number;
        *signp = '-';
    a8e4:	b3a0002d 	movlt	r0, #45	; 0x2d
    char *t = startp;

    ieeefp.value = number;
    *signp = 0;
    if ( ieeefp.number.sign ){  // this checks for <0.0 and -0.0
        number = -number;
    a8e8:	b2882102 	addlt	r2, r8, #-2147483648	; 0x80000000
        *signp = '-';
    a8ec:	b5cd0306 	strblt	r0, [sp, #774]
    char *t = startp;

    ieeefp.value = number;
    *signp = 0;
    if ( ieeefp.number.sign ){  // this checks for <0.0 and -0.0
        number = -number;
    a8f0:	b1a08002 	movlt	r8, r2
        *signp = '-';
    }

    if (finite(number)) {
    a8f4:	e3c84102 	bic	r4, r8, #-2147483648	; 0x80000000
    a8f8:	e1a05004 	mov	r5, r4
    a8fc:	e3e03102 	mvn	r3, #-2147483648	; 0x80000000
    a900:	e1a00007 	mov	r0, r7
    a904:	e1a01005 	mov	r1, r5
    a908:	e3e02000 	mvn	r2, #0	; 0x0
    a90c:	e2433601 	sub	r3, r3, #1048576	; 0x100000
    a910:	eb001cf7 	bl	11cf4 <__aeabi_dcmpun>
    a914:	e3500000 	cmp	r0, #0	; 0x0
    a918:	e3a06000 	mov	r6, #0	; 0x0
    a91c:	1a00027e 	bne	b31c <vfnprintf+0x125c>
    a920:	e3e03102 	mvn	r3, #-2147483648	; 0x80000000
    a924:	e1a00007 	mov	r0, r7
    a928:	e1a01005 	mov	r1, r5
    a92c:	e3e02000 	mvn	r2, #0	; 0x0
    a930:	e2433601 	sub	r3, r3, #1048576	; 0x100000
    a934:	eb001ce8 	bl	11cdc <__aeabi_dcmpgt>
    a938:	e1500006 	cmp	r0, r6
    a93c:	1a000276 	bne	b31c <vfnprintf+0x125c>
    a940:	e3560001 	cmp	r6, #1	; 0x1
    a944:	1a000287 	bne	b368 <vfnprintf+0x12a8>
                                ++t;
                }
        }
    } else {
	unsigned case_adj;
	switch (fmtch) {
    a948:	e59d3038 	ldr	r3, [sp, #56]
    a94c:	e2432065 	sub	r2, r3, #101	; 0x65
    a950:	e3520002 	cmp	r2, #2	; 0x2
	    case_adj = 'a' - 'A';
	    break;
	default:
	    case_adj = 0;
	}
	if (isnan(number)) {
    a954:	e1a00007 	mov	r0, r7
    a958:	e1a01008 	mov	r1, r8
    a95c:	e1a02007 	mov	r2, r7
    a960:	e1a03008 	mov	r3, r8
                                ++t;
                }
        }
    } else {
	unsigned case_adj;
	switch (fmtch) {
    a964:	83a0504e 	movhi	r5, #78	; 0x4e
    a968:	93a0506e 	movls	r5, #110	; 0x6e
    a96c:	83a04000 	movhi	r4, #0	; 0x0
    a970:	93a04020 	movls	r4, #32	; 0x20
	    case_adj = 'a' - 'A';
	    break;
	default:
	    case_adj = 0;
	}
	if (isnan(number)) {
    a974:	eb001cde 	bl	11cf4 <__aeabi_dcmpun>
    a978:	e3500000 	cmp	r0, #0	; 0x0
    a97c:	1a00044d 	bne	bab8 <vfnprintf+0x19f8>
	    *t++ = 'A' + case_adj;
	    *t++ = 'N' + case_adj;
	} else { // infinite
	    *t++ = 'I' + case_adj;
	    *t++ = 'N' + case_adj;
	    *t++ = 'F' + case_adj;
    a980:	e2842046 	add	r2, r4, #70	; 0x46
	if (isnan(number)) {
	    *t++ = 'N' + case_adj;
	    *t++ = 'A' + case_adj;
	    *t++ = 'N' + case_adj;
	} else { // infinite
	    *t++ = 'I' + case_adj;
    a984:	e2843049 	add	r3, r4, #73	; 0x49
	    *t++ = 'N' + case_adj;
    a988:	e5cd5079 	strb	r5, [sp, #121]
    a98c:	e28d5078 	add	r5, sp, #120	; 0x78
	if (isnan(number)) {
	    *t++ = 'N' + case_adj;
	    *t++ = 'A' + case_adj;
	    *t++ = 'N' + case_adj;
	} else { // infinite
	    *t++ = 'I' + case_adj;
    a990:	e5cd3078 	strb	r3, [sp, #120]
	    *t++ = 'N' + case_adj;
	    *t++ = 'F' + case_adj;
    a994:	e5cd207a 	strb	r2, [sp, #122]
    a998:	e58d501c 	str	r5, [sp, #28]
    a99c:	e3a0b003 	mov	fp, #3	; 0x3
    a9a0:	e28d7c03 	add	r7, sp, #768	; 0x300
                         */
                        cp = buf;
                        *cp = '\0';
                        size = cvt(_double, prec, flags, &softsign, ch,
                            cp, buf + sizeof(buf));
                        if (softsign)
    a9a4:	e5dd3306 	ldrb	r3, [sp, #774]
    a9a8:	e3530000 	cmp	r3, #0	; 0x0
                                sign = '-';
    a9ac:	13a0302d 	movne	r3, #45	; 0x2d
    a9b0:	15cd3307 	strbne	r3, [sp, #775]
                        if (*cp == '\0')
    a9b4:	e5dd3078 	ldrb	r3, [sp, #120]
    a9b8:	e3530000 	cmp	r3, #0	; 0x0
    a9bc:	1a00025c 	bne	b334 <vfnprintf+0x1274>
    a9c0:	e59dc01c 	ldr	ip, [sp, #28]
    a9c4:	e59de054 	ldr	lr, [sp, #84]
    a9c8:	e28c9001 	add	r9, ip, #1	; 0x1
    a9cc:	e1a08003 	mov	r8, r3
    a9d0:	e08b200e 	add	r2, fp, lr
    a9d4:	eafffea4 	b	a46c <vfnprintf+0x3ac>
                        } while (is_digit(ch));
                        width = x;
                        goto reswitch;
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                case 'L':
                        flags |= LONGDBL;
    a9d8:	e59d203c 	ldr	r2, [sp, #60]
    a9dc:	e3822008 	orr	r2, r2, #8	; 0x8
    a9e0:	e58d203c 	str	r2, [sp, #60]
    a9e4:	e59dc058 	ldr	ip, [sp, #88]
    a9e8:	e1a03005 	mov	r3, r5
    a9ec:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    a9f0:	e1a05003 	mov	r5, r3
    a9f4:	eafffdda 	b	a164 <vfnprintf+0xa4>
                case 'u':
                        _uquad = UARG();
                        base = DEC;
                        goto nosign;
                case 'X':
                        xdigs = (char *)"0123456789ABCDEF";
    a9f8:	e59fe884 	ldr	lr, [pc, #2180]	; b284 <vfnprintf+0x11c4>
    a9fc:	e58de050 	str	lr, [sp, #80]
    aa00:	eaffff45 	b	a71c <vfnprintf+0x65c>
                        goto rflag;
                case 'q':
                        flags |= QUADINT;
                        goto rflag;
                case 'c':
                        *(cp = buf) = va_arg(arg, int);
    aa04:	e5953000 	ldr	r3, [r5]
    aa08:	e5cd3078 	strb	r3, [sp, #120]
                        size = 1;
                        sign = '\0';
    aa0c:	e3a03000 	mov	r3, #0	; 0x0
    aa10:	e5cd3307 	strb	r3, [sp, #775]
    aa14:	e2855004 	add	r5, r5, #4	; 0x4
    aa18:	e28d9078 	add	r9, sp, #120	; 0x78
    aa1c:	e3a0b001 	mov	fp, #1	; 0x1
    aa20:	eaffff16 	b	a680 <vfnprintf+0x5c0>
#endif
                case 'h':
                        flags |= SHORTINT;
                        goto rflag;
                case 'l':
                        if (*fmt == 'l') {
    aa24:	e59dc058 	ldr	ip, [sp, #88]
    aa28:	e5dc2000 	ldrb	r2, [ip]
    aa2c:	e352006c 	cmp	r2, #108	; 0x6c
    aa30:	0a000244 	beq	b348 <vfnprintf+0x1288>
                                fmt++;
                                flags |= QUADINT;
                        } else {
                                flags |= LONGINT;
    aa34:	e59d103c 	ldr	r1, [sp, #60]
    aa38:	e1a03005 	mov	r3, r5
    aa3c:	e3811010 	orr	r1, r1, #16	; 0x10
    aa40:	e58d103c 	str	r1, [sp, #60]
    aa44:	e59dc058 	ldr	ip, [sp, #88]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    aa48:	e1a05003 	mov	r5, r3
    aa4c:	eafffdc4 	b	a164 <vfnprintf+0xa4>
                         
#endif // ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT

                case 'n':
#ifndef _NO_LONGLONG
                        if (flags & QUADINT)
    aa50:	e59d003c 	ldr	r0, [sp, #60]
    aa54:	e3100020 	tst	r0, #32	; 0x20
    aa58:	1a00020c 	bne	b290 <vfnprintf+0x11d0>
                                *va_arg(arg, quad_t *) = ret;
                        else 
#endif
                        if (flags & LONGINT)
    aa5c:	e59d203c 	ldr	r2, [sp, #60]
    aa60:	e3120010 	tst	r2, #16	; 0x10
    aa64:	0a0003dd 	beq	b9e0 <vfnprintf+0x1920>
                                *va_arg(arg, long *) = ret;
    aa68:	e5953000 	ldr	r3, [r5]
    aa6c:	e59d4040 	ldr	r4, [sp, #64]
    aa70:	e2855004 	add	r5, r5, #4	; 0x4
    aa74:	e5834000 	str	r4, [r3]
    aa78:	e58d502c 	str	r5, [sp, #44]
    aa7c:	eafffd9a 	b	a0ec <vfnprintf+0x2c>
                case 'L':
                        flags |= LONGDBL;
                        goto rflag;
#endif
                case 'h':
                        flags |= SHORTINT;
    aa80:	e59d303c 	ldr	r3, [sp, #60]
    aa84:	e3833040 	orr	r3, r3, #64	; 0x40
    aa88:	e58d303c 	str	r3, [sp, #60]
    aa8c:	e1a03005 	mov	r3, r5
    aa90:	eaffff1b 	b	a704 <vfnprintf+0x644>
                         * of printable characters, in an implementation-
                         * defined manner.''
                         *      -- ANSI X3J11
                         */
                        /* NOSTRICT */
                        _uquad = (unsigned long)va_arg(arg, void *);
    aa94:	e5953000 	ldr	r3, [r5]
                        base = HEX;
                        xdigs = (char *)"0123456789abcdef";
                        flags |= HEXPREFIX;
    aa98:	e59d203c 	ldr	r2, [sp, #60]
                         * of printable characters, in an implementation-
                         * defined manner.''
                         *      -- ANSI X3J11
                         */
                        /* NOSTRICT */
                        _uquad = (unsigned long)va_arg(arg, void *);
    aa9c:	e1a06003 	mov	r6, r3
    aaa0:	e3a07000 	mov	r7, #0	; 0x0
                        base = HEX;
                        xdigs = (char *)"0123456789abcdef";
    aaa4:	e59f37d4 	ldr	r3, [pc, #2004]	; b280 <vfnprintf+0x11c0>
                        flags |= HEXPREFIX;
    aaa8:	e3822002 	orr	r2, r2, #2	; 0x2
                         * of printable characters, in an implementation-
                         * defined manner.''
                         *      -- ANSI X3J11
                         */
                        /* NOSTRICT */
                        _uquad = (unsigned long)va_arg(arg, void *);
    aaac:	e2855004 	add	r5, r5, #4	; 0x4
                        base = HEX;
                        xdigs = (char *)"0123456789abcdef";
                        flags |= HEXPREFIX;
    aab0:	e3a04078 	mov	r4, #120	; 0x78
    aab4:	e58d203c 	str	r2, [sp, #60]
                         * of printable characters, in an implementation-
                         * defined manner.''
                         *      -- ANSI X3J11
                         */
                        /* NOSTRICT */
                        _uquad = (unsigned long)va_arg(arg, void *);
    aab8:	e58d502c 	str	r5, [sp, #44]
                        base = HEX;
                        xdigs = (char *)"0123456789abcdef";
    aabc:	e58d3050 	str	r3, [sp, #80]
                        flags |= HEXPREFIX;
    aac0:	e58d4038 	str	r4, [sp, #56]
    aac4:	e3a0c002 	mov	ip, #2	; 0x2
    aac8:	eafffe48 	b	a3f0 <vfnprintf+0x330>
                        ch = 'x';
                        goto nosign;
                case 's':
                        if ((cp = va_arg(arg, char *)) == NULL)
    aacc:	e5959000 	ldr	r9, [r5]
                                cp = (char *)"(null)";
    aad0:	e59f37b0 	ldr	r3, [pc, #1968]	; b288 <vfnprintf+0x11c8>
                        if (prec >= 0) {
    aad4:	e59dc05c 	ldr	ip, [sp, #92]
                        flags |= HEXPREFIX;
                        ch = 'x';
                        goto nosign;
                case 's':
                        if ((cp = va_arg(arg, char *)) == NULL)
                                cp = (char *)"(null)";
    aad8:	e3590000 	cmp	r9, #0	; 0x0
    aadc:	01a09003 	moveq	r9, r3
                        if (prec >= 0) {
    aae0:	e35c0000 	cmp	ip, #0	; 0x0
    aae4:	ba00039c 	blt	b95c <vfnprintf+0x189c>
                                /*
                                 * can't use strlen; can only look for the
                                 * NUL in the first `prec' characters, and
                                 * strlen() will go further.
                                 */
                                char *p = (char *)memchr(cp, 0, prec);
    aae8:	e1a00009 	mov	r0, r9
    aaec:	e3a01000 	mov	r1, #0	; 0x0
    aaf0:	e1a0200c 	mov	r2, ip
    aaf4:	eb0008ad 	bl	cdb0 <__memchr>

                                if (p != NULL) {
    aaf8:	e3500000 	cmp	r0, #0	; 0x0
    aafc:	0a000003 	beq	ab10 <vfnprintf+0xa50>
                                        size = p - cp;
                                        if (size > prec)
    ab00:	e59de05c 	ldr	lr, [sp, #92]
                                 * strlen() will go further.
                                 */
                                char *p = (char *)memchr(cp, 0, prec);

                                if (p != NULL) {
                                        size = p - cp;
    ab04:	e069b000 	rsb	fp, r9, r0
                                        if (size > prec)
    ab08:	e15b000e 	cmp	fp, lr
    ab0c:	da000000 	ble	ab14 <vfnprintf+0xa54>
                                                size = prec;
                                } else
                                        size = prec;
                        } else
                                size = strlen(cp);
    ab10:	e59db05c 	ldr	fp, [sp, #92]
                        sign = '\0';
    ab14:	e3a00000 	mov	r0, #0	; 0x0
                        xdigs = (char *)"0123456789abcdef";
                        flags |= HEXPREFIX;
                        ch = 'x';
                        goto nosign;
                case 's':
                        if ((cp = va_arg(arg, char *)) == NULL)
    ab18:	e2855004 	add	r5, r5, #4	; 0x4
                                                size = prec;
                                } else
                                        size = prec;
                        } else
                                size = strlen(cp);
                        sign = '\0';
    ab1c:	e5cd0307 	strb	r0, [sp, #775]
    ab20:	eafffed6 	b	a680 <vfnprintf+0x5c0>
                        if ((long) _uquad < 0)
#endif
                        {

                                _uquad = -_uquad;
                                sign = '-';
    ab24:	e3a0302d 	mov	r3, #45	; 0x2d
#else
                        if ((long) _uquad < 0)
#endif
                        {

                                _uquad = -_uquad;
    ab28:	e2766000 	rsbs	r6, r6, #0	; 0x0
    ab2c:	e2e77000 	rsc	r7, r7, #0	; 0x0
                                sign = '-';
    ab30:	e5cd3307 	strb	r3, [sp, #775]
    ab34:	e3a0c001 	mov	ip, #1	; 0x1
    ab38:	eafffe2e 	b	a3f8 <vfnprintf+0x338>
                realsz = dprec > fieldsz ? dprec : fieldsz;

                /* right-adjusting blank padding */
                if ((flags & (LADJUST|ZEROPAD)) == 0) {
                    if (width - realsz > 0) {
                        PAD(width - realsz, blanks);
    ab3c:	e59dc030 	ldr	ip, [sp, #48]
    ab40:	e59de040 	ldr	lr, [sp, #64]
    ab44:	e24cc001 	sub	ip, ip, #1	; 0x1
    ab48:	e06ee00c 	rsb	lr, lr, ip
    ab4c:	e58dc074 	str	ip, [sp, #116]
    ab50:	e58de070 	str	lr, [sp, #112]
    ab54:	e1a04006 	mov	r4, r6
    ab58:	e59d2070 	ldr	r2, [sp, #112]
    ab5c:	e1540002 	cmp	r4, r2
    ab60:	31a02004 	movcc	r2, r4
    ab64:	e58d2300 	str	r2, [sp, #768]
    ab68:	e59ac000 	ldr	ip, [sl]
    ab6c:	e1a0000a 	mov	r0, sl
    ab70:	e59f1704 	ldr	r1, [pc, #1796]	; b27c <vfnprintf+0x11bc>
    ab74:	e1a03007 	mov	r3, r7
    ab78:	e1a0e00f 	mov	lr, pc
    ab7c:	e59cf008 	ldr	pc, [ip, #8]
    ab80:	e3500000 	cmp	r0, #0	; 0x0
    ab84:	1afffdeb 	bne	a338 <vfnprintf+0x278>
    ab88:	e59d3300 	ldr	r3, [sp, #768]
    ab8c:	e1540003 	cmp	r4, r3
    ab90:	8a0003b3 	bhi	ba64 <vfnprintf+0x19a4>
                        ret += width - realsz;
    ab94:	e59d5040 	ldr	r5, [sp, #64]
    ab98:	e0855006 	add	r5, r5, r6
    ab9c:	e58d5040 	str	r5, [sp, #64]
                    }
                }

                /* prefix */
                if (sign) {
    aba0:	e5dd3307 	ldrb	r3, [sp, #775]
    aba4:	e3530000 	cmp	r3, #0	; 0x0
    aba8:	1a00006f 	bne	ad6c <vfnprintf+0xcac>
                        PRINT(&sign, 1);
                        ret++;
                } else if (flags & HEXPREFIX) {
    abac:	e59d103c 	ldr	r1, [sp, #60]
    abb0:	e3110002 	tst	r1, #2	; 0x2
    abb4:	1a0000d3 	bne	af08 <vfnprintf+0xe48>
                        PRINT(ox, 2);
                        ret += 2;
                }

                /* right-adjusting zero padding */
                if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
    abb8:	e59de034 	ldr	lr, [sp, #52]
    abbc:	e35e0080 	cmp	lr, #128	; 0x80
    abc0:	0a000081 	beq	adcc <vfnprintf+0xd0c>
                        PAD(width - realsz, zeroes);
                        ret += width - realsz;
                    }
                }

                if (dprec - fieldsz > 0) {
    abc4:	e59d1048 	ldr	r1, [sp, #72]
    abc8:	e0616008 	rsb	r6, r1, r8
    abcc:	e3560000 	cmp	r6, #0	; 0x0
    abd0:	da000030 	ble	ac98 <vfnprintf+0xbd8>
                    /* leading zeroes from decimal precision */
                    PAD(dprec - fieldsz, zeroes);
    abd4:	e3560010 	cmp	r6, #16	; 0x10
    abd8:	da000018 	ble	ac40 <vfnprintf+0xb80>
    abdc:	e59d4074 	ldr	r4, [sp, #116]
    abe0:	e59d5040 	ldr	r5, [sp, #64]
    abe4:	e0658004 	rsb	r8, r5, r4
    abe8:	e3580010 	cmp	r8, #16	; 0x10
    abec:	31a05008 	movcc	r5, r8
    abf0:	23a05010 	movcs	r5, #16	; 0x10
    abf4:	e1a04006 	mov	r4, r6
    abf8:	ea000004 	b	ac10 <vfnprintf+0xb50>
    abfc:	e59d3300 	ldr	r3, [sp, #768]
    ac00:	e353000f 	cmp	r3, #15	; 0xf
    ac04:	9a0000bb 	bls	aef8 <vfnprintf+0xe38>
    ac08:	e3540010 	cmp	r4, #16	; 0x10
    ac0c:	da00000f 	ble	ac50 <vfnprintf+0xb90>
    ac10:	e58d5300 	str	r5, [sp, #768]
    ac14:	e59ac000 	ldr	ip, [sl]
    ac18:	e1a0000a 	mov	r0, sl
    ac1c:	e59f1650 	ldr	r1, [pc, #1616]	; b274 <vfnprintf+0x11b4>
    ac20:	e1a02005 	mov	r2, r5
    ac24:	e1a03007 	mov	r3, r7
    ac28:	e1a0e00f 	mov	lr, pc
    ac2c:	e59cf008 	ldr	pc, [ip, #8]
    ac30:	e3500000 	cmp	r0, #0	; 0x0
    ac34:	e2444010 	sub	r4, r4, #16	; 0x10
    ac38:	0affffef 	beq	abfc <vfnprintf+0xb3c>
    ac3c:	eafffdbd 	b	a338 <vfnprintf+0x278>
    ac40:	e59d2074 	ldr	r2, [sp, #116]
    ac44:	e59d3040 	ldr	r3, [sp, #64]
    ac48:	e1a04006 	mov	r4, r6
    ac4c:	e0638002 	rsb	r8, r3, r2
    ac50:	e1540008 	cmp	r4, r8
    ac54:	31a02004 	movcc	r2, r4
    ac58:	21a02008 	movcs	r2, r8
    ac5c:	e58d2300 	str	r2, [sp, #768]
    ac60:	e59ac000 	ldr	ip, [sl]
    ac64:	e1a0000a 	mov	r0, sl
    ac68:	e59f1604 	ldr	r1, [pc, #1540]	; b274 <vfnprintf+0x11b4>
    ac6c:	e1a03007 	mov	r3, r7
    ac70:	e1a0e00f 	mov	lr, pc
    ac74:	e59cf008 	ldr	pc, [ip, #8]
    ac78:	e3500000 	cmp	r0, #0	; 0x0
    ac7c:	1afffdad 	bne	a338 <vfnprintf+0x278>
    ac80:	e59d3300 	ldr	r3, [sp, #768]
    ac84:	e1540003 	cmp	r4, r3
    ac88:	8a0001a5 	bhi	b324 <vfnprintf+0x1264>
                    ret += dprec - fieldsz;
    ac8c:	e59d0040 	ldr	r0, [sp, #64]
    ac90:	e0800006 	add	r0, r0, r6
    ac94:	e58d0040 	str	r0, [sp, #64]
                }

                /* the string or number proper */
                PRINT(cp, size);
    ac98:	e59d1074 	ldr	r1, [sp, #116]
    ac9c:	e59d3040 	ldr	r3, [sp, #64]
    aca0:	e0632001 	rsb	r2, r3, r1
    aca4:	e152000b 	cmp	r2, fp
    aca8:	21a0200b 	movcs	r2, fp
    acac:	e58d2300 	str	r2, [sp, #768]
    acb0:	e1a01009 	mov	r1, r9
    acb4:	e59ac000 	ldr	ip, [sl]
    acb8:	e1a0000a 	mov	r0, sl
    acbc:	e1a03007 	mov	r3, r7
    acc0:	e1a0e00f 	mov	lr, pc
    acc4:	e59cf008 	ldr	pc, [ip, #8]
    acc8:	e3500000 	cmp	r0, #0	; 0x0
    accc:	1afffd99 	bne	a338 <vfnprintf+0x278>
    acd0:	e59d3300 	ldr	r3, [sp, #768]
    acd4:	e15b0003 	cmp	fp, r3
    acd8:	8a000361 	bhi	ba64 <vfnprintf+0x19a4>
                ret += size;
    acdc:	e59dc040 	ldr	ip, [sp, #64]

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
    ace0:	e59d5054 	ldr	r5, [sp, #84]
                    ret += dprec - fieldsz;
                }

                /* the string or number proper */
                PRINT(cp, size);
                ret += size;
    ace4:	e08cc00b 	add	ip, ip, fp

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
    ace8:	e3550000 	cmp	r5, #0	; 0x0
                    ret += dprec - fieldsz;
                }

                /* the string or number proper */
                PRINT(cp, size);
                ret += size;
    acec:	e58dc040 	str	ip, [sp, #64]

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
    acf0:	0a000056 	beq	ae50 <vfnprintf+0xd90>
    acf4:	e3550010 	cmp	r5, #16	; 0x10
    acf8:	d59de074 	ldrle	lr, [sp, #116]
    acfc:	d1a04005 	movle	r4, r5
    ad00:	d06c600e 	rsble	r6, ip, lr
    ad04:	dafffd79 	ble	a2f0 <vfnprintf+0x230>
    ad08:	e59d0074 	ldr	r0, [sp, #116]
    ad0c:	e59d1040 	ldr	r1, [sp, #64]
    ad10:	e0616000 	rsb	r6, r1, r0
    ad14:	e3560010 	cmp	r6, #16	; 0x10
    ad18:	31a05006 	movcc	r5, r6
    ad1c:	23a05010 	movcs	r5, #16	; 0x10
    ad20:	e59d4054 	ldr	r4, [sp, #84]
    ad24:	ea000004 	b	ad3c <vfnprintf+0xc7c>
    ad28:	e59d3300 	ldr	r3, [sp, #768]
    ad2c:	e353000f 	cmp	r3, #15	; 0xf
    ad30:	9a00008d 	bls	af6c <vfnprintf+0xeac>
    ad34:	e3540010 	cmp	r4, #16	; 0x10
    ad38:	dafffd6c 	ble	a2f0 <vfnprintf+0x230>
    ad3c:	e58d5300 	str	r5, [sp, #768]
    ad40:	e59ac000 	ldr	ip, [sl]
    ad44:	e1a0000a 	mov	r0, sl
    ad48:	e59f1524 	ldr	r1, [pc, #1316]	; b274 <vfnprintf+0x11b4>
    ad4c:	e1a02005 	mov	r2, r5
    ad50:	e1a03007 	mov	r3, r7
    ad54:	e1a0e00f 	mov	lr, pc
    ad58:	e59cf008 	ldr	pc, [ip, #8]
    ad5c:	e3500000 	cmp	r0, #0	; 0x0
    ad60:	e2444010 	sub	r4, r4, #16	; 0x10
    ad64:	0affffef 	beq	ad28 <vfnprintf+0xc68>
    ad68:	eafffd72 	b	a338 <vfnprintf+0x278>
                    }
                }

                /* prefix */
                if (sign) {
                        PRINT(&sign, 1);
    ad6c:	e59dc074 	ldr	ip, [sp, #116]
    ad70:	e59de040 	ldr	lr, [sp, #64]
    ad74:	e06e200c 	rsb	r2, lr, ip
    ad78:	e3520001 	cmp	r2, #1	; 0x1
    ad7c:	23a02001 	movcs	r2, #1	; 0x1
    ad80:	e28d1fc1 	add	r1, sp, #772	; 0x304
    ad84:	e58d2300 	str	r2, [sp, #768]
    ad88:	e59ac000 	ldr	ip, [sl]
    ad8c:	e1a0000a 	mov	r0, sl
    ad90:	e2811003 	add	r1, r1, #3	; 0x3
    ad94:	e1a03007 	mov	r3, r7
    ad98:	e1a0e00f 	mov	lr, pc
    ad9c:	e59cf008 	ldr	pc, [ip, #8]
    ada0:	e3500000 	cmp	r0, #0	; 0x0
    ada4:	1afffd63 	bne	a338 <vfnprintf+0x278>
    ada8:	e59d3300 	ldr	r3, [sp, #768]
    adac:	e3530000 	cmp	r3, #0	; 0x0
    adb0:	0afffd60 	beq	a338 <vfnprintf+0x278>
                        ret++;
    adb4:	e59d0040 	ldr	r0, [sp, #64]
                        PRINT(ox, 2);
                        ret += 2;
                }

                /* right-adjusting zero padding */
                if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
    adb8:	e59de034 	ldr	lr, [sp, #52]
                }

                /* prefix */
                if (sign) {
                        PRINT(&sign, 1);
                        ret++;
    adbc:	e2800001 	add	r0, r0, #1	; 0x1
                        PRINT(ox, 2);
                        ret += 2;
                }

                /* right-adjusting zero padding */
                if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
    adc0:	e35e0080 	cmp	lr, #128	; 0x80
                }

                /* prefix */
                if (sign) {
                        PRINT(&sign, 1);
                        ret++;
    adc4:	e58d0040 	str	r0, [sp, #64]
                        PRINT(ox, 2);
                        ret += 2;
                }

                /* right-adjusting zero padding */
                if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
    adc8:	1affff7d 	bne	abc4 <vfnprintf+0xb04>
                    if (width - realsz > 0) {
    adcc:	e59d0044 	ldr	r0, [sp, #68]
    add0:	e59d104c 	ldr	r1, [sp, #76]
    add4:	e0616000 	rsb	r6, r1, r0
    add8:	e3560000 	cmp	r6, #0	; 0x0
    addc:	daffff78 	ble	abc4 <vfnprintf+0xb04>
                        PAD(width - realsz, zeroes);
    ade0:	e3560010 	cmp	r6, #16	; 0x10
    ade4:	da00010a 	ble	b214 <vfnprintf+0x1154>
    ade8:	e59d5040 	ldr	r5, [sp, #64]
    adec:	e59d4074 	ldr	r4, [sp, #116]
    adf0:	e0654004 	rsb	r4, r5, r4
    adf4:	e1a05004 	mov	r5, r4
    adf8:	e58d406c 	str	r4, [sp, #108]
    adfc:	e3550010 	cmp	r5, #16	; 0x10
    ae00:	23a05010 	movcs	r5, #16	; 0x10
    ae04:	e1a04006 	mov	r4, r6
    ae08:	ea000004 	b	ae20 <vfnprintf+0xd60>
    ae0c:	e59d3300 	ldr	r3, [sp, #768]
    ae10:	e353000f 	cmp	r3, #15	; 0xf
    ae14:	9a000037 	bls	aef8 <vfnprintf+0xe38>
    ae18:	e3540010 	cmp	r4, #16	; 0x10
    ae1c:	da000101 	ble	b228 <vfnprintf+0x1168>
    ae20:	e58d5300 	str	r5, [sp, #768]
    ae24:	e59ac000 	ldr	ip, [sl]
    ae28:	e1a0000a 	mov	r0, sl
    ae2c:	e59f1440 	ldr	r1, [pc, #1088]	; b274 <vfnprintf+0x11b4>
    ae30:	e1a02005 	mov	r2, r5
    ae34:	e1a03007 	mov	r3, r7
    ae38:	e1a0e00f 	mov	lr, pc
    ae3c:	e59cf008 	ldr	pc, [ip, #8]
    ae40:	e3500000 	cmp	r0, #0	; 0x0
    ae44:	e2444010 	sub	r4, r4, #16	; 0x10
    ae48:	0affffef 	beq	ae0c <vfnprintf+0xd4c>
    ae4c:	eafffd39 	b	a338 <vfnprintf+0x278>
                ret += size;

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
                ret += fpprec;
    ae50:	e28d503c 	add	r5, sp, #60	; 0x3c
    ae54:	e8951020 	ldm	r5, {r5, ip}
    ae58:	e59de054 	ldr	lr, [sp, #84]
#endif

                /* left-adjusting padding (always blank) */
                if (flags & LADJUST) {
    ae5c:	e3150004 	tst	r5, #4	; 0x4
                ret += size;

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
                ret += fpprec;
    ae60:	e08cc00e 	add	ip, ip, lr
    ae64:	e58dc040 	str	ip, [sp, #64]
#endif

                /* left-adjusting padding (always blank) */
                if (flags & LADJUST) {
    ae68:	0afffc9f 	beq	a0ec <vfnprintf+0x2c>
                    if (width - realsz > 0) {
    ae6c:	e59d0044 	ldr	r0, [sp, #68]
    ae70:	e59d104c 	ldr	r1, [sp, #76]
    ae74:	e0616000 	rsb	r6, r1, r0
    ae78:	e3560000 	cmp	r6, #0	; 0x0
    ae7c:	dafffc9a 	ble	a0ec <vfnprintf+0x2c>
                        PAD(width - realsz, blanks);
    ae80:	e3560010 	cmp	r6, #16	; 0x10
    ae84:	d59d2074 	ldrle	r2, [sp, #116]
    ae88:	d1a04006 	movle	r4, r6
    ae8c:	d06c8002 	rsble	r8, ip, r2
    ae90:	da0002b5 	ble	b96c <vfnprintf+0x18ac>
    ae94:	e59d4040 	ldr	r4, [sp, #64]
    ae98:	e59d3074 	ldr	r3, [sp, #116]
    ae9c:	e0648003 	rsb	r8, r4, r3
    aea0:	e3580010 	cmp	r8, #16	; 0x10
    aea4:	31a05008 	movcc	r5, r8
    aea8:	23a05010 	movcs	r5, #16	; 0x10
    aeac:	e1a04006 	mov	r4, r6
    aeb0:	ea000004 	b	aec8 <vfnprintf+0xe08>
    aeb4:	e59d3300 	ldr	r3, [sp, #768]
    aeb8:	e353000f 	cmp	r3, #15	; 0xf
    aebc:	9a0002d0 	bls	ba04 <vfnprintf+0x1944>
    aec0:	e3540010 	cmp	r4, #16	; 0x10
    aec4:	da0002a8 	ble	b96c <vfnprintf+0x18ac>
    aec8:	e58d5300 	str	r5, [sp, #768]
    aecc:	e59ac000 	ldr	ip, [sl]
    aed0:	e1a0000a 	mov	r0, sl
    aed4:	e59f13a0 	ldr	r1, [pc, #928]	; b27c <vfnprintf+0x11bc>
    aed8:	e1a02005 	mov	r2, r5
    aedc:	e1a03007 	mov	r3, r7
    aee0:	e1a0e00f 	mov	lr, pc
    aee4:	e59cf008 	ldr	pc, [ip, #8]
    aee8:	e3500000 	cmp	r0, #0	; 0x0
    aeec:	e2444010 	sub	r4, r4, #16	; 0x10
    aef0:	0affffef 	beq	aeb4 <vfnprintf+0xdf4>
    aef4:	eafffd0f 	b	a338 <vfnprintf+0x278>
    aef8:	e59dc040 	ldr	ip, [sp, #64]
    aefc:	e083c00c 	add	ip, r3, ip
    af00:	e58dc040 	str	ip, [sp, #64]
    af04:	eafffd0b 	b	a338 <vfnprintf+0x278>
                        PRINT(&sign, 1);
                        ret++;
                } else if (flags & HEXPREFIX) {
                        ox[0] = '0';
                        ox[1] = ch;
                        PRINT(ox, 2);
    af08:	e59d3074 	ldr	r3, [sp, #116]
    af0c:	e59d4040 	ldr	r4, [sp, #64]
                if (sign) {
                        PRINT(&sign, 1);
                        ret++;
                } else if (flags & HEXPREFIX) {
                        ox[0] = '0';
                        ox[1] = ch;
    af10:	e59d5038 	ldr	r5, [sp, #56]
                        PRINT(ox, 2);
    af14:	e0642003 	rsb	r2, r4, r3
                /* prefix */
                if (sign) {
                        PRINT(&sign, 1);
                        ret++;
                } else if (flags & HEXPREFIX) {
                        ox[0] = '0';
    af18:	e3a03030 	mov	r3, #48	; 0x30
    af1c:	e5cd3304 	strb	r3, [sp, #772]
                        ox[1] = ch;
    af20:	e5cd5305 	strb	r5, [sp, #773]
                        PRINT(ox, 2);
    af24:	e3520002 	cmp	r2, #2	; 0x2
    af28:	23a02002 	movcs	r2, #2	; 0x2
    af2c:	e58d2300 	str	r2, [sp, #768]
    af30:	e59ac000 	ldr	ip, [sl]
    af34:	e1a0000a 	mov	r0, sl
    af38:	e28d1fc1 	add	r1, sp, #772	; 0x304
    af3c:	e1a03007 	mov	r3, r7
    af40:	e1a0e00f 	mov	lr, pc
    af44:	e59cf008 	ldr	pc, [ip, #8]
    af48:	e3500000 	cmp	r0, #0	; 0x0
    af4c:	1afffcf9 	bne	a338 <vfnprintf+0x278>
    af50:	e59d3300 	ldr	r3, [sp, #768]
    af54:	e3530001 	cmp	r3, #1	; 0x1
    af58:	9afffcf4 	bls	a330 <vfnprintf+0x270>
                        ret += 2;
    af5c:	e59dc040 	ldr	ip, [sp, #64]
    af60:	e28cc002 	add	ip, ip, #2	; 0x2
    af64:	e58dc040 	str	ip, [sp, #64]
    af68:	eaffff12 	b	abb8 <vfnprintf+0xaf8>
                PRINT(cp, size);
                ret += size;

#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                /* trailing f.p. zeroes */
                PAD(fpprec, zeroes);
    af6c:	e59d2040 	ldr	r2, [sp, #64]
    af70:	e0832002 	add	r2, r3, r2
    af74:	e58d2040 	str	r2, [sp, #64]
    af78:	eafffcee 	b	a338 <vfnprintf+0x278>
	                                                /* The following is usually faster than using a modulo */
                                                        u_quad_t next = _uquad / 10;
                                                        *--cp = to_char(_uquad - (next * 10));
                                                        _uquad = next;
                                                }
                                                *--cp = to_char(_uquad);
    af7c:	e28d9f6f 	add	r9, sp, #444	; 0x1bc
                                        break;

                                case HEX:
                                        do {
                                                *--cp = xdigs[_uquad & 15];
                                                _uquad >>= 4;
    af80:	e1a02226 	lsr	r2, r6, #4
    af84:	e1822e07 	orr	r2, r2, r7, lsl #28
                                        }
                                        break;

                                case HEX:
                                        do {
                                                *--cp = xdigs[_uquad & 15];
    af88:	e59d5050 	ldr	r5, [sp, #80]
                                                _uquad >>= 4;
    af8c:	e1a01227 	lsr	r1, r7, #4
    af90:	e1a03002 	mov	r3, r2
                                        }
                                        break;

                                case HEX:
                                        do {
                                                *--cp = xdigs[_uquad & 15];
    af94:	e206200f 	and	r2, r6, #15	; 0xf
                                                _uquad >>= 4;
    af98:	e1a04001 	mov	r4, r1
                                        }
                                        break;

                                case HEX:
                                        do {
                                                *--cp = xdigs[_uquad & 15];
    af9c:	e7d51002 	ldrb	r1, [r5, r2]
                                                *--cp = to_char(_uquad);
                                        }
                                        break;

                                case HEX:
                                        do {
    afa0:	e193c004 	orrs	ip, r3, r4
                                                *--cp = xdigs[_uquad & 15];
                                                _uquad >>= 4;
    afa4:	e1a06003 	mov	r6, r3
    afa8:	e1a07004 	mov	r7, r4
                                        }
                                        break;

                                case HEX:
                                        do {
                                                *--cp = xdigs[_uquad & 15];
    afac:	e5691001 	strb	r1, [r9, #-1]!
                                                *--cp = to_char(_uquad);
                                        }
                                        break;

                                case HEX:
                                        do {
    afb0:	1afffff2 	bne	af80 <vfnprintf+0xec0>
    afb4:	e59de014 	ldr	lr, [sp, #20]
    afb8:	e069b00e 	rsb	fp, r9, lr
    afbc:	eafffd76 	b	a59c <vfnprintf+0x4dc>
                                        if (flags & ALT && *cp != '0')
                                                *--cp = '0';
                                        break;

                                case DEC:
                                        if (!(flags & QUADINT)) {
    afc0:	e59d203c 	ldr	r2, [sp, #60]
    afc4:	e3120020 	tst	r2, #32	; 0x20
    afc8:	0a000079 	beq	b1b4 <vfnprintf+0x10f4>
                                                        v = next;
                                                }
                                                *--cp = to_char(v);
                                        }
                                        else {
                                                while (_uquad >= 10) {
    afcc:	e3570000 	cmp	r7, #0	; 0x0
    afd0:	0a0000cc 	beq	b308 <vfnprintf+0x1248>
	                                                /* The following is usually faster than using a modulo */
                                                        unsigned long next = v / 10;
                                                        *--cp = to_char(v - (next * 10));
                                                        v = next;
                                                }
                                                *--cp = to_char(v);
    afd4:	e28dbf6f 	add	fp, sp, #444	; 0x1bc
                                        }
                                        else {
                                                while (_uquad >= 10) {
	                                                /* The following is usually faster than using a modulo */
                                                        u_quad_t next = _uquad / 10;
    afd8:	e1a00006 	mov	r0, r6
    afdc:	e1a01007 	mov	r1, r7
    afe0:	e3a0200a 	mov	r2, #10	; 0xa
    afe4:	e3a03000 	mov	r3, #0	; 0x0
    afe8:	eb001b8e 	bl	11e28 <__aeabi_uldivmod>
    afec:	e1a08000 	mov	r8, r0
    aff0:	e1a09001 	mov	r9, r1
                                                        *--cp = to_char(_uquad - (next * 10));
    aff4:	e0901008 	adds	r1, r0, r8
    aff8:	e0a92009 	adc	r2, r9, r9
    affc:	e1a0e102 	lsl	lr, r2, #2
    b000:	e18e0f21 	orr	r0, lr, r1, lsr #30
    b004:	e1a03101 	lsl	r3, r1, #2
    b008:	e58de024 	str	lr, [sp, #36]
    b00c:	e58d3020 	str	r3, [sp, #32]
    b010:	e58d0024 	str	r0, [sp, #36]
    b014:	e28d3020 	add	r3, sp, #32	; 0x20
    b018:	e8930018 	ldm	r3, {r3, r4}
    b01c:	e2860030 	add	r0, r6, #48	; 0x30
    b020:	e0911003 	adds	r1, r1, r3
    b024:	e0610000 	rsb	r0, r1, r0
                                                        v = next;
                                                }
                                                *--cp = to_char(v);
                                        }
                                        else {
                                                while (_uquad >= 10) {
    b028:	e3590000 	cmp	r9, #0	; 0x0
	                                                /* The following is usually faster than using a modulo */
                                                        u_quad_t next = _uquad / 10;
                                                        *--cp = to_char(_uquad - (next * 10));
    b02c:	e1a05008 	mov	r5, r8
    b030:	e56b0001 	strb	r0, [fp, #-1]!
    b034:	e1a06008 	mov	r6, r8
    b038:	e1a07009 	mov	r7, r9
                                                        v = next;
                                                }
                                                *--cp = to_char(v);
                                        }
                                        else {
                                                while (_uquad >= 10) {
    b03c:	1affffe5 	bne	afd8 <vfnprintf+0xf18>
    b040:	e3580009 	cmp	r8, #9	; 0x9
    b044:	8affffe3 	bhi	afd8 <vfnprintf+0xf18>
    b048:	e24b9001 	sub	r9, fp, #1	; 0x1
    b04c:	e1a06008 	mov	r6, r8
	                                                /* The following is usually faster than using a modulo */
                                                        u_quad_t next = _uquad / 10;
                                                        *--cp = to_char(_uquad - (next * 10));
                                                        _uquad = next;
                                                }
                                                *--cp = to_char(_uquad);
    b050:	e2863030 	add	r3, r6, #48	; 0x30
    b054:	e5c93000 	strb	r3, [r9]
    b058:	e59d4014 	ldr	r4, [sp, #20]
    b05c:	e069b004 	rsb	fp, r9, r4
    b060:	eafffd4d 	b	a59c <vfnprintf+0x4dc>
                        break;
                case 'U':
                        flags |= LONGINT;
                        /*FALLTHROUGH*/
                case 'u':
                        _uquad = UARG();
    b064:	e59d303c 	ldr	r3, [sp, #60]
    b068:	e3130010 	tst	r3, #16	; 0x10
    b06c:	1a00000b 	bne	b0a0 <vfnprintf+0xfe0>
    b070:	e59d403c 	ldr	r4, [sp, #60]
    b074:	e3140040 	tst	r4, #64	; 0x40
    b078:	0a000008 	beq	b0a0 <vfnprintf+0xfe0>
    b07c:	e5953000 	ldr	r3, [r5]
    b080:	e1a03803 	lsl	r3, r3, #16
    b084:	e1a03823 	lsr	r3, r3, #16
    b088:	e2855004 	add	r5, r5, #4	; 0x4
    b08c:	e1a06003 	mov	r6, r3
    b090:	e3a07000 	mov	r7, #0	; 0x0
    b094:	e58d502c 	str	r5, [sp, #44]
    b098:	e3a0c001 	mov	ip, #1	; 0x1
    b09c:	eafffcd3 	b	a3f0 <vfnprintf+0x330>
    b0a0:	e5953000 	ldr	r3, [r5]
    b0a4:	e2855004 	add	r5, r5, #4	; 0x4
    b0a8:	e1a06003 	mov	r6, r3
    b0ac:	e3a07000 	mov	r7, #0	; 0x0
    b0b0:	e58d502c 	str	r5, [sp, #44]
    b0b4:	e3a0c001 	mov	ip, #1	; 0x1
    b0b8:	eafffccc 	b	a3f0 <vfnprintf+0x330>
                        continue;       /* no output */
                case 'O':
                        flags |= LONGINT;
                        /*FALLTHROUGH*/
                case 'o':
                        _uquad = UARG();
    b0bc:	e59de03c 	ldr	lr, [sp, #60]
    b0c0:	e21e2010 	ands	r2, lr, #16	; 0x10
    b0c4:	1a00000b 	bne	b0f8 <vfnprintf+0x1038>
    b0c8:	e59d003c 	ldr	r0, [sp, #60]
    b0cc:	e210c040 	ands	ip, r0, #64	; 0x40
    b0d0:	0a000238 	beq	b9b8 <vfnprintf+0x18f8>
    b0d4:	e5953000 	ldr	r3, [r5]
    b0d8:	e1a03803 	lsl	r3, r3, #16
    b0dc:	e1a03823 	lsr	r3, r3, #16
    b0e0:	e2855004 	add	r5, r5, #4	; 0x4
    b0e4:	e1a06003 	mov	r6, r3
    b0e8:	e3a07000 	mov	r7, #0	; 0x0
    b0ec:	e1a0c002 	mov	ip, r2
    b0f0:	e58d502c 	str	r5, [sp, #44]
    b0f4:	eafffcbd 	b	a3f0 <vfnprintf+0x330>
    b0f8:	e5953000 	ldr	r3, [r5]
    b0fc:	e2855004 	add	r5, r5, #4	; 0x4
    b100:	e1a06003 	mov	r6, r3
    b104:	e3a07000 	mov	r7, #0	; 0x0
    b108:	e58d502c 	str	r5, [sp, #44]
    b10c:	eafffcb7 	b	a3f0 <vfnprintf+0x330>
                case 'D':
                        flags |= LONGINT;
                        /*FALLTHROUGH*/
                case 'd':
                case 'i':
                        _uquad = SARG();
    b110:	e59de03c 	ldr	lr, [sp, #60]
    b114:	e31e0010 	tst	lr, #16	; 0x10
    b118:	1a00000a 	bne	b148 <vfnprintf+0x1088>
    b11c:	e59d003c 	ldr	r0, [sp, #60]
    b120:	e3100040 	tst	r0, #64	; 0x40
    b124:	0a000007 	beq	b148 <vfnprintf+0x1088>
    b128:	e5953000 	ldr	r3, [r5]
    b12c:	e1a03803 	lsl	r3, r3, #16
    b130:	e1a03843 	asr	r3, r3, #16
    b134:	e2855004 	add	r5, r5, #4	; 0x4
    b138:	e1a06003 	mov	r6, r3
    b13c:	e1a07fc6 	asr	r7, r6, #31
    b140:	e58d502c 	str	r5, [sp, #44]
    b144:	eafffd2c 	b	a5fc <vfnprintf+0x53c>
    b148:	e5953000 	ldr	r3, [r5]
    b14c:	e2855004 	add	r5, r5, #4	; 0x4
    b150:	e1a06003 	mov	r6, r3
    b154:	e1a07fc6 	asr	r7, r6, #31
    b158:	e58d502c 	str	r5, [sp, #44]
    b15c:	eafffd26 	b	a5fc <vfnprintf+0x53c>
                case 'X':
                        xdigs = (char *)"0123456789ABCDEF";
                        goto hex;
                case 'x':
                        xdigs = (char *)"0123456789abcdef";
hex:                    _uquad = UARG();
    b160:	e59d203c 	ldr	r2, [sp, #60]
    b164:	e3120010 	tst	r2, #16	; 0x10
    b168:	1a00000b 	bne	b19c <vfnprintf+0x10dc>
    b16c:	e59d303c 	ldr	r3, [sp, #60]
    b170:	e3130040 	tst	r3, #64	; 0x40
    b174:	059d403c 	ldreq	r4, [sp, #60]
    b178:	0a000007 	beq	b19c <vfnprintf+0x10dc>
    b17c:	e5953000 	ldr	r3, [r5]
    b180:	e1a03803 	lsl	r3, r3, #16
    b184:	e1a03823 	lsr	r3, r3, #16
    b188:	e2855004 	add	r5, r5, #4	; 0x4
    b18c:	e1a06003 	mov	r6, r3
    b190:	e3a07000 	mov	r7, #0	; 0x0
    b194:	e58d502c 	str	r5, [sp, #44]
    b198:	eafffd67 	b	a73c <vfnprintf+0x67c>
    b19c:	e5953000 	ldr	r3, [r5]
    b1a0:	e2855004 	add	r5, r5, #4	; 0x4
    b1a4:	e1a06003 	mov	r6, r3
    b1a8:	e3a07000 	mov	r7, #0	; 0x0
    b1ac:	e58d502c 	str	r5, [sp, #44]
    b1b0:	eafffd61 	b	a73c <vfnprintf+0x67c>

                                case DEC:
                                        if (!(flags & QUADINT)) {
                                                /* many numbers are 1 digit */
                                                unsigned long v = (unsigned long)_uquad;
                                                while (v >= 10) {
    b1b4:	e3560009 	cmp	r6, #9	; 0x9
    b1b8:	928d9f6f 	addls	r9, sp, #444	; 0x1bc
                                        break;

                                case DEC:
                                        if (!(flags & QUADINT)) {
                                                /* many numbers are 1 digit */
                                                unsigned long v = (unsigned long)_uquad;
    b1bc:	e1a0c006 	mov	ip, r6
                                                while (v >= 10) {
    b1c0:	92499001 	subls	r9, r9, #1	; 0x1
    b1c4:	9a00000d 	bls	b200 <vfnprintf+0x1140>
    b1c8:	e28def6f 	add	lr, sp, #444	; 0x1bc
	                                                /* The following is usually faster than using a modulo */
                                                        unsigned long next = v / 10;
    b1cc:	e59f40b8 	ldr	r4, [pc, #184]	; b28c <vfnprintf+0x11cc>
    b1d0:	e0835c94 	umull	r5, r3, r4, ip
    b1d4:	e1a031a3 	lsr	r3, r3, #3
                                                        *--cp = to_char(v - (next * 10));
    b1d8:	e1a00083 	lsl	r0, r3, #1
    b1dc:	e1a02183 	lsl	r2, r3, #3
    b1e0:	e28c1030 	add	r1, ip, #48	; 0x30
    b1e4:	e0800002 	add	r0, r0, r2
    b1e8:	e0601001 	rsb	r1, r0, r1

                                case DEC:
                                        if (!(flags & QUADINT)) {
                                                /* many numbers are 1 digit */
                                                unsigned long v = (unsigned long)_uquad;
                                                while (v >= 10) {
    b1ec:	e3530009 	cmp	r3, #9	; 0x9
	                                                /* The following is usually faster than using a modulo */
                                                        unsigned long next = v / 10;
                                                        *--cp = to_char(v - (next * 10));
    b1f0:	e1a0c003 	mov	ip, r3
    b1f4:	e56e1001 	strb	r1, [lr, #-1]!

                                case DEC:
                                        if (!(flags & QUADINT)) {
                                                /* many numbers are 1 digit */
                                                unsigned long v = (unsigned long)_uquad;
                                                while (v >= 10) {
    b1f8:	8afffff3 	bhi	b1cc <vfnprintf+0x110c>
    b1fc:	e24e9001 	sub	r9, lr, #1	; 0x1
	                                                /* The following is usually faster than using a modulo */
                                                        unsigned long next = v / 10;
                                                        *--cp = to_char(v - (next * 10));
                                                        v = next;
                                                }
                                                *--cp = to_char(v);
    b200:	e28c3030 	add	r3, ip, #48	; 0x30
    b204:	e5c93000 	strb	r3, [r9]
    b208:	e59dc014 	ldr	ip, [sp, #20]
    b20c:	e069b00c 	rsb	fp, r9, ip
    b210:	eafffce1 	b	a59c <vfnprintf+0x4dc>
                }

                /* right-adjusting zero padding */
                if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
                    if (width - realsz > 0) {
                        PAD(width - realsz, zeroes);
    b214:	e59d2074 	ldr	r2, [sp, #116]
    b218:	e59d3040 	ldr	r3, [sp, #64]
    b21c:	e0632002 	rsb	r2, r3, r2
    b220:	e58d206c 	str	r2, [sp, #108]
    b224:	e1a04006 	mov	r4, r6
    b228:	e59d206c 	ldr	r2, [sp, #108]
    b22c:	e1540002 	cmp	r4, r2
    b230:	31a02004 	movcc	r2, r4
    b234:	e58d2300 	str	r2, [sp, #768]
    b238:	e59ac000 	ldr	ip, [sl]
    b23c:	e1a0000a 	mov	r0, sl
    b240:	e59f102c 	ldr	r1, [pc, #44]	; b274 <vfnprintf+0x11b4>
    b244:	e1a03007 	mov	r3, r7
    b248:	e1a0e00f 	mov	lr, pc
    b24c:	e59cf008 	ldr	pc, [ip, #8]
    b250:	e3500000 	cmp	r0, #0	; 0x0
    b254:	1afffc37 	bne	a338 <vfnprintf+0x278>
    b258:	e59d3300 	ldr	r3, [sp, #768]
    b25c:	e1540003 	cmp	r4, r3
    b260:	8a00002f 	bhi	b324 <vfnprintf+0x1264>
                        ret += width - realsz;
    b264:	e59d0040 	ldr	r0, [sp, #64]
    b268:	e0800006 	add	r0, r0, r6
    b26c:	e58d0040 	str	r0, [sp, #64]
    b270:	eafffe53 	b	abc4 <vfnprintf+0xb04>
    b274:	400007cc 	.word	0x400007cc
    b278:	00012ae4 	.word	0x00012ae4
    b27c:	400007dc 	.word	0x400007dc
    b280:	000129fc 	.word	0x000129fc
    b284:	000129bc 	.word	0x000129bc
    b288:	00012adc 	.word	0x00012adc
    b28c:	cccccccd 	.word	0xcccccccd
#endif // ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT

                case 'n':
#ifndef _NO_LONGLONG
                        if (flags & QUADINT)
                                *va_arg(arg, quad_t *) = ret;
    b290:	e59d1040 	ldr	r1, [sp, #64]
    b294:	e5952000 	ldr	r2, [r5]
    b298:	e1a03001 	mov	r3, r1
    b29c:	e1a04fc3 	asr	r4, r3, #31
    b2a0:	e2855004 	add	r5, r5, #4	; 0x4
    b2a4:	e8820018 	stm	r2, {r3, r4}
    b2a8:	e58d502c 	str	r5, [sp, #44]
    b2ac:	eafffb8e 	b	a0ec <vfnprintf+0x2c>
                        /*
                         * don't do unrealistic precision; just pad it with
                         * zeroes later, so buffer size stays rational.
                         */
                        if (prec > MAXFRACT) {
                                if ((ch != 'g' && ch != 'G') || (flags&ALT))
    b2b0:	e59d5038 	ldr	r5, [sp, #56]
    b2b4:	e3550067 	cmp	r5, #103	; 0x67
    b2b8:	13550047 	cmpne	r5, #71	; 0x47
    b2bc:	1a000005 	bne	b2d8 <vfnprintf+0x1218>
    b2c0:	e59dc03c 	ldr	ip, [sp, #60]
    b2c4:	e21c9001 	ands	r9, ip, #1	; 0x1
    b2c8:	03a0e00f 	moveq	lr, #15	; 0xf
    b2cc:	058d9054 	streq	r9, [sp, #84]
    b2d0:	058de05c 	streq	lr, [sp, #92]
    b2d4:	0afffd7e 	beq	a8d4 <vfnprintf+0x814>
                                        fpprec = prec - MAXFRACT;
    b2d8:	e59d005c 	ldr	r0, [sp, #92]
    b2dc:	e3a0100f 	mov	r1, #15	; 0xf
    b2e0:	e240000f 	sub	r0, r0, #15	; 0xf
    b2e4:	e58d0054 	str	r0, [sp, #84]
    b2e8:	e58d105c 	str	r1, [sp, #92]
    b2ec:	eafffd78 	b	a8d4 <vfnprintf+0x814>
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    b2f0:	e59d1058 	ldr	r1, [sp, #88]
    b2f4:	e1a03005 	mov	r3, r5
    b2f8:	e5d12000 	ldrb	r2, [r1]
    b2fc:	e1a0c001 	mov	ip, r1
    b300:	e1a05003 	mov	r5, r3
    b304:	eafffb96 	b	a164 <vfnprintf+0xa4>
                                                        v = next;
                                                }
                                                *--cp = to_char(v);
                                        }
                                        else {
                                                while (_uquad >= 10) {
    b308:	e3560009 	cmp	r6, #9	; 0x9
    b30c:	928d9f6f 	addls	r9, sp, #444	; 0x1bc
    b310:	92499001 	subls	r9, r9, #1	; 0x1
    b314:	9affff4d 	bls	b050 <vfnprintf+0xf90>
    b318:	eaffff2d 	b	afd4 <vfnprintf+0xf14>
    if ( ieeefp.number.sign ){  // this checks for <0.0 and -0.0
        number = -number;
        *signp = '-';
    }

    if (finite(number)) {
    b31c:	e3a06001 	mov	r6, #1	; 0x1
    b320:	eafffd86 	b	a940 <vfnprintf+0x880>
                    }
                }

                if (dprec - fieldsz > 0) {
                    /* leading zeroes from decimal precision */
                    PAD(dprec - fieldsz, zeroes);
    b324:	e59de040 	ldr	lr, [sp, #64]
    b328:	e083e00e 	add	lr, r3, lr
    b32c:	e58de040 	str	lr, [sp, #64]
    b330:	eafffc00 	b	a338 <vfnprintf+0x278>
                                goto done;
                        /* pretend it was %c with argument ch */
                        cp = buf;
                        *cp = ch;
                        size = 1;
                        sign = '\0';
    b334:	e59d5054 	ldr	r5, [sp, #84]
    b338:	e59d901c 	ldr	r9, [sp, #28]
    b33c:	e08b2005 	add	r2, fp, r5
    b340:	e3a08000 	mov	r8, #0	; 0x0
    b344:	eafffc48 	b	a46c <vfnprintf+0x3ac>
                        flags |= SHORTINT;
                        goto rflag;
                case 'l':
                        if (*fmt == 'l') {
                                fmt++;
                                flags |= QUADINT;
    b348:	e59d003c 	ldr	r0, [sp, #60]
    b34c:	e3800020 	orr	r0, r0, #32	; 0x20
    b350:	e58d003c 	str	r0, [sp, #60]
    b354:	e1a03005 	mov	r3, r5
    b358:	e5dc2001 	ldrb	r2, [ip, #1]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    b35c:	e1a05003 	mov	r5, r3
                case 'h':
                        flags |= SHORTINT;
                        goto rflag;
                case 'l':
                        if (*fmt == 'l') {
                                fmt++;
    b360:	e28cc001 	add	ip, ip, #1	; 0x1
    b364:	eafffb7e 	b	a164 <vfnprintf+0xa4>
        double fract;
        int dotrim, expcnt, gformat;
        double integer, tmp;

        dotrim = expcnt = gformat = 0;
        fract = modf(number, &integer);
    b368:	e28d9fbe 	add	r9, sp, #760	; 0x2f8
    b36c:	e1a00007 	mov	r0, r7
        char *p;
        double fract;
        int dotrim, expcnt, gformat;
        double integer, tmp;

        dotrim = expcnt = gformat = 0;
    b370:	e3a0e000 	mov	lr, #0	; 0x0
        fract = modf(number, &integer);
    b374:	e1a02009 	mov	r2, r9
    b378:	e1a01008 	mov	r1, r8
        char *p;
        double fract;
        int dotrim, expcnt, gformat;
        double integer, tmp;

        dotrim = expcnt = gformat = 0;
    b37c:	e58de300 	str	lr, [sp, #768]
        fract = modf(number, &integer);
    b380:	eb000709 	bl	cfac <modf>

        /*
         * get integer portion of number; put into the end of the buffer; the
         * .01 is added for modf(356.0 / 10, &integer) returning .59999999...
         */
        for (p = endp - 1; integer; ++expcnt) {
    b384:	e28d4fbe 	add	r4, sp, #760	; 0x2f8
    b388:	e8940030 	ldm	r4, {r4, r5}
        double fract;
        int dotrim, expcnt, gformat;
        double integer, tmp;

        dotrim = expcnt = gformat = 0;
        fract = modf(number, &integer);
    b38c:	e58d0060 	str	r0, [sp, #96]
    b390:	e58d1064 	str	r1, [sp, #100]

        /*
         * get integer portion of number; put into the end of the buffer; the
         * .01 is added for modf(356.0 / 10, &integer) returning .59999999...
         */
        for (p = endp - 1; integer; ++expcnt) {
    b394:	e3a02000 	mov	r2, #0	; 0x0
    b398:	e3a03000 	mov	r3, #0	; 0x0
    b39c:	e1a00004 	mov	r0, r4
    b3a0:	e1a01005 	mov	r1, r5
    b3a4:	eb001a34 	bl	11c7c <__aeabi_dcmpeq>
    b3a8:	e3500000 	cmp	r0, #0	; 0x0
    b3ac:	128d7f6f 	addne	r7, sp, #444	; 0x1bc
    b3b0:	128d0078 	addne	r0, sp, #120	; 0x78
    b3b4:	12477001 	subne	r7, r7, #1	; 0x1
    b3b8:	158d001c 	strne	r0, [sp, #28]
    b3bc:	1a000025 	bne	b458 <vfnprintf+0x1398>
    b3c0:	e28d1078 	add	r1, sp, #120	; 0x78
    b3c4:	e28d6f6f 	add	r6, sp, #444	; 0x1bc
    b3c8:	e58d101c 	str	r1, [sp, #28]
    b3cc:	e2466002 	sub	r6, r6, #2	; 0x2
                tmp = modf(integer / 10, &integer);
    b3d0:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    b3d4:	e2833709 	add	r3, r3, #2359296	; 0x240000
    b3d8:	e1a00004 	mov	r0, r4
    b3dc:	e1a01005 	mov	r1, r5
    b3e0:	e3a02000 	mov	r2, #0	; 0x0
    b3e4:	eb00196f 	bl	119a8 <__aeabi_ddiv>
    b3e8:	e1a02009 	mov	r2, r9
    b3ec:	eb0006ee 	bl	cfac <modf>
                *p-- = to_char((int)((tmp + .01) * 10));
    b3f0:	e28f2e3d 	add	r2, pc, #976	; 0x3d0
    b3f4:	e892000c 	ldm	r2, {r2, r3}
        /*
         * get integer portion of number; put into the end of the buffer; the
         * .01 is added for modf(356.0 / 10, &integer) returning .59999999...
         */
        for (p = endp - 1; integer; ++expcnt) {
                tmp = modf(integer / 10, &integer);
    b3f8:	e58d02f0 	str	r0, [sp, #752]
    b3fc:	e58d12f4 	str	r1, [sp, #756]
                *p-- = to_char((int)((tmp + .01) * 10));
    b400:	eb0017c0 	bl	11308 <__adddf3>
    b404:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    b408:	e3a02000 	mov	r2, #0	; 0x0
    b40c:	e2833709 	add	r3, r3, #2359296	; 0x240000
    b410:	eb0018c0 	bl	11718 <__aeabi_dmul>
    b414:	eb001a44 	bl	11d2c <__aeabi_d2iz>
    b418:	e2800030 	add	r0, r0, #48	; 0x30
    b41c:	e5c60001 	strb	r0, [r6, #1]

        /*
         * get integer portion of number; put into the end of the buffer; the
         * .01 is added for modf(356.0 / 10, &integer) returning .59999999...
         */
        for (p = endp - 1; integer; ++expcnt) {
    b420:	e59d8300 	ldr	r8, [sp, #768]
    b424:	e28d4fbe 	add	r4, sp, #760	; 0x2f8
    b428:	e8940030 	ldm	r4, {r4, r5}
    b42c:	e288c001 	add	ip, r8, #1	; 0x1
    b430:	e1a00004 	mov	r0, r4
    b434:	e1a01005 	mov	r1, r5
    b438:	e3a02000 	mov	r2, #0	; 0x0
    b43c:	e3a03000 	mov	r3, #0	; 0x0
    b440:	e58dc300 	str	ip, [sp, #768]
    b444:	eb001a0c 	bl	11c7c <__aeabi_dcmpeq>
    b448:	e3500000 	cmp	r0, #0	; 0x0
                tmp = modf(integer / 10, &integer);
                *p-- = to_char((int)((tmp + .01) * 10));
    b44c:	e1a07006 	mov	r7, r6

        /*
         * get integer portion of number; put into the end of the buffer; the
         * .01 is added for modf(356.0 / 10, &integer) returning .59999999...
         */
        for (p = endp - 1; integer; ++expcnt) {
    b450:	e2466001 	sub	r6, r6, #1	; 0x1
    b454:	0affffdd 	beq	b3d0 <vfnprintf+0x1310>
                tmp = modf(integer / 10, &integer);
                *p-- = to_char((int)((tmp + .01) * 10));
        }
        switch (fmtch) {
    b458:	e59d2038 	ldr	r2, [sp, #56]
    b45c:	e2423045 	sub	r3, r2, #69	; 0x45
    b460:	e3530022 	cmp	r3, #34	; 0x22
    b464:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    b468:	ea000022 	b	b4f8 <vfnprintf+0x1438>
    b46c:	0000b7d8 	.word	0x0000b7d8
    b470:	0000b4f8 	.word	0x0000b4f8
    b474:	0000b5dc 	.word	0x0000b5dc
    b478:	0000b4f8 	.word	0x0000b4f8
    b47c:	0000b4f8 	.word	0x0000b4f8
    b480:	0000b4f8 	.word	0x0000b4f8
    b484:	0000b4f8 	.word	0x0000b4f8
    b488:	0000b4f8 	.word	0x0000b4f8
    b48c:	0000b4f8 	.word	0x0000b4f8
    b490:	0000b4f8 	.word	0x0000b4f8
    b494:	0000b4f8 	.word	0x0000b4f8
    b498:	0000b4f8 	.word	0x0000b4f8
    b49c:	0000b4f8 	.word	0x0000b4f8
    b4a0:	0000b4f8 	.word	0x0000b4f8
    b4a4:	0000b4f8 	.word	0x0000b4f8
    b4a8:	0000b4f8 	.word	0x0000b4f8
    b4ac:	0000b4f8 	.word	0x0000b4f8
    b4b0:	0000b4f8 	.word	0x0000b4f8
    b4b4:	0000b4f8 	.word	0x0000b4f8
    b4b8:	0000b4f8 	.word	0x0000b4f8
    b4bc:	0000b4f8 	.word	0x0000b4f8
    b4c0:	0000b4f8 	.word	0x0000b4f8
    b4c4:	0000b4f8 	.word	0x0000b4f8
    b4c8:	0000b4f8 	.word	0x0000b4f8
    b4cc:	0000b4f8 	.word	0x0000b4f8
    b4d0:	0000b4f8 	.word	0x0000b4f8
    b4d4:	0000b4f8 	.word	0x0000b4f8
    b4d8:	0000b4f8 	.word	0x0000b4f8
    b4dc:	0000b4f8 	.word	0x0000b4f8
    b4e0:	0000b4f8 	.word	0x0000b4f8
    b4e4:	0000b4f8 	.word	0x0000b4f8
    b4e8:	0000b4f8 	.word	0x0000b4f8
    b4ec:	0000b7d8 	.word	0x0000b7d8
    b4f0:	0000b504 	.word	0x0000b504
    b4f4:	0000b5dc 	.word	0x0000b5dc
    b4f8:	e3a0b000 	mov	fp, #0	; 0x0
    b4fc:	e28d7c03 	add	r7, sp, #768	; 0x300
    b500:	eafffd27 	b	a9a4 <vfnprintf+0x8e4>
        case 'f':
                /* reverse integer into beginning of buffer */
                if (expcnt)
    b504:	e59d3300 	ldr	r3, [sp, #768]
    b508:	e3530000 	cmp	r3, #0	; 0x0
    b50c:	0a000214 	beq	bd64 <vfnprintf+0x1ca4>
                        for (; ++p < endp; *t++ = *p);
    b510:	e59d4014 	ldr	r4, [sp, #20]
    b514:	e2873001 	add	r3, r7, #1	; 0x1
    b518:	e1540003 	cmp	r4, r3
    b51c:	959d501c 	ldrls	r5, [sp, #28]
    b520:	92854001 	addls	r4, r5, #1	; 0x1
    b524:	9a00000a 	bls	b554 <vfnprintf+0x1494>
    b528:	e59dc01c 	ldr	ip, [sp, #28]
    b52c:	e28c0d05 	add	r0, ip, #320	; 0x140
    b530:	e1a01007 	mov	r1, r7
    b534:	e2800003 	add	r0, r0, #3	; 0x3
    b538:	e28c2002 	add	r2, ip, #2	; 0x2
    b53c:	e5f13001 	ldrb	r3, [r1, #1]!
    b540:	e1510000 	cmp	r1, r0
    b544:	e5423001 	strb	r3, [r2, #-1]
    b548:	e1a04002 	mov	r4, r2
    b54c:	e2822001 	add	r2, r2, #1	; 0x1
    b550:	1afffff9 	bne	b53c <vfnprintf+0x147c>
                        *t++ = '0';
                /*
                 * if precision required or alternate flag set, add in a
                 * decimal point.
                 */
                if (prec || flags&ALT)
    b554:	e59d005c 	ldr	r0, [sp, #92]
    b558:	e3500000 	cmp	r0, #0	; 0x0
    b55c:	1a000002 	bne	b56c <vfnprintf+0x14ac>
    b560:	e59d103c 	ldr	r1, [sp, #60]
    b564:	e3110001 	tst	r1, #1	; 0x1
    b568:	0a000001 	beq	b574 <vfnprintf+0x14b4>
                        *t++ = '.';
    b56c:	e3a0302e 	mov	r3, #46	; 0x2e
    b570:	e4c43001 	strb	r3, [r4], #1
                /* if requires more precision and some fraction left */
                if (fract) {
    b574:	e28d0060 	add	r0, sp, #96	; 0x60
    b578:	e8900003 	ldm	r0, {r0, r1}
    b57c:	e3a02000 	mov	r2, #0	; 0x0
    b580:	e3a03000 	mov	r3, #0	; 0x0
    b584:	eb0019bc 	bl	11c7c <__aeabi_dcmpeq>
    b588:	e3500000 	cmp	r0, #0	; 0x0
    b58c:	0a0001dc 	beq	bd04 <vfnprintf+0x1c44>
                                } while (--prec && fract);
                        if (fract)
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
                }
                for (; prec--; *t++ = '0');
    b590:	e59d205c 	ldr	r2, [sp, #92]
    b594:	e3520000 	cmp	r2, #0	; 0x0
    b598:	059d301c 	ldreq	r3, [sp, #28]
                 * decimal point.
                 */
                if (prec || flags&ALT)
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
    b59c:	e2422001 	sub	r2, r2, #1	; 0x1
                                } while (--prec && fract);
                        if (fract)
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
                }
                for (; prec--; *t++ = '0');
    b5a0:	02830001 	addeq	r0, r3, #1	; 0x1
    b5a4:	0a0001e4 	beq	bd3c <vfnprintf+0x1c7c>
    b5a8:	e2822001 	add	r2, r2, #1	; 0x1
    b5ac:	e3a01000 	mov	r1, #0	; 0x0
    b5b0:	e3a03030 	mov	r3, #48	; 0x30
    b5b4:	e7c43001 	strb	r3, [r4, r1]
    b5b8:	e2811001 	add	r1, r1, #1	; 0x1
    b5bc:	e1510002 	cmp	r1, r2
    b5c0:	1afffffb 	bne	b5b4 <vfnprintf+0x14f4>
    b5c4:	e59dc01c 	ldr	ip, [sp, #28]
    b5c8:	e0842001 	add	r2, r4, r1
    b5cc:	e28c3001 	add	r3, ip, #1	; 0x1
    b5d0:	e063b002 	rsb	fp, r3, r2
    b5d4:	e28d7c03 	add	r7, sp, #768	; 0x300
    b5d8:	eafffcf1 	b	a9a4 <vfnprintf+0x8e4>
                t = exponent(t, expcnt, fmtch);
                break;
        case 'g':
        case 'G':
                /* a precision of 0 is treated as a precision of 1. */
                if (!prec)
    b5dc:	e59d305c 	ldr	r3, [sp, #92]
                 * ``The style used depends on the value converted; style e
                 * will be used only if the exponent resulting from the
                 * conversion is less than -4 or greater than the precision.''
                 *      -- ANSI X3J11
                 */
                if (expcnt > prec || (!expcnt && fract && fract < .0001)) {
    b5e0:	e59d8300 	ldr	r8, [sp, #768]
                t = exponent(t, expcnt, fmtch);
                break;
        case 'g':
        case 'G':
                /* a precision of 0 is treated as a precision of 1. */
                if (!prec)
    b5e4:	e3530000 	cmp	r3, #0	; 0x0
    b5e8:	e1a04003 	mov	r4, r3
    b5ec:	03a03001 	moveq	r3, #1	; 0x1
                 * ``The style used depends on the value converted; style e
                 * will be used only if the exponent resulting from the
                 * conversion is less than -4 or greater than the precision.''
                 *      -- ANSI X3J11
                 */
                if (expcnt > prec || (!expcnt && fract && fract < .0001)) {
    b5f0:	e1580003 	cmp	r8, r3
                t = exponent(t, expcnt, fmtch);
                break;
        case 'g':
        case 'G':
                /* a precision of 0 is treated as a precision of 1. */
                if (!prec)
    b5f4:	e58d305c 	str	r3, [sp, #92]
                 * ``The style used depends on the value converted; style e
                 * will be used only if the exponent resulting from the
                 * conversion is less than -4 or greater than the precision.''
                 *      -- ANSI X3J11
                 */
                if (expcnt > prec || (!expcnt && fract && fract < .0001)) {
    b5f8:	ca0001d2 	bgt	bd48 <vfnprintf+0x1c88>
    b5fc:	e3580000 	cmp	r8, #0	; 0x0
    b600:	0a00027d 	beq	bffc <HAL_BREAKINST_THUMB+0x13e>
                /*
                 * reverse integer into beginning of buffer,
                 * note, decrement precision
                 */
                if (expcnt)
                        for (; ++p < endp; *t++ = *p, --prec);
    b604:	e59d5014 	ldr	r5, [sp, #20]
    b608:	e2873001 	add	r3, r7, #1	; 0x1
    b60c:	e1550003 	cmp	r5, r3
    b610:	959dc01c 	ldrls	ip, [sp, #28]
    b614:	928c6001 	addls	r6, ip, #1	; 0x1
    b618:	9a000010 	bls	b660 <vfnprintf+0x15a0>
    b61c:	e59d101c 	ldr	r1, [sp, #28]
    b620:	e2810d05 	add	r0, r1, #320	; 0x140
    b624:	e2800003 	add	r0, r0, #3	; 0x3
                         * off-by-one problem, i.e. g/G considers the digit
                         * before the decimal point significant and e/E doesn't
                         * count it as precision.
                         */
                        --prec;
                        fmtch -= 2;             /* G->E, g->e */
    b628:	e2811002 	add	r1, r1, #2	; 0x2
    b62c:	e1a02007 	mov	r2, r7
                /*
                 * reverse integer into beginning of buffer,
                 * note, decrement precision
                 */
                if (expcnt)
                        for (; ++p < endp; *t++ = *p, --prec);
    b630:	e5f23001 	ldrb	r3, [r2, #1]!
    b634:	e1520000 	cmp	r2, r0
    b638:	e1a06001 	mov	r6, r1
    b63c:	e5413001 	strb	r3, [r1, #-1]
    b640:	e2811001 	add	r1, r1, #1	; 0x1
    b644:	1afffff9 	bne	b630 <vfnprintf+0x1570>
    b648:	e59d2014 	ldr	r2, [sp, #20]
    b64c:	e59d405c 	ldr	r4, [sp, #92]
    b650:	e0623007 	rsb	r3, r2, r7
    b654:	e2833001 	add	r3, r3, #1	; 0x1
    b658:	e0844003 	add	r4, r4, r3
    b65c:	e58d405c 	str	r4, [sp, #92]
                        *t++ = '0';
                /*
                 * if precision required or alternate flag set, add in a
                 * decimal point.  If no digits yet, add in leading 0.
                 */
                if (prec || flags&ALT) {
    b660:	e59dc05c 	ldr	ip, [sp, #92]
    b664:	e35c0000 	cmp	ip, #0	; 0x0
    b668:	159de03c 	ldrne	lr, [sp, #60]
    b66c:	120e9001 	andne	r9, lr, #1	; 0x1
    b670:	1a000003 	bne	b684 <vfnprintf+0x15c4>
    b674:	e59d003c 	ldr	r0, [sp, #60]
    b678:	e2109001 	ands	r9, r0, #1	; 0x1
    b67c:	059d705c 	ldreq	r7, [sp, #92]
    b680:	0a000002 	beq	b690 <vfnprintf+0x15d0>
                        dotrim = 1;
                        *t++ = '.';
    b684:	e3a0302e 	mov	r3, #46	; 0x2e
    b688:	e4c63001 	strb	r3, [r6], #1
    b68c:	e3a07001 	mov	r7, #1	; 0x1
                }
                else
                        dotrim = 0;
                /* if requires more precision and some fraction left */
                if (fract) {
    b690:	e28d0060 	add	r0, sp, #96	; 0x60
    b694:	e8900003 	ldm	r0, {r0, r1}
    b698:	e3a02000 	mov	r2, #0	; 0x0
    b69c:	e3a03000 	mov	r3, #0	; 0x0
    b6a0:	eb001975 	bl	11c7c <__aeabi_dcmpeq>
    b6a4:	e3500000 	cmp	r0, #0	; 0x0
    b6a8:	159d101c 	ldrne	r1, [sp, #28]
    b6ac:	12810001 	addne	r0, r1, #1	; 0x1
    b6b0:	1a000033 	bne	b784 <vfnprintf+0x16c4>
                        if (prec) {
    b6b4:	e59d205c 	ldr	r2, [sp, #92]
    b6b8:	e3520000 	cmp	r2, #0	; 0x0
    b6bc:	0a000023 	beq	b750 <vfnprintf+0x1690>
    b6c0:	e28d8e2f 	add	r8, sp, #752	; 0x2f0
                                do {
                                        fract = modf(fract * 10, &tmp);
    b6c4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    b6c8:	e2833709 	add	r3, r3, #2359296	; 0x240000
    b6cc:	e28d0060 	add	r0, sp, #96	; 0x60
    b6d0:	e8900003 	ldm	r0, {r0, r1}
    b6d4:	e3a02000 	mov	r2, #0	; 0x0
    b6d8:	eb00180e 	bl	11718 <__aeabi_dmul>
    b6dc:	e1a02008 	mov	r2, r8
    b6e0:	eb000631 	bl	cfac <modf>
                                        *t++ = to_char((int)tmp);
    b6e4:	e28d4e2f 	add	r4, sp, #752	; 0x2f0
    b6e8:	e8940030 	ldm	r4, {r4, r5}
                        dotrim = 0;
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec) {
                                do {
                                        fract = modf(fract * 10, &tmp);
    b6ec:	e58d0060 	str	r0, [sp, #96]
    b6f0:	e58d1064 	str	r1, [sp, #100]
                                        *t++ = to_char((int)tmp);
    b6f4:	e1a01005 	mov	r1, r5
    b6f8:	e1a00004 	mov	r0, r4
    b6fc:	eb00198a 	bl	11d2c <__aeabi_d2iz>
    b700:	e2800030 	add	r0, r0, #48	; 0x30
    b704:	e4c60001 	strb	r0, [r6], #1
                else
                        dotrim = 0;
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec) {
                                do {
    b708:	e1a01005 	mov	r1, r5
    b70c:	e1a00004 	mov	r0, r4
    b710:	e3a02000 	mov	r2, #0	; 0x0
    b714:	e3a03000 	mov	r3, #0	; 0x0
    b718:	eb001957 	bl	11c7c <__aeabi_dcmpeq>
    b71c:	e3500000 	cmp	r0, #0	; 0x0
    b720:	1affffe7 	bne	b6c4 <vfnprintf+0x1604>
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while(!tmp);
                                while (--prec && fract) {
    b724:	e59d305c 	ldr	r3, [sp, #92]
    b728:	e2533001 	subs	r3, r3, #1	; 0x1
    b72c:	e58d305c 	str	r3, [sp, #92]
    b730:	1a00014f 	bne	bc74 <vfnprintf+0x1bb4>
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                }
                        }
                        if (fract)
    b734:	e28d0060 	add	r0, sp, #96	; 0x60
    b738:	e8900003 	ldm	r0, {r0, r1}
    b73c:	e3a02000 	mov	r2, #0	; 0x0
    b740:	e3a03000 	mov	r3, #0	; 0x0
    b744:	eb00194c 	bl	11c7c <__aeabi_dcmpeq>
    b748:	e3500000 	cmp	r0, #0	; 0x0
    b74c:	1a000248 	bne	c074 <HAL_BREAKINST_THUMB+0x1b6>
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
    b750:	e59d401c 	ldr	r4, [sp, #28]
    b754:	e28dcfc1 	add	ip, sp, #772	; 0x304
    b758:	e246e001 	sub	lr, r6, #1	; 0x1
    b75c:	e3a02000 	mov	r2, #0	; 0x0
    b760:	e28cc002 	add	ip, ip, #2	; 0x2
    b764:	e28d0060 	add	r0, sp, #96	; 0x60
    b768:	e8900003 	ldm	r0, {r0, r1}
    b76c:	e2843001 	add	r3, r4, #1	; 0x1
    b770:	e3a05000 	mov	r5, #0	; 0x0
    b774:	e58de000 	str	lr, [sp]
    b778:	e98d1004 	stmib	sp, {r2, ip}
    b77c:	ebfffa03 	bl	9f90 <_ZL5rounddPiPcS0_cS0_>
    b780:	e58d505c 	str	r5, [sp, #92]
                }
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
    b784:	e3590000 	cmp	r9, #0	; 0x0
    b788:	0a0001ce 	beq	bec8 <HAL_BREAKINST_THUMB+0xa>
                        for (; prec--; *t++ = '0');
    b78c:	e59dc05c 	ldr	ip, [sp, #92]
    b790:	e35c0000 	cmp	ip, #0	; 0x0
    b794:	13a03000 	movne	r3, #0	; 0x0
    b798:	13a02030 	movne	r2, #48	; 0x30
    b79c:	0a0001d7 	beq	bf00 <HAL_BREAKINST_THUMB+0x42>
    b7a0:	e7c62003 	strb	r2, [r6, r3]
    b7a4:	e59de05c 	ldr	lr, [sp, #92]
    b7a8:	e2833001 	add	r3, r3, #1	; 0x1
    b7ac:	e153000e 	cmp	r3, lr
    b7b0:	1afffffa 	bne	b7a0 <vfnprintf+0x16e0>
    b7b4:	e0863003 	add	r3, r6, r3
    b7b8:	e060b003 	rsb	fp, r0, r3
    b7bc:	e28d7c03 	add	r7, sp, #768	; 0x300
    b7c0:	eafffc77 	b	a9a4 <vfnprintf+0x8e4>
    b7c4:	e1a00000 	nop			(mov r0,r0)
    b7c8:	47ae147b 	.word	0x47ae147b
    b7cc:	3f847ae1 	.word	0x3f847ae1
    b7d0:	400007dc 	.word	0x400007dc
    b7d4:	66666667 	.word	0x66666667
    b7d8:	e59d8300 	ldr	r8, [sp, #768]
                                } while (--prec && fract);
                        if (fract)
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
                }
                for (; prec--; *t++ = '0');
    b7dc:	e59d9038 	ldr	r9, [sp, #56]
    b7e0:	e3a0b000 	mov	fp, #0	; 0x0
                break;
        case 'e':
        case 'E':
eformat:        if (expcnt) {
    b7e4:	e3580000 	cmp	r8, #0	; 0x0
    b7e8:	0a0000ef 	beq	bbac <vfnprintf+0x1aec>
                        *t++ = *++p;
                        if (prec || flags&ALT)
    b7ec:	e59de05c 	ldr	lr, [sp, #92]
                for (; prec--; *t++ = '0');
                break;
        case 'e':
        case 'E':
eformat:        if (expcnt) {
                        *t++ = *++p;
    b7f0:	e5d73001 	ldrb	r3, [r7, #1]
                        if (prec || flags&ALT)
    b7f4:	e35e0000 	cmp	lr, #0	; 0x0
                for (; prec--; *t++ = '0');
                break;
        case 'e':
        case 'E':
eformat:        if (expcnt) {
                        *t++ = *++p;
    b7f8:	e5cd3079 	strb	r3, [sp, #121]
    b7fc:	e2871001 	add	r1, r7, #1	; 0x1
                        if (prec || flags&ALT)
    b800:	1a000186 	bne	be20 <vfnprintf+0x1d60>
    b804:	e59d003c 	ldr	r0, [sp, #60]
    b808:	e3100001 	tst	r0, #1	; 0x1
                }

        }
done:
error:
        return (((Cyg_OutputStream *) stream)->get_error() ? EOF : ret);
    b80c:	059d001c 	ldreq	r0, [sp, #28]
    b810:	02804002 	addeq	r4, r0, #2	; 0x2
        case 'e':
        case 'E':
eformat:        if (expcnt) {
                        *t++ = *++p;
                        if (prec || flags&ALT)
                                *t++ = '.';
    b814:	13a0302e 	movne	r3, #46	; 0x2e
    b818:	159d201c 	ldrne	r2, [sp, #28]
    b81c:	15cd307a 	strbne	r3, [sp, #122]
    b820:	12824003 	addne	r4, r2, #3	; 0x3
                        /*
                         * if done precision and more of the integer component,
                         * round using it; adjust fract so we don't re-round
                         * later.
                         */
                        if (!prec && ++p < endp) {
    b824:	e59d2014 	ldr	r2, [sp, #20]
    b828:	e2813001 	add	r3, r1, #1	; 0x1
    b82c:	e1530002 	cmp	r3, r2
    b830:	2a000084 	bcs	ba48 <vfnprintf+0x1988>
                                fract = 0;
                                startp = round((double)0, &expcnt, startp,
                                    t - 1, *p, signp);
    b834:	e244c001 	sub	ip, r4, #1	; 0x1
    b838:	e59d501c 	ldr	r5, [sp, #28]
    b83c:	e5d1e001 	ldrb	lr, [r1, #1]
    b840:	e28d7c03 	add	r7, sp, #768	; 0x300
    b844:	e58dc000 	str	ip, [sp]
    b848:	e28dcfc1 	add	ip, sp, #772	; 0x304
    b84c:	e3a01000 	mov	r1, #0	; 0x0
    b850:	e28cc002 	add	ip, ip, #2	; 0x2
    b854:	e3a00000 	mov	r0, #0	; 0x0
    b858:	e1a02007 	mov	r2, r7
    b85c:	e2853001 	add	r3, r5, #1	; 0x1
    b860:	e58de004 	str	lr, [sp, #4]
    b864:	e58dc008 	str	ip, [sp, #8]
    b868:	ebfff9c8 	bl	9f90 <_ZL5rounddPiPcS0_cS0_>
    b86c:	e3a01000 	mov	r1, #0	; 0x0
    b870:	e1a06000 	mov	r6, r0
    b874:	e3a00000 	mov	r0, #0	; 0x0
    b878:	e58d0060 	str	r0, [sp, #96]
    b87c:	e58d1064 	str	r1, [sp, #100]
    b880:	e3a01000 	mov	r1, #0	; 0x0
    b884:	e59d8300 	ldr	r8, [sp, #768]
    b888:	e58d105c 	str	r1, [sp, #92]
                        }
                        /* adjust expcnt for digit in front of decimal */
                        --expcnt;
    b88c:	e2483001 	sub	r3, r8, #1	; 0x1
    b890:	e59d205c 	ldr	r2, [sp, #92]
    b894:	e58d3300 	str	r3, [sp, #768]
    b898:	e2425001 	sub	r5, r2, #1	; 0x1
                        *t++ = '0';
                        if (prec || flags&ALT)
                                *t++ = '.';
                }
                /* if requires more precision and some fraction left */
                if (fract) {
    b89c:	e28d0060 	add	r0, sp, #96	; 0x60
    b8a0:	e8900003 	ldm	r0, {r0, r1}
    b8a4:	e3a02000 	mov	r2, #0	; 0x0
    b8a8:	e3a03000 	mov	r3, #0	; 0x0
    b8ac:	eb0018f2 	bl	11c7c <__aeabi_dcmpeq>
    b8b0:	e3500000 	cmp	r0, #0	; 0x0
    b8b4:	0a0000ab 	beq	bb68 <vfnprintf+0x1aa8>
                        if (fract)
                                startp = round(fract, &expcnt, startp,
                                    t - 1, (char)0, signp);
                }
                /* if requires more precision */
                for (; prec--; *t++ = '0');
    b8b8:	e59de05c 	ldr	lr, [sp, #92]
    b8bc:	e35e0000 	cmp	lr, #0	; 0x0
    b8c0:	0a000007 	beq	b8e4 <vfnprintf+0x1824>
    b8c4:	e2852001 	add	r2, r5, #1	; 0x1
    b8c8:	e3a03000 	mov	r3, #0	; 0x0
    b8cc:	e3a01030 	mov	r1, #48	; 0x30
    b8d0:	e7c41003 	strb	r1, [r4, r3]
    b8d4:	e2833001 	add	r3, r3, #1	; 0x1
    b8d8:	e1530002 	cmp	r3, r2
    b8dc:	1afffffb 	bne	b8d0 <vfnprintf+0x1810>
    b8e0:	e0844003 	add	r4, r4, r3

                /* unless alternate flag, trim any g/G format trailing 0's */
                if (gformat && !(flags&ALT)) {
    b8e4:	e35b0000 	cmp	fp, #0	; 0x0
    b8e8:	0a000002 	beq	b8f8 <vfnprintf+0x1838>
    b8ec:	e59d003c 	ldr	r0, [sp, #60]
    b8f0:	e3100001 	tst	r0, #1	; 0x1
    b8f4:	0a000046 	beq	ba14 <vfnprintf+0x1954>
                        while (t > startp && *--t == '0');
                        if (*t == '.')
                                --t;
                        ++t;
                }
                t = exponent(t, expcnt, fmtch);
    b8f8:	e59dc300 	ldr	ip, [sp, #768]
exponent(char *p, int exp, int fmtch)
{
        char *t;
        char expbuf[MAXEXP];

        *p++ = fmtch;
    b8fc:	e1a02004 	mov	r2, r4
        if (exp < 0) {
    b900:	e35c0000 	cmp	ip, #0	; 0x0
exponent(char *p, int exp, int fmtch)
{
        char *t;
        char expbuf[MAXEXP];

        *p++ = fmtch;
    b904:	e4c29001 	strb	r9, [r2], #1
        if (exp < 0) {
                exp = -exp;
                *p++ = '-';
    b908:	b3a0302d 	movlt	r3, #45	; 0x2d
        }
        else
                *p++ = '+';
    b90c:	a3a0302b 	movge	r3, #43	; 0x2b
        char *t;
        char expbuf[MAXEXP];

        *p++ = fmtch;
        if (exp < 0) {
                exp = -exp;
    b910:	b26cc000 	rsblt	ip, ip, #0	; 0x0
                *p++ = '-';
    b914:	b5c43001 	strblt	r3, [r4, #1]
    b918:	b2820001 	addlt	r0, r2, #1	; 0x1
        }
        else
                *p++ = '+';
    b91c:	a5c43001 	strbge	r3, [r4, #1]
    b920:	a2820001 	addge	r0, r2, #1	; 0x1
        t = expbuf + MAXEXP;
        if (exp > 9) {
    b924:	e35c0009 	cmp	ip, #9	; 0x9
    b928:	ca00006b 	bgt	badc <vfnprintf+0x1a1c>
                } while ((exp /= 10) > 9);
                *--t = to_char(exp);
                for (; t < expbuf + MAXEXP; *p++ = *t++);
        }
        else {
                *p++ = '0';
    b92c:	e1a03000 	mov	r3, r0
    b930:	e3a02030 	mov	r2, #48	; 0x30
    b934:	e4c32001 	strb	r2, [r3], #1
                *p++ = to_char(exp);
    b938:	e08c1002 	add	r1, ip, r2
    b93c:	e5c01001 	strb	r1, [r0, #1]
    b940:	e2830001 	add	r0, r3, #1	; 0x1
    b944:	e066b000 	rsb	fp, r6, r0
    b948:	eafffc15 	b	a9a4 <vfnprintf+0x8e4>
                         *      -- ANSI X3J11
                         * They don't exclude field widths read from args.
                         */
                        if ((width = va_arg(arg, int)) >= 0)
                                goto rflag;
                        width = -width;
    b94c:	e59d0044 	ldr	r0, [sp, #68]
    b950:	e2600000 	rsb	r0, r0, #0	; 0x0
    b954:	e58d0044 	str	r0, [sp, #68]
    b958:	eafffb90 	b	a7a0 <vfnprintf+0x6e0>
                                        if (size > prec)
                                                size = prec;
                                } else
                                        size = prec;
                        } else
                                size = strlen(cp);
    b95c:	e1a00009 	mov	r0, r9
    b960:	eb000565 	bl	cefc <__strlen>
    b964:	e1a0b000 	mov	fp, r0
    b968:	eafffc69 	b	ab14 <vfnprintf+0xa54>
#endif

                /* left-adjusting padding (always blank) */
                if (flags & LADJUST) {
                    if (width - realsz > 0) {
                        PAD(width - realsz, blanks);
    b96c:	e1540008 	cmp	r4, r8
    b970:	31a02004 	movcc	r2, r4
    b974:	21a02008 	movcs	r2, r8
    b978:	e58d2300 	str	r2, [sp, #768]
    b97c:	e1a03007 	mov	r3, r7
    b980:	e59ac000 	ldr	ip, [sl]
    b984:	e1a0000a 	mov	r0, sl
    b988:	e51f11c0 	ldr	r1, [pc, #-448]	; b7d0 <vfnprintf+0x1710>
    b98c:	e1a0e00f 	mov	lr, pc
    b990:	e59cf008 	ldr	pc, [ip, #8]
    b994:	e3500000 	cmp	r0, #0	; 0x0
    b998:	1afffa66 	bne	a338 <vfnprintf+0x278>
    b99c:	e59d3300 	ldr	r3, [sp, #768]
    b9a0:	e1540003 	cmp	r4, r3
    b9a4:	8afffd53 	bhi	aef8 <vfnprintf+0xe38>
                        ret += width - realsz;
    b9a8:	e59de040 	ldr	lr, [sp, #64]
    b9ac:	e08ee006 	add	lr, lr, r6
    b9b0:	e58de040 	str	lr, [sp, #64]
    b9b4:	eafff9cc 	b	a0ec <vfnprintf+0x2c>
                        continue;       /* no output */
                case 'O':
                        flags |= LONGINT;
                        /*FALLTHROUGH*/
                case 'o':
                        _uquad = UARG();
    b9b8:	e59d103c 	ldr	r1, [sp, #60]
    b9bc:	e211ec02 	ands	lr, r1, #512	; 0x200
    b9c0:	1afffdcc 	bne	b0f8 <vfnprintf+0x1038>
    b9c4:	e5953000 	ldr	r3, [r5]
    b9c8:	e2855004 	add	r5, r5, #4	; 0x4
    b9cc:	e1a0c00e 	mov	ip, lr
    b9d0:	e1a06003 	mov	r6, r3
    b9d4:	e3a07000 	mov	r7, #0	; 0x0
    b9d8:	e58d502c 	str	r5, [sp, #44]
    b9dc:	eafffa83 	b	a3f0 <vfnprintf+0x330>
                                *va_arg(arg, quad_t *) = ret;
                        else 
#endif
                        if (flags & LONGINT)
                                *va_arg(arg, long *) = ret;
                        else if (flags & SHORTINT)
    b9e0:	e59dc03c 	ldr	ip, [sp, #60]
    b9e4:	e31c0040 	tst	ip, #64	; 0x40
    b9e8:	0a000021 	beq	ba74 <vfnprintf+0x19b4>
                                *va_arg(arg, short *) = ret;
    b9ec:	e5953000 	ldr	r3, [r5]
    b9f0:	e59de040 	ldr	lr, [sp, #64]
    b9f4:	e2855004 	add	r5, r5, #4	; 0x4
    b9f8:	e1c3e0b0 	strh	lr, [r3]
    b9fc:	e58d502c 	str	r5, [sp, #44]
    ba00:	eafff9b9 	b	a0ec <vfnprintf+0x2c>
#endif

                /* left-adjusting padding (always blank) */
                if (flags & LADJUST) {
                    if (width - realsz > 0) {
                        PAD(width - realsz, blanks);
    ba04:	e59d5040 	ldr	r5, [sp, #64]
    ba08:	e0835005 	add	r5, r3, r5
    ba0c:	e58d5040 	str	r5, [sp, #64]
    ba10:	eafffa48 	b	a338 <vfnprintf+0x278>
                /* if requires more precision */
                for (; prec--; *t++ = '0');

                /* unless alternate flag, trim any g/G format trailing 0's */
                if (gformat && !(flags&ALT)) {
                        while (t > startp && *--t == '0');
    ba14:	e1560004 	cmp	r6, r4
                        /*
                         * if done precision and more of the integer component,
                         * round using it; adjust fract so we don't re-round
                         * later.
                         */
                        if (!prec && ++p < endp) {
    ba18:	25d43000 	ldrbcs	r3, [r4]
                /* if requires more precision */
                for (; prec--; *t++ = '0');

                /* unless alternate flag, trim any g/G format trailing 0's */
                if (gformat && !(flags&ALT)) {
                        while (t > startp && *--t == '0');
    ba1c:	2a000003 	bcs	ba30 <vfnprintf+0x1970>
    ba20:	e5742001 	ldrb	r2, [r4, #-1]!
    ba24:	e3520030 	cmp	r2, #48	; 0x30
    ba28:	e1a03002 	mov	r3, r2
    ba2c:	0a0000f7 	beq	be10 <vfnprintf+0x1d50>
                        if (*t == '.')
    ba30:	e353002e 	cmp	r3, #46	; 0x2e
                                --t;
                        ++t;
    ba34:	12844001 	addne	r4, r4, #1	; 0x1
    ba38:	1affffae 	bne	b8f8 <vfnprintf+0x1838>

                /* unless alternate flag, trim any g/G format trailing 0's */
                if (gformat && !(flags&ALT)) {
                        while (t > startp && *--t == '0');
                        if (*t == '.')
                                --t;
    ba3c:	e2444001 	sub	r4, r4, #1	; 0x1
                        ++t;
    ba40:	e2844001 	add	r4, r4, #1	; 0x1
    ba44:	eaffffab 	b	b8f8 <vfnprintf+0x1838>
                        /*
                         * if done precision and more of the integer component,
                         * round using it; adjust fract so we don't re-round
                         * later.
                         */
                        if (!prec && ++p < endp) {
    ba48:	e59d301c 	ldr	r3, [sp, #28]
    ba4c:	e3a05000 	mov	r5, #0	; 0x0
    ba50:	e2836001 	add	r6, r3, #1	; 0x1
    ba54:	e58d505c 	str	r5, [sp, #92]
    ba58:	e28d7c03 	add	r7, sp, #768	; 0x300
    ba5c:	e59d8300 	ldr	r8, [sp, #768]
    ba60:	eaffff89 	b	b88c <vfnprintf+0x17cc>
                    PAD(dprec - fieldsz, zeroes);
                    ret += dprec - fieldsz;
                }

                /* the string or number proper */
                PRINT(cp, size);
    ba64:	e59d4040 	ldr	r4, [sp, #64]
    ba68:	e0834004 	add	r4, r3, r4
    ba6c:	e58d4040 	str	r4, [sp, #64]
    ba70:	eafffa30 	b	a338 <vfnprintf+0x278>
#endif
                        if (flags & LONGINT)
                                *va_arg(arg, long *) = ret;
                        else if (flags & SHORTINT)
                                *va_arg(arg, short *) = ret;
                        else if (flags & SIZET)
    ba74:	e59d003c 	ldr	r0, [sp, #60]
    ba78:	e3100c02 	tst	r0, #512	; 0x200
                                *va_arg(arg, size_t *) = ret;
    ba7c:	15953000 	ldrne	r3, [r5]
                        else
                                *va_arg(arg, int *) = ret;
    ba80:	05953000 	ldreq	r3, [r5]
                        if (flags & LONGINT)
                                *va_arg(arg, long *) = ret;
                        else if (flags & SHORTINT)
                                *va_arg(arg, short *) = ret;
                        else if (flags & SIZET)
                                *va_arg(arg, size_t *) = ret;
    ba84:	159d1040 	ldrne	r1, [sp, #64]
                        else
                                *va_arg(arg, int *) = ret;
    ba88:	059d2040 	ldreq	r2, [sp, #64]
                        if (flags & LONGINT)
                                *va_arg(arg, long *) = ret;
                        else if (flags & SHORTINT)
                                *va_arg(arg, short *) = ret;
                        else if (flags & SIZET)
                                *va_arg(arg, size_t *) = ret;
    ba8c:	12855004 	addne	r5, r5, #4	; 0x4
                        else
                                *va_arg(arg, int *) = ret;
    ba90:	02855004 	addeq	r5, r5, #4	; 0x4
                        if (flags & LONGINT)
                                *va_arg(arg, long *) = ret;
                        else if (flags & SHORTINT)
                                *va_arg(arg, short *) = ret;
                        else if (flags & SIZET)
                                *va_arg(arg, size_t *) = ret;
    ba94:	15831000 	strne	r1, [r3]
    ba98:	158d502c 	strne	r5, [sp, #44]
                        else
                                *va_arg(arg, int *) = ret;
    ba9c:	05832000 	streq	r2, [r3]
    baa0:	058d502c 	streq	r5, [sp, #44]
    baa4:	eafff990 	b	a0ec <vfnprintf+0x2c>
                                fmt--;
                                break;
                        }
                }
                if ((y = fmt - cp) != 0) {
                        PRINT(cp, y);
    baa8:	e59d1040 	ldr	r1, [sp, #64]
    baac:	e0831001 	add	r1, r3, r1
    bab0:	e58d1040 	str	r1, [sp, #64]
    bab4:	eafffa1f 	b	a338 <vfnprintf+0x278>
	default:
	    case_adj = 0;
	}
	if (isnan(number)) {
	    *t++ = 'N' + case_adj;
	    *t++ = 'A' + case_adj;
    bab8:	e2843041 	add	r3, r4, #65	; 0x41
    babc:	e28d4078 	add	r4, sp, #120	; 0x78
    bac0:	e5cd3079 	strb	r3, [sp, #121]
	    *t++ = 'N' + case_adj;
    bac4:	e5cd507a 	strb	r5, [sp, #122]
	    break;
	default:
	    case_adj = 0;
	}
	if (isnan(number)) {
	    *t++ = 'N' + case_adj;
    bac8:	e5cd5078 	strb	r5, [sp, #120]
	    *t++ = 'A' + case_adj;
	    *t++ = 'N' + case_adj;
    bacc:	e3a0b003 	mov	fp, #3	; 0x3
    bad0:	e28d7c03 	add	r7, sp, #768	; 0x300
    bad4:	e58d401c 	str	r4, [sp, #28]
    bad8:	eafffbb1 	b	a9a4 <vfnprintf+0x8e4>
                *p++ = '-';
        }
        else
                *p++ = '+';
        t = expbuf + MAXEXP;
        if (exp > 9) {
    badc:	e28d8e2f 	add	r8, sp, #752	; 0x2f0
                do {
                        *--t = to_char(exp % 10);
    bae0:	e51fe314 	ldr	lr, [pc, #-788]	; b7d4 <vfnprintf+0x1714>
                *p++ = '-';
        }
        else
                *p++ = '+';
        t = expbuf + MAXEXP;
        if (exp > 9) {
    bae4:	e1a04008 	mov	r4, r8
                do {
                        *--t = to_char(exp % 10);
    bae8:	e0c12c9e 	smull	r2, r1, lr, ip
    baec:	e1a02fcc 	asr	r2, ip, #31
    baf0:	e0622141 	rsb	r2, r2, r1, asr #2
    baf4:	e1a03082 	lsl	r3, r2, #1
    baf8:	e1a01182 	lsl	r1, r2, #3
    bafc:	e0833001 	add	r3, r3, r1
    bb00:	e063300c 	rsb	r3, r3, ip
    bb04:	e2833030 	add	r3, r3, #48	; 0x30
        }
        else
                *p++ = '+';
        t = expbuf + MAXEXP;
        if (exp > 9) {
                do {
    bb08:	e3520009 	cmp	r2, #9	; 0x9
    bb0c:	e1a0c002 	mov	ip, r2
                        *--t = to_char(exp % 10);
    bb10:	e5643001 	strb	r3, [r4, #-1]!
        }
        else
                *p++ = '+';
        t = expbuf + MAXEXP;
        if (exp > 9) {
                do {
    bb14:	cafffff3 	bgt	bae8 <vfnprintf+0x1a28>
                        *--t = to_char(exp % 10);
                } while ((exp /= 10) > 9);
                *--t = to_char(exp);
    bb18:	e2822030 	add	r2, r2, #48	; 0x30
    bb1c:	e2443001 	sub	r3, r4, #1	; 0x1
    bb20:	e20210ff 	and	r1, r2, #255	; 0xff
                for (; t < expbuf + MAXEXP; *p++ = *t++);
    bb24:	e1530008 	cmp	r3, r8
        t = expbuf + MAXEXP;
        if (exp > 9) {
                do {
                        *--t = to_char(exp % 10);
                } while ((exp /= 10) > 9);
                *--t = to_char(exp);
    bb28:	e5441001 	strb	r1, [r4, #-1]
                for (; t < expbuf + MAXEXP; *p++ = *t++);
    bb2c:	2affff84 	bcs	b944 <vfnprintf+0x1884>
    bb30:	e3a0c000 	mov	ip, #0	; 0x0
    bb34:	ea000001 	b	bb40 <vfnprintf+0x1a80>
    bb38:	e7d4100c 	ldrb	r1, [r4, ip]
    bb3c:	e28cc001 	add	ip, ip, #1	; 0x1
    bb40:	e084300c 	add	r3, r4, ip
    bb44:	e1580003 	cmp	r8, r3
    bb48:	e7c0100c 	strb	r1, [r0, ip]
    bb4c:	8afffff9 	bhi	bb38 <vfnprintf+0x1a78>
    bb50:	e28d3e2f 	add	r3, sp, #752	; 0x2f0
    bb54:	e2833001 	add	r3, r3, #1	; 0x1
    bb58:	e0643003 	rsb	r3, r4, r3
    bb5c:	e0800003 	add	r0, r0, r3
        }
        else {
                *p++ = '0';
                *p++ = to_char(exp);
    bb60:	e066b000 	rsb	fp, r6, r0
    bb64:	eafffb8e 	b	a9a4 <vfnprintf+0x8e4>
                        if (prec || flags&ALT)
                                *t++ = '.';
                }
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
    bb68:	e59de05c 	ldr	lr, [sp, #92]
    bb6c:	e35e0000 	cmp	lr, #0	; 0x0
    bb70:	1a000080 	bne	bd78 <vfnprintf+0x1cb8>
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while (--prec && fract);
                        if (fract)
                                startp = round(fract, &expcnt, startp,
                                    t - 1, (char)0, signp);
    bb74:	e28dcfc1 	add	ip, sp, #772	; 0x304
    bb78:	e28cc002 	add	ip, ip, #2	; 0x2
    bb7c:	e1a03006 	mov	r3, r6
    bb80:	e244e001 	sub	lr, r4, #1	; 0x1
    bb84:	e58dc008 	str	ip, [sp, #8]
    bb88:	e28d0060 	add	r0, sp, #96	; 0x60
    bb8c:	e8900003 	ldm	r0, {r0, r1}
    bb90:	e3a0c000 	mov	ip, #0	; 0x0
    bb94:	e1a02007 	mov	r2, r7
    bb98:	e58de000 	str	lr, [sp]
    bb9c:	e58dc004 	str	ip, [sp, #4]
    bba0:	ebfff8fa 	bl	9f90 <_ZL5rounddPiPcS0_cS0_>
    bba4:	e1a06000 	mov	r6, r0
    bba8:	eaffff4d 	b	b8e4 <vfnprintf+0x1824>
                        }
                        /* adjust expcnt for digit in front of decimal */
                        --expcnt;
                }
                /* until first fractional digit, decrement exponent */
                else if (fract) {
    bbac:	e28d0060 	add	r0, sp, #96	; 0x60
    bbb0:	e8900003 	ldm	r0, {r0, r1}
    bbb4:	e3a02000 	mov	r2, #0	; 0x0
    bbb8:	e3a03000 	mov	r3, #0	; 0x0
    bbbc:	eb00182e 	bl	11c7c <__aeabi_dcmpeq>
    bbc0:	e3500000 	cmp	r0, #0	; 0x0
    bbc4:	1a0000b1 	bne	be90 <vfnprintf+0x1dd0>
                        /* adjust expcnt for digit in front of decimal */
                        for (expcnt = -1;; --expcnt) {
    bbc8:	e3e03000 	mvn	r3, #0	; 0x0
    bbcc:	e58d3300 	str	r3, [sp, #768]
    bbd0:	e28d8e2f 	add	r8, sp, #752	; 0x2f0
    bbd4:	ea000002 	b	bbe4 <vfnprintf+0x1b24>
    bbd8:	e59d3300 	ldr	r3, [sp, #768]
    bbdc:	e2433001 	sub	r3, r3, #1	; 0x1
    bbe0:	e58d3300 	str	r3, [sp, #768]
                                fract = modf(fract * 10, &tmp);
    bbe4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    bbe8:	e2833709 	add	r3, r3, #2359296	; 0x240000
    bbec:	e28d0060 	add	r0, sp, #96	; 0x60
    bbf0:	e8900003 	ldm	r0, {r0, r1}
    bbf4:	e3a02000 	mov	r2, #0	; 0x0
    bbf8:	eb0016c6 	bl	11718 <__aeabi_dmul>
    bbfc:	e1a02008 	mov	r2, r8
    bc00:	eb0004e9 	bl	cfac <modf>
                                if (tmp)
    bc04:	e28d4e2f 	add	r4, sp, #752	; 0x2f0
    bc08:	e8940030 	ldm	r4, {r4, r5}
                }
                /* until first fractional digit, decrement exponent */
                else if (fract) {
                        /* adjust expcnt for digit in front of decimal */
                        for (expcnt = -1;; --expcnt) {
                                fract = modf(fract * 10, &tmp);
    bc0c:	e58d0060 	str	r0, [sp, #96]
    bc10:	e58d1064 	str	r1, [sp, #100]
                                if (tmp)
    bc14:	e3a02000 	mov	r2, #0	; 0x0
    bc18:	e3a03000 	mov	r3, #0	; 0x0
    bc1c:	e1a00004 	mov	r0, r4
    bc20:	e1a01005 	mov	r1, r5
    bc24:	eb001814 	bl	11c7c <__aeabi_dcmpeq>
    bc28:	e3500000 	cmp	r0, #0	; 0x0
    bc2c:	1affffe9 	bne	bbd8 <vfnprintf+0x1b18>
                                        break;
                        }
                        *t++ = to_char((int)tmp);
    bc30:	e1a00004 	mov	r0, r4
    bc34:	e1a01005 	mov	r1, r5
    bc38:	eb00183b 	bl	11d2c <__aeabi_d2iz>
                        if (prec || flags&ALT)
    bc3c:	e59d305c 	ldr	r3, [sp, #92]
                        for (expcnt = -1;; --expcnt) {
                                fract = modf(fract * 10, &tmp);
                                if (tmp)
                                        break;
                        }
                        *t++ = to_char((int)tmp);
    bc40:	e2800030 	add	r0, r0, #48	; 0x30
                        if (prec || flags&ALT)
    bc44:	e3530000 	cmp	r3, #0	; 0x0
                        for (expcnt = -1;; --expcnt) {
                                fract = modf(fract * 10, &tmp);
                                if (tmp)
                                        break;
                        }
                        *t++ = to_char((int)tmp);
    bc48:	e5cd0079 	strb	r0, [sp, #121]
                        if (prec || flags&ALT)
    bc4c:	1a0000e1 	bne	bfd8 <HAL_BREAKINST_THUMB+0x11a>
    bc50:	e59d403c 	ldr	r4, [sp, #60]
    bc54:	e3140001 	tst	r4, #1	; 0x1
    bc58:	1a0000de 	bne	bfd8 <HAL_BREAKINST_THUMB+0x11a>
    bc5c:	e59d501c 	ldr	r5, [sp, #28]
    bc60:	e28d7c03 	add	r7, sp, #768	; 0x300
    bc64:	e2854002 	add	r4, r5, #2	; 0x2
    bc68:	e2856001 	add	r6, r5, #1	; 0x1
    bc6c:	e3e05000 	mvn	r5, #0	; 0x0
    bc70:	eaffff09 	b	b89c <vfnprintf+0x17dc>
                        if (prec) {
                                do {
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while(!tmp);
                                while (--prec && fract) {
    bc74:	e28d0060 	add	r0, sp, #96	; 0x60
    bc78:	e8900003 	ldm	r0, {r0, r1}
    bc7c:	e3a02000 	mov	r2, #0	; 0x0
    bc80:	e3a03000 	mov	r3, #0	; 0x0
    bc84:	eb0017fc 	bl	11c7c <__aeabi_dcmpeq>
    bc88:	e3500000 	cmp	r0, #0	; 0x0
    bc8c:	1a000019 	bne	bcf8 <vfnprintf+0x1c38>
                                        fract = modf(fract * 10, &tmp);
    bc90:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    bc94:	e2833709 	add	r3, r3, #2359296	; 0x240000
    bc98:	e28d0060 	add	r0, sp, #96	; 0x60
    bc9c:	e8900003 	ldm	r0, {r0, r1}
    bca0:	e3a02000 	mov	r2, #0	; 0x0
    bca4:	eb00169b 	bl	11718 <__aeabi_dmul>
    bca8:	e1a02008 	mov	r2, r8
    bcac:	eb0004be 	bl	cfac <modf>
    bcb0:	e58d0060 	str	r0, [sp, #96]
    bcb4:	e58d1064 	str	r1, [sp, #100]
                                        *t++ = to_char((int)tmp);
    bcb8:	e28d0e2f 	add	r0, sp, #752	; 0x2f0
    bcbc:	e8900003 	ldm	r0, {r0, r1}
    bcc0:	eb001819 	bl	11d2c <__aeabi_d2iz>
                        if (prec) {
                                do {
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while(!tmp);
                                while (--prec && fract) {
    bcc4:	e59d405c 	ldr	r4, [sp, #92]
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
    bcc8:	e280c030 	add	ip, r0, #48	; 0x30
                        if (prec) {
                                do {
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while(!tmp);
                                while (--prec && fract) {
    bccc:	e2544001 	subs	r4, r4, #1	; 0x1
    bcd0:	e28d0060 	add	r0, sp, #96	; 0x60
    bcd4:	e8900003 	ldm	r0, {r0, r1}
    bcd8:	e58d405c 	str	r4, [sp, #92]
    bcdc:	e3a02000 	mov	r2, #0	; 0x0
    bce0:	e3a03000 	mov	r3, #0	; 0x0
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
    bce4:	e4c6c001 	strb	ip, [r6], #1
                        if (prec) {
                                do {
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while(!tmp);
                                while (--prec && fract) {
    bce8:	0afffe91 	beq	b734 <vfnprintf+0x1674>
    bcec:	eb0017e2 	bl	11c7c <__aeabi_dcmpeq>
    bcf0:	e3500000 	cmp	r0, #0	; 0x0
    bcf4:	0affffe5 	beq	bc90 <vfnprintf+0x1bd0>
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
                        for (; prec--; *t++ = '0');
                else if (dotrim) {
                        while (t > startp && *--t == '0');
                        if (*t != '.')
    bcf8:	e59dc01c 	ldr	ip, [sp, #28]
    bcfc:	e28c0001 	add	r0, ip, #1	; 0x1
    bd00:	eafffe9f 	b	b784 <vfnprintf+0x16c4>
                 */
                if (prec || flags&ALT)
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
    bd04:	e59d505c 	ldr	r5, [sp, #92]
    bd08:	e3550000 	cmp	r5, #0	; 0x0
    bd0c:	1a000087 	bne	bf30 <HAL_BREAKINST_THUMB+0x72>
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while (--prec && fract);
                        if (fract)
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
    bd10:	e59d501c 	ldr	r5, [sp, #28]
    bd14:	e28dcfc1 	add	ip, sp, #772	; 0x304
    bd18:	e244e001 	sub	lr, r4, #1	; 0x1
    bd1c:	e3a02000 	mov	r2, #0	; 0x0
    bd20:	e28cc002 	add	ip, ip, #2	; 0x2
    bd24:	e28d0060 	add	r0, sp, #96	; 0x60
    bd28:	e8900003 	ldm	r0, {r0, r1}
    bd2c:	e2853001 	add	r3, r5, #1	; 0x1
    bd30:	e58de000 	str	lr, [sp]
    bd34:	e98d1004 	stmib	sp, {r2, ip}
    bd38:	ebfff894 	bl	9f90 <_ZL5rounddPiPcS0_cS0_>
    bd3c:	e060b004 	rsb	fp, r0, r4
    bd40:	e28d7c03 	add	r7, sp, #768	; 0x300
    bd44:	eafffb16 	b	a9a4 <vfnprintf+0x8e4>
                         * precision; for the e/E format, this just causes an
                         * off-by-one problem, i.e. g/G considers the digit
                         * before the decimal point significant and e/E doesn't
                         * count it as precision.
                         */
                        --prec;
    bd48:	e59de05c 	ldr	lr, [sp, #92]
                        fmtch -= 2;             /* G->E, g->e */
    bd4c:	e59d0038 	ldr	r0, [sp, #56]
                         * precision; for the e/E format, this just causes an
                         * off-by-one problem, i.e. g/G considers the digit
                         * before the decimal point significant and e/E doesn't
                         * count it as precision.
                         */
                        --prec;
    bd50:	e24ee001 	sub	lr, lr, #1	; 0x1
    bd54:	e58de05c 	str	lr, [sp, #92]
                        fmtch -= 2;             /* G->E, g->e */
    bd58:	e2409002 	sub	r9, r0, #2	; 0x2
    bd5c:	e3a0b001 	mov	fp, #1	; 0x1
    bd60:	eafffe9f 	b	b7e4 <vfnprintf+0x1724>
        case 'f':
                /* reverse integer into beginning of buffer */
                if (expcnt)
                        for (; ++p < endp; *t++ = *p);
                else
                        *t++ = '0';
    bd64:	e59de01c 	ldr	lr, [sp, #28]
    bd68:	e3a03030 	mov	r3, #48	; 0x30
    bd6c:	e5cd3079 	strb	r3, [sp, #121]
    bd70:	e28e4002 	add	r4, lr, #2	; 0x2
    bd74:	eafffdf6 	b	b554 <vfnprintf+0x1494>
    bd78:	e28d8e2f 	add	r8, sp, #752	; 0x2f0
                }
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
                                        fract = modf(fract * 10, &tmp);
    bd7c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    bd80:	e2833709 	add	r3, r3, #2359296	; 0x240000
    bd84:	e28d0060 	add	r0, sp, #96	; 0x60
    bd88:	e8900003 	ldm	r0, {r0, r1}
    bd8c:	e3a02000 	mov	r2, #0	; 0x0
    bd90:	eb001660 	bl	11718 <__aeabi_dmul>
    bd94:	e1a02008 	mov	r2, r8
    bd98:	eb000483 	bl	cfac <modf>
    bd9c:	e58d0060 	str	r0, [sp, #96]
    bda0:	e58d1064 	str	r1, [sp, #100]
                                        *t++ = to_char((int)tmp);
    bda4:	e28d0e2f 	add	r0, sp, #752	; 0x2f0
    bda8:	e8900003 	ldm	r0, {r0, r1}
    bdac:	eb0017de 	bl	11d2c <__aeabi_d2iz>
                                *t++ = '.';
                }
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bdb0:	e59d505c 	ldr	r5, [sp, #92]
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
    bdb4:	e280c030 	add	ip, r0, #48	; 0x30
                                *t++ = '.';
                }
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bdb8:	e2555001 	subs	r5, r5, #1	; 0x1
    bdbc:	e28d0060 	add	r0, sp, #96	; 0x60
    bdc0:	e8900003 	ldm	r0, {r0, r1}
    bdc4:	e58d505c 	str	r5, [sp, #92]
    bdc8:	e3a02000 	mov	r2, #0	; 0x0
    bdcc:	e3a03000 	mov	r3, #0	; 0x0
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
    bdd0:	e4c4c001 	strb	ip, [r4], #1
                                *t++ = '.';
                }
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bdd4:	1a000007 	bne	bdf8 <vfnprintf+0x1d38>
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while (--prec && fract);
                        if (fract)
    bdd8:	e28d0060 	add	r0, sp, #96	; 0x60
    bddc:	e8900003 	ldm	r0, {r0, r1}
    bde0:	e3a02000 	mov	r2, #0	; 0x0
    bde4:	e3a03000 	mov	r3, #0	; 0x0
    bde8:	eb0017a3 	bl	11c7c <__aeabi_dcmpeq>
    bdec:	e3500000 	cmp	r0, #0	; 0x0
    bdf0:	0affff5f 	beq	bb74 <vfnprintf+0x1ab4>
    bdf4:	eafffeba 	b	b8e4 <vfnprintf+0x1824>
                                *t++ = '.';
                }
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bdf8:	eb00179f 	bl	11c7c <__aeabi_dcmpeq>
    bdfc:	e3500000 	cmp	r0, #0	; 0x0
    be00:	0affffdd 	beq	bd7c <vfnprintf+0x1cbc>
                        if (fract)
                                startp = round(fract, &expcnt, startp,
                                    t - 1, (char)0, signp);
                }
                /* if requires more precision */
                for (; prec--; *t++ = '0');
    be04:	e59d105c 	ldr	r1, [sp, #92]
    be08:	e2415001 	sub	r5, r1, #1	; 0x1
    be0c:	eafffeac 	b	b8c4 <vfnprintf+0x1804>

                /* unless alternate flag, trim any g/G format trailing 0's */
                if (gformat && !(flags&ALT)) {
                        while (t > startp && *--t == '0');
    be10:	e1560004 	cmp	r6, r4
    be14:	3affff01 	bcc	ba20 <vfnprintf+0x1960>
    be18:	e1a03002 	mov	r3, r2
    be1c:	eaffff03 	b	ba30 <vfnprintf+0x1970>
eformat:        if (expcnt) {
                        *t++ = *++p;
                        if (prec || flags&ALT)
                                *t++ = '.';
                        /* if requires more precision and some integer left */
                        for (; prec && ++p < endp; --prec)
    be20:	e59d2014 	ldr	r2, [sp, #20]
    be24:	e2811001 	add	r1, r1, #1	; 0x1
    be28:	e1510002 	cmp	r1, r2
        case 'e':
        case 'E':
eformat:        if (expcnt) {
                        *t++ = *++p;
                        if (prec || flags&ALT)
                                *t++ = '.';
    be2c:	e3a0302e 	mov	r3, #46	; 0x2e
    be30:	e5cd307a 	strb	r3, [sp, #122]
                        /* if requires more precision and some integer left */
                        for (; prec && ++p < endp; --prec)
    be34:	259d301c 	ldrcs	r3, [sp, #28]
    be38:	228d7c03 	addcs	r7, sp, #768	; 0x300
    be3c:	22836001 	addcs	r6, r3, #1	; 0x1
    be40:	22834003 	addcs	r4, r3, #3	; 0x3
    be44:	2afffe90 	bcs	b88c <vfnprintf+0x17cc>
        case 'e':
        case 'E':
eformat:        if (expcnt) {
                        *t++ = *++p;
                        if (prec || flags&ALT)
                                *t++ = '.';
    be48:	e28d207c 	add	r2, sp, #124	; 0x7c
                        /* if requires more precision and some integer left */
                        for (; prec && ++p < endp; --prec)
    be4c:	e59dc05c 	ldr	ip, [sp, #92]
                                *t++ = *p;
    be50:	e5d13000 	ldrb	r3, [r1]
eformat:        if (expcnt) {
                        *t++ = *++p;
                        if (prec || flags&ALT)
                                *t++ = '.';
                        /* if requires more precision and some integer left */
                        for (; prec && ++p < endp; --prec)
    be54:	e25cc001 	subs	ip, ip, #1	; 0x1
    be58:	e58dc05c 	str	ip, [sp, #92]
                                *t++ = *p;
    be5c:	e1a04002 	mov	r4, r2
    be60:	e5423001 	strb	r3, [r2, #-1]
eformat:        if (expcnt) {
                        *t++ = *++p;
                        if (prec || flags&ALT)
                                *t++ = '.';
                        /* if requires more precision and some integer left */
                        for (; prec && ++p < endp; --prec)
    be64:	0afffe6e 	beq	b824 <vfnprintf+0x1764>
    be68:	e59d3014 	ldr	r3, [sp, #20]
    be6c:	e2811001 	add	r1, r1, #1	; 0x1
    be70:	e1510003 	cmp	r1, r3
    be74:	e2842001 	add	r2, r4, #1	; 0x1
    be78:	3afffff3 	bcc	be4c <vfnprintf+0x1d8c>
    be7c:	e59d501c 	ldr	r5, [sp, #28]
    be80:	e28d7c03 	add	r7, sp, #768	; 0x300
    be84:	e2856001 	add	r6, r5, #1	; 0x1
    be88:	e59d8300 	ldr	r8, [sp, #768]
    be8c:	eafffe7e 	b	b88c <vfnprintf+0x17cc>
                        if (prec || flags&ALT)
                                *t++ = '.';
                }
                else {
                        *t++ = '0';
                        if (prec || flags&ALT)
    be90:	e59d005c 	ldr	r0, [sp, #92]
                        *t++ = to_char((int)tmp);
                        if (prec || flags&ALT)
                                *t++ = '.';
                }
                else {
                        *t++ = '0';
    be94:	e3a03030 	mov	r3, #48	; 0x30
                        if (prec || flags&ALT)
    be98:	e3500000 	cmp	r0, #0	; 0x0
                        *t++ = to_char((int)tmp);
                        if (prec || flags&ALT)
                                *t++ = '.';
                }
                else {
                        *t++ = '0';
    be9c:	e5cd3079 	strb	r3, [sp, #121]
                        if (prec || flags&ALT)
    bea0:	1a000019 	bne	bf0c <HAL_BREAKINST_THUMB+0x4e>
    bea4:	e59d103c 	ldr	r1, [sp, #60]
    bea8:	e3110001 	tst	r1, #1	; 0x1
    beac:	1a000016 	bne	bf0c <HAL_BREAKINST_THUMB+0x4e>
    beb0:	e59d201c 	ldr	r2, [sp, #28]
    beb4:	e3e05000 	mvn	r5, #0	; 0x0
    beb8:	e2824002 	add	r4, r2, #2	; 0x2
    bebc:	e2826001 	add	r6, r2, #1	; 0x1
    bec0:	e28d7c03 	add	r7, sp, #768	; 0x300
    bec4:	eafffe74 	b	b89c <vfnprintf+0x17dc>
                                    t - 1, (char)0, signp);
                }
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
                        for (; prec--; *t++ = '0');
                else if (dotrim) {
    bec8:	e3570000 	cmp	r7, #0	; 0x0
    becc:	0a00000b 	beq	bf00 <HAL_BREAKINST_THUMB+0x42>
                        while (t > startp && *--t == '0');
    bed0:	e1500006 	cmp	r0, r6
                for (; prec--; *t++ = '0');

                /* unless alternate flag, trim any g/G format trailing 0's */
                if (gformat && !(flags&ALT)) {
                        while (t > startp && *--t == '0');
                        if (*t == '.')
    bed4:	25d63000 	ldrbcs	r3, [r6]
                }
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
                        for (; prec--; *t++ = '0');
                else if (dotrim) {
                        while (t > startp && *--t == '0');
    bed8:	2a000003 	bcs	beec <HAL_BREAKINST_THUMB+0x2e>
    bedc:	e5761001 	ldrb	r1, [r6, #-1]!
    bee0:	e3510030 	cmp	r1, #48	; 0x30
    bee4:	e1a03001 	mov	r3, r1
    bee8:	0a00005d 	beq	c064 <HAL_BREAKINST_THUMB+0x1a6>
                        if (*t != '.')
    beec:	e353002e 	cmp	r3, #46	; 0x2e
                }
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
                        for (; prec--; *t++ = '0');
                else if (dotrim) {
                        while (t > startp && *--t == '0');
    bef0:	12863001 	addne	r3, r6, #1	; 0x1
    bef4:	1060b003 	rsbne	fp, r0, r3
    bef8:	128d7c03 	addne	r7, sp, #768	; 0x300
                        if (*t != '.')
    befc:	1afffaa8 	bne	a9a4 <vfnprintf+0x8e4>
    bf00:	e060b006 	rsb	fp, r0, r6
    bf04:	e28d7c03 	add	r7, sp, #768	; 0x300
    bf08:	eafffaa5 	b	a9a4 <vfnprintf+0x8e4>
                                *t++ = '.';
                }
                else {
                        *t++ = '0';
                        if (prec || flags&ALT)
                                *t++ = '.';
    bf0c:	e3a0302e 	mov	r3, #46	; 0x2e
    bf10:	e59dc01c 	ldr	ip, [sp, #28]
    bf14:	e5cd307a 	strb	r3, [sp, #122]
    bf18:	e59d305c 	ldr	r3, [sp, #92]
    bf1c:	e28c4003 	add	r4, ip, #3	; 0x3
    bf20:	e2435001 	sub	r5, r3, #1	; 0x1
    bf24:	e28c6001 	add	r6, ip, #1	; 0x1
    bf28:	e28d7c03 	add	r7, sp, #768	; 0x300
    bf2c:	eafffe5a 	b	b89c <vfnprintf+0x17dc>
    bf30:	e28d8e2f 	add	r8, sp, #752	; 0x2f0
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
                                        fract = modf(fract * 10, &tmp);
    bf34:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    bf38:	e2833709 	add	r3, r3, #2359296	; 0x240000
    bf3c:	e28d0060 	add	r0, sp, #96	; 0x60
    bf40:	e8900003 	ldm	r0, {r0, r1}
    bf44:	e3a02000 	mov	r2, #0	; 0x0
    bf48:	eb0015f2 	bl	11718 <__aeabi_dmul>
    bf4c:	e1a02008 	mov	r2, r8
    bf50:	eb000415 	bl	cfac <modf>
    bf54:	e58d0060 	str	r0, [sp, #96]
    bf58:	e58d1064 	str	r1, [sp, #100]
                                        *t++ = to_char((int)tmp);
    bf5c:	e28d0e2f 	add	r0, sp, #752	; 0x2f0
    bf60:	e8900003 	ldm	r0, {r0, r1}
    bf64:	eb001770 	bl	11d2c <__aeabi_d2iz>
                if (prec || flags&ALT)
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bf68:	e59de05c 	ldr	lr, [sp, #92]
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
    bf6c:	e280c030 	add	ip, r0, #48	; 0x30
                if (prec || flags&ALT)
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bf70:	e25ee001 	subs	lr, lr, #1	; 0x1
    bf74:	e28d0060 	add	r0, sp, #96	; 0x60
    bf78:	e8900003 	ldm	r0, {r0, r1}
    bf7c:	e58de05c 	str	lr, [sp, #92]
    bf80:	e3a02000 	mov	r2, #0	; 0x0
    bf84:	e3a03000 	mov	r3, #0	; 0x0
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
    bf88:	e4c4c001 	strb	ip, [r4], #1
                if (prec || flags&ALT)
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bf8c:	1a00000b 	bne	bfc0 <HAL_BREAKINST_THUMB+0x102>
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while (--prec && fract);
                        if (fract)
    bf90:	e3a03000 	mov	r3, #0	; 0x0
    bf94:	e28d0060 	add	r0, sp, #96	; 0x60
    bf98:	e8900003 	ldm	r0, {r0, r1}
    bf9c:	e3a02000 	mov	r2, #0	; 0x0
    bfa0:	eb001735 	bl	11c7c <__aeabi_dcmpeq>
    bfa4:	e3500000 	cmp	r0, #0	; 0x0
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
                }
                for (; prec--; *t++ = '0');
    bfa8:	159d001c 	ldrne	r0, [sp, #28]
    bfac:	12803001 	addne	r3, r0, #1	; 0x1
    bfb0:	1063b004 	rsbne	fp, r3, r4
    bfb4:	128d7c03 	addne	r7, sp, #768	; 0x300
                        if (prec)
                                do {
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                } while (--prec && fract);
                        if (fract)
    bfb8:	0affff54 	beq	bd10 <vfnprintf+0x1c50>
    bfbc:	eafffa78 	b	a9a4 <vfnprintf+0x8e4>
                if (prec || flags&ALT)
                        *t++ = '.';
                /* if requires more precision and some fraction left */
                if (fract) {
                        if (prec)
                                do {
    bfc0:	eb00172d 	bl	11c7c <__aeabi_dcmpeq>
    bfc4:	e3500000 	cmp	r0, #0	; 0x0
    bfc8:	0affffd9 	beq	bf34 <HAL_BREAKINST_THUMB+0x76>
                                } while (--prec && fract);
                        if (fract)
                                startp = round(fract, (int *)NULL, startp,
                                    t - 1, (char)0, signp);
                }
                for (; prec--; *t++ = '0');
    bfcc:	e59de05c 	ldr	lr, [sp, #92]
    bfd0:	e24e2001 	sub	r2, lr, #1	; 0x1
    bfd4:	eafffd73 	b	b5a8 <vfnprintf+0x14e8>
                                if (tmp)
                                        break;
                        }
                        *t++ = to_char((int)tmp);
                        if (prec || flags&ALT)
                                *t++ = '.';
    bfd8:	e59de01c 	ldr	lr, [sp, #28]
    bfdc:	e59dc05c 	ldr	ip, [sp, #92]
    bfe0:	e3a0302e 	mov	r3, #46	; 0x2e
    bfe4:	e5cd307a 	strb	r3, [sp, #122]
    bfe8:	e24c5001 	sub	r5, ip, #1	; 0x1
    bfec:	e28e4003 	add	r4, lr, #3	; 0x3
    bff0:	e28e6001 	add	r6, lr, #1	; 0x1
    bff4:	e28d7c03 	add	r7, sp, #768	; 0x300
    bff8:	eafffe27 	b	b89c <vfnprintf+0x17dc>
                 * ``The style used depends on the value converted; style e
                 * will be used only if the exponent resulting from the
                 * conversion is less than -4 or greater than the precision.''
                 *      -- ANSI X3J11
                 */
                if (expcnt > prec || (!expcnt && fract && fract < .0001)) {
    bffc:	e28d0060 	add	r0, sp, #96	; 0x60
    c000:	e8900003 	ldm	r0, {r0, r1}
    c004:	e3a02000 	mov	r2, #0	; 0x0
    c008:	e3a03000 	mov	r3, #0	; 0x0
    c00c:	eb00171a 	bl	11c7c <__aeabi_dcmpeq>
    c010:	e3500000 	cmp	r0, #0	; 0x0
    c014:	1a000006 	bne	c034 <HAL_BREAKINST_THUMB+0x176>
    c018:	e28d0060 	add	r0, sp, #96	; 0x60
    c01c:	e8900003 	ldm	r0, {r0, r1}
    c020:	e28f2060 	add	r2, pc, #96	; 0x60
    c024:	e892000c 	ldm	r2, {r2, r3}
    c028:	eb001719 	bl	11c94 <__aeabi_dcmplt>
    c02c:	e3500000 	cmp	r0, #0	; 0x0
    c030:	1affff44 	bne	bd48 <vfnprintf+0x1c88>
                 * note, decrement precision
                 */
                if (expcnt)
                        for (; ++p < endp; *t++ = *p, --prec);
                else
                        *t++ = '0';
    c034:	e59d501c 	ldr	r5, [sp, #28]
    c038:	e3a03030 	mov	r3, #48	; 0x30
    c03c:	e5cd3079 	strb	r3, [sp, #121]
    c040:	e2856002 	add	r6, r5, #2	; 0x2
    c044:	eafffd85 	b	b660 <vfnprintf+0x15a0>
                        sign = '+';
                        goto rflag;
                case '.':
                        if ((ch = *fmt++) == '*') {
                                x = va_arg(arg, int);
                                prec = x < 0 ? -1 : x;
    c048:	e5953000 	ldr	r3, [r5]
    c04c:	e1833fc3 	orr	r3, r3, r3, asr #31
    c050:	e58d305c 	str	r3, [sp, #92]
                case '+':
                        sign = '+';
                        goto rflag;
                case '.':
                        if ((ch = *fmt++) == '*') {
                                x = va_arg(arg, int);
    c054:	e2853004 	add	r3, r5, #4	; 0x4
                                prec = x < 0 ? -1 : x;
    c058:	e5dc2000 	ldrb	r2, [ip]
#ifdef CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
                fpprec = 0;
#endif
                width = 0;
                prec = -1;
                sign = '\0';
    c05c:	e1a05003 	mov	r5, r3
    c060:	eafff83f 	b	a164 <vfnprintf+0xa4>
                }
                /* alternate format, adds 0's for precision, else trim 0's */
                if (flags&ALT)
                        for (; prec--; *t++ = '0');
                else if (dotrim) {
                        while (t > startp && *--t == '0');
    c064:	e1500006 	cmp	r0, r6
    c068:	3affff9b 	bcc	bedc <HAL_BREAKINST_THUMB+0x1e>
    c06c:	e1a03001 	mov	r3, r1
    c070:	eaffff9d 	b	beec <HAL_BREAKINST_THUMB+0x2e>
                                while (--prec && fract) {
                                        fract = modf(fract * 10, &tmp);
                                        *t++ = to_char((int)tmp);
                                }
                        }
                        if (fract)
    c074:	e59d501c 	ldr	r5, [sp, #28]
    c078:	e3a0c000 	mov	ip, #0	; 0x0
    c07c:	e2850001 	add	r0, r5, #1	; 0x1
    c080:	e58dc05c 	str	ip, [sp, #92]
    c084:	eafffdbe 	b	b784 <vfnprintf+0x16c4>
    c088:	eb1c432d 	.word	0xeb1c432d
    c08c:	3f1a36e2 	.word	0x3f1a36e2

0000c090 <_ZL5exp10j>:
                              10.0,
                              100.0,
                              1000.0,
                              10000.0};
    
    if (x < (sizeof(powtab)/sizeof(double)))
    c090:	e3500004 	cmp	r0, #4	; 0x4
/*
 * compute 10**x by successive squaring.
 */

static const double
exp10(unsigned x)
    c094:	e92d4070 	push	{r4, r5, r6, lr}
                              10.0,
                              100.0,
                              1000.0,
                              10000.0};
    
    if (x < (sizeof(powtab)/sizeof(double)))
    c098:	9a000015 	bls	c0f4 <_ZL5exp10j+0x64>
        return powtab[x];
    else if (x & 1)
    c09c:	e3100001 	tst	r0, #1	; 0x1
    c0a0:	1a00000c 	bne	c0d8 <_ZL5exp10j+0x48>
        return 10.0 * exp10(x-1);
    else
        return exp10(x/2) * exp10(x/2);
    c0a4:	e1a060a0 	lsr	r6, r0, #1
    c0a8:	e1a00006 	mov	r0, r6
    c0ac:	ebfffff7 	bl	c090 <_ZL5exp10j>
    c0b0:	e1a04000 	mov	r4, r0
    c0b4:	e1a00006 	mov	r0, r6
    c0b8:	e1a05001 	mov	r5, r1
    c0bc:	ebfffff3 	bl	c090 <_ZL5exp10j>
    c0c0:	e1a02000 	mov	r2, r0
    c0c4:	e1a03001 	mov	r3, r1
    c0c8:	e1a00004 	mov	r0, r4
    c0cc:	e1a01005 	mov	r1, r5
    c0d0:	eb001590 	bl	11718 <__aeabi_dmul>
} // exp10()
    c0d4:	e8bd8070 	pop	{r4, r5, r6, pc}
                              10000.0};
    
    if (x < (sizeof(powtab)/sizeof(double)))
        return powtab[x];
    else if (x & 1)
        return 10.0 * exp10(x-1);
    c0d8:	e2400001 	sub	r0, r0, #1	; 0x1
    c0dc:	ebffffeb 	bl	c090 <_ZL5exp10j>
    c0e0:	e3a03101 	mov	r3, #1073741824	; 0x40000000
    c0e4:	e3a02000 	mov	r2, #0	; 0x0
    c0e8:	e2833709 	add	r3, r3, #2359296	; 0x240000
    c0ec:	eb001589 	bl	11718 <__aeabi_dmul>
    c0f0:	e8bd8070 	pop	{r4, r5, r6, pc}
                              100.0,
                              1000.0,
                              10000.0};
    
    if (x < (sizeof(powtab)/sizeof(double)))
        return powtab[x];
    c0f4:	e59f300c 	ldr	r3, [pc, #12]	; c108 <_ZL5exp10j+0x78>
    c0f8:	e1a02180 	lsl	r2, r0, #3
    c0fc:	e0833002 	add	r3, r3, r2
    c100:	e8930003 	ldm	r3, {r0, r1}
    c104:	e8bd8070 	pop	{r4, r5, r6, pc}
    c108:	00012b00 	.word	0x00012b00

0000c10c <strtod>:
        return r * exp10(dexp);
} // adjust()


externC double
strtod( const char *nptr, char **endptr )
    c10c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c110:	e24dd014 	sub	sp, sp, #20	; 0x14
    c114:	e58d000c 	str	r0, [sp, #12]
    c118:	e58d1008 	str	r1, [sp, #8]
    c11c:	e1a03000 	mov	r3, r0

    // endptr is allowed to be NULL, but if it isn't, we check it
    if (endptr != NULL)
        CYG_CHECK_DATA_PTR( endptr, "endptr is an invalid pointer!" );
    
    while(isspace(*nptr)) nptr++;
    c120:	e5d3c000 	ldrb	ip, [r3]
    c124:	e35c000c 	cmp	ip, #12	; 0xc
    c128:	135c0020 	cmpne	ip, #32	; 0x20
    c12c:	0a000013 	beq	c180 <strtod+0x74>
    c130:	e35c000d 	cmp	ip, #13	; 0xd
    c134:	135c000a 	cmpne	ip, #10	; 0xa
    c138:	0a000010 	beq	c180 <strtod+0x74>
    c13c:	e35c000b 	cmp	ip, #11	; 0xb
    c140:	135c0009 	cmpne	ip, #9	; 0x9
    c144:	0a00000d 	beq	c180 <strtod+0x74>
    if(*nptr == '\0')
    c148:	e35c0000 	cmp	ip, #0	; 0x0
    c14c:	1a00000d 	bne	c188 <strtod+0x7c>
    {   /* just leading spaces */
        if(endptr != NULL) *endptr = (char *)start;
    c150:	e59d2008 	ldr	r2, [sp, #8]
    c154:	e3520000 	cmp	r2, #0	; 0x0
    c158:	0a000089 	beq	c384 <strtod+0x278>
    c15c:	e59d200c 	ldr	r2, [sp, #12]
    c160:	e59d3008 	ldr	r3, [sp, #8]
    c164:	e5832000 	str	r2, [r3]
    c168:	e3a06000 	mov	r6, #0	; 0x0
    c16c:	e3a07000 	mov	r7, #0	; 0x0
  

    CYG_REPORT_RETVAL( retval );

    return retval;
} // strtod()
    c170:	e1a00006 	mov	r0, r6
    c174:	e1a01007 	mov	r1, r7
    c178:	e28dd014 	add	sp, sp, #20	; 0x14
    c17c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    // endptr is allowed to be NULL, but if it isn't, we check it
    if (endptr != NULL)
        CYG_CHECK_DATA_PTR( endptr, "endptr is an invalid pointer!" );
    
    while(isspace(*nptr)) nptr++;
    c180:	e2833001 	add	r3, r3, #1	; 0x1
    c184:	eaffffe5 	b	c120 <strtod+0x14>
        if(endptr != NULL) *endptr = (char *)start;
        return 0.0;
    }
    
    
    if(Issign(*nptr))
    c188:	e35c002d 	cmp	ip, #45	; 0x2d
    c18c:	13a01000 	movne	r1, #0	; 0x0
    c190:	03a01001 	moveq	r1, #1	; 0x1
    c194:	e35c002b 	cmp	ip, #43	; 0x2b
    c198:	11a02001 	movne	r2, r1
    c19c:	03812001 	orreq	r2, r1, #1	; 0x1
    c1a0:	e3520000 	cmp	r2, #0	; 0x0
    c1a4:	1a00006d 	bne	c360 <strtod+0x254>
    c1a8:	e1a0a002 	mov	sl, r2
    c1ac:	e3a0b000 	mov	fp, #0	; 0x0
    c1b0:	e1a07003 	mov	r7, r3
    c1b4:	e1a0400b 	mov	r4, fp
    c1b8:	e3a08000 	mov	r8, #0	; 0x0
    c1bc:	e3a09000 	mov	r9, #0	; 0x0
            if(endptr != NULL) *endptr = (char *)start;
            return 0.0;
        }
    }
    
    for(; (isdigit(*nptr) || (*nptr == '.')); nptr++)
    c1c0:	e24c6030 	sub	r6, ip, #48	; 0x30
static int
ten_mul(double *acc, int digit)
{
    /* [atw] Crude, but effective (at least on a KB)...
     */
    *acc *= 10;
    c1c4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
            if(endptr != NULL) *endptr = (char *)start;
            return 0.0;
        }
    }
    
    for(; (isdigit(*nptr) || (*nptr == '.')); nptr++)
    c1c8:	e3560009 	cmp	r6, #9	; 0x9
static int
ten_mul(double *acc, int digit)
{
    /* [atw] Crude, but effective (at least on a KB)...
     */
    *acc *= 10;
    c1cc:	e1a00008 	mov	r0, r8
    c1d0:	e1a01009 	mov	r1, r9
    c1d4:	e3a02000 	mov	r2, #0	; 0x0
    c1d8:	e2833709 	add	r3, r3, #2359296	; 0x240000
        if(*nptr == '.')
            flags |= DECP;
        else
        {
            if( ten_mul(&accum, Val(*nptr)) ) texp++;
            if(flags & DECP) texp--;
    c1dc:	e1a05007 	mov	r5, r7
            if(endptr != NULL) *endptr = (char *)start;
            return 0.0;
        }
    }
    
    for(; (isdigit(*nptr) || (*nptr == '.')); nptr++)
    c1e0:	9a00006a 	bls	c390 <strtod+0x284>
    c1e4:	e35c002e 	cmp	ip, #46	; 0x2e
    c1e8:	1a000003 	bne	c1fc <strtod+0xf0>
    {
        conv_done = 1;
        if(*nptr == '.')
            flags |= DECP;
    c1ec:	e38aa004 	orr	sl, sl, #4	; 0x4
        else
        {
            if( ten_mul(&accum, Val(*nptr)) ) texp++;
            if(flags & DECP) texp--;
    c1f0:	e5f7c001 	ldrb	ip, [r7, #1]!
    c1f4:	e3a04001 	mov	r4, #1	; 0x1
    c1f8:	eafffff0 	b	c1c0 <strtod+0xb4>
        }
    }
    
    if(Ise(*nptr))
    c1fc:	e35c0045 	cmp	ip, #69	; 0x45
    c200:	135c0065 	cmpne	ip, #101	; 0x65
            if(endptr != NULL) *endptr = (char *)start;
            return 0.0;
        }
    }
    
    for(; (isdigit(*nptr) || (*nptr == '.')); nptr++)
    c204:	e58d8004 	str	r8, [sp, #4]
    c208:	e58d9000 	str	r9, [sp]
            if( ten_mul(&accum, Val(*nptr)) ) texp++;
            if(flags & DECP) texp--;
        }
    }
    
    if(Ise(*nptr))
    c20c:	1a000034 	bne	c2e4 <strtod+0x1d8>
    {
        conv_done = 1;
        if(*++nptr != '\0') /* skip e|E */
    c210:	e5d73001 	ldrb	r3, [r7, #1]
    c214:	e3530000 	cmp	r3, #0	; 0x0
    c218:	e2875001 	add	r5, r7, #1	; 0x1
    c21c:	0a000072 	beq	c3ec <strtod+0x2e0>
    c220:	e1a02005 	mov	r2, r5
    c224:	e353000c 	cmp	r3, #12	; 0xc
    c228:	13530020 	cmpne	r3, #32	; 0x20
    c22c:	e1a05002 	mov	r5, r2
    c230:	0a00006f 	beq	c3f4 <strtod+0x2e8>
    c234:	e353000d 	cmp	r3, #13	; 0xd
    c238:	1353000a 	cmpne	r3, #10	; 0xa
    c23c:	0a00006c 	beq	c3f4 <strtod+0x2e8>
    c240:	e353000b 	cmp	r3, #11	; 0xb
    c244:	13530009 	cmpne	r3, #9	; 0x9
    c248:	0a000069 	beq	c3f4 <strtod+0x2e8>
        {  /* ! ([nptr]xxx[.[yyy]]e)  */
            
            while(isspace(*nptr)) nptr++; /* Ansi allows spaces after e */
            if(*nptr != '\0')
    c24c:	e3530000 	cmp	r3, #0	; 0x0
    c250:	0a000065 	beq	c3ec <strtod+0x2e0>
            { /*  ! ([nptr]xxx[.[yyy]]e[space])  */
                
                if(Issign(*nptr))
    c254:	e353002d 	cmp	r3, #45	; 0x2d
    c258:	13a02000 	movne	r2, #0	; 0x0
    c25c:	03a02001 	moveq	r2, #1	; 0x1
    c260:	e353002d 	cmp	r3, #45	; 0x2d
    c264:	1353002b 	cmpne	r3, #43	; 0x2b
    c268:	1a000004 	bne	c280 <strtod+0x174>
                    if(*nptr++ == '-') flags |= ESIGN;
    c26c:	e3520000 	cmp	r2, #0	; 0x0
    c270:	e2855001 	add	r5, r5, #1	; 0x1
    c274:	05d53000 	ldrbeq	r3, [r5]
    c278:	15d53000 	ldrbne	r3, [r5]
    c27c:	138aa002 	orrne	sl, sl, #2	; 0x2
                
                if(*nptr != '\0')
    c280:	e3530000 	cmp	r3, #0	; 0x0
    c284:	0a000058 	beq	c3ec <strtod+0x2e0>
                { /*  ! ([nptr]xxx[.[yyy]]e[nptr])  -- error?? */
                    
                    for(; isdigit(*nptr); nptr++)
    c288:	e1a00003 	mov	r0, r3
    c28c:	e2433030 	sub	r3, r3, #48	; 0x30
    c290:	e3530009 	cmp	r3, #9	; 0x9
    c294:	83a01000 	movhi	r1, #0	; 0x0
    c298:	8a00000c 	bhi	c2d0 <strtod+0x1c4>
                        if (e < MAXE) /* prevent from grossly overflowing */
    c29c:	e3a0ce13 	mov	ip, #304	; 0x130
    c2a0:	e28cc003 	add	ip, ip, #3	; 0x3
                    if(*nptr++ == '-') flags |= ESIGN;
                
                if(*nptr != '\0')
                { /*  ! ([nptr]xxx[.[yyy]]e[nptr])  -- error?? */
                    
                    for(; isdigit(*nptr); nptr++)
    c2a4:	e3a01000 	mov	r1, #0	; 0x0
                        if (e < MAXE) /* prevent from grossly overflowing */
                            e = e*10 + Val(*nptr);
    c2a8:	e1a03081 	lsl	r3, r1, #1
    c2ac:	e1a02181 	lsl	r2, r1, #3
    c2b0:	e0832002 	add	r2, r3, r2
    c2b4:	e2403030 	sub	r3, r0, #48	; 0x30
                    if(*nptr++ == '-') flags |= ESIGN;
                
                if(*nptr != '\0')
                { /*  ! ([nptr]xxx[.[yyy]]e[nptr])  -- error?? */
                    
                    for(; isdigit(*nptr); nptr++)
    c2b8:	e5f50001 	ldrb	r0, [r5, #1]!
                        if (e < MAXE) /* prevent from grossly overflowing */
    c2bc:	e151000c 	cmp	r1, ip
                            e = e*10 + Val(*nptr);
    c2c0:	d0831002 	addle	r1, r3, r2
                    if(*nptr++ == '-') flags |= ESIGN;
                
                if(*nptr != '\0')
                { /*  ! ([nptr]xxx[.[yyy]]e[nptr])  -- error?? */
                    
                    for(; isdigit(*nptr); nptr++)
    c2c4:	e2403030 	sub	r3, r0, #48	; 0x30
    c2c8:	e3530009 	cmp	r3, #9	; 0x9
    c2cc:	9afffff5 	bls	c2a8 <strtod+0x19c>
                        if (e < MAXE) /* prevent from grossly overflowing */
                            e = e*10 + Val(*nptr);
                    
                    /* dont care what comes after this */
                    if(flags & ESIGN)
    c2d0:	e31a0002 	tst	sl, #2	; 0x2
                        texp -= e;
    c2d4:	1061b00b 	rsbne	fp, r1, fp
    c2d8:	13a04001 	movne	r4, #1	; 0x1
                    else
                        texp += e;
    c2dc:	0081b00b 	addeq	fp, r1, fp
    c2e0:	03a04001 	moveq	r4, #1	; 0x1
                }
            }
        }
    }
    
    if(endptr != NULL) 
    c2e4:	e59d2008 	ldr	r2, [sp, #8]
    c2e8:	e3520000 	cmp	r2, #0	; 0x0
    c2ec:	0a000003 	beq	c300 <strtod+0x1f4>
        *endptr = (char *)((conv_done) ? nptr : start);
    c2f0:	e59d300c 	ldr	r3, [sp, #12]
    c2f4:	e3540000 	cmp	r4, #0	; 0x0
    c2f8:	01a05003 	moveq	r5, r3
    c2fc:	e5825000 	str	r5, [r2]
     /* dexp    decimal exponent       */
     /* sign    sign flag              */
{
    double r;
    
    if (dexp > MAXE)
    c300:	e35b0f4d 	cmp	fp, #308	; 0x134
    }
    
    if(endptr != NULL) 
        *endptr = (char *)((conv_done) ? nptr : start);
    
    retval = adjust(&accum, (int)texp, (int)(flags & SIGN));
    c304:	e20a4001 	and	r4, sl, #1	; 0x1
     /* dexp    decimal exponent       */
     /* sign    sign flag              */
{
    double r;
    
    if (dexp > MAXE)
    c308:	ca00003b 	bgt	c3fc <strtod+0x2f0>
    {
        errno = ERANGE;
        return (sign) ? -HUGE_VAL : HUGE_VAL;
    }
    else if (dexp < MINE)
    c30c:	e37b0f4d 	cmn	fp, #308	; 0x134
    c310:	da00002f 	ble	c3d4 <strtod+0x2c8>
        errno = ERANGE;
        return 0.0;
    }
    
    r = *acc;
    if (sign)
    c314:	e3540000 	cmp	r4, #0	; 0x0
        r = -r;
    c318:	159d2000 	ldrne	r2, [sp]
        errno = ERANGE;
        return 0.0;
    }
    
    r = *acc;
    if (sign)
    c31c:	01a06008 	moveq	r6, r8
    c320:	01a07009 	moveq	r7, r9
        r = -r;
    c324:	159d6004 	ldrne	r6, [sp, #4]
    c328:	12827102 	addne	r7, r2, #-2147483648	; 0x80000000
    if (dexp==0)
    c32c:	e35b0000 	cmp	fp, #0	; 0x0
    c330:	0affff8e 	beq	c170 <strtod+0x64>
        return r;
    
    if (dexp < 0)
    c334:	ba00003d 	blt	c430 <strtod+0x324>
        return r / exp10(abs(dexp));
    else
        return r * exp10(dexp);
    c338:	e1a0000b 	mov	r0, fp
    c33c:	ebffff53 	bl	c090 <_ZL5exp10j>
    c340:	e1a02000 	mov	r2, r0
    c344:	e1a03001 	mov	r3, r1
    c348:	e1a00006 	mov	r0, r6
    c34c:	e1a01007 	mov	r1, r7
    c350:	eb0014f0 	bl	11718 <__aeabi_dmul>
    c354:	e1a06000 	mov	r6, r0
    c358:	e1a07001 	mov	r7, r1
    c35c:	eaffff83 	b	c170 <strtod+0x64>
    
    
    if(Issign(*nptr))
    {
        if(*nptr == '-') flags = SIGN;
        if(*++nptr == '\0')
    c360:	e5f3c001 	ldrb	ip, [r3, #1]!
    c364:	e35c0000 	cmp	ip, #0	; 0x0
    c368:	11a0a001 	movne	sl, r1
    c36c:	1affff8e 	bne	c1ac <strtod+0xa0>
        {   /* "+|-" : should be an error ? */
            if(endptr != NULL) *endptr = (char *)start;
    c370:	e59d3008 	ldr	r3, [sp, #8]
    c374:	e3530000 	cmp	r3, #0	; 0x0
    c378:	159d300c 	ldrne	r3, [sp, #12]
    c37c:	159d2008 	ldrne	r2, [sp, #8]
    c380:	15823000 	strne	r3, [r2]
    c384:	e3a06000 	mov	r6, #0	; 0x0
    c388:	e3a07000 	mov	r7, #0	; 0x0
    c38c:	eaffff77 	b	c170 <strtod+0x64>
    }
    
    for(; (isdigit(*nptr) || (*nptr == '.')); nptr++)
    {
        conv_done = 1;
        if(*nptr == '.')
    c390:	e35c002e 	cmp	ip, #46	; 0x2e
    c394:	0affff94 	beq	c1ec <strtod+0xe0>
static int
ten_mul(double *acc, int digit)
{
    /* [atw] Crude, but effective (at least on a KB)...
     */
    *acc *= 10;
    c398:	eb0014de 	bl	11718 <__aeabi_dmul>
    c39c:	e1a04000 	mov	r4, r0
    *acc += digit;
    c3a0:	e1a00006 	mov	r0, r6
static int
ten_mul(double *acc, int digit)
{
    /* [atw] Crude, but effective (at least on a KB)...
     */
    *acc *= 10;
    c3a4:	e1a05001 	mov	r5, r1
    *acc += digit;
    c3a8:	eb0014a3 	bl	1163c <__aeabi_i2d>
    c3ac:	e1a02000 	mov	r2, r0
    c3b0:	e1a03001 	mov	r3, r1
    c3b4:	e1a00004 	mov	r0, r4
    c3b8:	e1a01005 	mov	r1, r5
    c3bc:	eb0013d1 	bl	11308 <__adddf3>
        if(*nptr == '.')
            flags |= DECP;
        else
        {
            if( ten_mul(&accum, Val(*nptr)) ) texp++;
            if(flags & DECP) texp--;
    c3c0:	e31a0004 	tst	sl, #4	; 0x4
ten_mul(double *acc, int digit)
{
    /* [atw] Crude, but effective (at least on a KB)...
     */
    *acc *= 10;
    *acc += digit;
    c3c4:	e1a08000 	mov	r8, r0
    c3c8:	e1a09001 	mov	r9, r1
        if(*nptr == '.')
            flags |= DECP;
        else
        {
            if( ten_mul(&accum, Val(*nptr)) ) texp++;
            if(flags & DECP) texp--;
    c3cc:	124bb001 	subne	fp, fp, #1	; 0x1
    c3d0:	eaffff86 	b	c1f0 <strtod+0xe4>
        errno = ERANGE;
        return (sign) ? -HUGE_VAL : HUGE_VAL;
    }
    else if (dexp < MINE)
    {
        errno = ERANGE;
    c3d4:	eb000565 	bl	d970 <cyg_error_get_errno_p>
    c3d8:	e3a03022 	mov	r3, #34	; 0x22
    c3dc:	e5803000 	str	r3, [r0]
    c3e0:	e3a06000 	mov	r6, #0	; 0x0
    c3e4:	e3a07000 	mov	r7, #0	; 0x0
    c3e8:	eaffff60 	b	c170 <strtod+0x64>
                    
                    /* dont care what comes after this */
                    if(flags & ESIGN)
                        texp -= e;
                    else
                        texp += e;
    c3ec:	e3a04001 	mov	r4, #1	; 0x1
    c3f0:	eaffffbb 	b	c2e4 <strtod+0x1d8>
    c3f4:	e5f23001 	ldrb	r3, [r2, #1]!
    c3f8:	eaffff89 	b	c224 <strtod+0x118>
{
    double r;
    
    if (dexp > MAXE)
    {
        errno = ERANGE;
    c3fc:	eb00055b 	bl	d970 <cyg_error_get_errno_p>
    c400:	e3a03022 	mov	r3, #34	; 0x22
        return (sign) ? -HUGE_VAL : HUGE_VAL;
    c404:	e3540000 	cmp	r4, #0	; 0x0
{
    double r;
    
    if (dexp > MAXE)
    {
        errno = ERANGE;
    c408:	e5803000 	str	r3, [r0]
        return (sign) ? -HUGE_VAL : HUGE_VAL;
    c40c:	0a000004 	beq	c424 <strtod+0x318>
    c410:	e59f2040 	ldr	r2, [pc, #64]	; c458 <strtod+0x34c>
    c414:	e5923004 	ldr	r3, [r2, #4]
    c418:	e5926000 	ldr	r6, [r2]
    c41c:	e2837102 	add	r7, r3, #-2147483648	; 0x80000000
    c420:	eaffff52 	b	c170 <strtod+0x64>
    c424:	e59f302c 	ldr	r3, [pc, #44]	; c458 <strtod+0x34c>
    c428:	e89300c0 	ldm	r3, {r6, r7}
    c42c:	eaffff4f 	b	c170 <strtod+0x64>
        r = -r;
    if (dexp==0)
        return r;
    
    if (dexp < 0)
        return r / exp10(abs(dexp));
    c430:	e26b0000 	rsb	r0, fp, #0	; 0x0
    c434:	ebffff15 	bl	c090 <_ZL5exp10j>
    c438:	e1a02000 	mov	r2, r0
    c43c:	e1a03001 	mov	r3, r1
    c440:	e1a00006 	mov	r0, r6
    c444:	e1a01007 	mov	r1, r7
    c448:	eb001556 	bl	119a8 <__aeabi_ddiv>
    c44c:	e1a06000 	mov	r6, r0
    c450:	e1a07001 	mov	r7, r1
    c454:	eaffff45 	b	c170 <strtod+0x64>
    c458:	00012b38 	.word	0x00012b38

0000c45c <strtol>:
// Ignores `locale' stuff.  Assumes that the upper and lower case
// alphabets and digits are each contiguous.
//

long
strtol( const char *nptr, char **endptr, int base )
    c45c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c460:	e24dd00c 	sub	sp, sp, #12	; 0xc
    c464:	e58d1004 	str	r1, [sp, #4]
    c468:	e1a0b000 	mov	fp, r0
    c46c:	e1a07002 	mov	r7, r2
    c470:	e1a06000 	mov	r6, r0
    // If base is 0, allow 0x for hex and 0 for octal, else
    // assume decimal; if base is already 16, allow 0x.
    //
    
    do {
        c = *s++;
    c474:	e4d65001 	ldrb	r5, [r6], #1
    c478:	e355000c 	cmp	r5, #12	; 0xc
    c47c:	13550020 	cmpne	r5, #32	; 0x20
    c480:	0afffffb 	beq	c474 <strtol+0x18>
    c484:	e355000d 	cmp	r5, #13	; 0xd
    c488:	1355000a 	cmpne	r5, #10	; 0xa
    c48c:	0afffff8 	beq	c474 <strtol+0x18>
    c490:	e355000b 	cmp	r5, #11	; 0xb
    c494:	13550009 	cmpne	r5, #9	; 0x9
    c498:	13a03000 	movne	r3, #0	; 0x0
    c49c:	03a03001 	moveq	r3, #1	; 0x1
    c4a0:	0afffff3 	beq	c474 <strtol+0x18>
    } while (isspace(c));
    if (c == '-') {
    c4a4:	e355002d 	cmp	r5, #45	; 0x2d
        neg = 1;
        c = *s++;
    c4a8:	04d65001 	ldrbeq	r5, [r6], #1
    c4ac:	03a09001 	moveq	r9, #1	; 0x1
    //
    
    do {
        c = *s++;
    } while (isspace(c));
    if (c == '-') {
    c4b0:	0a000002 	beq	c4c0 <strtol+0x64>
        neg = 1;
        c = *s++;
    } else if (c == '+')
    c4b4:	e355002b 	cmp	r5, #43	; 0x2b
        c = *s++;
    c4b8:	04d65001 	ldrbeq	r5, [r6], #1
    c4bc:	e1a09003 	mov	r9, r3
    if ((base == 0 || base == 16) &&
    c4c0:	e2772001 	rsbs	r2, r7, #1	; 0x1
    c4c4:	33a02000 	movcc	r2, #0	; 0x0
    c4c8:	e3570000 	cmp	r7, #0	; 0x0
    c4cc:	13570010 	cmpne	r7, #16	; 0x10
    c4d0:	1a000008 	bne	c4f8 <strtol+0x9c>
    c4d4:	e3550030 	cmp	r5, #48	; 0x30
    c4d8:	0a00004f 	beq	c61c <strtol+0x1c0>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
    c4dc:	e3520000 	cmp	r2, #0	; 0x0
    c4e0:	0a000004 	beq	c4f8 <strtol+0x9c>
        base = c == '0' ? 8 : 10;
    c4e4:	e3550030 	cmp	r5, #48	; 0x30
    c4e8:	13a0700a 	movne	r7, #10	; 0xa
    c4ec:	11a08007 	movne	r8, r7
    c4f0:	1a000001 	bne	c4fc <strtol+0xa0>
    c4f4:	e3a07008 	mov	r7, #8	; 0x8
    c4f8:	e1a08007 	mov	r8, r7
    //
    // Set any if any `digits' consumed; make it negative to indicate
    // overflow.
    //
    
    cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    c4fc:	e3590000 	cmp	r9, #0	; 0x0
    c500:	13a04102 	movne	r4, #-2147483648	; 0x80000000
    c504:	03e04102 	mvneq	r4, #-2147483648	; 0x80000000
    cutlim = cutoff % (unsigned long)base;
    c508:	e1a00004 	mov	r0, r4
    c50c:	e1a01008 	mov	r1, r8
    c510:	eb001321 	bl	1119c <__aeabi_uidivmod>
    cutoff /= (unsigned long)base;
    c514:	e1a00004 	mov	r0, r4
    // Set any if any `digits' consumed; make it negative to indicate
    // overflow.
    //
    
    cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    cutlim = cutoff % (unsigned long)base;
    c518:	e1a0a001 	mov	sl, r1
    cutoff /= (unsigned long)base;
    c51c:	e1a01008 	mov	r1, r8
    c520:	eb0012de 	bl	110a0 <__aeabi_uidiv>
    c524:	e1a01000 	mov	r1, r0
    c528:	e3a00000 	mov	r0, #0	; 0x0
    c52c:	e1a04000 	mov	r4, r0
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    c530:	e2453030 	sub	r3, r5, #48	; 0x30
    c534:	e3530009 	cmp	r3, #9	; 0x9
            c -= '0';
    c538:	91a02003 	movls	r2, r3
    
    cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    cutlim = cutoff % (unsigned long)base;
    cutoff /= (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    c53c:	9a000007 	bls	c560 <strtol+0x104>


CYGPRI_LIBC_I18N_CTYPE_INLINE int
isalpha( int c )
{
    return ( islower(c) || isupper(c) );
    c540:	e2453061 	sub	r3, r5, #97	; 0x61
    c544:	e3530019 	cmp	r3, #25	; 0x19
    c548:	8a00001a 	bhi	c5b8 <strtol+0x15c>
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    c54c:	e2453041 	sub	r3, r5, #65	; 0x41
    c550:	e3530019 	cmp	r3, #25	; 0x19
    c554:	83a03057 	movhi	r3, #87	; 0x57
    c558:	9a000014 	bls	c5b0 <strtol+0x154>
    c55c:	e0632005 	rsb	r2, r3, r5
        else
            break;
        if (c >= base)
    c560:	e1570002 	cmp	r7, r2
    c564:	da000016 	ble	c5c4 <strtol+0x168>
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    c568:	e1500001 	cmp	r0, r1
    c56c:	93a03000 	movls	r3, #0	; 0x0
    c570:	83a03001 	movhi	r3, #1	; 0x1
    c574:	e1933fa4 	orrs	r3, r3, r4, lsr #31
    c578:	1a000009 	bne	c5a4 <strtol+0x148>
    c57c:	e1500001 	cmp	r0, r1
    c580:	13a03000 	movne	r3, #0	; 0x0
    c584:	03a03001 	moveq	r3, #1	; 0x1
    c588:	e152000a 	cmp	r2, sl
    c58c:	d3a03000 	movle	r3, #0	; 0x0
    c590:	e3530000 	cmp	r3, #0	; 0x0
            any = -1;
        else {
            any = 1;
            acc *= base;
            acc += c;
    c594:	00202098 	mlaeq	r0, r8, r0, r2
    c598:	03a04001 	moveq	r4, #1	; 0x1
    //
    
    cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    cutlim = cutoff % (unsigned long)base;
    cutoff /= (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++) {
    c59c:	04d65001 	ldrbeq	r5, [r6], #1
    c5a0:	0affffe2 	beq	c530 <strtol+0xd4>
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
            any = -1;
        else {
            any = 1;
            acc *= base;
            acc += c;
    c5a4:	e3e04000 	mvn	r4, #0	; 0x0
    //
    
    cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    cutlim = cutoff % (unsigned long)base;
    cutoff /= (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++) {
    c5a8:	e4d65001 	ldrb	r5, [r6], #1
    c5ac:	eaffffdf 	b	c530 <strtol+0xd4>
        if (isdigit(c))
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    c5b0:	e3a03037 	mov	r3, #55	; 0x37
    c5b4:	eaffffe8 	b	c55c <strtol+0x100>
    c5b8:	e2453041 	sub	r3, r5, #65	; 0x41
    c5bc:	e3530019 	cmp	r3, #25	; 0x19
    c5c0:	9afffffa 	bls	c5b0 <strtol+0x154>
            any = 1;
            acc *= base;
            acc += c;
        }
    }
    if (any < 0) {
    c5c4:	e3540000 	cmp	r4, #0	; 0x0
    c5c8:	ba00000c 	blt	c600 <strtol+0x1a4>
        acc = neg ? LONG_MIN : LONG_MAX;
        errno = ERANGE;
    } else if (neg)
    c5cc:	e3590000 	cmp	r9, #0	; 0x0
    c5d0:	01a05000 	moveq	r5, r0
    c5d4:	12605000 	rsbne	r5, r0, #0	; 0x0
        acc = -acc;
    if (endptr != 0)
    c5d8:	e59d3004 	ldr	r3, [sp, #4]
    c5dc:	e3530000 	cmp	r3, #0	; 0x0
    c5e0:	0a000003 	beq	c5f4 <strtol+0x198>
        *endptr = (char *) (any ? s - 1 : nptr);
    c5e4:	e3540000 	cmp	r4, #0	; 0x0
    c5e8:	e59d3004 	ldr	r3, [sp, #4]
    c5ec:	1246b001 	subne	fp, r6, #1	; 0x1
    c5f0:	e583b000 	str	fp, [r3]

    CYG_REPORT_RETVAL ( acc );

    return acc;
} // strtol()
    c5f4:	e1a00005 	mov	r0, r5
    c5f8:	e28dd00c 	add	sp, sp, #12	; 0xc
    c5fc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            acc *= base;
            acc += c;
        }
    }
    if (any < 0) {
        acc = neg ? LONG_MIN : LONG_MAX;
    c600:	e3590000 	cmp	r9, #0	; 0x0
    c604:	13a05102 	movne	r5, #-2147483648	; 0x80000000
    c608:	03e05102 	mvneq	r5, #-2147483648	; 0x80000000
        errno = ERANGE;
    c60c:	eb0004d7 	bl	d970 <cyg_error_get_errno_p>
    c610:	e3a03022 	mov	r3, #34	; 0x22
    c614:	e5803000 	str	r3, [r0]
    c618:	eaffffee 	b	c5d8 <strtol+0x17c>
    if (c == '-') {
        neg = 1;
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
    c61c:	e5d63000 	ldrb	r3, [r6]
    c620:	e3530058 	cmp	r3, #88	; 0x58
    c624:	13530078 	cmpne	r3, #120	; 0x78
    c628:	1affffab 	bne	c4dc <strtol+0x80>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
    c62c:	e3a07010 	mov	r7, #16	; 0x10
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
    c630:	e5d65001 	ldrb	r5, [r6, #1]
        s += 2;
    c634:	e1a08007 	mov	r8, r7
    c638:	e2866002 	add	r6, r6, #2	; 0x2
    c63c:	eaffffae 	b	c4fc <strtol+0xa0>

0000c640 <strtoul>:
// Ignores `locale' stuff.  Assumes that the upper and lower case
// alphabets and digits are each contiguous.
//

unsigned long
strtoul( const char *nptr, char **endptr, int base )
    c640:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c644:	e1a0a000 	mov	sl, r0
    c648:	e24dd004 	sub	sp, sp, #4	; 0x4
    c64c:	e1a0b001 	mov	fp, r1
    c650:	e1a08002 	mov	r8, r2
    c654:	e1a07000 	mov	r7, r0
        CYG_CHECK_DATA_PTR( endptr, "endptr is not a valid pointer!" );
    //
    // See strtol for comments as to the logic used.
    //
    do {
        c = *s++;
    c658:	e4d74001 	ldrb	r4, [r7], #1

CYGPRI_LIBC_I18N_CTYPE_INLINE int
isspace( int c )
{
    return ( (c == ' ') || (c == '\f') || (c == '\n') || (c == '\r') ||
             (c == '\t') || (c == '\v') );
    c65c:	e354000c 	cmp	r4, #12	; 0xc
    c660:	13540020 	cmpne	r4, #32	; 0x20
    c664:	0afffffb 	beq	c658 <strtoul+0x18>
    c668:	e354000d 	cmp	r4, #13	; 0xd
    c66c:	1354000a 	cmpne	r4, #10	; 0xa
    c670:	0afffff8 	beq	c658 <strtoul+0x18>
    c674:	e354000b 	cmp	r4, #11	; 0xb
    c678:	13540009 	cmpne	r4, #9	; 0x9
    c67c:	13a03000 	movne	r3, #0	; 0x0
    c680:	03a03001 	moveq	r3, #1	; 0x1
    c684:	0afffff3 	beq	c658 <strtoul+0x18>
    } while (isspace(c));
    if (c == '-') {
    c688:	e354002d 	cmp	r4, #45	; 0x2d
        neg = 1;
        c = *s++;
    c68c:	04d74001 	ldrbeq	r4, [r7], #1
    c690:	03a09001 	moveq	r9, #1	; 0x1
    // See strtol for comments as to the logic used.
    //
    do {
        c = *s++;
    } while (isspace(c));
    if (c == '-') {
    c694:	0a000002 	beq	c6a4 <strtoul+0x64>
        neg = 1;
        c = *s++;
    } else if (c == '+')
    c698:	e354002b 	cmp	r4, #43	; 0x2b
        c = *s++;
    c69c:	04d74001 	ldrbeq	r4, [r7], #1
    c6a0:	e1a09003 	mov	r9, r3
    if ((base == 0 || base == 16) &&
    c6a4:	e2782001 	rsbs	r2, r8, #1	; 0x1
    c6a8:	33a02000 	movcc	r2, #0	; 0x0
    c6ac:	e3580000 	cmp	r8, #0	; 0x0
    c6b0:	13580010 	cmpne	r8, #16	; 0x10
    c6b4:	1a00000d 	bne	c6f0 <strtoul+0xb0>
    c6b8:	e3540030 	cmp	r4, #48	; 0x30
    c6bc:	0a00004a 	beq	c7ec <strtoul+0x1ac>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
    c6c0:	e3520000 	cmp	r2, #0	; 0x0
    c6c4:	0a000009 	beq	c6f0 <strtoul+0xb0>
        base = c == '0' ? 8 : 10;
    c6c8:	e3540030 	cmp	r4, #48	; 0x30
    c6cc:	13a0800a 	movne	r8, #10	; 0xa
    c6d0:	03a08008 	moveq	r8, #8	; 0x8
    c6d4:	11a0c008 	movne	ip, r8
    c6d8:	159f6138 	ldrne	r6, [pc, #312]	; c818 <strtoul+0x1d8>
    c6dc:	13a01005 	movne	r1, #5	; 0x5
    c6e0:	01a0c008 	moveq	ip, r8
    c6e4:	03e0620e 	mvneq	r6, #-536870912	; 0xe0000000
    c6e8:	03a01007 	moveq	r1, #7	; 0x7
    c6ec:	ea000007 	b	c710 <strtoul+0xd0>
        acc = ULONG_MAX;
        errno = ERANGE;
    } else if (neg)
        acc = -acc;
    if (endptr != 0)
        *endptr = (char *) (any ? s - 1 : nptr);
    c6f0:	e1a01008 	mov	r1, r8
    c6f4:	e3e00000 	mvn	r0, #0	; 0x0
    c6f8:	eb001268 	bl	110a0 <__aeabi_uidiv>
    c6fc:	e1a01008 	mov	r1, r8
    c700:	e1a06000 	mov	r6, r0
    c704:	e3e00000 	mvn	r0, #0	; 0x0
    c708:	eb0012a3 	bl	1119c <__aeabi_uidivmod>
    c70c:	e1a0c008 	mov	ip, r8
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    c710:	e3a00000 	mov	r0, #0	; 0x0
    c714:	e1a05000 	mov	r5, r0
    cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    c718:	e2443030 	sub	r3, r4, #48	; 0x30
    c71c:	e3530009 	cmp	r3, #9	; 0x9
            c -= '0';
    c720:	91a02003 	movls	r2, r3
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    c724:	9a000007 	bls	c748 <strtoul+0x108>


CYGPRI_LIBC_I18N_CTYPE_INLINE int
isalpha( int c )
{
    return ( islower(c) || isupper(c) );
    c728:	e2443061 	sub	r3, r4, #97	; 0x61
    c72c:	e3530019 	cmp	r3, #25	; 0x19
    c730:	8a00001a 	bhi	c7a0 <strtoul+0x160>
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    c734:	e2443041 	sub	r3, r4, #65	; 0x41
    c738:	e3530019 	cmp	r3, #25	; 0x19
    c73c:	83a03057 	movhi	r3, #87	; 0x57
    c740:	9a000014 	bls	c798 <strtoul+0x158>
    c744:	e0632004 	rsb	r2, r3, r4
        else
            break;
        if (c >= base)
    c748:	e1580002 	cmp	r8, r2
    c74c:	da000016 	ble	c7ac <strtoul+0x16c>
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    c750:	e1500006 	cmp	r0, r6
    c754:	93a03000 	movls	r3, #0	; 0x0
    c758:	83a03001 	movhi	r3, #1	; 0x1
    c75c:	e1933fa5 	orrs	r3, r3, r5, lsr #31
    c760:	1a000009 	bne	c78c <strtoul+0x14c>
    c764:	e1500006 	cmp	r0, r6
    c768:	13a03000 	movne	r3, #0	; 0x0
    c76c:	03a03001 	moveq	r3, #1	; 0x1
    c770:	e1520001 	cmp	r2, r1
    c774:	d3a03000 	movle	r3, #0	; 0x0
    c778:	e3530000 	cmp	r3, #0	; 0x0
            any = -1;
        else {
            any = 1;
            acc *= base;
            acc += c;
    c77c:	0020209c 	mlaeq	r0, ip, r0, r2
    c780:	03a05001 	moveq	r5, #1	; 0x1
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
            break;
        if (c >= base)
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    c784:	0a000001 	beq	c790 <strtoul+0x150>
    c788:	e1a00006 	mov	r0, r6
    c78c:	e3e05000 	mvn	r5, #0	; 0x0
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    for (acc = 0, any = 0;; c = *s++) {
    c790:	e4d74001 	ldrb	r4, [r7], #1
    c794:	eaffffdf 	b	c718 <strtoul+0xd8>
        if (isdigit(c))
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    c798:	e3a03037 	mov	r3, #55	; 0x37
    c79c:	eaffffe8 	b	c744 <strtoul+0x104>
    c7a0:	e2443041 	sub	r3, r4, #65	; 0x41
    c7a4:	e3530019 	cmp	r3, #25	; 0x19
    c7a8:	9afffffa 	bls	c798 <strtoul+0x158>
            any = 1;
            acc *= base;
            acc += c;
        }
    }
    if (any < 0) {
    c7ac:	e3550000 	cmp	r5, #0	; 0x0
    c7b0:	ba000008 	blt	c7d8 <strtoul+0x198>
        acc = ULONG_MAX;
        errno = ERANGE;
    } else if (neg)
    c7b4:	e3590000 	cmp	r9, #0	; 0x0
        acc = -acc;
    c7b8:	12600000 	rsbne	r0, r0, #0	; 0x0
    if (endptr != 0)
    c7bc:	e35b0000 	cmp	fp, #0	; 0x0
    c7c0:	0a000002 	beq	c7d0 <strtoul+0x190>
        *endptr = (char *) (any ? s - 1 : nptr);
    c7c4:	e3550000 	cmp	r5, #0	; 0x0
    c7c8:	1247a001 	subne	sl, r7, #1	; 0x1
    c7cc:	e58ba000 	str	sl, [fp]
    
    CYG_REPORT_RETVAL( acc );

    return acc;
} // strtoul()
    c7d0:	e28dd004 	add	sp, sp, #4	; 0x4
    c7d4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            acc += c;
        }
    }
    if (any < 0) {
        acc = ULONG_MAX;
        errno = ERANGE;
    c7d8:	eb000464 	bl	d970 <cyg_error_get_errno_p>
    c7dc:	e3a03022 	mov	r3, #34	; 0x22
    c7e0:	e5803000 	str	r3, [r0]
    c7e4:	e3e00000 	mvn	r0, #0	; 0x0
    c7e8:	eafffff3 	b	c7bc <strtoul+0x17c>
    if (c == '-') {
        neg = 1;
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
    c7ec:	e5d73000 	ldrb	r3, [r7]
    c7f0:	e3530058 	cmp	r3, #88	; 0x58
    c7f4:	13530078 	cmpne	r3, #120	; 0x78
    c7f8:	1affffb0 	bne	c6c0 <strtoul+0x80>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
    c7fc:	e3a08010 	mov	r8, #16	; 0x10
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
    c800:	e5d74001 	ldrb	r4, [r7, #1]
        s += 2;
    c804:	e1a0c008 	mov	ip, r8
    c808:	e2877002 	add	r7, r7, #2	; 0x2
    c80c:	e3e0620f 	mvn	r6, #-268435456	; 0xf0000000
    c810:	e3a0100f 	mov	r1, #15	; 0xf
    c814:	eaffffbd 	b	c710 <strtoul+0xd0>
    c818:	19999999 	.word	0x19999999

0000c81c <strtoll>:
// Ignores `locale' stuff.  Assumes that the upper and lower case
// alphabets and digits are each contiguous.
//

long long
strtoll( const char *nptr, char **endptr, int base )
    c81c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c820:	e24dd01c 	sub	sp, sp, #28	; 0x1c
    c824:	e58d000c 	str	r0, [sp, #12]
    c828:	e58d1008 	str	r1, [sp, #8]
    c82c:	e1a0b002 	mov	fp, r2
    c830:	e1a0a000 	mov	sl, r0
    // If base is 0, allow 0x for hex and 0 for octal, else
    // assume decimal; if base is already 16, allow 0x.
    //
    
    do {
        c = *s++;
    c834:	e4da6001 	ldrb	r6, [sl], #1

CYGPRI_LIBC_I18N_CTYPE_INLINE int
isspace( int c )
{
    return ( (c == ' ') || (c == '\f') || (c == '\n') || (c == '\r') ||
             (c == '\t') || (c == '\v') );
    c838:	e356000c 	cmp	r6, #12	; 0xc
    c83c:	13560020 	cmpne	r6, #32	; 0x20
    c840:	0afffffb 	beq	c834 <strtoll+0x18>
    c844:	e356000d 	cmp	r6, #13	; 0xd
    c848:	1356000a 	cmpne	r6, #10	; 0xa
    c84c:	0afffff8 	beq	c834 <strtoll+0x18>
    c850:	e356000b 	cmp	r6, #11	; 0xb
    c854:	13560009 	cmpne	r6, #9	; 0x9
    c858:	13a03000 	movne	r3, #0	; 0x0
    c85c:	03a03001 	moveq	r3, #1	; 0x1
    c860:	0afffff3 	beq	c834 <strtoll+0x18>
    } while (isspace(c));
    if (c == '-') {
    c864:	e356002d 	cmp	r6, #45	; 0x2d
    c868:	0a00007c 	beq	ca60 <strtoll+0x244>
        neg = 1;
        c = *s++;
    } else if (c == '+')
    c86c:	e356002b 	cmp	r6, #43	; 0x2b
        c = *s++;
    c870:	04da6001 	ldrbeq	r6, [sl], #1
    c874:	e58d3010 	str	r3, [sp, #16]
    if ((base == 0 || base == 16) &&
    c878:	e27b2001 	rsbs	r2, fp, #1	; 0x1
    c87c:	33a02000 	movcc	r2, #0	; 0x0
    c880:	e35b0000 	cmp	fp, #0	; 0x0
    c884:	135b0010 	cmpne	fp, #16	; 0x10
    c888:	1a00000b 	bne	c8bc <strtoll+0xa0>
    c88c:	e3560030 	cmp	r6, #48	; 0x30
    c890:	0a000080 	beq	ca98 <strtoll+0x27c>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
    c894:	e3520000 	cmp	r2, #0	; 0x0
    c898:	0a000007 	beq	c8bc <strtoll+0xa0>
        base = c == '0' ? 8 : 10;
    c89c:	e3560030 	cmp	r6, #48	; 0x30
    c8a0:	13a0b00a 	movne	fp, #10	; 0xa
    c8a4:	13a0800a 	movne	r8, #10	; 0xa
    c8a8:	13a09000 	movne	r9, #0	; 0x0
    c8ac:	03a0b008 	moveq	fp, #8	; 0x8
    c8b0:	03a08008 	moveq	r8, #8	; 0x8
    c8b4:	03a09000 	moveq	r9, #0	; 0x0
    c8b8:	ea000001 	b	c8c4 <strtoll+0xa8>
        acc = neg ? LONG_LONG_MIN : LONG_LONG_MAX;
        errno = ERANGE;
    } else if (neg)
        acc = -acc;
    if (endptr != 0)
        *endptr = (char *) (any ? s - 1 : nptr);
    c8bc:	e1a0800b 	mov	r8, fp
    c8c0:	e1a09fc8 	asr	r9, r8, #31
    //
    // Set any if any `digits' consumed; make it negative to indicate
    // overflow.
    //
    
    cutoff = neg ? -(unsigned long long)LONG_LONG_MIN : LONG_LONG_MAX;
    c8c4:	e59d2010 	ldr	r2, [sp, #16]
    c8c8:	e3520000 	cmp	r2, #0	; 0x0
    c8cc:	03e04000 	mvneq	r4, #0	; 0x0
    c8d0:	03e05102 	mvneq	r5, #-2147483648	; 0x80000000
    c8d4:	13a04000 	movne	r4, #0	; 0x0
    c8d8:	13a05102 	movne	r5, #-2147483648	; 0x80000000
    cutlim = cutoff % (unsigned long long)base;
    c8dc:	e1a00004 	mov	r0, r4
    c8e0:	e1a01005 	mov	r1, r5
    c8e4:	e1a02008 	mov	r2, r8
    c8e8:	e1a03009 	mov	r3, r9
    c8ec:	eb00154d 	bl	11e28 <__aeabi_uldivmod>
    cutoff /= (unsigned long long)base;
    c8f0:	e1a00004 	mov	r0, r4
    // Set any if any `digits' consumed; make it negative to indicate
    // overflow.
    //
    
    cutoff = neg ? -(unsigned long long)LONG_LONG_MIN : LONG_LONG_MAX;
    cutlim = cutoff % (unsigned long long)base;
    c8f4:	e58d2014 	str	r2, [sp, #20]
    cutoff /= (unsigned long long)base;
    c8f8:	e1a01005 	mov	r1, r5
    c8fc:	e1a02008 	mov	r2, r8
    c900:	e1a03009 	mov	r3, r9
    c904:	eb001547 	bl	11e28 <__aeabi_uldivmod>
    c908:	e58d0004 	str	r0, [sp, #4]
    c90c:	e1a0e001 	mov	lr, r1
    c910:	e3a04000 	mov	r4, #0	; 0x0
    c914:	e3a05000 	mov	r5, #0	; 0x0
    c918:	e3a07000 	mov	r7, #0	; 0x0
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    c91c:	e2463030 	sub	r3, r6, #48	; 0x30
    c920:	e3530009 	cmp	r3, #9	; 0x9
            c -= '0';
    c924:	91a0c003 	movls	ip, r3
    
    cutoff = neg ? -(unsigned long long)LONG_LONG_MIN : LONG_LONG_MAX;
    cutlim = cutoff % (unsigned long long)base;
    cutoff /= (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    c928:	9a000007 	bls	c94c <strtoll+0x130>


CYGPRI_LIBC_I18N_CTYPE_INLINE int
isalpha( int c )
{
    return ( islower(c) || isupper(c) );
    c92c:	e2463061 	sub	r3, r6, #97	; 0x61
    c930:	e3530019 	cmp	r3, #25	; 0x19
    c934:	8a00002c 	bhi	c9ec <strtoll+0x1d0>
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    c938:	e2463041 	sub	r3, r6, #65	; 0x41
    c93c:	e3530019 	cmp	r3, #25	; 0x19
    c940:	83a03057 	movhi	r3, #87	; 0x57
    c944:	9a000026 	bls	c9e4 <strtoll+0x1c8>
    c948:	e063c006 	rsb	ip, r3, r6
        else
            break;
        if (c >= base)
    c94c:	e15b000c 	cmp	fp, ip
    c950:	da000028 	ble	c9f8 <strtoll+0x1dc>
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    c954:	e155000e 	cmp	r5, lr
    c958:	e1a03fa7 	lsr	r3, r7, #31
    c95c:	e3a02000 	mov	r2, #0	; 0x0
    c960:	8a00001d 	bhi	c9dc <strtoll+0x1c0>
    c964:	0a000019 	beq	c9d0 <strtoll+0x1b4>
    c968:	e1833002 	orr	r3, r3, r2
    c96c:	e21330ff 	ands	r3, r3, #255	; 0xff
    c970:	1a000013 	bne	c9c4 <strtoll+0x1a8>
    c974:	e59d2004 	ldr	r2, [sp, #4]
    c978:	e1540002 	cmp	r4, r2
    c97c:	0a000031 	beq	ca48 <strtoll+0x22c>
    c980:	e59d1014 	ldr	r1, [sp, #20]
    c984:	e15c0001 	cmp	ip, r1
    c988:	d3a03000 	movle	r3, #0	; 0x0
    c98c:	c2033001 	andgt	r3, r3, #1	; 0x1
    c990:	e3530000 	cmp	r3, #0	; 0x0
    c994:	1a00000a 	bne	c9c4 <strtoll+0x1a8>
            any = -1;
        else {
            any = 1;
            acc *= base;
    c998:	e0030994 	mul	r3, r4, r9
    c99c:	e0821894 	umull	r1, r2, r4, r8
    c9a0:	e0203598 	mla	r0, r8, r5, r3
            acc += c;
    c9a4:	e1a0400c 	mov	r4, ip
    c9a8:	e1a05fc4 	asr	r5, r4, #31
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
            any = -1;
        else {
            any = 1;
            acc *= base;
    c9ac:	e0802002 	add	r2, r0, r2
            acc += c;
    c9b0:	e0944001 	adds	r4, r4, r1
    c9b4:	e0a55002 	adc	r5, r5, r2
    c9b8:	e3a07001 	mov	r7, #1	; 0x1
    //
    
    cutoff = neg ? -(unsigned long long)LONG_LONG_MIN : LONG_LONG_MAX;
    cutlim = cutoff % (unsigned long long)base;
    cutoff /= (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
    c9bc:	e4da6001 	ldrb	r6, [sl], #1
    c9c0:	eaffffd5 	b	c91c <strtoll+0x100>
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
            any = -1;
        else {
            any = 1;
            acc *= base;
            acc += c;
    c9c4:	e3e07000 	mvn	r7, #0	; 0x0
    //
    
    cutoff = neg ? -(unsigned long long)LONG_LONG_MIN : LONG_LONG_MAX;
    cutlim = cutoff % (unsigned long long)base;
    cutoff /= (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
    c9c8:	e4da6001 	ldrb	r6, [sl], #1
    c9cc:	eaffffd2 	b	c91c <strtoll+0x100>
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
            break;
        if (c >= base)
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    c9d0:	e59d1004 	ldr	r1, [sp, #4]
    c9d4:	e1540001 	cmp	r4, r1
    c9d8:	9affffe2 	bls	c968 <strtoll+0x14c>
    c9dc:	e3a02001 	mov	r2, #1	; 0x1
    c9e0:	eaffffe0 	b	c968 <strtoll+0x14c>
    cutoff /= (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    c9e4:	e3a03037 	mov	r3, #55	; 0x37
    c9e8:	eaffffd6 	b	c948 <strtoll+0x12c>
    c9ec:	e2463041 	sub	r3, r6, #65	; 0x41
    c9f0:	e3530019 	cmp	r3, #25	; 0x19
    c9f4:	9afffffa 	bls	c9e4 <strtoll+0x1c8>
            any = 1;
            acc *= base;
            acc += c;
        }
    }
    if (any < 0) {
    c9f8:	e3570000 	cmp	r7, #0	; 0x0
    c9fc:	ba00001b 	blt	ca70 <strtoll+0x254>
        acc = neg ? LONG_LONG_MIN : LONG_LONG_MAX;
        errno = ERANGE;
    } else if (neg)
    ca00:	e59d3010 	ldr	r3, [sp, #16]
    ca04:	e3530000 	cmp	r3, #0	; 0x0
    ca08:	1a000011 	bne	ca54 <strtoll+0x238>
    ca0c:	e1a08004 	mov	r8, r4
    ca10:	e1a09005 	mov	r9, r5
        acc = -acc;
    if (endptr != 0)
    ca14:	e59d1008 	ldr	r1, [sp, #8]
    ca18:	e3510000 	cmp	r1, #0	; 0x0
    ca1c:	0a000005 	beq	ca38 <strtoll+0x21c>
        *endptr = (char *) (any ? s - 1 : nptr);
    ca20:	e3570000 	cmp	r7, #0	; 0x0
    ca24:	124aa001 	subne	sl, sl, #1	; 0x1
    ca28:	158da00c 	strne	sl, [sp, #12]
    ca2c:	e28d2008 	add	r2, sp, #8	; 0x8
    ca30:	e892000c 	ldm	r2, {r2, r3}
    ca34:	e5823000 	str	r3, [r2]

    CYG_REPORT_RETVAL ( acc );

    return acc;
} // strtoll()
    ca38:	e1a01009 	mov	r1, r9
    ca3c:	e1a00008 	mov	r0, r8
    ca40:	e28dd01c 	add	sp, sp, #28	; 0x1c
    ca44:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
            break;
        if (c >= base)
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    ca48:	e155000e 	cmp	r5, lr
    ca4c:	03a03001 	moveq	r3, #1	; 0x1
    ca50:	eaffffca 	b	c980 <strtoll+0x164>
        }
    }
    if (any < 0) {
        acc = neg ? LONG_LONG_MIN : LONG_LONG_MAX;
        errno = ERANGE;
    } else if (neg)
    ca54:	e2748000 	rsbs	r8, r4, #0	; 0x0
    ca58:	e2e59000 	rsc	r9, r5, #0	; 0x0
    ca5c:	eaffffec 	b	ca14 <strtoll+0x1f8>
    do {
        c = *s++;
    } while (isspace(c));
    if (c == '-') {
        neg = 1;
        c = *s++;
    ca60:	e3a01001 	mov	r1, #1	; 0x1
    ca64:	e4da6001 	ldrb	r6, [sl], #1
    ca68:	e58d1010 	str	r1, [sp, #16]
    ca6c:	eaffff81 	b	c878 <strtoll+0x5c>
            acc *= base;
            acc += c;
        }
    }
    if (any < 0) {
        acc = neg ? LONG_LONG_MIN : LONG_LONG_MAX;
    ca70:	e59d2010 	ldr	r2, [sp, #16]
    ca74:	e3520000 	cmp	r2, #0	; 0x0
    ca78:	03e08000 	mvneq	r8, #0	; 0x0
    ca7c:	03e09102 	mvneq	r9, #-2147483648	; 0x80000000
    ca80:	13a08000 	movne	r8, #0	; 0x0
    ca84:	13a09102 	movne	r9, #-2147483648	; 0x80000000
        errno = ERANGE;
    ca88:	eb0003b8 	bl	d970 <cyg_error_get_errno_p>
    ca8c:	e3a03022 	mov	r3, #34	; 0x22
    ca90:	e5803000 	str	r3, [r0]
    ca94:	eaffffde 	b	ca14 <strtoll+0x1f8>
    if (c == '-') {
        neg = 1;
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
    ca98:	e5da3000 	ldrb	r3, [sl]
    ca9c:	e3530058 	cmp	r3, #88	; 0x58
    caa0:	13530078 	cmpne	r3, #120	; 0x78
    caa4:	1affff7a 	bne	c894 <strtoll+0x78>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
    caa8:	e5da6001 	ldrb	r6, [sl, #1]
        s += 2;
    caac:	e3a0b010 	mov	fp, #16	; 0x10
    cab0:	e28aa002 	add	sl, sl, #2	; 0x2
    cab4:	e3a08010 	mov	r8, #16	; 0x10
    cab8:	e3a09000 	mov	r9, #0	; 0x0
    cabc:	eaffff80 	b	c8c4 <strtoll+0xa8>

0000cac0 <strtoull>:
// Ignores `locale' stuff.  Assumes that the upper and lower case
// alphabets and digits are each contiguous.
//

unsigned long long
strtoull( const char *nptr, char **endptr, int base )
    cac0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cac4:	e24dd024 	sub	sp, sp, #36	; 0x24
    cac8:	e58d0008 	str	r0, [sp, #8]
    cacc:	e58d1004 	str	r1, [sp, #4]
    cad0:	e1a0b002 	mov	fp, r2
    cad4:	e1a09000 	mov	r9, r0
        CYG_CHECK_DATA_PTR( endptr, "endptr is not a valid pointer!" );
    //
    // See strtoll for comments as to the logic used.
    //
    do {
        c = *s++;
    cad8:	e4d96001 	ldrb	r6, [r9], #1

CYGPRI_LIBC_I18N_CTYPE_INLINE int
isspace( int c )
{
    return ( (c == ' ') || (c == '\f') || (c == '\n') || (c == '\r') ||
             (c == '\t') || (c == '\v') );
    cadc:	e356000c 	cmp	r6, #12	; 0xc
    cae0:	13560020 	cmpne	r6, #32	; 0x20
    cae4:	0afffffb 	beq	cad8 <strtoull+0x18>
    cae8:	e356000d 	cmp	r6, #13	; 0xd
    caec:	1356000a 	cmpne	r6, #10	; 0xa
    caf0:	0afffff8 	beq	cad8 <strtoull+0x18>
    caf4:	e356000b 	cmp	r6, #11	; 0xb
    caf8:	13560009 	cmpne	r6, #9	; 0x9
    cafc:	13a03000 	movne	r3, #0	; 0x0
    cb00:	03a03001 	moveq	r3, #1	; 0x1
    cb04:	0afffff3 	beq	cad8 <strtoull+0x18>
    } while (isspace(c));
    if (c == '-') {
    cb08:	e356002d 	cmp	r6, #45	; 0x2d
    cb0c:	0a00007b 	beq	cd00 <strtoull+0x240>
        neg = 1;
        c = *s++;
    } else if (c == '+')
    cb10:	e356002b 	cmp	r6, #43	; 0x2b
        c = *s++;
    cb14:	04d96001 	ldrbeq	r6, [r9], #1
    cb18:	e58d300c 	str	r3, [sp, #12]
    if ((base == 0 || base == 16) &&
    cb1c:	e27b2001 	rsbs	r2, fp, #1	; 0x1
    cb20:	33a02000 	movcc	r2, #0	; 0x0
    cb24:	e35b0000 	cmp	fp, #0	; 0x0
    cb28:	135b0010 	cmpne	fp, #16	; 0x10
    cb2c:	1a00000f 	bne	cb70 <strtoull+0xb0>
    cb30:	e3560030 	cmp	r6, #48	; 0x30
    cb34:	0a00007b 	beq	cd28 <strtoull+0x268>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
    cb38:	e3520000 	cmp	r2, #0	; 0x0
    cb3c:	0a000093 	beq	cd90 <strtoull+0x2d0>
        base = c == '0' ? 8 : 10;
    cb40:	e3560030 	cmp	r6, #48	; 0x30
    cb44:	0a000087 	beq	cd68 <strtoull+0x2a8>
    cb48:	e3a04000 	mov	r4, #0	; 0x0
    cb4c:	e3a0300a 	mov	r3, #10	; 0xa
    cb50:	e58d3010 	str	r3, [sp, #16]
    cb54:	e58d4014 	str	r4, [sp, #20]
    cb58:	e3a04005 	mov	r4, #5	; 0x5
    cb5c:	e3a0b00a 	mov	fp, #10	; 0xa
    cb60:	e28f7d09 	add	r7, pc, #576	; 0x240
    cb64:	e8970180 	ldm	r7, {r7, r8}
    cb68:	e58d401c 	str	r4, [sp, #28]
    cb6c:	ea000010 	b	cbb4 <strtoull+0xf4>
        acc = ULONG_LONG_MAX;
        errno = ERANGE;
    } else if (neg)
        acc = -acc;
    if (endptr != 0)
        *endptr = (char *) (any ? s - 1 : nptr);
    cb70:	e1a0300b 	mov	r3, fp
    cb74:	e1a04fc3 	asr	r4, r3, #31
    cb78:	e58d3010 	str	r3, [sp, #16]
    cb7c:	e58d4014 	str	r4, [sp, #20]
    cb80:	e1a02003 	mov	r2, r3
    cb84:	e1a03004 	mov	r3, r4
    cb88:	e3e00000 	mvn	r0, #0	; 0x0
    cb8c:	e3e01000 	mvn	r1, #0	; 0x0
    cb90:	eb0014a4 	bl	11e28 <__aeabi_uldivmod>
    cb94:	e28d2010 	add	r2, sp, #16	; 0x10
    cb98:	e892000c 	ldm	r2, {r2, r3}
    cb9c:	e1a07000 	mov	r7, r0
    cba0:	e1a08001 	mov	r8, r1
    cba4:	e3e00000 	mvn	r0, #0	; 0x0
    cba8:	e3e01000 	mvn	r1, #0	; 0x0
    cbac:	eb00149d 	bl	11e28 <__aeabi_uldivmod>
    cbb0:	e58d201c 	str	r2, [sp, #28]
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cbb4:	e3a04000 	mov	r4, #0	; 0x0
    cbb8:	e3a05000 	mov	r5, #0	; 0x0
    cbbc:	e3a0a000 	mov	sl, #0	; 0x0
    cutoff = (unsigned long long)ULONG_LONG_MAX / (unsigned long long)base;
    cutlim = (unsigned long long)ULONG_LONG_MAX % (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    cbc0:	e2463030 	sub	r3, r6, #48	; 0x30
    cbc4:	e3530009 	cmp	r3, #9	; 0x9
            c -= '0';
    cbc8:	91a0c003 	movls	ip, r3
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cutoff = (unsigned long long)ULONG_LONG_MAX / (unsigned long long)base;
    cutlim = (unsigned long long)ULONG_LONG_MAX % (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
    cbcc:	9a000007 	bls	cbf0 <strtoull+0x130>


CYGPRI_LIBC_I18N_CTYPE_INLINE int
isalpha( int c )
{
    return ( islower(c) || isupper(c) );
    cbd0:	e2463061 	sub	r3, r6, #97	; 0x61
    cbd4:	e3530019 	cmp	r3, #25	; 0x19
    cbd8:	8a000021 	bhi	cc64 <strtoull+0x1a4>
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    cbdc:	e2463041 	sub	r3, r6, #65	; 0x41
    cbe0:	e3530019 	cmp	r3, #25	; 0x19
    cbe4:	83a03057 	movhi	r3, #87	; 0x57
    cbe8:	9a00001b 	bls	cc5c <strtoull+0x19c>
    cbec:	e063c006 	rsb	ip, r3, r6
        else
            break;
        if (c >= base)
    cbf0:	e15b000c 	cmp	fp, ip
    cbf4:	da00001d 	ble	cc70 <strtoull+0x1b0>
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    cbf8:	e1550008 	cmp	r5, r8
    cbfc:	e1a03faa 	lsr	r3, sl, #31
    cc00:	e3a02000 	mov	r2, #0	; 0x0
    cc04:	8a000012 	bhi	cc54 <strtoull+0x194>
    cc08:	0a00000f 	beq	cc4c <strtoull+0x18c>
    cc0c:	e1833002 	orr	r3, r3, r2
    cc10:	e21330ff 	ands	r3, r3, #255	; 0xff
    cc14:	1a000009 	bne	cc40 <strtoull+0x180>
    cc18:	e1540007 	cmp	r4, r7
    cc1c:	0a000031 	beq	cce8 <strtoull+0x228>
    cc20:	e59d001c 	ldr	r0, [sp, #28]
    cc24:	e15c0000 	cmp	ip, r0
    cc28:	d3a03000 	movle	r3, #0	; 0x0
    cc2c:	c2033001 	andgt	r3, r3, #1	; 0x1
    cc30:	e3530000 	cmp	r3, #0	; 0x0
    cc34:	0a00001e 	beq	ccb4 <strtoull+0x1f4>
    cc38:	e1a04007 	mov	r4, r7
    cc3c:	e1a05008 	mov	r5, r8
    cc40:	e3e0a000 	mvn	sl, #0	; 0x0
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cutoff = (unsigned long long)ULONG_LONG_MAX / (unsigned long long)base;
    cutlim = (unsigned long long)ULONG_LONG_MAX % (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
    cc44:	e4d96001 	ldrb	r6, [r9], #1
    cc48:	eaffffdc 	b	cbc0 <strtoull+0x100>
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
            break;
        if (c >= base)
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    cc4c:	e1540007 	cmp	r4, r7
    cc50:	9affffed 	bls	cc0c <strtoull+0x14c>
    cc54:	e3a02001 	mov	r2, #1	; 0x1
    cc58:	eaffffeb 	b	cc0c <strtoull+0x14c>
    cutlim = (unsigned long long)ULONG_LONG_MAX % (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
        if (isdigit(c))
            c -= '0';
        else if (isalpha(c))
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    cc5c:	e3a03037 	mov	r3, #55	; 0x37
    cc60:	eaffffe1 	b	cbec <strtoull+0x12c>
    cc64:	e2463041 	sub	r3, r6, #65	; 0x41
    cc68:	e3530019 	cmp	r3, #25	; 0x19
    cc6c:	9afffffa 	bls	cc5c <strtoull+0x19c>
            any = 1;
            acc *= base;
            acc += c;
        }
    }
    if (any < 0) {
    cc70:	e35a0000 	cmp	sl, #0	; 0x0
    cc74:	ba000025 	blt	cd10 <strtoull+0x250>
        acc = ULONG_LONG_MAX;
        errno = ERANGE;
    } else if (neg)
    cc78:	e59d200c 	ldr	r2, [sp, #12]
    cc7c:	e3520000 	cmp	r2, #0	; 0x0
    cc80:	1a00001b 	bne	ccf4 <strtoull+0x234>
        acc = -acc;
    if (endptr != 0)
    cc84:	e59d3004 	ldr	r3, [sp, #4]
    cc88:	e3530000 	cmp	r3, #0	; 0x0
    cc8c:	0a000004 	beq	cca4 <strtoull+0x1e4>
        *endptr = (char *) (any ? s - 1 : nptr);
    cc90:	e35a0000 	cmp	sl, #0	; 0x0
    cc94:	12499001 	subne	r9, r9, #1	; 0x1
    cc98:	158d9008 	strne	r9, [sp, #8]
    cc9c:	e99d0005 	ldmib	sp, {r0, r2}
    cca0:	e5802000 	str	r2, [r0]
    
    CYG_REPORT_RETVAL( acc );

    return acc;
} // strtoull()
    cca4:	e1a01005 	mov	r1, r5
    cca8:	e1a00004 	mov	r0, r4
    ccac:	e28dd024 	add	sp, sp, #36	; 0x24
    ccb0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
            any = -1;
        else {
            any = 1;
            acc *= base;
    ccb4:	e59d3014 	ldr	r3, [sp, #20]
    ccb8:	e0030394 	mul	r3, r4, r3
    ccbc:	e59d0010 	ldr	r0, [sp, #16]
    ccc0:	e0821094 	umull	r1, r2, r4, r0
    ccc4:	e0203095 	mla	r0, r5, r0, r3
            acc += c;
    ccc8:	e1a0400c 	mov	r4, ip
    cccc:	e1a05fc4 	asr	r5, r4, #31
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
            any = -1;
        else {
            any = 1;
            acc *= base;
    ccd0:	e0802002 	add	r2, r0, r2
            acc += c;
    ccd4:	e0944001 	adds	r4, r4, r1
    ccd8:	e0a55002 	adc	r5, r5, r2
    ccdc:	e3a0a001 	mov	sl, #1	; 0x1
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cutoff = (unsigned long long)ULONG_LONG_MAX / (unsigned long long)base;
    cutlim = (unsigned long long)ULONG_LONG_MAX % (unsigned long long)base;
    for (acc = 0, any = 0;; c = *s++) {
    cce0:	e4d96001 	ldrb	r6, [r9], #1
    cce4:	eaffffb5 	b	cbc0 <strtoull+0x100>
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
            break;
        if (c >= base)
            break;
        if ((any < 0) || (acc > cutoff) || ((acc == cutoff) && (c > cutlim)))
    cce8:	e1550008 	cmp	r5, r8
    ccec:	03a03001 	moveq	r3, #1	; 0x1
    ccf0:	eaffffca 	b	cc20 <strtoull+0x160>
    }
    if (any < 0) {
        acc = ULONG_LONG_MAX;
        errno = ERANGE;
    } else if (neg)
        acc = -acc;
    ccf4:	e2744000 	rsbs	r4, r4, #0	; 0x0
    ccf8:	e2e55000 	rsc	r5, r5, #0	; 0x0
    ccfc:	eaffffe0 	b	cc84 <strtoull+0x1c4>
    do {
        c = *s++;
    } while (isspace(c));
    if (c == '-') {
        neg = 1;
        c = *s++;
    cd00:	e3a00001 	mov	r0, #1	; 0x1
    cd04:	e4d96001 	ldrb	r6, [r9], #1
    cd08:	e58d000c 	str	r0, [sp, #12]
    cd0c:	eaffff82 	b	cb1c <strtoull+0x5c>
            acc += c;
        }
    }
    if (any < 0) {
        acc = ULONG_LONG_MAX;
        errno = ERANGE;
    cd10:	eb000316 	bl	d970 <cyg_error_get_errno_p>
    cd14:	e3a03022 	mov	r3, #34	; 0x22
    cd18:	e5803000 	str	r3, [r0]
    cd1c:	e3e04000 	mvn	r4, #0	; 0x0
    cd20:	e3e05000 	mvn	r5, #0	; 0x0
    cd24:	eaffffd6 	b	cc84 <strtoull+0x1c4>
    if (c == '-') {
        neg = 1;
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
    cd28:	e5d93000 	ldrb	r3, [r9]
    cd2c:	e3530058 	cmp	r3, #88	; 0x58
    cd30:	13530078 	cmpne	r3, #120	; 0x78
    cd34:	1affff7f 	bne	cb38 <strtoull+0x78>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
    cd38:	e3a03000 	mov	r3, #0	; 0x0
    cd3c:	e3a02010 	mov	r2, #16	; 0x10
        c = *s++;
    } else if (c == '+')
        c = *s++;
    if ((base == 0 || base == 16) &&
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
    cd40:	e5d96001 	ldrb	r6, [r9, #1]
        s += 2;
    cd44:	e58d2010 	str	r2, [sp, #16]
    cd48:	e58d3014 	str	r3, [sp, #20]
    cd4c:	e3a0300f 	mov	r3, #15	; 0xf
    cd50:	e2899002 	add	r9, r9, #2	; 0x2
    cd54:	e3a0b010 	mov	fp, #16	; 0x10
    cd58:	e3e07000 	mvn	r7, #0	; 0x0
    cd5c:	e3e0820f 	mvn	r8, #-268435456	; 0xf0000000
    cd60:	e58d301c 	str	r3, [sp, #28]
    cd64:	eaffff92 	b	cbb4 <strtoull+0xf4>
        base = 16;
    }
    if (base == 0)
        base = c == '0' ? 8 : 10;
    cd68:	e3a03000 	mov	r3, #0	; 0x0
    cd6c:	e3a02008 	mov	r2, #8	; 0x8
    cd70:	e58d2010 	str	r2, [sp, #16]
    cd74:	e58d3014 	str	r3, [sp, #20]
    cd78:	e3a03007 	mov	r3, #7	; 0x7
    cd7c:	e3a0b008 	mov	fp, #8	; 0x8
    cd80:	e3e07000 	mvn	r7, #0	; 0x0
    cd84:	e3e0820e 	mvn	r8, #-536870912	; 0xe0000000
    cd88:	e58d301c 	str	r3, [sp, #28]
    cd8c:	eaffff88 	b	cbb4 <strtoull+0xf4>
        c == '0' && (*s == 'x' || *s == 'X')) {
        c = s[1];
        s += 2;
        base = 16;
    }
    if (base == 0)
    cd90:	e1a0200b 	mov	r2, fp
    cd94:	e1a03fc2 	asr	r3, r2, #31
    cd98:	e58d2010 	str	r2, [sp, #16]
    cd9c:	e58d3014 	str	r3, [sp, #20]
    cda0:	eaffff78 	b	cb88 <strtoull+0xc8>
    cda4:	e1a00000 	nop			(mov r0,r0)
    cda8:	99999999 	.word	0x99999999
    cdac:	19999999 	.word	0x19999999

0000cdb0 <__memchr>:

    c &= 0xff;
    
    // If the size is small, or src is unaligned, then 
    // use the bytewise loop.  We can hope this is rare.
    if (CYG_LIBC_STR_OPT_TOO_SMALL (n) || CYG_LIBC_STR_UNALIGNED (src)) 
    cdb0:	e3520003 	cmp	r2, #3	; 0x3
memchr( const void *s, int c, size_t n )  CYGBLD_ATTRIB_WEAK_ALIAS(__memchr);

// FUNCTIONS

void *
__memchr( const void *s, int c, size_t n )
    cdb4:	e92d0070 	push	{r4, r5, r6}
    cdb8:	e1a0c002 	mov	ip, r2
    cdbc:	e1a03000 	mov	r3, r0
    CYG_WORD *aligned_src;
    CYG_WORD buffer;
    CYG_WORD mask;
    cyg_ucount8 i;

    c &= 0xff;
    cdc0:	e20110ff 	and	r1, r1, #255	; 0xff
    
    // If the size is small, or src is unaligned, then 
    // use the bytewise loop.  We can hope this is rare.
    if (CYG_LIBC_STR_OPT_TOO_SMALL (n) || CYG_LIBC_STR_UNALIGNED (src)) 
    cdc4:	9a000047 	bls	cee8 <__memchr+0x138>
    cdc8:	e2132003 	ands	r2, r3, #3	; 0x3
    cdcc:	0a00000d 	beq	ce08 <__memchr+0x58>
    {
        while (n--)
        {
            if (*src == c)
    cdd0:	e5d33000 	ldrb	r3, [r3]
    cdd4:	e1530001 	cmp	r3, r1
    
    // If the size is small, or src is unaligned, then 
    // use the bytewise loop.  We can hope this is rare.
    if (CYG_LIBC_STR_OPT_TOO_SMALL (n) || CYG_LIBC_STR_UNALIGNED (src)) 
    {
        while (n--)
    cdd8:	124c2001 	subne	r2, ip, #1	; 0x1
        {
            if (*src == c)
    cddc:	1a000003 	bne	cdf0 <__memchr+0x40>
    cde0:	ea000006 	b	ce00 <__memchr+0x50>
    cde4:	e5f03001 	ldrb	r3, [r0, #1]!
    cde8:	e1530001 	cmp	r3, r1
    cdec:	0a000003 	beq	ce00 <__memchr+0x50>
    
    // If the size is small, or src is unaligned, then 
    // use the bytewise loop.  We can hope this is rare.
    if (CYG_LIBC_STR_OPT_TOO_SMALL (n) || CYG_LIBC_STR_UNALIGNED (src)) 
    {
        while (n--)
    cdf0:	e3520000 	cmp	r2, #0	; 0x0
            if (*src == c)
            {
                CYG_REPORT_RETVAL( src );
                return (void *) src;
            } // if
            src++;
    cdf4:	e2422001 	sub	r2, r2, #1	; 0x1
    
    // If the size is small, or src is unaligned, then 
    // use the bytewise loop.  We can hope this is rare.
    if (CYG_LIBC_STR_OPT_TOO_SMALL (n) || CYG_LIBC_STR_UNALIGNED (src)) 
    {
        while (n--)
    cdf8:	1afffff9 	bne	cde4 <__memchr+0x34>
    
    // If there are fewer than CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE characters
    // left, then we resort to the bytewise loop.
    
    src = (const unsigned char *) aligned_src;
    while (n--)
    cdfc:	e3a00000 	mov	r0, #0	; 0x0

    CYG_REPORT_RETVAL( NULL );
    return NULL;
#endif // not defined(CYGIMP_LIBC_STRING_PREFER_SMALL_TO_FAST) ||
       //     defined(__OPTIMIZE_SIZE__)
} // __memchr()
    ce00:	e8bd0070 	pop	{r4, r5, r6}
    ce04:	e12fff1e 	bx	lr
    // contain the search character, which is detected by XORing 
    // the word-sized segment with a word-sized block of the search
    // character and then detecting for the presence of NULL in the
    // result.

    aligned_src = (CYG_WORD *) src;
    ce08:	e1a04002 	mov	r4, r2
    ce0c:	e1a00003 	mov	r0, r3
    mask = 0;
    for (i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++)
    ce10:	e2822001 	add	r2, r2, #1	; 0x1
        mask = (mask << 8) + c;
    ce14:	e1a03404 	lsl	r3, r4, #8
    // character and then detecting for the presence of NULL in the
    // result.

    aligned_src = (CYG_WORD *) src;
    mask = 0;
    for (i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++)
    ce18:	e3520004 	cmp	r2, #4	; 0x4
        mask = (mask << 8) + c;
    ce1c:	e0834001 	add	r4, r3, r1
    // character and then detecting for the presence of NULL in the
    // result.

    aligned_src = (CYG_WORD *) src;
    mask = 0;
    for (i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++)
    ce20:	1afffffa 	bne	ce10 <__memchr+0x60>
        mask = (mask << 8) + c;
    
    while (n > CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE)
    ce24:	e35c0004 	cmp	ip, #4	; 0x4
    ce28:	0a00001f 	beq	ceac <__memchr+0xfc>
    {
        buffer = *aligned_src;
        buffer ^=  mask;
        if (CYG_LIBC_STR_DETECTNULL (buffer))
    ce2c:	e59f30c0 	ldr	r3, [pc, #192]	; cef4 <__memchr+0x144>
    ce30:	e59f20c0 	ldr	r2, [pc, #192]	; cef8 <__memchr+0x148>
    ce34:	e5936000 	ldr	r6, [r3]
    ce38:	e5925000 	ldr	r5, [r2]
    for (i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++)
        mask = (mask << 8) + c;
    
    while (n > CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE)
    {
        buffer = *aligned_src;
    ce3c:	e5903000 	ldr	r3, [r0]
        buffer ^=  mask;
    ce40:	e0243003 	eor	r3, r4, r3
        if (CYG_LIBC_STR_DETECTNULL (buffer))
    ce44:	e1e02003 	mvn	r2, r3
    ce48:	e0663003 	rsb	r3, r6, r3
    ce4c:	e0033002 	and	r3, r3, r2
    ce50:	e1130005 	tst	r3, r5
                    return (void *) src;
                } // if
                src++;
            }
        }
        n -= CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE;
    ce54:	e24cc004 	sub	ip, ip, #4	; 0x4
    
    while (n > CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE)
    {
        buffer = *aligned_src;
        buffer ^=  mask;
        if (CYG_LIBC_STR_DETECTNULL (buffer))
    ce58:	0a00000e 	beq	ce98 <__memchr+0xe8>
        {
            src = (unsigned char*) aligned_src;
            for ( i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++ )
            {
                if (*src == c)
    ce5c:	e5d03000 	ldrb	r3, [r0]
    ce60:	e1530001 	cmp	r3, r1
    ce64:	0a00001c 	beq	cedc <__memchr+0x12c>
    ce68:	e5d03001 	ldrb	r3, [r0, #1]
    ce6c:	e1530001 	cmp	r3, r1
    ce70:	e2803001 	add	r3, r0, #1	; 0x1
    ce74:	0a000019 	beq	cee0 <__memchr+0x130>
    ce78:	e5d03002 	ldrb	r3, [r0, #2]
    ce7c:	e1530001 	cmp	r3, r1
    ce80:	e2803002 	add	r3, r0, #2	; 0x2
    ce84:	0a000015 	beq	cee0 <__memchr+0x130>
    ce88:	e5d03003 	ldrb	r3, [r0, #3]
    ce8c:	e1530001 	cmp	r3, r1
    ce90:	e2803003 	add	r3, r0, #3	; 0x3
    ce94:	0a000011 	beq	cee0 <__memchr+0x130>
    aligned_src = (CYG_WORD *) src;
    mask = 0;
    for (i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++)
        mask = (mask << 8) + c;
    
    while (n > CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE)
    ce98:	e35c0004 	cmp	ip, #4	; 0x4
                } // if
                src++;
            }
        }
        n -= CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE;
        aligned_src++;
    ce9c:	e2800004 	add	r0, r0, #4	; 0x4
    aligned_src = (CYG_WORD *) src;
    mask = 0;
    for (i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++)
        mask = (mask << 8) + c;
    
    while (n > CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE)
    cea0:	8affffe5 	bhi	ce3c <__memchr+0x8c>
    
    // If there are fewer than CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE characters
    // left, then we resort to the bytewise loop.
    
    src = (const unsigned char *) aligned_src;
    while (n--)
    cea4:	e35c0000 	cmp	ip, #0	; 0x0
    cea8:	0affffd3 	beq	cdfc <__memchr+0x4c>
    {
        if (*src == c)
    ceac:	e5d03000 	ldrb	r3, [r0]
    ceb0:	e1530001 	cmp	r3, r1
    
    // If there are fewer than CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE characters
    // left, then we resort to the bytewise loop.
    
    src = (const unsigned char *) aligned_src;
    while (n--)
    ceb4:	124c2001 	subne	r2, ip, #1	; 0x1
    {
        if (*src == c)
    ceb8:	1a000003 	bne	cecc <__memchr+0x11c>
    cebc:	eaffffcf 	b	ce00 <__memchr+0x50>
    cec0:	e5f03001 	ldrb	r3, [r0, #1]!
    cec4:	e1530001 	cmp	r3, r1
    cec8:	0affffcc 	beq	ce00 <__memchr+0x50>
    
    // If there are fewer than CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE characters
    // left, then we resort to the bytewise loop.
    
    src = (const unsigned char *) aligned_src;
    while (n--)
    cecc:	e3520000 	cmp	r2, #0	; 0x0
        if (*src == c)
        {
            CYG_REPORT_RETVAL( src );
            return (void *) src;
        } // if
        src++;
    ced0:	e2422001 	sub	r2, r2, #1	; 0x1
    
    // If there are fewer than CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE characters
    // left, then we resort to the bytewise loop.
    
    src = (const unsigned char *) aligned_src;
    while (n--)
    ced4:	1afffff9 	bne	cec0 <__memchr+0x110>
    ced8:	eaffffc7 	b	cdfc <__memchr+0x4c>
        if (CYG_LIBC_STR_DETECTNULL (buffer))
        {
            src = (unsigned char*) aligned_src;
            for ( i = 0; i < CYG_LIBC_STR_OPT_LITTLEBLOCKSIZE; i++ )
            {
                if (*src == c)
    cedc:	e1a03000 	mov	r3, r0
    cee0:	e1a00003 	mov	r0, r3
    cee4:	eaffffc5 	b	ce00 <__memchr+0x50>
    
    // If the size is small, or src is unaligned, then 
    // use the bytewise loop.  We can hope this is rare.
    if (CYG_LIBC_STR_OPT_TOO_SMALL (n) || CYG_LIBC_STR_UNALIGNED (src)) 
    {
        while (n--)
    cee8:	e3520000 	cmp	r2, #0	; 0x0
    ceec:	0affffc2 	beq	cdfc <__memchr+0x4c>
    cef0:	eaffffb6 	b	cdd0 <__memchr+0x20>
    cef4:	00012b28 	.word	0x00012b28
    cef8:	00012b30 	.word	0x00012b30

0000cefc <__strlen>:
#else

    const char *start = s;
    CYG_WORD *aligned_addr;
    
    if (CYG_LIBC_STR_UNALIGNED (s))
    cefc:	e3100003 	tst	r0, #3	; 0x3
strlen( const char *s ) CYGBLD_ATTRIB_WEAK_ALIAS(__strlen);

// FUNCTIONS

size_t
__strlen( const char *s )
    cf00:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    cf04:	e1a0c000 	mov	ip, r0
#else

    const char *start = s;
    CYG_WORD *aligned_addr;
    
    if (CYG_LIBC_STR_UNALIGNED (s))
    cf08:	0a000009 	beq	cf34 <__strlen+0x38>
    {
        while (*s)
    cf0c:	e5d00000 	ldrb	r0, [r0]
    cf10:	e3500000 	cmp	r0, #0	; 0x0
    cf14:	0a000004 	beq	cf2c <__strlen+0x30>
    cf18:	e1a0000c 	mov	r0, ip
    cf1c:	e5f03001 	ldrb	r3, [r0, #1]!
    cf20:	e3530000 	cmp	r3, #0	; 0x0
    cf24:	1afffffc 	bne	cf1c <__strlen+0x20>
        s++;
    retval = s - start;

    CYG_REPORT_RETVAL( retval );
    
    return retval;
    cf28:	e06c0000 	rsb	r0, ip, r0
#endif // not defined(CYGIMP_LIBC_STRING_PREFER_SMALL_TO_FAST) ||
       //     defined(__OPTIMIZE_SIZE__)
} // __strlen()
    cf2c:	e8bd0010 	pop	{r4}
    cf30:	e12fff1e 	bx	lr
    
    // If the string is word-aligned, we can check for the presence of 
    // a null in each word-sized block.
    
    aligned_addr = (CYG_WORD *)s;
    while (!CYG_LIBC_STR_DETECTNULL (*aligned_addr))
    cf34:	e59f2068 	ldr	r2, [pc, #104]	; cfa4 <__strlen+0xa8>
    cf38:	e5903000 	ldr	r3, [r0]
    cf3c:	e5924000 	ldr	r4, [r2]
    cf40:	e59f2060 	ldr	r2, [pc, #96]	; cfa8 <__strlen+0xac>
    cf44:	e1e01003 	mvn	r1, r3
    cf48:	e5920000 	ldr	r0, [r2]
    cf4c:	e0643003 	rsb	r3, r4, r3
    cf50:	e0033001 	and	r3, r3, r1
    cf54:	e1130000 	tst	r3, r0
    }
    
    // If the string is word-aligned, we can check for the presence of 
    // a null in each word-sized block.
    
    aligned_addr = (CYG_WORD *)s;
    cf58:	e1a0100c 	mov	r1, ip
    while (!CYG_LIBC_STR_DETECTNULL (*aligned_addr))
    cf5c:	1a000005 	bne	cf78 <__strlen+0x7c>
    cf60:	e5b12004 	ldr	r2, [r1, #4]!
    cf64:	e1e03002 	mvn	r3, r2
    cf68:	e0003003 	and	r3, r0, r3
    cf6c:	e0642002 	rsb	r2, r4, r2
    cf70:	e1130002 	tst	r3, r2
    cf74:	0afffff9 	beq	cf60 <__strlen+0x64>
        aligned_addr++;
    
    // Once a null is detected, we check each byte in that block for a
    // precise position of the null.
    s = (char*)aligned_addr; 
    while (*s)
    cf78:	e5d13000 	ldrb	r3, [r1]
    cf7c:	e3530000 	cmp	r3, #0	; 0x0
    while (!CYG_LIBC_STR_DETECTNULL (*aligned_addr))
        aligned_addr++;
    
    // Once a null is detected, we check each byte in that block for a
    // precise position of the null.
    s = (char*)aligned_addr; 
    cf80:	e1a00001 	mov	r0, r1
    while (*s)
    cf84:	0affffe7 	beq	cf28 <__strlen+0x2c>
    cf88:	e5f03001 	ldrb	r3, [r0, #1]!
    cf8c:	e3530000 	cmp	r3, #0	; 0x0
    cf90:	0affffe4 	beq	cf28 <__strlen+0x2c>
    cf94:	e5f03001 	ldrb	r3, [r0, #1]!
    cf98:	e3530000 	cmp	r3, #0	; 0x0
    cf9c:	1afffff9 	bne	cf88 <__strlen+0x8c>
    cfa0:	eaffffe0 	b	cf28 <__strlen+0x2c>
    cfa4:	00012b28 	.word	0x00012b28
    cfa8:	00012b30 	.word	0x00012b30

0000cfac <modf>:

        double modf(double x, double *iptr)
{
        int i0,i1,j0;
        unsigned i;
        i0 =  CYG_LIBM_HI(x);           /* high x */
    cfac:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    cfb0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    cfb4:	e28d4008 	add	r4, sp, #8	; 0x8
    cfb8:	e9240003 	stmdb	r4!, {r0, r1}
    cfbc:	e5945004 	ldr	r5, [r4, #4]
        i1 =  CYG_LIBM_LO(x);           /* low  x */
        j0 = ((i0>>20)&0x7ff)-0x3ff;    /* exponent of x */
    cfc0:	e1a03a45 	asr	r3, r5, #20
    cfc4:	e1a03a83 	lsl	r3, r3, #21
    cfc8:	e1a03aa3 	lsr	r3, r3, #21
    cfcc:	e243cfff 	sub	ip, r3, #1020	; 0x3fc
    cfd0:	e24cc003 	sub	ip, ip, #3	; 0x3
        if(j0<20) {                     /* integer part in high x */
    cfd4:	e35c0013 	cmp	ip, #19	; 0x13

        double modf(double x, double *iptr)
{
        int i0,i1,j0;
        unsigned i;
        i0 =  CYG_LIBM_HI(x);           /* high x */
    cfd8:	e1a07002 	mov	r7, r2
        i1 =  CYG_LIBM_LO(x);           /* low  x */
    cfdc:	e59d6000 	ldr	r6, [sp]
        j0 = ((i0>>20)&0x7ff)-0x3ff;    /* exponent of x */
        if(j0<20) {                     /* integer part in high x */
    cfe0:	ca000011 	bgt	d02c <modf+0x80>
            if(j0<0) {                  /* |x|<1 */
    cfe4:	e35c0000 	cmp	ip, #0	; 0x0
                CYG_LIBM_HIp(iptr) = i0&0x80000000;
    cfe8:	b2052102 	andlt	r2, r5, #-2147483648	; 0x80000000
                CYG_LIBM_LOp(iptr) = 0;         /* *iptr = +-0 */
    cfec:	b3a03000 	movlt	r3, #0	; 0x0
    cff0:	b5873000 	strlt	r3, [r7]
        i0 =  CYG_LIBM_HI(x);           /* high x */
        i1 =  CYG_LIBM_LO(x);           /* low  x */
        j0 = ((i0>>20)&0x7ff)-0x3ff;    /* exponent of x */
        if(j0<20) {                     /* integer part in high x */
            if(j0<0) {                  /* |x|<1 */
                CYG_LIBM_HIp(iptr) = i0&0x80000000;
    cff4:	b5872004 	strlt	r2, [r7, #4]
        unsigned i;
        i0 =  CYG_LIBM_HI(x);           /* high x */
        i1 =  CYG_LIBM_LO(x);           /* low  x */
        j0 = ((i0>>20)&0x7ff)-0x3ff;    /* exponent of x */
        if(j0<20) {                     /* integer part in high x */
            if(j0<0) {                  /* |x|<1 */
    cff8:	ba000009 	blt	d024 <modf+0x78>
                CYG_LIBM_HIp(iptr) = i0&0x80000000;
                CYG_LIBM_LOp(iptr) = 0;         /* *iptr = +-0 */
                return x;
            } else {
                i = (0x000fffff)>>j0;
    cffc:	e3a03601 	mov	r3, #1048576	; 0x100000
    d000:	e2433001 	sub	r3, r3, #1	; 0x1
    d004:	e1a03c53 	asr	r3, r3, ip
                if(((i0&i)|i1)==0) {            /* x is integral */
    d008:	e0032005 	and	r2, r3, r5
    d00c:	e1922006 	orrs	r2, r2, r6
    d010:	1a000019 	bne	d07c <modf+0xd0>
                    *iptr = x;
                    CYG_LIBM_HI(x) &= 0x80000000;
    d014:	e2053102 	and	r3, r5, #-2147483648	; 0x80000000
                    CYG_LIBM_LO(x)  = 0;        /* return +-0 */
    d018:	e884000c 	stm	r4, {r2, r3}
                CYG_LIBM_LOp(iptr) = 0;         /* *iptr = +-0 */
                return x;
            } else {
                i = (0x000fffff)>>j0;
                if(((i0&i)|i1)==0) {            /* x is integral */
                    *iptr = x;
    d01c:	e8870003 	stm	r7, {r0, r1}
                    CYG_LIBM_HI(x) &= 0x80000000;
                    CYG_LIBM_LO(x)  = 0;        /* return +-0 */
                    return x;
    d020:	e89d0003 	ldm	sp, {r0, r1}
                CYG_LIBM_HIp(iptr) = i0;
                CYG_LIBM_LOp(iptr) = i1&(~i);
                return x - *iptr;
            }
        }
}
    d024:	e28dd00c 	add	sp, sp, #12	; 0xc
    d028:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
                    CYG_LIBM_HIp(iptr) = i0&(~i);
                    CYG_LIBM_LOp(iptr) = 0;
                    return x - *iptr;
                }
            }
        } else if (j0>51) {             /* no fraction part */
    d02c:	e35c0033 	cmp	ip, #51	; 0x33
    d030:	ca00000a 	bgt	d060 <modf+0xb4>
            *iptr = x*one;
            CYG_LIBM_HI(x) &= 0x80000000;
            CYG_LIBM_LO(x)  = 0;        /* return +-0 */
            return x;
        } else {                        /* fraction part in low x */
            i = ((unsigned)(0xffffffff))>>(j0-20);
    d034:	e24c2014 	sub	r2, ip, #20	; 0x14
    d038:	e3e03000 	mvn	r3, #0	; 0x0
    d03c:	e1a02233 	lsr	r2, r3, r2
            if((i1&i)==0) {             /* x is integral */
    d040:	e012c006 	ands	ip, r2, r6
    d044:	0a000013 	beq	d098 <modf+0xec>
                CYG_LIBM_HI(x) &= 0x80000000;
                CYG_LIBM_LO(x)  = 0;    /* return +-0 */
                return x;
            } else {
                CYG_LIBM_HIp(iptr) = i0;
                CYG_LIBM_LOp(iptr) = i1&(~i);
    d048:	e1e03002 	mvn	r3, r2
    d04c:	e0033006 	and	r3, r3, r6
                *iptr = x;
                CYG_LIBM_HI(x) &= 0x80000000;
                CYG_LIBM_LO(x)  = 0;    /* return +-0 */
                return x;
            } else {
                CYG_LIBM_HIp(iptr) = i0;
    d050:	e8870028 	stm	r7, {r3, r5}
                CYG_LIBM_LOp(iptr) = i1&(~i);
                return x - *iptr;
    d054:	e897000c 	ldm	r7, {r2, r3}
    d058:	eb0010a9 	bl	11304 <__aeabi_dsub>
    d05c:	eafffff0 	b	d024 <modf+0x78>
                    return x - *iptr;
                }
            }
        } else if (j0>51) {             /* no fraction part */
            *iptr = x*one;
            CYG_LIBM_HI(x) &= 0x80000000;
    d060:	e2052102 	and	r2, r5, #-2147483648	; 0x80000000
            CYG_LIBM_LO(x)  = 0;        /* return +-0 */
    d064:	e3a03000 	mov	r3, #0	; 0x0
    d068:	e5843000 	str	r3, [r4]
                    return x - *iptr;
                }
            }
        } else if (j0>51) {             /* no fraction part */
            *iptr = x*one;
            CYG_LIBM_HI(x) &= 0x80000000;
    d06c:	e5842004 	str	r2, [r4, #4]
                    CYG_LIBM_LOp(iptr) = 0;
                    return x - *iptr;
                }
            }
        } else if (j0>51) {             /* no fraction part */
            *iptr = x*one;
    d070:	e8870003 	stm	r7, {r0, r1}
            CYG_LIBM_HI(x) &= 0x80000000;
            CYG_LIBM_LO(x)  = 0;        /* return +-0 */
            return x;
    d074:	e89d0003 	ldm	sp, {r0, r1}
    d078:	eaffffe9 	b	d024 <modf+0x78>
                    *iptr = x;
                    CYG_LIBM_HI(x) &= 0x80000000;
                    CYG_LIBM_LO(x)  = 0;        /* return +-0 */
                    return x;
                } else {
                    CYG_LIBM_HIp(iptr) = i0&(~i);
    d07c:	e1e03003 	mvn	r3, r3
    d080:	e0033005 	and	r3, r3, r5
                    CYG_LIBM_LOp(iptr) = 0;
    d084:	e3a02000 	mov	r2, #0	; 0x0
                    *iptr = x;
                    CYG_LIBM_HI(x) &= 0x80000000;
                    CYG_LIBM_LO(x)  = 0;        /* return +-0 */
                    return x;
                } else {
                    CYG_LIBM_HIp(iptr) = i0&(~i);
    d088:	e887000c 	stm	r7, {r2, r3}
                    CYG_LIBM_LOp(iptr) = 0;
                    return x - *iptr;
    d08c:	e897000c 	ldm	r7, {r2, r3}
    d090:	eb00109b 	bl	11304 <__aeabi_dsub>
    d094:	eaffffe2 	b	d024 <modf+0x78>
            return x;
        } else {                        /* fraction part in low x */
            i = ((unsigned)(0xffffffff))>>(j0-20);
            if((i1&i)==0) {             /* x is integral */
                *iptr = x;
                CYG_LIBM_HI(x) &= 0x80000000;
    d098:	e2053102 	and	r3, r5, #-2147483648	; 0x80000000
                CYG_LIBM_LO(x)  = 0;    /* return +-0 */
    d09c:	e584c000 	str	ip, [r4]
            return x;
        } else {                        /* fraction part in low x */
            i = ((unsigned)(0xffffffff))>>(j0-20);
            if((i1&i)==0) {             /* x is integral */
                *iptr = x;
                CYG_LIBM_HI(x) &= 0x80000000;
    d0a0:	e5843004 	str	r3, [r4, #4]
            CYG_LIBM_LO(x)  = 0;        /* return +-0 */
            return x;
        } else {                        /* fraction part in low x */
            i = ((unsigned)(0xffffffff))>>(j0-20);
            if((i1&i)==0) {             /* x is integral */
                *iptr = x;
    d0a4:	e8870003 	stm	r7, {r0, r1}
                CYG_LIBM_HI(x) &= 0x80000000;
                CYG_LIBM_LO(x)  = 0;    /* return +-0 */
                return x;
    d0a8:	e89d0003 	ldm	sp, {r0, r1}
    d0ac:	eaffffdc 	b	d024 <modf+0x78>

0000d0b0 <__strerror>:
{
    register char *s;
    
    CYG_REPORT_FUNCNAMETYPE( "__strerror", "String form of error is \"%s\"" );

    switch (errnum)
    d0b0:	e3a03f5b 	mov	r3, #364	; 0x16c
    d0b4:	e2833001 	add	r3, r3, #1	; 0x1
    d0b8:	e1500003 	cmp	r0, r3
    d0bc:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
    d0c0:	ea00018d 	b	d6fc <__strerror+0x64c>
    d0c4:	0000d7dc 	.word	0x0000d7dc
    d0c8:	0000d7d4 	.word	0x0000d7d4
    d0cc:	0000d7cc 	.word	0x0000d7cc
    d0d0:	0000d7c4 	.word	0x0000d7c4
    d0d4:	0000d7bc 	.word	0x0000d7bc
    d0d8:	0000d7b4 	.word	0x0000d7b4
    d0dc:	0000d6fc 	.word	0x0000d6fc
    d0e0:	0000d6fc 	.word	0x0000d6fc
    d0e4:	0000d6fc 	.word	0x0000d6fc
    d0e8:	0000d7ac 	.word	0x0000d7ac
    d0ec:	0000d6fc 	.word	0x0000d6fc
    d0f0:	0000d7a4 	.word	0x0000d7a4
    d0f4:	0000d79c 	.word	0x0000d79c
    d0f8:	0000d6fc 	.word	0x0000d6fc
    d0fc:	0000d6fc 	.word	0x0000d6fc
    d100:	0000d6fc 	.word	0x0000d6fc
    d104:	0000d794 	.word	0x0000d794
    d108:	0000d6fc 	.word	0x0000d6fc
    d10c:	0000d78c 	.word	0x0000d78c
    d110:	0000d784 	.word	0x0000d784
    d114:	0000d77c 	.word	0x0000d77c
    d118:	0000d774 	.word	0x0000d774
    d11c:	0000d76c 	.word	0x0000d76c
    d120:	0000d764 	.word	0x0000d764
    d124:	0000d75c 	.word	0x0000d75c
    d128:	0000d6fc 	.word	0x0000d6fc
    d12c:	0000d6fc 	.word	0x0000d6fc
    d130:	0000d754 	.word	0x0000d754
    d134:	0000d74c 	.word	0x0000d74c
    d138:	0000d744 	.word	0x0000d744
    d13c:	0000d73c 	.word	0x0000d73c
    d140:	0000d6fc 	.word	0x0000d6fc
    d144:	0000d6fc 	.word	0x0000d6fc
    d148:	0000d734 	.word	0x0000d734
    d14c:	0000d72c 	.word	0x0000d72c
    d150:	0000d724 	.word	0x0000d724
    d154:	0000d6fc 	.word	0x0000d6fc
    d158:	0000d6fc 	.word	0x0000d6fc
    d15c:	0000d71c 	.word	0x0000d71c
    d160:	0000d6fc 	.word	0x0000d6fc
    d164:	0000d6fc 	.word	0x0000d6fc
    d168:	0000d6fc 	.word	0x0000d6fc
    d16c:	0000d6fc 	.word	0x0000d6fc
    d170:	0000d6fc 	.word	0x0000d6fc
    d174:	0000d6fc 	.word	0x0000d6fc
    d178:	0000d6fc 	.word	0x0000d6fc
    d17c:	0000d6fc 	.word	0x0000d6fc
    d180:	0000d6fc 	.word	0x0000d6fc
    d184:	0000d6fc 	.word	0x0000d6fc
    d188:	0000d6fc 	.word	0x0000d6fc
    d18c:	0000d6fc 	.word	0x0000d6fc
    d190:	0000d6fc 	.word	0x0000d6fc
    d194:	0000d6fc 	.word	0x0000d6fc
    d198:	0000d6fc 	.word	0x0000d6fc
    d19c:	0000d6fc 	.word	0x0000d6fc
    d1a0:	0000d6fc 	.word	0x0000d6fc
    d1a4:	0000d6fc 	.word	0x0000d6fc
    d1a8:	0000d6fc 	.word	0x0000d6fc
    d1ac:	0000d6fc 	.word	0x0000d6fc
    d1b0:	0000d6fc 	.word	0x0000d6fc
    d1b4:	0000d714 	.word	0x0000d714
    d1b8:	0000d6fc 	.word	0x0000d6fc
    d1bc:	0000d6fc 	.word	0x0000d6fc
    d1c0:	0000d6fc 	.word	0x0000d6fc
    d1c4:	0000d6fc 	.word	0x0000d6fc
    d1c8:	0000d6fc 	.word	0x0000d6fc
    d1cc:	0000d6fc 	.word	0x0000d6fc
    d1d0:	0000d6fc 	.word	0x0000d6fc
    d1d4:	0000d6fc 	.word	0x0000d6fc
    d1d8:	0000d6fc 	.word	0x0000d6fc
    d1dc:	0000d6fc 	.word	0x0000d6fc
    d1e0:	0000d6fc 	.word	0x0000d6fc
    d1e4:	0000d6fc 	.word	0x0000d6fc
    d1e8:	0000d6fc 	.word	0x0000d6fc
    d1ec:	0000d6fc 	.word	0x0000d6fc
    d1f0:	0000d6fc 	.word	0x0000d6fc
    d1f4:	0000d6fc 	.word	0x0000d6fc
    d1f8:	0000d6fc 	.word	0x0000d6fc
    d1fc:	0000d6fc 	.word	0x0000d6fc
    d200:	0000d6fc 	.word	0x0000d6fc
    d204:	0000d6fc 	.word	0x0000d6fc
    d208:	0000d6fc 	.word	0x0000d6fc
    d20c:	0000d6fc 	.word	0x0000d6fc
    d210:	0000d6fc 	.word	0x0000d6fc
    d214:	0000d6fc 	.word	0x0000d6fc
    d218:	0000d6fc 	.word	0x0000d6fc
    d21c:	0000d6fc 	.word	0x0000d6fc
    d220:	0000d6fc 	.word	0x0000d6fc
    d224:	0000d6fc 	.word	0x0000d6fc
    d228:	0000d6fc 	.word	0x0000d6fc
    d22c:	0000d6fc 	.word	0x0000d6fc
    d230:	0000d6fc 	.word	0x0000d6fc
    d234:	0000d6fc 	.word	0x0000d6fc
    d238:	0000d6fc 	.word	0x0000d6fc
    d23c:	0000d6fc 	.word	0x0000d6fc
    d240:	0000d70c 	.word	0x0000d70c
    d244:	0000d6fc 	.word	0x0000d6fc
    d248:	0000d6fc 	.word	0x0000d6fc
    d24c:	0000d6fc 	.word	0x0000d6fc
    d250:	0000d6fc 	.word	0x0000d6fc
    d254:	0000d6fc 	.word	0x0000d6fc
    d258:	0000d6fc 	.word	0x0000d6fc
    d25c:	0000d6fc 	.word	0x0000d6fc
    d260:	0000d6fc 	.word	0x0000d6fc
    d264:	0000d6fc 	.word	0x0000d6fc
    d268:	0000d6fc 	.word	0x0000d6fc
    d26c:	0000d6fc 	.word	0x0000d6fc
    d270:	0000d6fc 	.word	0x0000d6fc
    d274:	0000d6fc 	.word	0x0000d6fc
    d278:	0000d6fc 	.word	0x0000d6fc
    d27c:	0000d6fc 	.word	0x0000d6fc
    d280:	0000d6fc 	.word	0x0000d6fc
    d284:	0000d6fc 	.word	0x0000d6fc
    d288:	0000d6fc 	.word	0x0000d6fc
    d28c:	0000d6fc 	.word	0x0000d6fc
    d290:	0000d6fc 	.word	0x0000d6fc
    d294:	0000d6fc 	.word	0x0000d6fc
    d298:	0000d6fc 	.word	0x0000d6fc
    d29c:	0000d6fc 	.word	0x0000d6fc
    d2a0:	0000d6fc 	.word	0x0000d6fc
    d2a4:	0000d6fc 	.word	0x0000d6fc
    d2a8:	0000d6fc 	.word	0x0000d6fc
    d2ac:	0000d6fc 	.word	0x0000d6fc
    d2b0:	0000d6fc 	.word	0x0000d6fc
    d2b4:	0000d6fc 	.word	0x0000d6fc
    d2b8:	0000d6fc 	.word	0x0000d6fc
    d2bc:	0000d6fc 	.word	0x0000d6fc
    d2c0:	0000d6fc 	.word	0x0000d6fc
    d2c4:	0000d6fc 	.word	0x0000d6fc
    d2c8:	0000d6fc 	.word	0x0000d6fc
    d2cc:	0000d6fc 	.word	0x0000d6fc
    d2d0:	0000d6fc 	.word	0x0000d6fc
    d2d4:	0000d6fc 	.word	0x0000d6fc
    d2d8:	0000d6fc 	.word	0x0000d6fc
    d2dc:	0000d6fc 	.word	0x0000d6fc
    d2e0:	0000d6fc 	.word	0x0000d6fc
    d2e4:	0000d6fc 	.word	0x0000d6fc
    d2e8:	0000d6fc 	.word	0x0000d6fc
    d2ec:	0000d6fc 	.word	0x0000d6fc
    d2f0:	d6fc      	.short	0xd6fc
    d2f2:	00          	.byte	0x00
    d2f3:	00          	.byte	0x00
    d2f4:	0000d6fc 	.word	0x0000d6fc
    d2f8:	0000d6fc 	.word	0x0000d6fc
    d2fc:	0000d6fc 	.word	0x0000d6fc
    d300:	0000d6fc 	.word	0x0000d6fc
    d304:	0000d6fc 	.word	0x0000d6fc
    d308:	0000d6fc 	.word	0x0000d6fc
    d30c:	0000d6fc 	.word	0x0000d6fc
    d310:	0000d6fc 	.word	0x0000d6fc
    d314:	0000d6fc 	.word	0x0000d6fc
    d318:	0000d6fc 	.word	0x0000d6fc
    d31c:	0000d6fc 	.word	0x0000d6fc
    d320:	0000d6fc 	.word	0x0000d6fc
    d324:	0000d6fc 	.word	0x0000d6fc
    d328:	0000d6fc 	.word	0x0000d6fc
    d32c:	0000d6fc 	.word	0x0000d6fc
    d330:	0000d6fc 	.word	0x0000d6fc
    d334:	0000d6fc 	.word	0x0000d6fc
    d338:	0000d6fc 	.word	0x0000d6fc
    d33c:	0000d6fc 	.word	0x0000d6fc
    d340:	0000d6fc 	.word	0x0000d6fc
    d344:	0000d6fc 	.word	0x0000d6fc
    d348:	0000d6fc 	.word	0x0000d6fc
    d34c:	0000d6fc 	.word	0x0000d6fc
    d350:	0000d6fc 	.word	0x0000d6fc
    d354:	0000d6fc 	.word	0x0000d6fc
    d358:	0000d6fc 	.word	0x0000d6fc
    d35c:	0000d6fc 	.word	0x0000d6fc
    d360:	0000d6fc 	.word	0x0000d6fc
    d364:	0000d6fc 	.word	0x0000d6fc
    d368:	0000d6fc 	.word	0x0000d6fc
    d36c:	0000d6fc 	.word	0x0000d6fc
    d370:	0000d6fc 	.word	0x0000d6fc
    d374:	0000d6fc 	.word	0x0000d6fc
    d378:	0000d6fc 	.word	0x0000d6fc
    d37c:	0000d6fc 	.word	0x0000d6fc
    d380:	0000d6fc 	.word	0x0000d6fc
    d384:	0000d6fc 	.word	0x0000d6fc
    d388:	0000d6fc 	.word	0x0000d6fc
    d38c:	0000d6fc 	.word	0x0000d6fc
    d390:	0000d6fc 	.word	0x0000d6fc
    d394:	0000d6fc 	.word	0x0000d6fc
    d398:	0000d6fc 	.word	0x0000d6fc
    d39c:	0000d6fc 	.word	0x0000d6fc
    d3a0:	0000d6fc 	.word	0x0000d6fc
    d3a4:	0000d6fc 	.word	0x0000d6fc
    d3a8:	0000d6fc 	.word	0x0000d6fc
    d3ac:	0000d6fc 	.word	0x0000d6fc
    d3b0:	0000d6fc 	.word	0x0000d6fc
    d3b4:	0000d6fc 	.word	0x0000d6fc
    d3b8:	0000d6fc 	.word	0x0000d6fc
    d3bc:	0000d6fc 	.word	0x0000d6fc
    d3c0:	0000d6fc 	.word	0x0000d6fc
    d3c4:	0000d6fc 	.word	0x0000d6fc
    d3c8:	0000d6fc 	.word	0x0000d6fc
    d3cc:	0000d6fc 	.word	0x0000d6fc
    d3d0:	0000d6fc 	.word	0x0000d6fc
    d3d4:	0000d6fc 	.word	0x0000d6fc
    d3d8:	0000d6fc 	.word	0x0000d6fc
    d3dc:	0000d6fc 	.word	0x0000d6fc
    d3e0:	0000d6fc 	.word	0x0000d6fc
    d3e4:	0000d704 	.word	0x0000d704
    d3e8:	0000d67c 	.word	0x0000d67c
    d3ec:	0000d6f4 	.word	0x0000d6f4
    d3f0:	0000d6fc 	.word	0x0000d6fc
    d3f4:	0000d6fc 	.word	0x0000d6fc
    d3f8:	0000d6fc 	.word	0x0000d6fc
    d3fc:	0000d6fc 	.word	0x0000d6fc
    d400:	0000d6fc 	.word	0x0000d6fc
    d404:	0000d6fc 	.word	0x0000d6fc
    d408:	0000d6fc 	.word	0x0000d6fc
    d40c:	0000d6fc 	.word	0x0000d6fc
    d410:	0000d6fc 	.word	0x0000d6fc
    d414:	0000d6fc 	.word	0x0000d6fc
    d418:	0000d6fc 	.word	0x0000d6fc
    d41c:	0000d6fc 	.word	0x0000d6fc
    d420:	0000d6fc 	.word	0x0000d6fc
    d424:	0000d6fc 	.word	0x0000d6fc
    d428:	0000d6fc 	.word	0x0000d6fc
    d42c:	0000d6fc 	.word	0x0000d6fc
    d430:	0000d6fc 	.word	0x0000d6fc
    d434:	0000d6fc 	.word	0x0000d6fc
    d438:	0000d6fc 	.word	0x0000d6fc
    d43c:	0000d6fc 	.word	0x0000d6fc
    d440:	0000d6fc 	.word	0x0000d6fc
    d444:	0000d6fc 	.word	0x0000d6fc
    d448:	0000d6fc 	.word	0x0000d6fc
    d44c:	0000d6fc 	.word	0x0000d6fc
    d450:	0000d6fc 	.word	0x0000d6fc
    d454:	0000d6fc 	.word	0x0000d6fc
    d458:	0000d6fc 	.word	0x0000d6fc
    d45c:	0000d6fc 	.word	0x0000d6fc
    d460:	0000d6fc 	.word	0x0000d6fc
    d464:	0000d6fc 	.word	0x0000d6fc
    d468:	0000d6fc 	.word	0x0000d6fc
    d46c:	0000d6fc 	.word	0x0000d6fc
    d470:	0000d6fc 	.word	0x0000d6fc
    d474:	0000d6fc 	.word	0x0000d6fc
    d478:	0000d6fc 	.word	0x0000d6fc
    d47c:	0000d6fc 	.word	0x0000d6fc
    d480:	0000d6fc 	.word	0x0000d6fc
    d484:	0000d6fc 	.word	0x0000d6fc
    d488:	0000d6fc 	.word	0x0000d6fc
    d48c:	0000d6fc 	.word	0x0000d6fc
    d490:	0000d6fc 	.word	0x0000d6fc
    d494:	0000d6fc 	.word	0x0000d6fc
    d498:	0000d6fc 	.word	0x0000d6fc
    d49c:	0000d6fc 	.word	0x0000d6fc
    d4a0:	0000d6fc 	.word	0x0000d6fc
    d4a4:	0000d6fc 	.word	0x0000d6fc
    d4a8:	0000d6fc 	.word	0x0000d6fc
    d4ac:	0000d6fc 	.word	0x0000d6fc
    d4b0:	0000d6fc 	.word	0x0000d6fc
    d4b4:	0000d6fc 	.word	0x0000d6fc
    d4b8:	0000d6fc 	.word	0x0000d6fc
    d4bc:	0000d6fc 	.word	0x0000d6fc
    d4c0:	0000d6fc 	.word	0x0000d6fc
    d4c4:	0000d6fc 	.word	0x0000d6fc
    d4c8:	0000d6fc 	.word	0x0000d6fc
    d4cc:	0000d6fc 	.word	0x0000d6fc
    d4d0:	0000d6fc 	.word	0x0000d6fc
    d4d4:	0000d6fc 	.word	0x0000d6fc
    d4d8:	0000d6fc 	.word	0x0000d6fc
    d4dc:	0000d6fc 	.word	0x0000d6fc
    d4e0:	0000d6fc 	.word	0x0000d6fc
    d4e4:	0000d6fc 	.word	0x0000d6fc
    d4e8:	0000d6fc 	.word	0x0000d6fc
    d4ec:	0000d6fc 	.word	0x0000d6fc
    d4f0:	0000d6fc 	.word	0x0000d6fc
    d4f4:	0000d6fc 	.word	0x0000d6fc
    d4f8:	0000d6fc 	.word	0x0000d6fc
    d4fc:	0000d6fc 	.word	0x0000d6fc
    d500:	0000d6fc 	.word	0x0000d6fc
    d504:	0000d6fc 	.word	0x0000d6fc
    d508:	0000d6fc 	.word	0x0000d6fc
    d50c:	0000d6fc 	.word	0x0000d6fc
    d510:	0000d6fc 	.word	0x0000d6fc
    d514:	0000d6fc 	.word	0x0000d6fc
    d518:	0000d6fc 	.word	0x0000d6fc
    d51c:	0000d6fc 	.word	0x0000d6fc
    d520:	0000d6fc 	.word	0x0000d6fc
    d524:	0000d6fc 	.word	0x0000d6fc
    d528:	0000d6fc 	.word	0x0000d6fc
    d52c:	0000d6fc 	.word	0x0000d6fc
    d530:	0000d6fc 	.word	0x0000d6fc
    d534:	0000d6fc 	.word	0x0000d6fc
    d538:	0000d6fc 	.word	0x0000d6fc
    d53c:	0000d6fc 	.word	0x0000d6fc
    d540:	0000d6fc 	.word	0x0000d6fc
    d544:	0000d6fc 	.word	0x0000d6fc
    d548:	0000d6fc 	.word	0x0000d6fc
    d54c:	0000d6fc 	.word	0x0000d6fc
    d550:	0000d6fc 	.word	0x0000d6fc
    d554:	0000d6fc 	.word	0x0000d6fc
    d558:	0000d6fc 	.word	0x0000d6fc
    d55c:	0000d6fc 	.word	0x0000d6fc
    d560:	0000d6fc 	.word	0x0000d6fc
    d564:	0000d6fc 	.word	0x0000d6fc
    d568:	0000d6fc 	.word	0x0000d6fc
    d56c:	0000d6fc 	.word	0x0000d6fc
    d570:	0000d6fc 	.word	0x0000d6fc
    d574:	0000d6ec 	.word	0x0000d6ec
    d578:	0000d6e4 	.word	0x0000d6e4
    d57c:	0000d6dc 	.word	0x0000d6dc
    d580:	0000d6d4 	.word	0x0000d6d4
    d584:	0000d6cc 	.word	0x0000d6cc
    d588:	0000d6fc 	.word	0x0000d6fc
    d58c:	0000d6fc 	.word	0x0000d6fc
    d590:	0000d6fc 	.word	0x0000d6fc
    d594:	0000d6fc 	.word	0x0000d6fc
    d598:	d6fc      	.short	0xd6fc
    d59a:	00          	.byte	0x00
    d59b:	00          	.byte	0x00
    d59c:	0000d6c4 	.word	0x0000d6c4
    d5a0:	0000d6bc 	.word	0x0000d6bc
    d5a4:	0000d6fc 	.word	0x0000d6fc
    d5a8:	0000d6fc 	.word	0x0000d6fc
    d5ac:	0000d6fc 	.word	0x0000d6fc
    d5b0:	0000d6fc 	.word	0x0000d6fc
    d5b4:	0000d6fc 	.word	0x0000d6fc
    d5b8:	0000d6fc 	.word	0x0000d6fc
    d5bc:	0000d6fc 	.word	0x0000d6fc
    d5c0:	0000d6fc 	.word	0x0000d6fc
    d5c4:	0000d6b4 	.word	0x0000d6b4
    d5c8:	0000d6ac 	.word	0x0000d6ac
    d5cc:	0000d6a4 	.word	0x0000d6a4
    d5d0:	0000d69c 	.word	0x0000d69c
    d5d4:	0000d694 	.word	0x0000d694
    d5d8:	0000d68c 	.word	0x0000d68c
    d5dc:	0000d684 	.word	0x0000d684
    d5e0:	0000d67c 	.word	0x0000d67c
    d5e4:	0000d86c 	.word	0x0000d86c
    d5e8:	0000d864 	.word	0x0000d864
    d5ec:	0000d85c 	.word	0x0000d85c
    d5f0:	0000d854 	.word	0x0000d854
    d5f4:	0000d6fc 	.word	0x0000d6fc
    d5f8:	0000d6fc 	.word	0x0000d6fc
    d5fc:	0000d6fc 	.word	0x0000d6fc
    d600:	0000d6fc 	.word	0x0000d6fc
    d604:	0000d6fc 	.word	0x0000d6fc
    d608:	0000d6fc 	.word	0x0000d6fc
    d60c:	0000d6fc 	.word	0x0000d6fc
    d610:	0000d6fc 	.word	0x0000d6fc
    d614:	0000d6fc 	.word	0x0000d6fc
    d618:	0000d6fc 	.word	0x0000d6fc
    d61c:	0000d6fc 	.word	0x0000d6fc
    d620:	0000d6fc 	.word	0x0000d6fc
    d624:	0000d6fc 	.word	0x0000d6fc
    d628:	0000d6fc 	.word	0x0000d6fc
    d62c:	0000d6fc 	.word	0x0000d6fc
    d630:	0000d6fc 	.word	0x0000d6fc
    d634:	0000d6fc 	.word	0x0000d6fc
    d638:	0000d6fc 	.word	0x0000d6fc
    d63c:	0000d84c 	.word	0x0000d84c
    d640:	0000d844 	.word	0x0000d844
    d644:	0000d83c 	.word	0x0000d83c
    d648:	0000d834 	.word	0x0000d834
    d64c:	0000d82c 	.word	0x0000d82c
    d650:	0000d824 	.word	0x0000d824
    d654:	0000d81c 	.word	0x0000d81c
    d658:	0000d814 	.word	0x0000d814
    d65c:	0000d80c 	.word	0x0000d80c
    d660:	0000d804 	.word	0x0000d804
    d664:	0000d7fc 	.word	0x0000d7fc
    d668:	0000d7f4 	.word	0x0000d7f4
    d66c:	0000d6fc 	.word	0x0000d6fc
    d670:	0000d6fc 	.word	0x0000d6fc
    d674:	0000d7ec 	.word	0x0000d7ec
    d678:	0000d7e4 	.word	0x0000d7e4
        s = (char *)"Socket type not supported";
        break;
#endif
#ifdef EOPNOTSUPP
    case EOPNOTSUPP:
        s = (char *)"Operation not supported";
    d67c:	e59f01f0 	ldr	r0, [pc, #496]	; d874 <__strerror+0x7c4>
    d680:	e12fff1e 	bx	lr
        s = (char *)"Protocol not supported";
        break;
#endif
#ifdef ESOCKTNOSUPPORT
    case ESOCKTNOSUPPORT:
        s = (char *)"Socket type not supported";
    d684:	e59f01ec 	ldr	r0, [pc, #492]	; d878 <__strerror+0x7c8>
    d688:	e12fff1e 	bx	lr
        s = (char *)"Protocol not available";
        break;
#endif
#ifdef EPROTONOSUPPORT
    case EPROTONOSUPPORT:
        s = (char *)"Protocol not supported";
    d68c:	e59f01e8 	ldr	r0, [pc, #488]	; d87c <__strerror+0x7cc>
    d690:	e12fff1e 	bx	lr
        s = (char *)"Protocol wrong type for socket";
        break;
#endif
#ifdef ENOPROTOOPT
    case ENOPROTOOPT:
        s = (char *)"Protocol not available";
    d694:	e59f01e4 	ldr	r0, [pc, #484]	; d880 <__strerror+0x7d0>
    d698:	e12fff1e 	bx	lr
        s = (char *)"Message too long";
        break;
#endif
#ifdef EPROTOTYPE
    case EPROTOTYPE:
        s = (char *)"Protocol wrong type for socket";
    d69c:	e59f01e0 	ldr	r0, [pc, #480]	; d884 <__strerror+0x7d4>
    d6a0:	e12fff1e 	bx	lr
        s = (char *)"Destination address required";
        break;
#endif
#ifdef EMSGSIZE
    case EMSGSIZE:
        s = (char *)"Message too long";
    d6a4:	e59f01dc 	ldr	r0, [pc, #476]	; d888 <__strerror+0x7d8>
    d6a8:	e12fff1e 	bx	lr
        s = (char *)"Socket operation on non-socket";
        break;
#endif
#ifdef EDESTADDRREQ
    case EDESTADDRREQ:
        s = (char *)"Destination address required";
    d6ac:	e59f01d8 	ldr	r0, [pc, #472]	; d88c <__strerror+0x7dc>
    d6b0:	e12fff1e 	bx	lr
        s = (char *)"Operation already in progress";
        break;
#endif
#ifdef ENOTSOCK
    case ENOTSOCK:
        s = (char *)"Socket operation on non-socket";
    d6b4:	e59f01d4 	ldr	r0, [pc, #468]	; d890 <__strerror+0x7e0>
    d6b8:	e12fff1e 	bx	lr
        s = (char *)"Operation now in progress";
        break;
#endif
#ifdef EALREADY
    case EALREADY:
        s = (char *)"Operation already in progress";
    d6bc:	e59f01d0 	ldr	r0, [pc, #464]	; d894 <__strerror+0x7e4>
    d6c0:	e12fff1e 	bx	lr
        s = (char *)"Broken pipe";
        break;
#endif
#ifdef EINPROGRESS
    case EINPROGRESS:
        s = (char *)"Operation now in progress";
    d6c4:	e59f01cc 	ldr	r0, [pc, #460]	; d898 <__strerror+0x7e8>
    d6c8:	e12fff1e 	bx	lr
        s = (char *)"Inappropriate ioctl for device";
        break;
#endif
#ifdef EPIPE
    case EPIPE:
        s = (char *)"Broken pipe";
    d6cc:	e59f01c8 	ldr	r0, [pc, #456]	; d89c <__strerror+0x7ec>
    d6d0:	e12fff1e 	bx	lr
        s = (char *)"File exists";
        break;
#endif
#ifdef ENOTTY
    case ENOTTY:
        s = (char *)"Inappropriate ioctl for device";
    d6d4:	e59f01c4 	ldr	r0, [pc, #452]	; d8a0 <__strerror+0x7f0>
    d6d8:	e12fff1e 	bx	lr
        s = (char *)"Permission denied";
        break;
#endif
#ifdef EEXIST
    case EEXIST:
        s = (char *)"File exists";
    d6dc:	e59f01c0 	ldr	r0, [pc, #448]	; d8a4 <__strerror+0x7f4>
    d6e0:	e12fff1e 	bx	lr
        s = (char *)"Device not configured";
        break;
#endif
#ifdef EACCES
    case EACCES:
        s = (char *)"Permission denied";
    d6e4:	e59f01bc 	ldr	r0, [pc, #444]	; d8a8 <__strerror+0x7f8>
    d6e8:	e12fff1e 	bx	lr
#endif
        
// Additional errors used by networking
#ifdef ENXIO
    case ENXIO:
        s = (char *)"Device not configured";
    d6ec:	e59f01b8 	ldr	r0, [pc, #440]	; d8ac <__strerror+0x7fc>
    d6f0:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EDEVNOSUPP
    case EDEVNOSUPP:
        s = (char *)"Device does not support this operation";
    d6f4:	e59f01b4 	ldr	r0, [pc, #436]	; d8b0 <__strerror+0x800>
    d6f8:	e12fff1e 	bx	lr
        s = (char *)"No route to host";
        break;
#endif

    default:
        s = (char *)"Unknown error";
    d6fc:	e59f01b0 	ldr	r0, [pc, #432]	; d8b4 <__strerror+0x804>
    } // switch

    CYG_REPORT_RETVAL(s);

    return s;
} // __strerror()
    d700:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EEOF
    case EEOF:
        s = (char *)"End of file reached";
    d704:	e59f01ac 	ldr	r0, [pc, #428]	; d8b8 <__strerror+0x808>
    d708:	e12fff1e 	bx	lr
        break;
#endif
        
#ifdef ENOTSUP
    case ENOTSUP:
        s = (char *)"Not supported";
    d70c:	e59f01a8 	ldr	r0, [pc, #424]	; d8bc <__strerror+0x80c>
    d710:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENAMETOOLONG
    case ENAMETOOLONG:
        s = (char *)"File name too long";
    d714:	e59f01a4 	ldr	r0, [pc, #420]	; d8c0 <__strerror+0x810>
    d718:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENOSYS
    case ENOSYS:
        s = (char *)"Function not implemented";
    d71c:	e59f01a0 	ldr	r0, [pc, #416]	; d8c4 <__strerror+0x814>
    d720:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EDEADLK
    case EDEADLK:
        s = (char *)"Resource deadlock would occur";
    d724:	e59f019c 	ldr	r0, [pc, #412]	; d8c8 <__strerror+0x818>
    d728:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ERANGE
    case ERANGE:
        s = (char *)"Math result cannot be represented";
    d72c:	e59f0198 	ldr	r0, [pc, #408]	; d8cc <__strerror+0x81c>
    d730:	e12fff1e 	bx	lr
        break;
#endif
        
#ifdef EDOM
    case EDOM:
        s = (char *)"Argument to math function outside valid domain";
    d734:	e59f0194 	ldr	r0, [pc, #404]	; d8d0 <__strerror+0x820>
    d738:	e12fff1e 	bx	lr
        break;
#endif
        
#ifdef EROFS
    case EROFS:
        s = (char *)"Read-only file system";
    d73c:	e59f0190 	ldr	r0, [pc, #400]	; d8d4 <__strerror+0x824>
    d740:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ESPIPE
    case ESPIPE:
        s = (char *)"Illegal seek";
    d744:	e59f018c 	ldr	r0, [pc, #396]	; d8d8 <__strerror+0x828>
    d748:	e12fff1e 	bx	lr
        break;
#endif
        
#ifdef ENOSPC
    case ENOSPC:
        s = (char *)"No space left on device";
    d74c:	e59f0188 	ldr	r0, [pc, #392]	; d8dc <__strerror+0x82c>
    d750:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EFBIG
    case EFBIG:
        s = (char *)"File too large";
    d754:	e59f0184 	ldr	r0, [pc, #388]	; d8e0 <__strerror+0x830>
    d758:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EMFILE
    case EMFILE:
        s = (char *)"Too many open files";
    d75c:	e59f0180 	ldr	r0, [pc, #384]	; d8e4 <__strerror+0x834>
    d760:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENFILE
    case ENFILE:
        s = (char *)"Too many open files in system";
    d764:	e59f017c 	ldr	r0, [pc, #380]	; d8e8 <__strerror+0x838>
    d768:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EINVAL
    case EINVAL:
        s = (char *)"Invalid argument";
    d76c:	e59f0178 	ldr	r0, [pc, #376]	; d8ec <__strerror+0x83c>
    d770:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EISDIR
    case EISDIR:
        s = (char *)"Is a directory";
    d774:	e59f0174 	ldr	r0, [pc, #372]	; d8f0 <__strerror+0x840>
    d778:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENOTDIR
    case ENOTDIR:
        s = (char *)"Not a directory";
    d77c:	e59f0170 	ldr	r0, [pc, #368]	; d8f4 <__strerror+0x844>
    d780:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENODEV
    case ENODEV:
        s = (char *)"No such device";
    d784:	e59f016c 	ldr	r0, [pc, #364]	; d8f8 <__strerror+0x848>
    d788:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EXDEV
    case EXDEV:
        s = (char *)"Improper link";
    d78c:	e59f0168 	ldr	r0, [pc, #360]	; d8fc <__strerror+0x84c>
    d790:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EBUSY
    case EBUSY:
        s = (char *)"Resource busy";
    d794:	e59f0164 	ldr	r0, [pc, #356]	; d900 <__strerror+0x850>
    d798:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENOMEM
    case ENOMEM:
        s = (char *)"Out of memory";
    d79c:	e59f0160 	ldr	r0, [pc, #352]	; d904 <__strerror+0x854>
    d7a0:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EAGAIN
    case EAGAIN:
        s = (char *)"Try again later";
    d7a4:	e59f015c 	ldr	r0, [pc, #348]	; d908 <__strerror+0x858>
    d7a8:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EBADF
    case EBADF:
        s = (char *)"Bad file handle";
    d7ac:	e59f0158 	ldr	r0, [pc, #344]	; d90c <__strerror+0x85c>
    d7b0:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EIO
    case EIO:
        s = (char *)"I/O error";
    d7b4:	e59f0154 	ldr	r0, [pc, #340]	; d910 <__strerror+0x860>
    d7b8:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EINTR
    case EINTR:
        s = (char *)"Operation interrupted";
    d7bc:	e59f0150 	ldr	r0, [pc, #336]	; d914 <__strerror+0x864>
    d7c0:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ESRCH
    case ESRCH:
        s = (char *)"No such process";
    d7c4:	e59f014c 	ldr	r0, [pc, #332]	; d918 <__strerror+0x868>
    d7c8:	e12fff1e 	bx	lr
        break;
#endif

#ifdef ENOENT
    case ENOENT:
        s = (char *)"No such entity";
    d7cc:	e59f0148 	ldr	r0, [pc, #328]	; d91c <__strerror+0x86c>
    d7d0:	e12fff1e 	bx	lr
        break;
#endif

#ifdef EPERM
    case EPERM:
        s = (char *)"Not permitted";
    d7d4:	e59f0144 	ldr	r0, [pc, #324]	; d920 <__strerror+0x870>
    d7d8:	e12fff1e 	bx	lr
    switch (errnum)
    {

#ifdef ENOERR
    case ENOERR:
        s = (char *)"No error";
    d7dc:	e59f0140 	ldr	r0, [pc, #320]	; d924 <__strerror+0x874>
    d7e0:	e12fff1e 	bx	lr
        s = (char *)"Host is down";
        break;
#endif
#ifdef EHOSTUNREACH
    case EHOSTUNREACH:
        s = (char *)"No route to host";
    d7e4:	e59f013c 	ldr	r0, [pc, #316]	; d928 <__strerror+0x878>
    d7e8:	e12fff1e 	bx	lr
        s = (char *)"Connection refused";
        break;
#endif
#ifdef EHOSTDOWN
    case EHOSTDOWN:
        s = (char *)"Host is down";
    d7ec:	e59f0138 	ldr	r0, [pc, #312]	; d92c <__strerror+0x87c>
    d7f0:	e12fff1e 	bx	lr
        s = (char *)"Operation timed out";
        break;
#endif
#ifdef ECONNREFUSED
    case ECONNREFUSED:
        s = (char *)"Connection refused";
    d7f4:	e59f0134 	ldr	r0, [pc, #308]	; d930 <__strerror+0x880>
    d7f8:	e12fff1e 	bx	lr
        s = (char *)"Too many references: can't splice";
        break;
#endif
#ifdef ETIMEDOUT
    case ETIMEDOUT:
        s = (char *)"Operation timed out";
    d7fc:	e59f0130 	ldr	r0, [pc, #304]	; d934 <__strerror+0x884>
    d800:	e12fff1e 	bx	lr
        s = (char *)"Can't send after socket shutdown";
        break;
#endif
#ifdef ETOOMANYREFS
    case ETOOMANYREFS:
        s = (char *)"Too many references: can't splice";
    d804:	e59f012c 	ldr	r0, [pc, #300]	; d938 <__strerror+0x888>
    d808:	e12fff1e 	bx	lr
        s = (char *)"Socket is not connected";
        break;
#endif
#ifdef ESHUTDOWN
    case ESHUTDOWN:
        s = (char *)"Can't send after socket shutdown";
    d80c:	e59f0128 	ldr	r0, [pc, #296]	; d93c <__strerror+0x88c>
    d810:	e12fff1e 	bx	lr
        s = (char *)"Socket is already connected";
        break;
#endif
#ifdef ENOTCONN
    case ENOTCONN:
        s = (char *)"Socket is not connected";
    d814:	e59f0124 	ldr	r0, [pc, #292]	; d940 <__strerror+0x890>
    d818:	e12fff1e 	bx	lr
        s = (char *)"No buffer space available";
        break;
#endif
#ifdef EISCONN
    case EISCONN:
        s = (char *)"Socket is already connected";
    d81c:	e59f0120 	ldr	r0, [pc, #288]	; d944 <__strerror+0x894>
    d820:	e12fff1e 	bx	lr
        s = (char *)"Connection reset by peer";
        break;
#endif
#ifdef ENOBUFS
    case ENOBUFS:
        s = (char *)"No buffer space available";
    d824:	e59f011c 	ldr	r0, [pc, #284]	; d948 <__strerror+0x898>
    d828:	e12fff1e 	bx	lr
        s = (char *)"Software caused connection abort";
        break;
#endif
#ifdef ECONNRESET
    case ECONNRESET:
        s = (char *)"Connection reset by peer";
    d82c:	e59f0118 	ldr	r0, [pc, #280]	; d94c <__strerror+0x89c>
    d830:	e12fff1e 	bx	lr
        s = (char *)"Network dropped connection on reset";
        break;
#endif
#ifdef ECONNABORTED
    case ECONNABORTED:
        s = (char *)"Software caused connection abort";
    d834:	e59f0114 	ldr	r0, [pc, #276]	; d950 <__strerror+0x8a0>
    d838:	e12fff1e 	bx	lr
        s = (char *)"Network is unreachable";
        break;
#endif
#ifdef ENETRESET
    case ENETRESET:
        s = (char *)"Network dropped connection on reset";
    d83c:	e59f0110 	ldr	r0, [pc, #272]	; d954 <__strerror+0x8a4>
    d840:	e12fff1e 	bx	lr
        s = (char *)"Network is down";
        break;
#endif
#ifdef ENETUNREACH
    case ENETUNREACH:
        s = (char *)"Network is unreachable";
    d844:	e59f010c 	ldr	r0, [pc, #268]	; d958 <__strerror+0x8a8>
    d848:	e12fff1e 	bx	lr
        s = (char *)"Can't assign requested address";
        break;
#endif
#ifdef ENETDOWN
    case ENETDOWN:
        s = (char *)"Network is down";
    d84c:	e59f0108 	ldr	r0, [pc, #264]	; d95c <__strerror+0x8ac>
    d850:	e12fff1e 	bx	lr
        s = (char *)"Address already in use";
        break;
#endif
#ifdef EADDRNOTAVAIL
    case EADDRNOTAVAIL:
        s = (char *)"Can't assign requested address";
    d854:	e59f0104 	ldr	r0, [pc, #260]	; d960 <__strerror+0x8b0>
    d858:	e12fff1e 	bx	lr
        s = (char *)"Address family not supported by protocol family";
        break;
#endif
#ifdef EADDRINUSE
    case EADDRINUSE:
        s = (char *)"Address already in use";
    d85c:	e59f0100 	ldr	r0, [pc, #256]	; d964 <__strerror+0x8b4>
    d860:	e12fff1e 	bx	lr
        s = (char *)"Protocol family not supported";
        break;
#endif
#ifdef EAFNOSUPPORT
    case EAFNOSUPPORT:
        s = (char *)"Address family not supported by protocol family";
    d864:	e59f00fc 	ldr	r0, [pc, #252]	; d968 <__strerror+0x8b8>
    d868:	e12fff1e 	bx	lr
        s = (char *)"Operation not supported";
        break;
#endif
#ifdef EPFNOSUPPORT
    case EPFNOSUPPORT:
        s = (char *)"Protocol family not supported";
    d86c:	e59f00f8 	ldr	r0, [pc, #248]	; d96c <__strerror+0x8bc>
    d870:	e12fff1e 	bx	lr
    d874:	00012d70 	.word	0x00012d70
    d878:	00012f04 	.word	0x00012f04
    d87c:	00012eec 	.word	0x00012eec
    d880:	00012ed4 	.word	0x00012ed4
    d884:	00012eb4 	.word	0x00012eb4
    d888:	00012ea0 	.word	0x00012ea0
    d88c:	00012e80 	.word	0x00012e80
    d890:	00012e60 	.word	0x00012e60
    d894:	00012e40 	.word	0x00012e40
    d898:	00012e24 	.word	0x00012e24
    d89c:	00012e18 	.word	0x00012e18
    d8a0:	00012df8 	.word	0x00012df8
    d8a4:	00012dec 	.word	0x00012dec
    d8a8:	00012dd8 	.word	0x00012dd8
    d8ac:	00012dc0 	.word	0x00012dc0
    d8b0:	00012d88 	.word	0x00012d88
    d8b4:	00013118 	.word	0x00013118
    d8b8:	00012d5c 	.word	0x00012d5c
    d8bc:	00012d4c 	.word	0x00012d4c
    d8c0:	00012d38 	.word	0x00012d38
    d8c4:	00012d1c 	.word	0x00012d1c
    d8c8:	00012cfc 	.word	0x00012cfc
    d8cc:	00012cd8 	.word	0x00012cd8
    d8d0:	00012ca8 	.word	0x00012ca8
    d8d4:	00012c90 	.word	0x00012c90
    d8d8:	00012c80 	.word	0x00012c80
    d8dc:	00012c68 	.word	0x00012c68
    d8e0:	00012c58 	.word	0x00012c58
    d8e4:	00012c44 	.word	0x00012c44
    d8e8:	00012c24 	.word	0x00012c24
    d8ec:	00012c10 	.word	0x00012c10
    d8f0:	00012c00 	.word	0x00012c00
    d8f4:	00012bf0 	.word	0x00012bf0
    d8f8:	00012be0 	.word	0x00012be0
    d8fc:	00012db0 	.word	0x00012db0
    d900:	00012bd0 	.word	0x00012bd0
    d904:	00012bc0 	.word	0x00012bc0
    d908:	00012bb0 	.word	0x00012bb0
    d90c:	00012ba0 	.word	0x00012ba0
    d910:	00012b94 	.word	0x00012b94
    d914:	00012b7c 	.word	0x00012b7c
    d918:	00012b6c 	.word	0x00012b6c
    d91c:	00012b5c 	.word	0x00012b5c
    d920:	00012b4c 	.word	0x00012b4c
    d924:	00012b40 	.word	0x00012b40
    d928:	00013104 	.word	0x00013104
    d92c:	000130f4 	.word	0x000130f4
    d930:	000130e0 	.word	0x000130e0
    d934:	000130cc 	.word	0x000130cc
    d938:	000130a8 	.word	0x000130a8
    d93c:	00013084 	.word	0x00013084
    d940:	0001306c 	.word	0x0001306c
    d944:	00013050 	.word	0x00013050
    d948:	00013034 	.word	0x00013034
    d94c:	00013018 	.word	0x00013018
    d950:	00012ff4 	.word	0x00012ff4
    d954:	00012fd0 	.word	0x00012fd0
    d958:	00012fb8 	.word	0x00012fb8
    d95c:	00012fa8 	.word	0x00012fa8
    d960:	00012f88 	.word	0x00012f88
    d964:	00012f70 	.word	0x00012f70
    d968:	00012f40 	.word	0x00012f40
    d96c:	00012f20 	.word	0x00012f20

0000d970 <cyg_error_get_errno_p>:
    d970:	e59f300c 	ldr	r3, [pc, #12]	; d984 <cyg_error_get_errno_p+0x14>
    d974:	e5932000 	ldr	r2, [r3]

    CYG_REPORT_RETVAL( errno_p );
    
    // return the internal data's errno
    return errno_p;
} // cyg_error_get_errno_p()
    d978:	e5930000 	ldr	r0, [r3]
    d97c:	e280008c 	add	r0, r0, #140	; 0x8c
    d980:	e12fff1e 	bx	lr
    d984:	40002538 	.word	0x40002538

0000d988 <hal_spurious_IRQ>:
#if defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
    exception_handler(regs);
#else
    CYG_FAIL("Spurious interrupt!!");
#endif    
}
    d988:	e12fff1e 	bx	lr

0000d98c <cyg_hal_invoke_constructors>:
#define NEXT_CONSTRUCTOR(c) ((c)--)
#endif

void
cyg_hal_invoke_constructors (void)
{
    d98c:	e92d4030 	push	{r4, r5, lr}
        }
    }
#else
    pfunc *p;

    for (p = &CONSTRUCTORS_START; p != CONSTRUCTORS_END; NEXT_CONSTRUCTOR(p))
    d990:	e59f302c 	ldr	r3, [pc, #44]	; d9c4 <cyg_hal_invoke_constructors+0x38>
    d994:	e59f502c 	ldr	r5, [pc, #44]	; d9c8 <cyg_hal_invoke_constructors+0x3c>
    d998:	e1530005 	cmp	r3, r5
#define NEXT_CONSTRUCTOR(c) ((c)--)
#endif

void
cyg_hal_invoke_constructors (void)
{
    d99c:	e24dd004 	sub	sp, sp, #4	; 0x4
        }
    }
#else
    pfunc *p;

    for (p = &CONSTRUCTORS_START; p != CONSTRUCTORS_END; NEXT_CONSTRUCTOR(p))
    d9a0:	0a000005 	beq	d9bc <cyg_hal_invoke_constructors+0x30>
    d9a4:	e1a04003 	mov	r4, r3
        (*p)();
    d9a8:	e4943004 	ldr	r3, [r4], #4
    d9ac:	e1a0e00f 	mov	lr, pc
    d9b0:	e12fff13 	bx	r3
        }
    }
#else
    pfunc *p;

    for (p = &CONSTRUCTORS_START; p != CONSTRUCTORS_END; NEXT_CONSTRUCTOR(p))
    d9b4:	e1540005 	cmp	r4, r5
    d9b8:	1afffffa 	bne	d9a8 <cyg_hal_invoke_constructors+0x1c>
        (*p)();
#endif
}
    d9bc:	e28dd004 	add	sp, sp, #4	; 0x4
    d9c0:	e8bd8030 	pop	{r4, r5, pc}
    d9c4:	40000854 	.word	0x40000854
    d9c8:	4000088c 	.word	0x4000088c

0000d9cc <hal_arch_default_isr>:
{
    CYG_TRACE1(true, "Interrupt: %d", vector);

    CYG_FAIL("Spurious Interrupt!!!");
    return 0;
}
    d9cc:	e3a00000 	mov	r0, #0	; 0x0
    d9d0:	e12fff1e 	bx	lr

0000d9d4 <hal_lsbindex>:
}
#endif

int
hal_lsbindex(int mask)
{
    d9d4:	e1a02000 	mov	r2, r0
    d9d8:	e3a00000 	mov	r0, #0	; 0x0
    int i;
    for (i = 0;  i < 32;  i++) {
      if (mask & (1<<i)) return (i);
    d9dc:	e1a03052 	asr	r3, r2, r0
    d9e0:	e3130001 	tst	r3, #1	; 0x1
    d9e4:	112fff1e 	bxne	lr

int
hal_lsbindex(int mask)
{
    int i;
    for (i = 0;  i < 32;  i++) {
    d9e8:	e2800001 	add	r0, r0, #1	; 0x1
    d9ec:	e3500020 	cmp	r0, #32	; 0x20
    d9f0:	1afffff9 	bne	d9dc <hal_lsbindex+0x8>
    d9f4:	e2400021 	sub	r0, r0, #33	; 0x21
      if (mask & (1<<i)) return (i);
    }
    return (-1);
}
    d9f8:	e12fff1e 	bx	lr

0000d9fc <hal_msbindex>:

int
hal_msbindex(int mask)
{
    d9fc:	e1a02000 	mov	r2, r0
    da00:	e3a0001f 	mov	r0, #31	; 0x1f
    int i;
    for (i = 31;  i >= 0;  i--) {
      if (mask & (1<<i)) return (i);
    da04:	e1a03052 	asr	r3, r2, r0
    da08:	e3130001 	tst	r3, #1	; 0x1
    da0c:	112fff1e 	bxne	lr

int
hal_msbindex(int mask)
{
    int i;
    for (i = 31;  i >= 0;  i--) {
    da10:	e2500001 	subs	r0, r0, #1	; 0x1
    da14:	2afffffa 	bcs	da04 <hal_msbindex+0x8>
      if (mask & (1<<i)) return (i);
    }
    return (-1);
}
    da18:	e12fff1e 	bx	lr

0000da1c <exception_handler>:
    // We should decode the vector and pass a more appropriate
    // value as the second argument. For now we simply pass a
    // pointer to the saved registers. We should also divert
    // breakpoint and other debug vectors into the debug stubs.

    cyg_hal_deliver_exception( regs->vector, (CYG_ADDRWORD)regs );
    da1c:	e1a01000 	mov	r1, r0
    da20:	e5900044 	ldr	r0, [r0, #68]
    da24:	eaffdc89 	b	4c50 <cyg_hal_deliver_exception>

0000da28 <hal_thread_switch_context>:
// Note: this is a little wasteful since r0..r3 don't need to be saved.
// They are saved here though so that the information can match the
// HAL_SavedRegisters
        
FUNC_START_ARM(hal_thread_switch_context, r2)
        mov     ip,sp
    da28:	e1a0c00d 	mov	ip, sp
        sub     sp,sp,#(ARMREG_SIZE - armreg_lr - 4) // skip svc_sp, svc_lr, vector, cpsr, and pc
    da2c:	e24dd014 	sub	sp, sp, #20	; 0x14
        stmfd   sp!,{ip,lr}
    da30:	e92d5000 	push	{ip, lr}
        stmfd   sp!,{r0-r10,fp,ip}
    da34:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
        mrs     r2,cpsr
    da38:	e10f2000 	mrs	r2, CPSR
        str     r2,[sp,#armreg_cpsr]
    da3c:	e58d2040 	str	r2, [sp, #64]
        str     sp,[r1]                 // return new stack pointer
    da40:	e581d000 	str	sp, [r1]

0000da44 <hal_thread_load_context>:
//  R0 = address of sp of next thread to execute
//  Note that this function is also the second half of
//  hal_thread_switch_context and is simply dropped into from it.
        
FUNC_START_ARM(hal_thread_load_context, r2)
        ldr     fp,[r0]                 // get context to restore
    da44:	e590b000 	ldr	fp, [r0]
        mrs     r0,cpsr                 // disable IRQ's
    da48:	e10f0000 	mrs	r0, CPSR
        orr     r0,r0,#CPSR_IRQ_DISABLE|CPSR_FIQ_DISABLE
    da4c:	e38000c0 	orr	r0, r0, #192	; 0xc0
        msr     cpsr,r0
    da50:	e129f000 	msr	CPSR_fc, r0
        ldr     r0,[fp,#armreg_cpsr]
    da54:	e59b0040 	ldr	r0, [fp, #64]
        msr     spsr,r0
    da58:	e169f000 	msr	SPSR_fc, r0
        ldmfd   fp,{r0-r10,fp,ip,sp,lr}
    da5c:	e89b7fff 	ldm	fp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}
        mrs     r1,spsr                 // r1 is scratch 
                                        // [r0 holds initial thread arg]
        msr     cpsr,r1                 // hopefully no mode switch here!
        bx      lr
#else
        movs    pc,lr                   // also restores saved PSR
    da60:	e1b0f00e 	movs	pc, lr

0000da64 <hal_setjmp>:
//  HAL longjmp, setjmp implementations
//  hal_setjmp saves only to callee save registers 4-14
//  and lr into buffer supplied in r0[arg0]

FUNC_START_ARM(hal_setjmp, r2)
        stmea   r0,{r4-r14}
    da64:	e8807ff0 	stm	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}
        mov     r0,#0
    da68:	e3a00000 	mov	r0, #0	; 0x0
#ifdef __thumb__
        bx      lr
#else
        mov     pc,lr;          # return
    da6c:	e1a0f00e 	mov	pc, lr

0000da70 <hal_longjmp>:
#endif

//  hal_longjmp loads state from r0[arg0] and returns
        
FUNC_START_ARM(hal_longjmp, r2)
        ldmfd   r0,{r4-r14}
    da70:	e8907ff0 	ldm	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}
        mov     r0,r1;          # return [arg1]
    da74:	e1a00001 	mov	r0, r1
#ifdef __thumb__
        bx      lr
#else
        mov     pc,lr
    da78:	e1a0f00e 	mov	pc, lr

0000da7c <hal_clock_initialize>:
    CYG_ADDRESS timer = CYGARC_HAL_LPC2XXX_REG_TIMER0_BASE;

    period = period / (CYGNUM_HAL_ARM_LPC2XXX_CLOCK_SPEED / CYGNUM_HAL_ARM_LPC2XXX_PCLK);

    // Disable and reset counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 2);
    da7c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    da80:	e2833901 	add	r3, r3, #16384	; 0x4000
    da84:	e3a02002 	mov	r2, #2	; 0x2
    
    // set prescale register to 0
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxPR, 0);
    da88:	e3a01000 	mov	r1, #0	; 0x0
    CYG_ADDRESS timer = CYGARC_HAL_LPC2XXX_REG_TIMER0_BASE;

    period = period / (CYGNUM_HAL_ARM_LPC2XXX_CLOCK_SPEED / CYGNUM_HAL_ARM_LPC2XXX_PCLK);

    // Disable and reset counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 2);
    da8c:	e5832004 	str	r2, [r3, #4]

void hal_clock_initialize(cyg_uint32 period)
{
    CYG_ADDRESS timer = CYGARC_HAL_LPC2XXX_REG_TIMER0_BASE;

    period = period / (CYGNUM_HAL_ARM_LPC2XXX_CLOCK_SPEED / CYGNUM_HAL_ARM_LPC2XXX_PCLK);
    da90:	e1a00120 	lsr	r0, r0, #2

    // Disable and reset counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 2);
    
    // set prescale register to 0
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxPR, 0);
    da94:	e583100c 	str	r1, [r3, #12]

    // Set up match register 
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMR0, period);
    
    // Reset and generate interrupt on match
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMCR, 
    da98:	e2822001 	add	r2, r2, #1	; 0x1
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_INT | 
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_RESET);

    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);
    da9c:	e2811001 	add	r1, r1, #1	; 0x1
    
    // set prescale register to 0
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxPR, 0);

    // Set up match register 
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMR0, period);
    daa0:	e5830018 	str	r0, [r3, #24]
    
    // Reset and generate interrupt on match
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMCR, 
    daa4:	e5832014 	str	r2, [r3, #20]
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_INT | 
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_RESET);

    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);
    daa8:	e5831004 	str	r1, [r3, #4]
}
    daac:	e12fff1e 	bx	lr

0000dab0 <hal_clock_reset>:

void hal_clock_reset(cyg_uint32 vector, cyg_uint32 period)
{
    CYG_ADDRESS timer = CYGARC_HAL_LPC2XXX_REG_TIMER0_BASE;

    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxIR, 
    dab0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    dab4:	e2833901 	add	r3, r3, #16384	; 0x4000
    dab8:	e3a02001 	mov	r2, #1	; 0x1
    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);
}

void hal_clock_reset(cyg_uint32 vector, cyg_uint32 period)
{
    dabc:	e92d4030 	push	{r4, r5, lr}
    CYG_ADDRESS timer = CYGARC_HAL_LPC2XXX_REG_TIMER0_BASE;

    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxIR, 
    dac0:	e5832000 	str	r2, [r3]
                     CYGARC_HAL_LPC2XXX_REG_TxIR_MR0);  // Clear interrupt

    if (period != _period) {
    dac4:	e59f5020 	ldr	r5, [pc, #32]	; daec <hal_clock_reset+0x3c>
    dac8:	e5953000 	ldr	r3, [r5]
    dacc:	e1510003 	cmp	r1, r3
    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);
}

void hal_clock_reset(cyg_uint32 vector, cyg_uint32 period)
{
    dad0:	e24dd004 	sub	sp, sp, #4	; 0x4
    dad4:	e1a04001 	mov	r4, r1

    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxIR, 
                     CYGARC_HAL_LPC2XXX_REG_TxIR_MR0);  // Clear interrupt

    if (period != _period) {
        hal_clock_initialize(period);
    dad8:	11a00001 	movne	r0, r1
    dadc:	1bffffe6 	blne	da7c <hal_clock_initialize>
    }
    _period = period;
    dae0:	e5854000 	str	r4, [r5]

}
    dae4:	e28dd004 	add	sp, sp, #4	; 0x4
    dae8:	e8bd8030 	pop	{r4, r5, pc}
    daec:	400046b4 	.word	0x400046b4

0000daf0 <hal_clock_read>:
void hal_clock_read(cyg_uint32 *pvalue)
{
    CYG_ADDRESS timer = CYGARC_HAL_LPC2XXX_REG_TIMER0_BASE;
    cyg_uint32 val;

    HAL_READ_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTC, val);
    daf0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    daf4:	e2833901 	add	r3, r3, #16384	; 0x4000
    daf8:	e5932008 	ldr	r2, [r3, #8]
    *pvalue = val;
    dafc:	e5802000 	str	r2, [r0]
}
    db00:	e12fff1e 	bx	lr

0000db04 <hal_delay_us>:

    // Calculate how many timer ticks the required number of
    // microseconds equate to. We do this calculation in 64 bit
    // arithmetic to avoid overflow.
    ticks = CYGNUM_HAL_ARM_LPC2XXX_PCLK;
    ticks = (((cyg_uint64)usecs) * (ticks))/1000000LL;
    db04:	e3a038e1 	mov	r3, #14745600	; 0xe10000
//
// Delay for some number of micro-seconds
// use TIMER1
//
void hal_delay_us(cyg_int32 usecs)
{
    db08:	e92d4030 	push	{r4, r5, lr}

    // Calculate how many timer ticks the required number of
    // microseconds equate to. We do this calculation in 64 bit
    // arithmetic to avoid overflow.
    ticks = CYGNUM_HAL_ARM_LPC2XXX_PCLK;
    ticks = (((cyg_uint64)usecs) * (ticks))/1000000LL;
    db0c:	e0c54390 	smull	r4, r5, r0, r3
    db10:	e3a0293d 	mov	r2, #999424	; 0xf4000
    db14:	e2822d09 	add	r2, r2, #576	; 0x240
    db18:	e3a03000 	mov	r3, #0	; 0x0
//
// Delay for some number of micro-seconds
// use TIMER1
//
void hal_delay_us(cyg_int32 usecs)
{
    db1c:	e24dd004 	sub	sp, sp, #4	; 0x4

    // Calculate how many timer ticks the required number of
    // microseconds equate to. We do this calculation in 64 bit
    // arithmetic to avoid overflow.
    ticks = CYGNUM_HAL_ARM_LPC2XXX_PCLK;
    ticks = (((cyg_uint64)usecs) * (ticks))/1000000LL;
    db20:	e1a00004 	mov	r0, r4
    db24:	e1a01005 	mov	r1, r5
    db28:	eb0010be 	bl	11e28 <__aeabi_uldivmod>
    
    // Disable and reset counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 2);
    db2c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    db30:	e2833902 	add	r3, r3, #32768	; 0x8000
    db34:	e3a02002 	mov	r2, #2	; 0x2
    db38:	e5832004 	str	r2, [r3, #4]
    
    // Stop on match
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMR0, ticks);
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMCR, 
    db3c:	e2822004 	add	r2, r2, #4	; 0x4
    
    // Disable and reset counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 2);
    
    // Stop on match
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMR0, ticks);
    db40:	e5830018 	str	r0, [r3, #24]
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMCR, 
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_STOP | 
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_RESET);

    //set prescale register to 0
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxPR, 0);			
    db44:	e3a0c000 	mov	ip, #0	; 0x0
    // Disable and reset counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 2);
    
    // Stop on match
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMR0, ticks);
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMCR, 
    db48:	e5832014 	str	r2, [r3, #20]

    //set prescale register to 0
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxPR, 0);			

    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);
    db4c:	e2422005 	sub	r2, r2, #5	; 0x5
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxMCR, 
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_STOP | 
                     CYGARC_HAL_LPC2XXX_REG_TxMCR_MR0_RESET);

    //set prescale register to 0
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxPR, 0);			
    db50:	e583c00c 	str	ip, [r3, #12]

    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);
    db54:	e5832004 	str	r2, [r3, #4]

    // Calculate how many timer ticks the required number of
    // microseconds equate to. We do this calculation in 64 bit
    // arithmetic to avoid overflow.
    ticks = CYGNUM_HAL_ARM_LPC2XXX_PCLK;
    ticks = (((cyg_uint64)usecs) * (ticks))/1000000LL;
    db58:	e1a0c000 	mov	ip, r0
    db5c:	e1a00001 	mov	r0, r1
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);

    // Wait for the match
    do {
        HAL_READ_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTC, stat);
    } while (stat < ticks);
    db60:	e3500000 	cmp	r0, #0	; 0x0
    // Enable counter
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);

    // Wait for the match
    do {
        HAL_READ_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTC, stat);
    db64:	e5932008 	ldr	r2, [r3, #8]
    } while (stat < ticks);
    db68:	8afffffc 	bhi	db60 <hal_delay_us+0x5c>
    db6c:	0a000001 	beq	db78 <hal_delay_us+0x74>
}
    db70:	e28dd004 	add	sp, sp, #4	; 0x4
    db74:	e8bd8030 	pop	{r4, r5, pc}
    HAL_WRITE_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTCR, 1);

    // Wait for the match
    do {
        HAL_READ_UINT32(timer+CYGARC_HAL_LPC2XXX_REG_TxTC, stat);
    } while (stat < ticks);
    db78:	e15c0002 	cmp	ip, r2
    db7c:	8afffff7 	bhi	db60 <hal_delay_us+0x5c>
    db80:	eafffffa 	b	db70 <hal_delay_us+0x6c>

0000db84 <lpc_get_vpbdiv>:
// we need to read twice consecutively to get correct value
cyg_uint32 lpc_get_vpbdiv(void)
{   
    cyg_uint32 vpbdiv_reg;
	
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    db84:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    db88:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    db8c:	e5932100 	ldr	r2, [r3, #256]
                    CYGARC_HAL_LPC2XXX_REG_VPBDIV, vpbdiv_reg);
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    db90:	e5930100 	ldr	r0, [r3, #256]
                    CYGARC_HAL_LPC2XXX_REG_VPBDIV, vpbdiv_reg);

    return (vpbdiv_reg);
}
    db94:	e12fff1e 	bx	lr

0000db98 <lpc_set_vpbdiv>:
#ifdef CYGHWR_HAL_ARM_LPC2XXX_FAMILY_LPC22XX
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE +
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV,
                     ((xclkdiv & 0x3) << 4) | (vpbdiv & 0x3));
#else
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    db98:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    db9c:	e2000003 	and	r0, r0, #3	; 0x3
    dba0:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    dba4:	e5830100 	str	r0, [r3, #256]
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV, vpbdiv & 0x3);
#endif
}
    dba8:	e12fff1e 	bx	lr

0000dbac <hal_IRQ_handler>:
// should interrogate the hardware and return the IRQ vector number.
int hal_IRQ_handler(void)
{
    cyg_uint32 irq_num;
    
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dbac:	e3e03000 	mvn	r3, #0	; 0x0
    dbb0:	e5130fcf 	ldr	r0, [r3, #-4047]
                    CYGARC_HAL_LPC2XXX_REG_VICVECTADDR, irq_num);
    //
    // if this is a non vectored ISR then we need to find out which interrupt 
    // caused the IRQ
    //      
    if (0xFFFFFFFF == irq_num)
    dbb4:	e1500003 	cmp	r0, r3
    dbb8:	112fff1e 	bxne	lr
    {
        cyg_uint32 irq_stat;
        
        // Find out which interrupt caused the IRQ. This picks the lowest
        // if there are more than 1.
        HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dbbc:	e5100fff 	ldr	r0, [r0, #-4095]
                        CYGARC_HAL_LPC2XXX_REG_VICIRQSTAT, irq_stat);
        irq_num = 0;
        while (!(irq_stat & 0x01))
    dbc0:	e2103001 	ands	r3, r0, #1	; 0x1
    dbc4:	13a03000 	movne	r3, #0	; 0x0
    dbc8:	1a000006 	bne	dbe8 <hal_IRQ_handler+0x3c>
        {
            irq_stat >>= 1;	
    dbcc:	e1a000a0 	lsr	r0, r0, #1
        // Find out which interrupt caused the IRQ. This picks the lowest
        // if there are more than 1.
        HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
                        CYGARC_HAL_LPC2XXX_REG_VICIRQSTAT, irq_stat);
        irq_num = 0;
        while (!(irq_stat & 0x01))
    dbd0:	e3100001 	tst	r0, #1	; 0x1
        {
            irq_stat >>= 1;	
            irq_num++;
    dbd4:	e2833001 	add	r3, r3, #1	; 0x1
        // Find out which interrupt caused the IRQ. This picks the lowest
        // if there are more than 1.
        HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
                        CYGARC_HAL_LPC2XXX_REG_VICIRQSTAT, irq_stat);
        irq_num = 0;
        while (!(irq_stat & 0x01))
    dbd8:	0afffffb 	beq	dbcc <hal_IRQ_handler+0x20>
            irq_stat >>= 1;	
            irq_num++;
        }
        
        // If not a valid interrrupt source, treat as spurious interrupt    
        if (irq_num < CYGNUM_HAL_ISR_MIN || irq_num > CYGNUM_HAL_ISR_MAX)
    dbdc:	e353001f 	cmp	r3, #31	; 0x1f
    dbe0:	83e00000 	mvnhi	r0, #0	; 0x0
    dbe4:	812fff1e 	bxhi	lr
    dbe8:	e1a00003 	mov	r0, r3
            irq_num = CYGNUM_HAL_INTERRUPT_NONE;
        }
    } // if (0xFFFFFFFF == irq_num)
    
    return (irq_num);
}
    dbec:	e12fff1e 	bx	lr

0000dbf0 <hal_interrupt_mask>:
void hal_interrupt_mask(int vector)
{
    CYG_ASSERT(vector <= CYGNUM_HAL_ISR_MAX &&
               vector >= CYGNUM_HAL_ISR_MIN , "Invalid vector");

    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dbf0:	e3a03001 	mov	r3, #1	; 0x1
    dbf4:	e1a03013 	lsl	r3, r3, r0
    dbf8:	e3e02000 	mvn	r2, #0	; 0x0
    dbfc:	e5023feb 	str	r3, [r2, #-4075]
                     CYGARC_HAL_LPC2XXX_REG_VICINTENCLEAR, 1 << vector);
}
    dc00:	e12fff1e 	bx	lr

0000dc04 <hal_interrupt_unmask>:
void hal_interrupt_unmask(int vector)
{
    CYG_ASSERT(vector <= CYGNUM_HAL_ISR_MAX &&
               vector >= CYGNUM_HAL_ISR_MIN , "Invalid vector");

    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dc04:	e3a03001 	mov	r3, #1	; 0x1
    dc08:	e1a03013 	lsl	r3, r3, r0
    dc0c:	e3e02000 	mvn	r2, #0	; 0x0
    dc10:	e5023fef 	str	r3, [r2, #-4079]
                     CYGARC_HAL_LPC2XXX_REG_VICINTENABLE, 1 << vector);
}
    dc14:	e12fff1e 	bx	lr

0000dc18 <hal_interrupt_acknowledge>:
// delivered
void hal_interrupt_acknowledge(int vector)
{

    // External interrupts have to be cleared from the EXTINT register
    if (vector >= CYGNUM_HAL_INTERRUPT_EINT0 &&
    dc18:	e240000e 	sub	r0, r0, #14	; 0xe
    dc1c:	e3500003 	cmp	r0, #3	; 0x3
      {
        // Map int vector to corresponding bit (0..3)
        vector = 1 << (vector - CYGNUM_HAL_INTERRUPT_EINT0);
        
        // Clear the external interrupt
        HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc20:	93a02001 	movls	r2, #1	; 0x1
    dc24:	91a02012 	lslls	r2, r2, r0
    dc28:	93a0320e 	movls	r3, #-536870912	; 0xe0000000
    dc2c:	9283397f 	addls	r3, r3, #2080768	; 0x1fc000
    dc30:	95832140 	strls	r2, [r3, #320]
                         CYGARC_HAL_LPC2XXX_REG_EXTINT, vector);
      }
    
    // Acknowledge interrupt in the VIC
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dc34:	e3a02000 	mov	r2, #0	; 0x0
    dc38:	e3e03000 	mvn	r3, #0	; 0x0
    dc3c:	e5032fcf 	str	r2, [r3, #-4047]
                     CYGARC_HAL_LPC2XXX_REG_VICVECTADDR, 0);  
}
    dc40:	e12fff1e 	bx	lr

0000dc44 <hal_interrupt_configure>:
// we need to read twice consecutively to get correct value
cyg_uint32 lpc_get_vpbdiv(void)
{   
    cyg_uint32 vpbdiv_reg;
	
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc44:	e3a0c20e 	mov	ip, #-536870912	; 0xe0000000
    dc48:	e28cc97f 	add	ip, ip, #2080768	; 0x1fc000
    dc4c:	e59c3100 	ldr	r3, [ip, #256]
    
    // Save current VPBDIV register settings
    saved_vpbdiv = lpc_get_vpbdiv();
    
    // Clear VPBDIV register
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc50:	e3a03000 	mov	r3, #0	; 0x0
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV, 0);
    
    // Read current mode and update for level (0) or edge detection (1)
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                    CYGARC_HAL_LPC2XXX_REG_EXTMODE, regval);
    if (level)
    dc54:	e1510003 	cmp	r1, r3
    // Only external interrupts are configurable	
    CYG_ASSERT(vector <= CYGNUM_HAL_INTERRUPT_EINT3 &&
               vector >= CYGNUM_HAL_INTERRUPT_EINT0 , "Invalid vector");

    // Map int vector to corresponding bit (0..3)
    vector = 1 << (vector - CYGNUM_HAL_INTERRUPT_EINT0);
    dc58:	e240000e 	sub	r0, r0, #14	; 0xe
// it trips up on two errata issues (for the LPC2294 Rev.A these are
// EXTINT.1 and VPBDIV.1) and so on these devices a somewhat convoluted
// sequence in order to work properly. There is nothing in the errata
// sequence that won't work on a processor without these issues.
void hal_interrupt_configure(int vector, int level, int up)
{
    dc5c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
{   
    cyg_uint32 vpbdiv_reg;
	
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                    CYGARC_HAL_LPC2XXX_REG_VPBDIV, vpbdiv_reg);
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc60:	e59c4100 	ldr	r4, [ip, #256]
    
    // Save current VPBDIV register settings
    saved_vpbdiv = lpc_get_vpbdiv();
    
    // Clear VPBDIV register
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc64:	e58c3100 	str	r3, [ip, #256]
    // Only external interrupts are configurable	
    CYG_ASSERT(vector <= CYGNUM_HAL_INTERRUPT_EINT3 &&
               vector >= CYGNUM_HAL_INTERRUPT_EINT0 , "Invalid vector");

    // Map int vector to corresponding bit (0..3)
    vector = 1 << (vector - CYGNUM_HAL_INTERRUPT_EINT0);
    dc68:	e2833001 	add	r3, r3, #1	; 0x1
    dc6c:	e1a01013 	lsl	r1, r3, r0
// it trips up on two errata issues (for the LPC2294 Rev.A these are
// EXTINT.1 and VPBDIV.1) and so on these devices a somewhat convoluted
// sequence in order to work properly. There is nothing in the errata
// sequence that won't work on a processor without these issues.
void hal_interrupt_configure(int vector, int level, int up)
{
    dc70:	e1a00002 	mov	r0, r2
    // Clear VPBDIV register
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV, 0);
    
    // Read current mode and update for level (0) or edge detection (1)
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc74:	e59c2148 	ldr	r2, [ip, #328]
                    CYGARC_HAL_LPC2XXX_REG_EXTMODE, regval);
    if (level)
      regval &= ~vector;
    dc78:	11e03001 	mvnne	r3, r1
    dc7c:	10032002 	andne	r2, r3, r2
    else
      regval |= vector;
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc80:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    dc84:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                    CYGARC_HAL_LPC2XXX_REG_EXTMODE, regval);
    if (level)
      regval &= ~vector;
    else
      regval |= vector;
    dc88:	01812002 	orreq	r2, r1, r2
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc8c:	e5832148 	str	r2, [r3, #328]
                     CYGARC_HAL_LPC2XXX_REG_EXTMODE, regval);
    
    // Set VPBDIV register to same value as mode
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc90:	e5832100 	str	r2, [r3, #256]
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV, regval);
    
    // Clear VPBDIV register
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dc94:	e3a02000 	mov	r2, #0	; 0x0
    dc98:	e5832100 	str	r2, [r3, #256]
    
    // Read current polarity and update for trigger level or edge
    // level: high (1), low (0) edge: rising (1), falling (0)
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                    CYGARC_HAL_LPC2XXX_REG_EXTPOLAR, regval);
    if (up)
    dc9c:	e1500002 	cmp	r0, r2
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV, 0);
    
    // Read current polarity and update for trigger level or edge
    // level: high (1), low (0) edge: rising (1), falling (0)
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dca0:	e593214c 	ldr	r2, [r3, #332]
                    CYGARC_HAL_LPC2XXX_REG_EXTPOLAR, regval);
    if (up)
      regval |= vector;
    else
      regval &= ~vector;
    dca4:	01e03001 	mvneq	r3, r1
    dca8:	00032002 	andeq	r2, r3, r2
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dcac:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    dcb0:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    // Read current polarity and update for trigger level or edge
    // level: high (1), low (0) edge: rising (1), falling (0)
    HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                    CYGARC_HAL_LPC2XXX_REG_EXTPOLAR, regval);
    if (up)
      regval |= vector;
    dcb4:	11812002 	orrne	r2, r1, r2
    else
      regval &= ~vector;
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dcb8:	e583214c 	str	r2, [r3, #332]
                     CYGARC_HAL_LPC2XXX_REG_EXTPOLAR, regval);
    
    // Set VPBDIV register to same value as mode
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dcbc:	e5832100 	str	r2, [r3, #256]
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV, regval);
    
    // Restore saved VPBDIV register
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dcc0:	e5834100 	str	r4, [r3, #256]
      regval &= ~vector;
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
                     CYGARC_HAL_LPC2XXX_REG_EXTPOLAR, regval);
#endif
    // Clear any spurious interrupt that might have been generated
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dcc4:	e5831140 	str	r1, [r3, #320]
                     CYGARC_HAL_LPC2XXX_REG_EXTINT, vector);
}
    dcc8:	e8bd0010 	pop	{r4}
    dccc:	e12fff1e 	bx	lr

0000dcd0 <hal_interrupt_set_level>:
    //
    // If level is < 16 then this is a vectored ISR and we try to write
    // the vector number of this ISR in the right slot of the vectored 
    // interrupt controller
    //
    if (level < 16)
    dcd0:	e351000f 	cmp	r1, #15	; 0xf
    {
        cyg_uint32 addr_offset =  level << 2;
    dcd4:	d1a03101 	lslle	r3, r1, #2
        HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
                        CYGARC_HAL_LPC2XXX_REG_VICVECTCNTL0 + 
                        addr_offset, reg_val);
        CYG_ASSERT((reg_val == 0) || (reg_val == (vector | 0x20)), 
                   "Priority already used by another vector");
        HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dcd8:	d3802020 	orrle	r2, r0, #32	; 0x20
    if (level < 16)
    {
        cyg_uint32 addr_offset =  level << 2;
        cyg_uint32 reg_val;
        
        HAL_READ_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dcdc:	d5131e00 	ldrle	r1, [r3, #-3584]
                        CYGARC_HAL_LPC2XXX_REG_VICVECTCNTL0 + 
                        addr_offset, reg_val);
        CYG_ASSERT((reg_val == 0) || (reg_val == (vector | 0x20)), 
                   "Priority already used by another vector");
        HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dce0:	d5032e00 	strle	r2, [r3, #-3584]
        //
        // We do not store the adress of the ISR here but we store the
        // vector number The hal_IRQ_handler then can faster determine
        // the right vector number
        //
        HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dce4:	d5030f00 	strle	r0, [r3, #-3840]
    dce8:	e12fff1e 	bx	lr

0000dcec <hal_lpc_watchdog_reset>:
}

// Use the watchdog to generate a reset
void hal_lpc_watchdog_reset(void)
{
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dcec:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
    dcf0:	e3a030ff 	mov	r3, #255	; 0xff
                     CYGARC_HAL_LPC2XXX_REG_WDTC, 0xFF);
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dcf4:	e3a02003 	mov	r2, #3	; 0x3
}

// Use the watchdog to generate a reset
void hal_lpc_watchdog_reset(void)
{
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dcf8:	e5813004 	str	r3, [r1, #4]
                     CYGARC_HAL_LPC2XXX_REG_WDTC, 0xFF);
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dcfc:	e5812000 	str	r2, [r1]
                     CYGARC_HAL_LPC2XXX_REG_WDMOD, 
                     CYGARC_HAL_LPC2XXX_REG_WDMOD_WDEN | 
                     CYGARC_HAL_LPC2XXX_REG_WDMOD_WDRESET);

    // feed WD with the two magic values
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dd00:	e2433055 	sub	r3, r3, #85	; 0x55
                     CYGARC_HAL_LPC2XXX_REG_WDFEED, 
                     CYGARC_HAL_LPC2XXX_REG_WDFEED_MAGIC1);	
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dd04:	e2822052 	add	r2, r2, #82	; 0x52
                     CYGARC_HAL_LPC2XXX_REG_WDMOD, 
                     CYGARC_HAL_LPC2XXX_REG_WDMOD_WDEN | 
                     CYGARC_HAL_LPC2XXX_REG_WDMOD_WDRESET);

    // feed WD with the two magic values
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dd08:	e5813008 	str	r3, [r1, #8]
                     CYGARC_HAL_LPC2XXX_REG_WDFEED, 
                     CYGARC_HAL_LPC2XXX_REG_WDFEED_MAGIC1);	
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_WD_BASE + 
    dd0c:	e5812008 	str	r2, [r1, #8]
    dd10:	eafffffe 	b	dd10 <hal_lpc_watchdog_reset+0x24>

0000dd14 <hal_hardware_init>:
#ifdef CYGHWR_HAL_ARM_LPC2XXX_FAMILY_LPC22XX
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE +
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV,
                     ((xclkdiv & 0x3) << 4) | (vpbdiv & 0x3));
#else
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dd14:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000

    //
    // 0xFFFFFFFF indicates that this is a non vectored ISR
    // This is the default setting for all  interrupts
    //
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dd18:	e3e01000 	mvn	r1, #0	; 0x0
#ifdef CYGHWR_HAL_ARM_LPC2XXX_FAMILY_LPC22XX
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE +
                     CYGARC_HAL_LPC2XXX_REG_VPBDIV,
                     ((xclkdiv & 0x3) << 4) | (vpbdiv & 0x3));
#else
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_SCB_BASE + 
    dd1c:	e3a02000 	mov	r2, #0	; 0x0
    dd20:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
    dd24:	e5832100 	str	r2, [r3, #256]

    //
    // 0xFFFFFFFF indicates that this is a non vectored ISR
    // This is the default setting for all  interrupts
    //
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_VIC_BASE + 
    dd28:	e5011fcb 	str	r1, [r1, #-4043]
    // Perform any platform specific initializations
    HAL_PLF_HARDWARE_INIT();
#endif

    // Set up eCos/ROM interfaces
    hal_if_init();
    dd2c:	eaffce48 	b	1654 <hal_if_init>

0000dd30 <hal_lpc2xxx_set_leds>:
extern void cyg_hal_plf_serial_init(void);
// Low bit of mask determines the on/off status of the LED. 0 means ON
// and 1 is OFF!
void hal_lpc2xxx_set_leds(int mask)
{
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_IO_BASE + 
    dd30:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
    dd34:	e283390a 	add	r3, r3, #163840	; 0x28000
    dd38:	e3a02080 	mov	r2, #128	; 0x80
                     CYGARC_HAL_LPC2XXX_REG_IOSET, (1<<7));
    if (mask & 1)	
    dd3c:	e3100001 	tst	r0, #1	; 0x1
extern void cyg_hal_plf_serial_init(void);
// Low bit of mask determines the on/off status of the LED. 0 means ON
// and 1 is OFF!
void hal_lpc2xxx_set_leds(int mask)
{
    HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_IO_BASE + 
    dd40:	e5832004 	str	r2, [r3, #4]
                     CYGARC_HAL_LPC2XXX_REG_IOSET, (1<<7));
    if (mask & 1)	
        HAL_WRITE_UINT32(CYGARC_HAL_LPC2XXX_REG_IO_BASE + 
    dd44:	1583200c 	strne	r2, [r3, #12]
    dd48:	e12fff1e 	bx	lr

0000dd4c <cyg_hal_plf_comms_init>:
void
cyg_hal_plf_comms_init(void)
{
    static int initialized = 0;
	
    if (initialized)
    dd4c:	e59f2014 	ldr	r2, [pc, #20]	; dd68 <cyg_hal_plf_comms_init+0x1c>
    dd50:	e5923000 	ldr	r3, [r2]
    dd54:	e3530000 	cmp	r3, #0	; 0x0
    dd58:	112fff1e 	bxne	lr
        return;
    initialized = 1;
    dd5c:	e2833001 	add	r3, r3, #1	; 0x1
    dd60:	e5823000 	str	r3, [r2]

    cyg_hal_plf_serial_init();
    dd64:	ea00086d 	b	ff20 <cyg_hal_plf_serial_init>
    dd68:	400046b8 	.word	0x400046b8

0000dd6c <_memcpy>:
#endif

    /* If the size is small, or either SRC or DST is unaligned,
     * then punt into the byte copy loop.  This should be rare.
     */
    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (src, dst))
    dd6c:	e3520003 	cmp	r2, #3	; 0x3

/* FUNCTIONS */

void *
_memcpy( void *s1, const void *s2, size_t n )
{
    dd70:	e92d0070 	push	{r4, r5, r6}
    dd74:	e1a04002 	mov	r4, r2
    dd78:	e1a06000 	mov	r6, r0
    dd7c:	e1a05001 	mov	r5, r1
#endif

    /* If the size is small, or either SRC or DST is unaligned,
     * then punt into the byte copy loop.  This should be rare.
     */
    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (src, dst))
    dd80:	9a00000b 	bls	ddb4 <_memcpy+0x48>
    dd84:	e1813000 	orr	r3, r1, r0
    dd88:	e3130003 	tst	r3, #3	; 0x3
    dd8c:	0a00000b 	beq	ddc0 <_memcpy+0x54>
    {
        while (n--)
    dd90:	e3a02000 	mov	r2, #0	; 0x0
            *dst++ = *src++;
    dd94:	e7d53002 	ldrb	r3, [r5, r2]
    dd98:	e7c63002 	strb	r3, [r6, r2]
    dd9c:	e2822001 	add	r2, r2, #1	; 0x1
    /* If the size is small, or either SRC or DST is unaligned,
     * then punt into the byte copy loop.  This should be rare.
     */
    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (src, dst))
    {
        while (n--)
    dda0:	e1540002 	cmp	r4, r2
    dda4:	1afffffa 	bne	dd94 <_memcpy+0x28>
    CYG_REPORT_RETVAL( s1 );
#endif
    return s1;
#endif /* not defined(CYGIMP_PREFER_SMALL_TO_FAST_MEMCPY) ||
        * defined(__OPTIMIZE_SIZE__) */
} /* _memcpy() */
    dda8:	e1a00006 	mov	r0, r6
    ddac:	e8bd0070 	pop	{r4, r5, r6}
    ddb0:	e12fff1e 	bx	lr
    /* If the size is small, or either SRC or DST is unaligned,
     * then punt into the byte copy loop.  This should be rare.
     */
    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (src, dst))
    {
        while (n--)
    ddb4:	e3520000 	cmp	r2, #0	; 0x0
    ddb8:	1afffff4 	bne	dd90 <_memcpy+0x24>
    ddbc:	eafffff9 	b	dda8 <_memcpy+0x3c>
    
    aligned_dst = (CYG_WORD *)dst;
    aligned_src = (const CYG_WORD *)src;
    
    /* Copy 4X long words at a time if possible.  */
    while (n >= CYG_STR_OPT_BIGBLOCKSIZE)
    ddc0:	e352000f 	cmp	r2, #15	; 0xf
        CYG_REPORT_RETVAL( s1 );
#endif
        return s1;
    } /* if */
    
    aligned_dst = (CYG_WORD *)dst;
    ddc4:	e1a0c000 	mov	ip, r0
    aligned_src = (const CYG_WORD *)src;
    
    /* Copy 4X long words at a time if possible.  */
    while (n >= CYG_STR_OPT_BIGBLOCKSIZE)
    ddc8:	81a01000 	movhi	r1, r0
    ddcc:	81a0c005 	movhi	ip, r5
    ddd0:	81a00002 	movhi	r0, r2
    ddd4:	9a000014 	bls	de2c <_memcpy+0xc0>
    {
        *aligned_dst++ = *aligned_src++;
    ddd8:	e59c3000 	ldr	r3, [ip]
    dddc:	e5813000 	str	r3, [r1]
        *aligned_dst++ = *aligned_src++;
    dde0:	e59c2004 	ldr	r2, [ip, #4]
    dde4:	e5812004 	str	r2, [r1, #4]
        *aligned_dst++ = *aligned_src++;
    dde8:	e59c3008 	ldr	r3, [ip, #8]
    ddec:	e5813008 	str	r3, [r1, #8]
        *aligned_dst++ = *aligned_src++;
        n -= CYG_STR_OPT_BIGBLOCKSIZE;
    ddf0:	e2400010 	sub	r0, r0, #16	; 0x10
    while (n >= CYG_STR_OPT_BIGBLOCKSIZE)
    {
        *aligned_dst++ = *aligned_src++;
        *aligned_dst++ = *aligned_src++;
        *aligned_dst++ = *aligned_src++;
        *aligned_dst++ = *aligned_src++;
    ddf4:	e59c300c 	ldr	r3, [ip, #12]
    
    aligned_dst = (CYG_WORD *)dst;
    aligned_src = (const CYG_WORD *)src;
    
    /* Copy 4X long words at a time if possible.  */
    while (n >= CYG_STR_OPT_BIGBLOCKSIZE)
    ddf8:	e350000f 	cmp	r0, #15	; 0xf
    {
        *aligned_dst++ = *aligned_src++;
        *aligned_dst++ = *aligned_src++;
        *aligned_dst++ = *aligned_src++;
        *aligned_dst++ = *aligned_src++;
    ddfc:	e581300c 	str	r3, [r1, #12]

/* FUNCTIONS */

void *
_memcpy( void *s1, const void *s2, size_t n )
{
    de00:	e28cc010 	add	ip, ip, #16	; 0x10
    de04:	e2811010 	add	r1, r1, #16	; 0x10
    
    aligned_dst = (CYG_WORD *)dst;
    aligned_src = (const CYG_WORD *)src;
    
    /* Copy 4X long words at a time if possible.  */
    while (n >= CYG_STR_OPT_BIGBLOCKSIZE)
    de08:	8afffff2 	bhi	ddd8 <_memcpy+0x6c>

/* FUNCTIONS */

void *
_memcpy( void *s1, const void *s2, size_t n )
{
    de0c:	e2442010 	sub	r2, r4, #16	; 0x10
    de10:	e3c2300f 	bic	r3, r2, #15	; 0xf
    de14:	e202400f 	and	r4, r2, #15	; 0xf
    de18:	e2833010 	add	r3, r3, #16	; 0x10
        *aligned_dst++ = *aligned_src++;
        n -= CYG_STR_OPT_BIGBLOCKSIZE;
    } /* while */
    
    /* Copy one long word at a time if possible.  */
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
    de1c:	e3540003 	cmp	r4, #3	; 0x3

/* FUNCTIONS */

void *
_memcpy( void *s1, const void *s2, size_t n )
{
    de20:	e0851003 	add	r1, r5, r3
    de24:	e086c003 	add	ip, r6, r3
        *aligned_dst++ = *aligned_src++;
        n -= CYG_STR_OPT_BIGBLOCKSIZE;
    } /* while */
    
    /* Copy one long word at a time if possible.  */
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
    de28:	9a00000c 	bls	de60 <_memcpy+0xf4>
    
    aligned_dst = (CYG_WORD *)dst;
    aligned_src = (const CYG_WORD *)src;
    
    /* Copy 4X long words at a time if possible.  */
    while (n >= CYG_STR_OPT_BIGBLOCKSIZE)
    de2c:	e3a02000 	mov	r2, #0	; 0x0
    } /* while */
    
    /* Copy one long word at a time if possible.  */
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
    {
        *aligned_dst++ = *aligned_src++;
    de30:	e7913002 	ldr	r3, [r1, r2]
    de34:	e78c3002 	str	r3, [ip, r2]
    de38:	e2822004 	add	r2, r2, #4	; 0x4
        *aligned_dst++ = *aligned_src++;
        n -= CYG_STR_OPT_BIGBLOCKSIZE;
    } /* while */
    
    /* Copy one long word at a time if possible.  */
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
    de3c:	e0623004 	rsb	r3, r2, r4
    de40:	e3530003 	cmp	r3, #3	; 0x3
    de44:	8afffff9 	bhi	de30 <_memcpy+0xc4>

/* FUNCTIONS */

void *
_memcpy( void *s1, const void *s2, size_t n )
{
    de48:	e2442004 	sub	r2, r4, #4	; 0x4
    de4c:	e3c23003 	bic	r3, r2, #3	; 0x3
    de50:	e2833004 	add	r3, r3, #4	; 0x4
    de54:	e08cc003 	add	ip, ip, r3
    de58:	e0811003 	add	r1, r1, r3
    de5c:	e2024003 	and	r4, r2, #3	; 0x3
    } /* while */
    
    /* Pick up any residual with a byte copier.  */
    dst = (char*)aligned_dst;
    src = (const char*)aligned_src;
    while (n--)
    de60:	e3540000 	cmp	r4, #0	; 0x0
    de64:	0affffcf 	beq	dda8 <_memcpy+0x3c>
    de68:	e3a02000 	mov	r2, #0	; 0x0
        *dst++ = *src++;
    de6c:	e7d13002 	ldrb	r3, [r1, r2]
    de70:	e7cc3002 	strb	r3, [ip, r2]
    de74:	e2822001 	add	r2, r2, #1	; 0x1
    } /* while */
    
    /* Pick up any residual with a byte copier.  */
    dst = (char*)aligned_dst;
    src = (const char*)aligned_src;
    while (n--)
    de78:	e1520004 	cmp	r2, r4
    de7c:	1afffffa 	bne	de6c <_memcpy+0x100>
    de80:	eaffffc8 	b	dda8 <_memcpy+0x3c>

0000de84 <_ZdlPv>:
#else
    counter++;
    CYG_ASSERT(counter < CYGNUM_INFRA_EMPTY_DELETE_THRESHOLD,
               "Do you want an empty delete function?");
#endif
}
    de84:	e12fff1e 	bx	lr

0000de88 <_ZdaPv>:
#else
    counter++;
    CYG_ASSERT(counter < CYGNUM_INFRA_EMPTY_DELETE_THRESHOLD,
               "Do you want an empty delete function?");
#endif
}
    de88:	e12fff1e 	bx	lr

0000de8c <_ZN11Cyg_CounterC2Ej>:
//==========================================================================
// Constructor for counter object

Cyg_Counter::Cyg_Counter(
    cyg_uint32      incr
    )
    de8c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)

public:

    Cyg_CList()
    {
        head = NULL;
    de90:	e3a02000 	mov	r2, #0	; 0x0
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    de94:	e3a03000 	mov	r3, #0	; 0x0
    de98:	e3a04000 	mov	r4, #0	; 0x0
    increment = incr;
    de9c:	e5801010 	str	r1, [r0, #16]
    dea0:	e5802000 	str	r2, [r0]
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    dea4:	e5803008 	str	r3, [r0, #8]
    dea8:	e580400c 	str	r4, [r0, #12]
    increment = incr;

}
    deac:	e8bd0010 	pop	{r4}
    deb0:	e12fff1e 	bx	lr

0000deb4 <_ZN11Cyg_CounterC1Ej>:
//==========================================================================
// Constructor for counter object

Cyg_Counter::Cyg_Counter(
    cyg_uint32      incr
    )
    deb4:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    deb8:	e3a02000 	mov	r2, #0	; 0x0
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    debc:	e3a03000 	mov	r3, #0	; 0x0
    dec0:	e3a04000 	mov	r4, #0	; 0x0
    increment = incr;
    dec4:	e5801010 	str	r1, [r0, #16]
    dec8:	e5802000 	str	r2, [r0]
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    decc:	e5803008 	str	r3, [r0, #8]
    ded0:	e580400c 	str	r4, [r0, #12]
    increment = incr;

}
    ded4:	e8bd0010 	pop	{r4}
    ded8:	e12fff1e 	bx	lr

0000dedc <_ZN11Cyg_CounterD2Ev>:

// -------------------------------------------------------------------------
// Destructor for Counter object

Cyg_Counter::~Cyg_Counter()
    dedc:	e5901000 	ldr	r1, [r0]
    dee0:	ea000009 	b	df0c <_ZN11Cyg_CounterD2Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    dee4:	e591c000 	ldr	ip, [r1]
            if( next == node )
    dee8:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    deec:	15913004 	ldrne	r3, [r1, #4]
    def0:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    def4:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    def8:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    defc:	1582c000 	strne	ip, [r2]
        next = prev = this;
    df00:	15811004 	strne	r1, [r1, #4]
    df04:	15811000 	strne	r1, [r1]
    df08:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    df0c:	e3510000 	cmp	r1, #0	; 0x0
    df10:	1afffff3 	bne	dee4 <_ZN11Cyg_CounterD2Ev+0x8>
{
    CYG_REPORT_FUNCTION();


}
    df14:	e5801000 	str	r1, [r0]
    df18:	e12fff1e 	bx	lr

0000df1c <_ZN11Cyg_CounterD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor for Counter object

Cyg_Counter::~Cyg_Counter()
    df1c:	e5901000 	ldr	r1, [r0]
    df20:	ea000009 	b	df4c <_ZN11Cyg_CounterD1Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    df24:	e591c000 	ldr	ip, [r1]
            if( next == node )
    df28:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    df2c:	15913004 	ldrne	r3, [r1, #4]
    df30:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    df34:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    df38:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    df3c:	1582c000 	strne	ip, [r2]
        next = prev = this;
    df40:	15811004 	strne	r1, [r1, #4]
    df44:	15811000 	strne	r1, [r1]
    df48:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    df4c:	e3510000 	cmp	r1, #0	; 0x0
    df50:	1afffff3 	bne	df24 <_ZN11Cyg_CounterD1Ev+0x8>
{
    CYG_REPORT_FUNCTION();


}
    df54:	e5801000 	str	r1, [r0]
    df58:	e12fff1e 	bx	lr

0000df5c <_ZN11Cyg_Counter9rem_alarmEP9Cyg_Alarm>:
    
    // General removal. Deals with what happend if this is only
    // object on list, or is the head.
    void remove( Cyg_DNode *node )
    {
        if( node == head )
    df5c:	e5903000 	ldr	r3, [r0]
    df60:	e1510003 	cmp	r1, r3
}

// -------------------------------------------------------------------------
// Remove an alarm from this counter

void Cyg_Counter::rem_alarm( Cyg_Alarm *alarm )
    df64:	e1a0c001 	mov	ip, r1
    df68:	0a000009 	beq	df94 <_ZN11Cyg_Counter9rem_alarmEP9Cyg_Alarm+0x38>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    df6c:	e5913000 	ldr	r3, [r1]
    df70:	e5912004 	ldr	r2, [r1, #4]
    df74:	e5832004 	str	r2, [r3, #4]
        prev->next = next;
    df78:	e5911004 	ldr	r1, [r1, #4]
        next = prev = this;
    df7c:	e58cc004 	str	ip, [ip, #4]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    df80:	e5813000 	str	r3, [r1]
        next = prev = this;
    df84:	e58cc000 	str	ip, [ip]

    CYG_INSTRUMENT_ALARM( REM, this, alarm );

    alarm_list_ptr->remove( alarm );
    
    alarm->enabled = false;
    df88:	e3a03000 	mov	r3, #0	; 0x0
    df8c:	e58c3028 	str	r3, [ip, #40]

}
    df90:	e12fff1e 	bx	lr

    // Remove the node at the head of the list
    Cyg_DNode *rem_head()
    {
        Cyg_DNode *node = head;
        if( node != NULL )
    df94:	e3510000 	cmp	r1, #0	; 0x0
    df98:	0afffffa 	beq	df88 <_ZN11Cyg_Counter9rem_alarmEP9Cyg_Alarm+0x2c>
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    df9c:	e5911000 	ldr	r1, [r1]
            if( next == node )
    dfa0:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    dfa4:	159c3004 	ldrne	r3, [ip, #4]
    dfa8:	15813004 	strne	r3, [r1, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    dfac:	03a03000 	moveq	r3, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    dfb0:	159c2004 	ldrne	r2, [ip, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    dfb4:	05803000 	streq	r3, [r0]

    CYG_INSTRUMENT_ALARM( REM, this, alarm );

    alarm_list_ptr->remove( alarm );
    
    alarm->enabled = false;
    dfb8:	e3a03000 	mov	r3, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    dfbc:	15821000 	strne	r1, [r2]
        next = prev = this;
    dfc0:	158cc004 	strne	ip, [ip, #4]
    dfc4:	158cc000 	strne	ip, [ip]
    dfc8:	e58c3028 	str	r3, [ip, #40]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    dfcc:	15801000 	strne	r1, [r0]

}
    dfd0:	e12fff1e 	bx	lr

0000dfd4 <_ZN9Cyg_ClockC2ENS_14cyg_resolutionE>:
//==========================================================================
// Constructor for clock object

Cyg_Clock::Cyg_Clock(
    cyg_resolution      res
    )
    dfd4:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    dfd8:	e24dd00c 	sub	sp, sp, #12	; 0xc
    dfdc:	e88d0006 	stm	sp, {r1, r2}
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    dfe0:	e59d3000 	ldr	r3, [sp]
//==========================================================================
// Constructor for clock object

Cyg_Clock::Cyg_Clock(
    cyg_resolution      res
    )
    dfe4:	e1a0c002 	mov	ip, r2

public:

    Cyg_CList()
    {
        head = NULL;
    dfe8:	e3a02000 	mov	r2, #0	; 0x0
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    dfec:	e5803014 	str	r3, [r0, #20]
    dff0:	e5802000 	str	r2, [r0]
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    dff4:	e3a03000 	mov	r3, #0	; 0x0
    dff8:	e3a04000 	mov	r4, #0	; 0x0
    increment = incr;
    dffc:	e2822001 	add	r2, r2, #1	; 0x1
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    e000:	e5803008 	str	r3, [r0, #8]
    e004:	e580400c 	str	r4, [r0, #12]
    increment = incr;
    e008:	e5802010 	str	r2, [r0, #16]
    cyg_resolution      res
    )
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    e00c:	e580c018 	str	ip, [r0, #24]
}
    e010:	e28dd00c 	add	sp, sp, #12	; 0xc
    e014:	e8bd0010 	pop	{r4}
    e018:	e12fff1e 	bx	lr

0000e01c <_ZN9Cyg_ClockC1ENS_14cyg_resolutionE>:
//==========================================================================
// Constructor for clock object

Cyg_Clock::Cyg_Clock(
    cyg_resolution      res
    )
    e01c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    e020:	e24dd00c 	sub	sp, sp, #12	; 0xc
    e024:	e88d0006 	stm	sp, {r1, r2}
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    e028:	e59d3000 	ldr	r3, [sp]
//==========================================================================
// Constructor for clock object

Cyg_Clock::Cyg_Clock(
    cyg_resolution      res
    )
    e02c:	e1a0c002 	mov	ip, r2
    e030:	e3a02000 	mov	r2, #0	; 0x0
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    e034:	e5803014 	str	r3, [r0, #20]
    e038:	e5802000 	str	r2, [r0]
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    e03c:	e3a03000 	mov	r3, #0	; 0x0
    e040:	e3a04000 	mov	r4, #0	; 0x0
    increment = incr;
    e044:	e2822001 	add	r2, r2, #1	; 0x1
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    e048:	e5803008 	str	r3, [r0, #8]
    e04c:	e580400c 	str	r4, [r0, #12]
    increment = incr;
    e050:	e5802010 	str	r2, [r0, #16]
    cyg_resolution      res
    )
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    e054:	e580c018 	str	ip, [r0, #24]
}
    e058:	e28dd00c 	add	sp, sp, #12	; 0xc
    e05c:	e8bd0010 	pop	{r4}
    e060:	e12fff1e 	bx	lr

0000e064 <_ZN9Cyg_ClockD2Ev>:

// -------------------------------------------------------------------------
// Destructor for Clock objects

Cyg_Clock::~Cyg_Clock()
    e064:	e5901000 	ldr	r1, [r0]
    e068:	ea000009 	b	e094 <_ZN9Cyg_ClockD2Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    e06c:	e591c000 	ldr	ip, [r1]
            if( next == node )
    e070:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    e074:	15913004 	ldrne	r3, [r1, #4]
    e078:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    e07c:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    e080:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    e084:	1582c000 	strne	ip, [r2]
        next = prev = this;
    e088:	15811004 	strne	r1, [r1, #4]
    e08c:	15811000 	strne	r1, [r1]
    e090:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    e094:	e3510000 	cmp	r1, #0	; 0x0
    e098:	1afffff3 	bne	e06c <_ZN9Cyg_ClockD2Ev+0x8>
{
    CYG_REPORT_FUNCTION();

}
    e09c:	e5801000 	str	r1, [r0]
    e0a0:	e12fff1e 	bx	lr

0000e0a4 <_ZN9Cyg_ClockD1Ev>:
}

// -------------------------------------------------------------------------
// Destructor for Clock objects

Cyg_Clock::~Cyg_Clock()
    e0a4:	e5901000 	ldr	r1, [r0]
    e0a8:	ea000009 	b	e0d4 <_ZN9Cyg_ClockD1Ev+0x30>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    e0ac:	e591c000 	ldr	ip, [r1]
            if( next == node )
    e0b0:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    e0b4:	15913004 	ldrne	r3, [r1, #4]
    e0b8:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    e0bc:	15912004 	ldrne	r2, [r1, #4]
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    e0c0:	03a0c000 	moveq	ip, #0	; 0x0
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    e0c4:	1582c000 	strne	ip, [r2]
        next = prev = this;
    e0c8:	15811004 	strne	r1, [r1, #4]
    e0cc:	15811000 	strne	r1, [r1]
    e0d0:	e1a0100c 	mov	r1, ip
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    e0d4:	e3510000 	cmp	r1, #0	; 0x0
    e0d8:	1afffff3 	bne	e0ac <_ZN9Cyg_ClockD1Ev+0x8>
{
    CYG_REPORT_FUNCTION();

}
    e0dc:	e5801000 	str	r1, [r0]
    e0e0:	e12fff1e 	bx	lr

0000e0e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy>:
// 100 and 1,000,000,000 for the dividend and divisor.
// So we want answers like 1/10 and 10/1 out of these routines.

static void construct_converter( Cyg_Clock::converter *pcc,
                                        cyg_uint64 m1, cyg_uint64 d1,
                                        cyg_uint64 m2, cyg_uint64 d2 )
    e0e4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e0e8:	e24dd064 	sub	sp, sp, #100	; 0x64
    e0ec:	e59dc090 	ldr	ip, [sp, #144]

    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    e0f0:	e004039c 	mul	r4, ip, r3
// 100 and 1,000,000,000 for the dividend and divisor.
// So we want answers like 1/10 and 10/1 out of these routines.

static void construct_converter( Cyg_Clock::converter *pcc,
                                        cyg_uint64 m1, cyg_uint64 d1,
                                        cyg_uint64 m2, cyg_uint64 d2 )
    e0f4:	e59de098 	ldr	lr, [sp, #152]
    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    lower = d1 * d2;
    e0f8:	e59d308c 	ldr	r3, [sp, #140]
    e0fc:	e005039e 	mul	r5, lr, r3

    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    e100:	e59d3094 	ldr	r3, [sp, #148]
    e104:	e0264392 	mla	r6, r2, r3, r4
    e108:	e084329c 	umull	r3, r4, ip, r2
// 100 and 1,000,000,000 for the dividend and divisor.
// So we want answers like 1/10 and 10/1 out of these routines.

static void construct_converter( Cyg_Clock::converter *pcc,
                                        cyg_uint64 m1, cyg_uint64 d1,
                                        cyg_uint64 m2, cyg_uint64 d2 )
    e10c:	e59d1088 	ldr	r1, [sp, #136]

    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    e110:	e58d3030 	str	r3, [sp, #48]
    e114:	e58d4034 	str	r4, [sp, #52]
    lower = d1 * d2;
    e118:	e59d309c 	ldr	r3, [sp, #156]
    e11c:	e0225391 	mla	r2, r1, r3, r5
    e120:	e084319e 	umull	r3, r4, lr, r1
    e124:	e58d3038 	str	r3, [sp, #56]
    e128:	e58d403c 	str	r4, [sp, #60]
    e12c:	e59de03c 	ldr	lr, [sp, #60]

    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    e130:	e59d4034 	ldr	r4, [sp, #52]
// 100 and 1,000,000,000 for the dividend and divisor.
// So we want answers like 1/10 and 10/1 out of these routines.

static void construct_converter( Cyg_Clock::converter *pcc,
                                        cyg_uint64 m1, cyg_uint64 d1,
                                        cyg_uint64 m2, cyg_uint64 d2 )
    e134:	e58d002c 	str	r0, [sp, #44]

    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    e138:	e0864004 	add	r4, r6, r4
    lower = d1 * d2;
    e13c:	e082e00e 	add	lr, r2, lr
    e140:	e3a00000 	mov	r0, #0	; 0x0

    int rounding = 0;

    // Here we assume that our workings will fit in a 64; the point is to
    // allow calculations with a number of ticks that may be large.
    upper = m1 * m2;
    e144:	e58d4034 	str	r4, [sp, #52]
    lower = d1 * d2;
    e148:	e58de03c 	str	lr, [sp, #60]
    e14c:	e58d0048 	str	r0, [sp, #72]
    cyg_uint64 save_lower = lower;
#endif

 retry_rounding:
    // First strip out common powers of 2
    while ( (0 == (1 & upper)) && ( 0 == (1 & lower)) ) {
    e150:	e28d3030 	add	r3, sp, #48	; 0x30
    e154:	e8930018 	ldm	r3, {r3, r4}
    e158:	e3a01001 	mov	r1, #1	; 0x1
    e15c:	e3a02000 	mov	r2, #0	; 0x0
    e160:	e0033001 	and	r3, r3, r1
    e164:	e0044002 	and	r4, r4, r2
    e168:	e193e004 	orrs	lr, r3, r4
    e16c:	1a000019 	bne	e1d8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0xf4>
    e170:	e28d3038 	add	r3, sp, #56	; 0x38
    e174:	e8930018 	ldm	r3, {r3, r4}
    e178:	e0033001 	and	r3, r3, r1
    e17c:	e0044002 	and	r4, r4, r2
    e180:	e1930004 	orrs	r0, r3, r4
    e184:	1a000013 	bne	e1d8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0xf4>
        upper >>= 1;
    e188:	e28d1030 	add	r1, sp, #48	; 0x30
    e18c:	e8910006 	ldm	r1, {r1, r2}
    e190:	e1b020a2 	lsrs	r2, r2, #1
    e194:	e1a01061 	rrx	r1, r1
    e198:	e58d1030 	str	r1, [sp, #48]
    e19c:	e58d2034 	str	r2, [sp, #52]
        lower >>= 1;
    e1a0:	e28d2038 	add	r2, sp, #56	; 0x38
    e1a4:	e892000c 	ldm	r2, {r2, r3}
    e1a8:	e1b030a3 	lsrs	r3, r3, #1
    e1ac:	e1a02062 	rrx	r2, r2
    e1b0:	e58d2038 	str	r2, [sp, #56]
    e1b4:	e58d303c 	str	r3, [sp, #60]
    cyg_uint64 save_lower = lower;
#endif

 retry_rounding:
    // First strip out common powers of 2
    while ( (0 == (1 & upper)) && ( 0 == (1 & lower)) ) {
    e1b8:	e28d3030 	add	r3, sp, #48	; 0x30
    e1bc:	e8930018 	ldm	r3, {r3, r4}
    e1c0:	e3a01001 	mov	r1, #1	; 0x1
    e1c4:	e3a02000 	mov	r2, #0	; 0x0
    e1c8:	e0033001 	and	r3, r3, r1
    e1cc:	e0044002 	and	r4, r4, r2
    e1d0:	e193e004 	orrs	lr, r3, r4
    e1d4:	0affffe5 	beq	e170 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8c>
    e1d8:	e3a01000 	mov	r1, #0	; 0x0
    e1dc:	e58d104c 	str	r1, [sp, #76]
    e1e0:	ea000004 	b	e1f8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x114>

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
    e1e4:	e59de04c 	ldr	lr, [sp, #76]
    e1e8:	e28ee002 	add	lr, lr, #2	; 0x2
        upper >>= 1;
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
    e1ec:	e35e0060 	cmp	lr, #96	; 0x60
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
    e1f0:	e58de04c 	str	lr, [sp, #76]
        upper >>= 1;
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
    e1f4:	0a00003f 	beq	e2f8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x214>
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
    e1f8:	e59f2838 	ldr	r2, [pc, #2104]	; ea38 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x954>
    e1fc:	e59d404c 	ldr	r4, [sp, #76]
    e200:	e19230b4 	ldrh	r3, [r2, r4]
        j = upper / p;
    e204:	e28d0030 	add	r0, sp, #48	; 0x30
    e208:	e8900003 	ldm	r0, {r0, r1}
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
    e20c:	e58d3008 	str	r3, [sp, #8]
        j = upper / p;
    e210:	e1a02003 	mov	r2, r3
    e214:	e3a03000 	mov	r3, #0	; 0x0
    e218:	eb000f02 	bl	11e28 <__aeabi_uldivmod>
        while ( j * p == upper ) {
    e21c:	e59de008 	ldr	lr, [sp, #8]
    e220:	e0843e90 	umull	r3, r4, r0, lr
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
    e224:	e1a05000 	mov	r5, r0
        while ( j * p == upper ) {
    e228:	e59d0030 	ldr	r0, [sp, #48]
    e22c:	e1500003 	cmp	r0, r3
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
    e230:	e1a06001 	mov	r6, r1
        while ( j * p == upper ) {
    e234:	e024419e 	mla	r4, lr, r1, r4
    e238:	1affffe9 	bne	e1e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x100>
    e23c:	e59d1034 	ldr	r1, [sp, #52]
    e240:	e1510004 	cmp	r1, r4
    e244:	1affffe6 	bne	e1e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x100>
            k = lower / p;
    e248:	e1a0200e 	mov	r2, lr
    e24c:	e3a03000 	mov	r3, #0	; 0x0
    e250:	e28d0038 	add	r0, sp, #56	; 0x38
    e254:	e8900003 	ldm	r0, {r0, r1}
    e258:	eb000ef2 	bl	11e28 <__aeabi_uldivmod>
            if ( k * p != lower )
    e25c:	e59d2008 	ldr	r2, [sp, #8]
    e260:	e0843290 	umull	r3, r4, r0, r2
    e264:	e59de038 	ldr	lr, [sp, #56]
    e268:	e15e0003 	cmp	lr, r3
    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
            k = lower / p;
    e26c:	e1a0a000 	mov	sl, r0
    e270:	e1a0b001 	mov	fp, r1
            if ( k * p != lower )
    e274:	e0244192 	mla	r4, r2, r1, r4
    e278:	1affffd9 	bne	e1e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x100>
    e27c:	e59d003c 	ldr	r0, [sp, #60]
    e280:	e1500004 	cmp	r0, r4
    e284:	1affffd6 	bne	e1e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x100>
                break;
            upper = j;
            lower = k;
            j = upper / p;
    e288:	e59d2008 	ldr	r2, [sp, #8]
    e28c:	e3a03000 	mov	r3, #0	; 0x0
    e290:	e1a00005 	mov	r0, r5
    e294:	e1a01006 	mov	r1, r6
    e298:	eb000ee2 	bl	11e28 <__aeabi_uldivmod>

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
    e29c:	e3a0c000 	mov	ip, #0	; 0x0
    e2a0:	e00c0c90 	mul	ip, r0, ip
    e2a4:	e59d2008 	ldr	r2, [sp, #8]
            k = lower / p;
            if ( k * p != lower )
                break;
            upper = j;
            lower = k;
            j = upper / p;
    e2a8:	e1a08000 	mov	r8, r0
    e2ac:	e1a09001 	mov	r9, r1

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
    e2b0:	e0810298 	umull	r0, r1, r8, r2
    e2b4:	e022c299 	mla	r2, r9, r2, ip
    e2b8:	e58d0030 	str	r0, [sp, #48]
    e2bc:	e58d1034 	str	r1, [sp, #52]
    e2c0:	e59d3030 	ldr	r3, [sp, #48]
    e2c4:	e0821001 	add	r1, r2, r1
    e2c8:	e1530005 	cmp	r3, r5
    e2cc:	e58d1034 	str	r1, [sp, #52]
    e2d0:	0a000028 	beq	e378 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x294>
    e2d4:	e58d5030 	str	r5, [sp, #48]
    e2d8:	e58d6034 	str	r6, [sp, #52]
    e2dc:	e59de04c 	ldr	lr, [sp, #76]
    e2e0:	e28ee002 	add	lr, lr, #2	; 0x2
        upper >>= 1;
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
    e2e4:	e35e0060 	cmp	lr, #96	; 0x60
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
    e2e8:	e58da038 	str	sl, [sp, #56]
    e2ec:	e58db03c 	str	fp, [sp, #60]
    e2f0:	e58de04c 	str	lr, [sp, #76]
        upper >>= 1;
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
    e2f4:	1affffbf 	bne	e1f8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x114>
    m1 = upper;
    d1 = lower;
    m2 = 1;
    d2 = 1;

    if ( m1 > 0x10000 ) {
    e2f8:	e59d0034 	ldr	r0, [sp, #52]
        upper >>= 1;
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
    e2fc:	e59d1030 	ldr	r1, [sp, #48]
    e300:	e28d2038 	add	r2, sp, #56	; 0x38
    e304:	e892000c 	ldm	r2, {r2, r3}
    m1 = upper;
    d1 = lower;
    m2 = 1;
    d2 = 1;

    if ( m1 > 0x10000 ) {
    e308:	e3500000 	cmp	r0, #0	; 0x0
    e30c:	e58d001c 	str	r0, [sp, #28]
        upper >>= 1;
        lower >>= 1;
    }

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
    e310:	e58d1020 	str	r1, [sp, #32]
    e314:	e58d2028 	str	r2, [sp, #40]
    e318:	e58d3024 	str	r3, [sp, #36]
    m1 = upper;
    d1 = lower;
    m2 = 1;
    d2 = 1;

    if ( m1 > 0x10000 ) {
    e31c:	1a00002e 	bne	e3dc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x2f8>
    e320:	e3510801 	cmp	r1, #65536	; 0x10000
    e324:	8a00002c 	bhi	e3dc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x2f8>
        if ( (d1 & 1) && (d1 == lower) && (d1 > 0x10000) && (rounding < 2) ) {
            CYG_ASSERT( 1 == d2, "d2 should be 1 to try rounding" );
            d1--;
            lower = d1;
            rounding++;
            goto retry_rounding;
    e328:	e3a07001 	mov	r7, #1	; 0x1
    e32c:	e3a08000 	mov	r8, #0	; 0x0
    e330:	e58d3014 	str	r3, [sp, #20]
    e334:	e58d2018 	str	r2, [sp, #24]
    e338:	e1a0c000 	mov	ip, r0
    e33c:	e1a0a007 	mov	sl, r7
    e340:	e1a00001 	mov	r0, r1
    e344:	e1a0b008 	mov	fp, r8
                "Unequal in reverse direction" );

    pcc->mul1 = m1;
    pcc->div1 = d1;
    pcc->mul2 = m2;
    pcc->div2 = d2;
    e348:	e59d302c 	ldr	r3, [sp, #44]
                "Unequal in forwards direction" );
    CYG_ASSERT( rounding || save_lower/save_upper == (d1 * d2)/(m1 * m2),
                "Unequal in reverse direction" );

    pcc->mul1 = m1;
    pcc->div1 = d1;
    e34c:	e59d4018 	ldr	r4, [sp, #24]
    e350:	e59de014 	ldr	lr, [sp, #20]
    pcc->mul2 = m2;
    pcc->div2 = d2;
    e354:	e583a018 	str	sl, [r3, #24]
    e358:	e583b01c 	str	fp, [r3, #28]
    CYG_ASSERT( rounding || save_lower/save_upper == (d1 * d2)/(m1 * m2),
                "Unequal in reverse direction" );

    pcc->mul1 = m1;
    pcc->div1 = d1;
    pcc->mul2 = m2;
    e35c:	e5837010 	str	r7, [r3, #16]
    e360:	e5838014 	str	r8, [r3, #20]
    CYG_ASSERT( rounding || save_upper/save_lower == (m1 * m2)/(d1 * d2),
                "Unequal in forwards direction" );
    CYG_ASSERT( rounding || save_lower/save_upper == (d1 * d2)/(m1 * m2),
                "Unequal in reverse direction" );

    pcc->mul1 = m1;
    e364:	e8831001 	stm	r3, {r0, ip}
    pcc->div1 = d1;
    e368:	e5834008 	str	r4, [r3, #8]
    e36c:	e583e00c 	str	lr, [r3, #12]
    pcc->mul2 = m2;
    pcc->div2 = d2;
}
    e370:	e28dd064 	add	sp, sp, #100	; 0x64
    e374:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    // then common factors - use lazy table above
    for ( i = 0 ; i < (sizeof( primes )/sizeof( primes[0] )); i++ ) {
        cyg_uint64 j, k, p = (cyg_uint64)(primes[i]);
        j = upper / p;
        while ( j * p == upper ) {
    e378:	e1510006 	cmp	r1, r6
    e37c:	1affffd4 	bne	e2d4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x1f0>
            k = lower / p;
    e380:	e59d2008 	ldr	r2, [sp, #8]
    e384:	e1a0000a 	mov	r0, sl
    e388:	e1a0100b 	mov	r1, fp
    e38c:	e3a03000 	mov	r3, #0	; 0x0
    e390:	eb000ea4 	bl	11e28 <__aeabi_uldivmod>
    e394:	e1a06000 	mov	r6, r0
    e398:	e1a07001 	mov	r7, r1
            if ( k * p != lower )
    e39c:	e3a01000 	mov	r1, #0	; 0x0
    e3a0:	e0010196 	mul	r1, r6, r1
    e3a4:	e59d2008 	ldr	r2, [sp, #8]
    e3a8:	e0854296 	umull	r4, r5, r6, r2
    e3ac:	e0221297 	mla	r2, r7, r2, r1
    e3b0:	e154000a 	cmp	r4, sl
    e3b4:	e0825005 	add	r5, r2, r5
    e3b8:	1affffc7 	bne	e2dc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x1f8>
    e3bc:	e155000b 	cmp	r5, fp
    e3c0:	1affffc5 	bne	e2dc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x1f8>
    e3c4:	e1a0c006 	mov	ip, r6
    e3c8:	e1a05008 	mov	r5, r8
    e3cc:	e1a06009 	mov	r6, r9
    e3d0:	e1a0a00c 	mov	sl, ip
    e3d4:	e1a0b007 	mov	fp, r7
    e3d8:	eaffffaa 	b	e288 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x1a4>
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e3dc:	e59d003c 	ldr	r0, [sp, #60]
    e3e0:	e59d1038 	ldr	r1, [sp, #56]
    e3e4:	e3500000 	cmp	r0, #0	; 0x0
    e3e8:	e1e03001 	mvn	r3, r1
    e3ec:	e2033001 	and	r3, r3, #1	; 0x1
    e3f0:	e3a02000 	mov	r2, #0	; 0x0
    e3f4:	1a000073 	bne	e5c8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x4e4>
    e3f8:	e3510001 	cmp	r1, #1	; 0x1
    e3fc:	8a000071 	bhi	e5c8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x4e4>
    e400:	e1130002 	tst	r3, r2
    e404:	1a000072 	bne	e5d4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x4f0>
    e408:	e28d5038 	add	r5, sp, #56	; 0x38
    e40c:	e8950060 	ldm	r5, {r5, r6}
    e410:	e3a02000 	mov	r2, #0	; 0x0
    e414:	e3a01001 	mov	r1, #1	; 0x1
            d2 <<= 1;
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e418:	e1560002 	cmp	r6, r2
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e41c:	e58d5058 	str	r5, [sp, #88]
    e420:	e58d605c 	str	r6, [sp, #92]
    e424:	e1a0a001 	mov	sl, r1
    e428:	e1a0b002 	mov	fp, r2
            d2 <<= 1;
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e42c:	8a000081 	bhi	e638 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x554>
    e430:	0a000172 	beq	ea00 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x91c>
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
            m1 >>= 1;
            m2 <<= 1;
            if ( m1 < 0x10000 )
    e434:	e28d3058 	add	r3, sp, #88	; 0x58
    e438:	e8930018 	ldm	r3, {r3, r4}
    e43c:	e58d3018 	str	r3, [sp, #24]
    e440:	e58d4014 	str	r4, [sp, #20]
                cont = (d2 < d1);
            }
        }
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
    e444:	e28d2058 	add	r2, sp, #88	; 0x58
    e448:	e8924004 	ldm	r2, {r2, lr}
    e44c:	e1a0128e 	lsl	r1, lr, #5
    e450:	e1811da2 	orr	r1, r1, r2, lsr #27
    e454:	e1a0c282 	lsl	ip, r2, #5
    e458:	e28d2030 	add	r2, sp, #48	; 0x30
    e45c:	e892000c 	ldm	r2, {r2, r3}
    e460:	e58d2050 	str	r2, [sp, #80]
    e464:	e58d3054 	str	r3, [sp, #84]
    e468:	e3a07001 	mov	r7, #1	; 0x1
    e46c:	e3a08000 	mov	r8, #0	; 0x0
            m1 >>= 1;
            m2 <<= 1;
            if ( m1 < 0x10000 )
    e470:	e3a00801 	mov	r0, #65536	; 0x10000
    e474:	e2400001 	sub	r0, r0, #1	; 0x1
                cont = (d2 < d1);
            }
        }
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
    e478:	e1a05007 	mov	r5, r7
    e47c:	e1a06008 	mov	r6, r8
    e480:	e59d3054 	ldr	r3, [sp, #84]
    e484:	e1530008 	cmp	r3, r8
    e488:	e28d3050 	add	r3, sp, #80	; 0x50
    e48c:	e8930018 	ldm	r3, {r3, r4}
    e490:	e0233005 	eor	r3, r3, r5
    e494:	e2033001 	and	r3, r3, #1	; 0x1
    e498:	e3a02000 	mov	r2, #0	; 0x0
    e49c:	8a00009f 	bhi	e720 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x63c>
    e4a0:	0a0000c3 	beq	e7b4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6d0>
    e4a4:	e1130002 	tst	r3, r2
    e4a8:	1a000081 	bne	e6b4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5d0>
            if ( m1 < 0x10000 )
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
    e4ac:	e59d3054 	ldr	r3, [sp, #84]
    e4b0:	e1530008 	cmp	r3, r8
    e4b4:	8a0000c5 	bhi	e7d0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6ec>
    e4b8:	0a0000c1 	beq	e7c4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6e0>
        }

        // if, after all that, m1 odd and unchanged, and too large,
        // decrement it just the once and try again: then try it
        // incremented once.
        if ( (m1 & 1) && (m1 == upper) && (m1 > 0x10000) && (rounding < 2) ) {
    e4bc:	e28d3050 	add	r3, sp, #80	; 0x50
    e4c0:	e8930018 	ldm	r3, {r3, r4}
    e4c4:	e3a01001 	mov	r1, #1	; 0x1
    e4c8:	e3a02000 	mov	r2, #0	; 0x0
    e4cc:	e0033001 	and	r3, r3, r1
    e4d0:	e0044002 	and	r4, r4, r2
    e4d4:	e1931004 	orrs	r1, r3, r4
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e4d8:	e28d0050 	add	r0, sp, #80	; 0x50
    e4dc:	e8901001 	ldm	r0, {r0, ip}
        }

        // if, after all that, m1 odd and unchanged, and too large,
        // decrement it just the once and try again: then try it
        // incremented once.
        if ( (m1 & 1) && (m1 == upper) && (m1 > 0x10000) && (rounding < 2) ) {
    e4e0:	0a000013 	beq	e534 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x450>
    e4e4:	e59d3020 	ldr	r3, [sp, #32]
    e4e8:	e1500003 	cmp	r0, r3
    e4ec:	e3a03000 	mov	r3, #0	; 0x0
    e4f0:	1a000002 	bne	e500 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x41c>
    e4f4:	e59de01c 	ldr	lr, [sp, #28]
    e4f8:	e15c000e 	cmp	ip, lr
    e4fc:	03a03001 	moveq	r3, #1	; 0x1
    e500:	e59d1054 	ldr	r1, [sp, #84]
    e504:	e3510000 	cmp	r1, #0	; 0x0
    e508:	e3a02000 	mov	r2, #0	; 0x0
    e50c:	1a000066 	bne	e6ac <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5c8>
    e510:	e59d4050 	ldr	r4, [sp, #80]
    e514:	e3540801 	cmp	r4, #65536	; 0x10000
    e518:	8a000063 	bhi	e6ac <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5c8>
    e51c:	e0033002 	and	r3, r3, r2
    e520:	e3130001 	tst	r3, #1	; 0x1
    e524:	0a000002 	beq	e534 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x450>
    e528:	e59de048 	ldr	lr, [sp, #72]
    e52c:	e35e0001 	cmp	lr, #1	; 0x1
    e530:	da000135 	ble	ea0c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x928>
            upper = m1;
            rounding++;
            goto retry_rounding;
        }
        // likewise for d1 - each of the pair can be odd only once each
        if ( (d1 & 1) && (d1 == lower) && (d1 > 0x10000) && (rounding < 2) ) {
    e534:	e28d3058 	add	r3, sp, #88	; 0x58
    e538:	e8930018 	ldm	r3, {r3, r4}
    e53c:	e3a01001 	mov	r1, #1	; 0x1
    e540:	e3a02000 	mov	r2, #0	; 0x0
    e544:	e0033001 	and	r3, r3, r1
    e548:	e0044002 	and	r4, r4, r2
    e54c:	e193e004 	orrs	lr, r3, r4
    e550:	0affff7c 	beq	e348 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x264>
    e554:	e59d1058 	ldr	r1, [sp, #88]
    e558:	e59d2028 	ldr	r2, [sp, #40]
    e55c:	e1510002 	cmp	r1, r2
    e560:	e3a03000 	mov	r3, #0	; 0x0
    e564:	0a000120 	beq	e9ec <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x908>
    e568:	e59d105c 	ldr	r1, [sp, #92]
    e56c:	e3510000 	cmp	r1, #0	; 0x0
    e570:	e3a02000 	mov	r2, #0	; 0x0
    e574:	1a00004a 	bne	e6a4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5c0>
    e578:	e59d4058 	ldr	r4, [sp, #88]
    e57c:	e3540801 	cmp	r4, #65536	; 0x10000
    e580:	8a000047 	bhi	e6a4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5c0>
    e584:	e0033002 	and	r3, r3, r2
    e588:	e3130001 	tst	r3, #1	; 0x1
    e58c:	0affff6d 	beq	e348 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x264>
    e590:	e59de048 	ldr	lr, [sp, #72]
    e594:	e35e0001 	cmp	lr, #1	; 0x1
    e598:	caffff6a 	bgt	e348 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x264>
            CYG_ASSERT( 1 == d2, "d2 should be 1 to try rounding" );
            d1--;
            lower = d1;
            rounding++;
    e59c:	e28d2058 	add	r2, sp, #88	; 0x58
    e5a0:	e892000c 	ldm	r2, {r2, r3}
            goto retry_rounding;
        }
        // likewise for d1 - each of the pair can be odd only once each
        if ( (d1 & 1) && (d1 == lower) && (d1 > 0x10000) && (rounding < 2) ) {
            CYG_ASSERT( 1 == d2, "d2 should be 1 to try rounding" );
            d1--;
    e5a4:	e3e00000 	mvn	r0, #0	; 0x0
            lower = d1;
            rounding++;
    e5a8:	e0922000 	adds	r2, r2, r0
            goto retry_rounding;
        }
        // likewise for d1 - each of the pair can be odd only once each
        if ( (d1 & 1) && (d1 == lower) && (d1 > 0x10000) && (rounding < 2) ) {
            CYG_ASSERT( 1 == d2, "d2 should be 1 to try rounding" );
            d1--;
    e5ac:	e3e01000 	mvn	r1, #0	; 0x0
            lower = d1;
            rounding++;
    e5b0:	e0a33001 	adc	r3, r3, r1
    e5b4:	e28ee001 	add	lr, lr, #1	; 0x1
    e5b8:	e58d2038 	str	r2, [sp, #56]
    e5bc:	e58d303c 	str	r3, [sp, #60]
    e5c0:	e58de048 	str	lr, [sp, #72]
    e5c4:	eafffee1 	b	e150 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6c>
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e5c8:	e3a02001 	mov	r2, #1	; 0x1
    e5cc:	e1130002 	tst	r3, r2
    e5d0:	0affff8c 	beq	e408 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x324>
    e5d4:	e3a01001 	mov	r1, #1	; 0x1
    e5d8:	e28d5038 	add	r5, sp, #56	; 0x38
    e5dc:	e8950060 	ldm	r5, {r5, r6}
    e5e0:	e3a02000 	mov	r2, #0	; 0x0
    e5e4:	e1a0a001 	mov	sl, r1
            d1 >>= 1;
            d2 <<= 1;
    e5e8:	e0917001 	adds	r7, r1, r1
    e5ec:	e0a28002 	adc	r8, r2, r2
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
            d1 >>= 1;
    e5f0:	e1b060a6 	lsrs	r6, r6, #1
    e5f4:	e1a05065 	rrx	r5, r5
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e5f8:	e025300a 	eor	r3, r5, sl
    e5fc:	e1560008 	cmp	r6, r8
            d1 >>= 1;
            d2 <<= 1;
    e600:	e1a01007 	mov	r1, r7
    e604:	e1a02008 	mov	r2, r8
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e608:	e2033001 	and	r3, r3, #1	; 0x1
    e60c:	e3a00000 	mov	r0, #0	; 0x0
    e610:	8a000065 	bhi	e7ac <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6c8>
    e614:	0a000062 	beq	e7a4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6c0>
    e618:	e1130000 	tst	r3, r0
    e61c:	1afffff1 	bne	e5e8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x504>
            d2 <<= 1;
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e620:	e1560002 	cmp	r6, r2
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e624:	e1a0a007 	mov	sl, r7
    e628:	e1a0b008 	mov	fp, r8
    e62c:	e58d5058 	str	r5, [sp, #88]
    e630:	e58d605c 	str	r6, [sp, #92]
            d2 <<= 1;
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e634:	9affff7d 	bls	e430 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x34c>
    e638:	e3a09000 	mov	r9, #0	; 0x0
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
    e63c:	e59fe3f4 	ldr	lr, [pc, #1012]	; ea38 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x954>
    e640:	e1a03089 	lsl	r3, r9, #1
    e644:	e19e20b3 	ldrh	r2, [lr, r3]
    e648:	e3a07000 	mov	r7, #0	; 0x0
            k = d1 / p;
    e64c:	e28d0058 	add	r0, sp, #88	; 0x58
    e650:	e8900003 	ldm	r0, {r0, r1}
    e654:	e1a03007 	mov	r3, r7
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
    e658:	e1a06002 	mov	r6, r2
            k = d1 / p;
    e65c:	eb000df1 	bl	11e28 <__aeabi_uldivmod>
    e660:	e3a08001 	mov	r8, #1	; 0x1
    e664:	e1a04000 	mov	r4, r0
    e668:	e1a05001 	mov	r5, r1
            while ( cont && ((k * p) == d1) ) {
    e66c:	e0030794 	mul	r3, r4, r7
    e670:	e0810694 	umull	r0, r1, r4, r6
    e674:	e0223596 	mla	r2, r6, r5, r3
    e678:	e0821001 	add	r1, r2, r1
    e67c:	e59d2058 	ldr	r2, [sp, #88]
    e680:	e1500002 	cmp	r0, r2
    e684:	0a000027 	beq	e728 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x644>
            d2 <<= 1;
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e688:	e2899001 	add	r9, r9, #1	; 0x1
    e68c:	e359002f 	cmp	r9, #47	; 0x2f
    e690:	83a03000 	movhi	r3, #0	; 0x0
    e694:	92083001 	andls	r3, r8, #1	; 0x1
    e698:	e3530000 	cmp	r3, #0	; 0x0
    e69c:	1affffe6 	bne	e63c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x558>
    e6a0:	eaffff63 	b	e434 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x350>
            upper = m1;
            rounding++;
            goto retry_rounding;
        }
        // likewise for d1 - each of the pair can be odd only once each
        if ( (d1 & 1) && (d1 == lower) && (d1 > 0x10000) && (rounding < 2) ) {
    e6a4:	e3a02001 	mov	r2, #1	; 0x1
    e6a8:	eaffffb5 	b	e584 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x4a0>
        }

        // if, after all that, m1 odd and unchanged, and too large,
        // decrement it just the once and try again: then try it
        // incremented once.
        if ( (m1 & 1) && (m1 == upper) && (m1 > 0x10000) && (rounding < 2) ) {
    e6ac:	e3a02001 	mov	r2, #1	; 0x1
    e6b0:	eaffff99 	b	e51c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x438>
                cont = (d2 < d1);
            }
        }
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
    e6b4:	e59de054 	ldr	lr, [sp, #84]
    e6b8:	e15e0001 	cmp	lr, r1
    e6bc:	8a000003 	bhi	e6d0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5ec>
    e6c0:	1affff79 	bne	e4ac <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3c8>
    e6c4:	e59d2050 	ldr	r2, [sp, #80]
    e6c8:	e152000c 	cmp	r2, ip
    e6cc:	9affff76 	bls	e4ac <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3c8>
            m1 >>= 1;
    e6d0:	e28d2050 	add	r2, sp, #80	; 0x50
    e6d4:	e892000c 	ldm	r2, {r2, r3}
    e6d8:	e1b030a3 	lsrs	r3, r3, #1
    e6dc:	e1a02062 	rrx	r2, r2
            m2 <<= 1;
    e6e0:	e0977007 	adds	r7, r7, r7
    e6e4:	e0a88008 	adc	r8, r8, r8
            if ( m1 < 0x10000 )
    e6e8:	e3530000 	cmp	r3, #0	; 0x0
            }
        }
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
            m1 >>= 1;
    e6ec:	e58d2050 	str	r2, [sp, #80]
    e6f0:	e58d3054 	str	r3, [sp, #84]
            m2 <<= 1;
            if ( m1 < 0x10000 )
    e6f4:	1affff61 	bne	e480 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x39c>
    e6f8:	e1520000 	cmp	r2, r0
    e6fc:	9affff6a 	bls	e4ac <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3c8>
                cont = (d2 < d1);
            }
        }
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
    e700:	e59d3054 	ldr	r3, [sp, #84]
    e704:	e1530008 	cmp	r3, r8
    e708:	e28d3050 	add	r3, sp, #80	; 0x50
    e70c:	e8930018 	ldm	r3, {r3, r4}
    e710:	e0233005 	eor	r3, r3, r5
    e714:	e2033001 	and	r3, r3, #1	; 0x1
    e718:	e3a02000 	mov	r2, #0	; 0x0
    e71c:	9affff5f 	bls	e4a0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3bc>
    e720:	e3a02001 	mov	r2, #1	; 0x1
    e724:	eaffff5e 	b	e4a4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3c0>
        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = d1 / p;
            while ( cont && ((k * p) == d1) ) {
    e728:	e59d305c 	ldr	r3, [sp, #92]
    e72c:	e1510003 	cmp	r1, r3
    e730:	1affffd4 	bne	e688 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x5a4>
                // we can extract a prime
                d1 = k;
                d2 *= p;
    e734:	e003079a 	mul	r3, sl, r7
    e738:	e081069a 	umull	r0, r1, sl, r6
    e73c:	e02c3b96 	mla	ip, r6, fp, r3
    e740:	e1a0b001 	mov	fp, r1
    e744:	e08cb00b 	add	fp, ip, fp
                k = d1 / p;
                cont = (d2 < d1);
    e748:	e155000b 	cmp	r5, fp
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = d1 / p;
            while ( cont && ((k * p) == d1) ) {
                // we can extract a prime
                d1 = k;
                d2 *= p;
    e74c:	e1a0a000 	mov	sl, r0
                k = d1 / p;
    e750:	e1a01005 	mov	r1, r5
    e754:	e1a00004 	mov	r0, r4
    e758:	e1a02006 	mov	r2, r6
    e75c:	e1a03007 	mov	r3, r7
    e760:	e58d4058 	str	r4, [sp, #88]
    e764:	e58d505c 	str	r5, [sp, #92]
                cont = (d2 < d1);
    e768:	e3a08001 	mov	r8, #1	; 0x1
    e76c:	8a000008 	bhi	e794 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6b0>
    e770:	0a000005 	beq	e78c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6a8>
        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = d1 / p;
            while ( cont && ((k * p) == d1) ) {
    e774:	e58d4058 	str	r4, [sp, #88]
    e778:	e58d505c 	str	r5, [sp, #92]
    e77c:	e59d105c 	ldr	r1, [sp, #92]
    e780:	e58d4018 	str	r4, [sp, #24]
    e784:	e58d1014 	str	r1, [sp, #20]
    e788:	eaffff2d 	b	e444 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x360>
                // we can extract a prime
                d1 = k;
                d2 *= p;
                k = d1 / p;
                cont = (d2 < d1);
    e78c:	e154000a 	cmp	r4, sl
    e790:	9afffff7 	bls	e774 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x690>
            k = d1 / p;
            while ( cont && ((k * p) == d1) ) {
                // we can extract a prime
                d1 = k;
                d2 *= p;
                k = d1 / p;
    e794:	eb000da3 	bl	11e28 <__aeabi_uldivmod>
    e798:	e1a05001 	mov	r5, r1
    e79c:	e1a04000 	mov	r4, r0
    e7a0:	eaffffb1 	b	e66c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x588>
    if ( m1 > 0x10000 ) {
        // only bother if there are more than 16 bits consumed here

        // now move powers of 2 from d1 to d2
        // keeping them the same order of magnitude
        while ( (0 == (1 & d1)) && (d2 < d1) ) {
    e7a4:	e1550007 	cmp	r5, r7
    e7a8:	9affff9a 	bls	e618 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x534>
    e7ac:	e3a00001 	mov	r0, #1	; 0x1
    e7b0:	eaffff98 	b	e618 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x534>
                cont = (d2 < d1);
            }
        }
        
        // move powers of 2 from m1 to m2 so long as we do not go less than d1
        while ( (0 == (1 & m1)) && (m2 < m1) && (m1 > (d1 << 5)) ) {
    e7b4:	e59d4050 	ldr	r4, [sp, #80]
    e7b8:	e1540007 	cmp	r4, r7
    e7bc:	83a02001 	movhi	r2, #1	; 0x1
    e7c0:	eaffff37 	b	e4a4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3c0>
            if ( m1 < 0x10000 )
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
    e7c4:	e59d4050 	ldr	r4, [sp, #80]
    e7c8:	e1540007 	cmp	r4, r7
    e7cc:	9affff3a 	bls	e4bc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3d8>
    e7d0:	e28d0058 	add	r0, sp, #88	; 0x58
    e7d4:	e8904001 	ldm	r0, {r0, lr}
    e7d8:	e1a0e20e 	lsl	lr, lr, #4
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e7dc:	e59d1054 	ldr	r1, [sp, #84]
            if ( m1 < 0x10000 )
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
    e7e0:	e18eee20 	orr	lr, lr, r0, lsr #28
    e7e4:	e1a02200 	lsl	r2, r0, #4
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e7e8:	e151000e 	cmp	r1, lr
            if ( m1 < 0x10000 )
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
    e7ec:	e58de00c 	str	lr, [sp, #12]
    e7f0:	e58d2010 	str	r2, [sp, #16]
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e7f4:	e3a03000 	mov	r3, #0	; 0x0
    e7f8:	8a000079 	bhi	e9e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x900>
    e7fc:	0a000075 	beq	e9d8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8f4>
    e800:	e59de054 	ldr	lr, [sp, #84]
    e804:	e35e0000 	cmp	lr, #0	; 0x0
    e808:	e3a02000 	mov	r2, #0	; 0x0
    e80c:	1a00002f 	bne	e8d0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7ec>
    e810:	e59d0050 	ldr	r0, [sp, #80]
    e814:	e3500801 	cmp	r0, #65536	; 0x10000
    e818:	8a00002c 	bhi	e8d0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7ec>
    e81c:	e0033002 	and	r3, r3, r2
    e820:	e3130001 	tst	r3, #1	; 0x1
    e824:	0affff24 	beq	e4bc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3d8>
    e828:	e3a01000 	mov	r1, #0	; 0x0
    e82c:	e58d1044 	str	r1, [sp, #68]
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
    e830:	e59d2044 	ldr	r2, [sp, #68]
    e834:	e59f41fc 	ldr	r4, [pc, #508]	; ea38 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x954>
    e838:	e1a03082 	lsl	r3, r2, #1
    e83c:	e3a0c000 	mov	ip, #0	; 0x0
    e840:	e19420b3 	ldrh	r2, [r4, r3]
            k = m1 / p;
    e844:	e28d0050 	add	r0, sp, #80	; 0x50
    e848:	e8900003 	ldm	r0, {r0, r1}
    e84c:	e1a0300c 	mov	r3, ip
    e850:	e58dc004 	str	ip, [sp, #4]
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
    e854:	e1a09002 	mov	r9, r2
            k = m1 / p;
    e858:	eb000d72 	bl	11e28 <__aeabi_uldivmod>
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
    e85c:	e59de00c 	ldr	lr, [sp, #12]
    e860:	e151000e 	cmp	r1, lr
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = m1 / p;
    e864:	e1a05000 	mov	r5, r0
    e868:	e1a06001 	mov	r6, r1
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
    e86c:	e3a03000 	mov	r3, #0	; 0x0
    e870:	e59dc004 	ldr	ip, [sp, #4]
    e874:	8a00001a 	bhi	e8e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x800>
    e878:	0a000016 	beq	e8d8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7f4>
    e87c:	e3560000 	cmp	r6, #0	; 0x0
    e880:	e3a02000 	mov	r2, #0	; 0x0
    e884:	1a00000f 	bne	e8c8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7e4>
    e888:	e3550801 	cmp	r5, #65536	; 0x10000
    e88c:	8a00000d 	bhi	e8c8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7e4>
    e890:	e0033002 	and	r3, r3, r2
    e894:	e3130001 	tst	r3, #1	; 0x1
    e898:	0affff07 	beq	e4bc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3d8>
    e89c:	e0843995 	umull	r3, r4, r5, r9
    e8a0:	e59d1050 	ldr	r1, [sp, #80]
    e8a4:	e1530001 	cmp	r3, r1
    e8a8:	e0244699 	mla	r4, r9, r6, r4
    e8ac:	0a00000e 	beq	e8ec <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x808>
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e8b0:	e59d0044 	ldr	r0, [sp, #68]
    e8b4:	e2800001 	add	r0, r0, #1	; 0x1
    e8b8:	e350002f 	cmp	r0, #47	; 0x2f
    e8bc:	e58d0044 	str	r0, [sp, #68]
    e8c0:	9affffda 	bls	e830 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x74c>
    e8c4:	eafffefc 	b	e4bc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3d8>
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = m1 / p;
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
    e8c8:	e3a02001 	mov	r2, #1	; 0x1
    e8cc:	eaffffef 	b	e890 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7ac>
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e8d0:	e3a02001 	mov	r2, #1	; 0x1
    e8d4:	eaffffd0 	b	e81c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x738>
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = m1 / p;
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
    e8d8:	e59d0010 	ldr	r0, [sp, #16]
    e8dc:	e1550000 	cmp	r5, r0
    e8e0:	9affffe5 	bls	e87c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x798>
    e8e4:	e3a03001 	mov	r3, #1	; 0x1
    e8e8:	eaffffe3 	b	e87c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x798>
    e8ec:	e59d2054 	ldr	r2, [sp, #84]
    e8f0:	e1540002 	cmp	r4, r2
    e8f4:	1affffed 	bne	e8b0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7cc>
                // we can extract a prime
                m1 = k;
                m2 *= p;
    e8f8:	e0030c97 	mul	r3, r7, ip
    e8fc:	e0223899 	mla	r2, r9, r8, r3
    e900:	e0843997 	umull	r3, r4, r7, r9
    e904:	e0828004 	add	r8, r2, r4
                k = m1 / p; // examine k for getting too small
                cont = ((m2 < m1) && (k > (d1 << 4)) && (k > 0x10000));
    e908:	e1560008 	cmp	r6, r8
            k = m1 / p;
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
                // we can extract a prime
                m1 = k;
                m2 *= p;
    e90c:	e1a07003 	mov	r7, r3
                k = m1 / p; // examine k for getting too small
                cont = ((m2 < m1) && (k > (d1 << 4)) && (k > 0x10000));
    e910:	8a000005 	bhi	e92c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x848>
    e914:	0a000002 	beq	e924 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x840>

    pcc->mul1 = m1;
    pcc->div1 = d1;
    pcc->mul2 = m2;
    pcc->div2 = d2;
}
    e918:	e58d5050 	str	r5, [sp, #80]
    e91c:	e58d6054 	str	r6, [sp, #84]
    e920:	eafffee5 	b	e4bc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x3d8>
            while ( cont && ((k * p) == m1) ) {
                // we can extract a prime
                m1 = k;
                m2 *= p;
                k = m1 / p; // examine k for getting too small
                cont = ((m2 < m1) && (k > (d1 << 4)) && (k > 0x10000));
    e924:	e1550003 	cmp	r5, r3
    e928:	9afffffa 	bls	e918 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x834>
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
                // we can extract a prime
                m1 = k;
                m2 *= p;
                k = m1 / p; // examine k for getting too small
    e92c:	e1a0300c 	mov	r3, ip
    e930:	e1a00005 	mov	r0, r5
    e934:	e1a01006 	mov	r1, r6
    e938:	e1a02009 	mov	r2, r9
    e93c:	e58dc004 	str	ip, [sp, #4]
    e940:	eb000d38 	bl	11e28 <__aeabi_uldivmod>
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
            cyg_uint64 k, p = (cyg_uint64)(primes[i]);
            k = m1 / p;
            cont = cont && (k > (d1 << 4) && (k > 0x10000));
            while ( cont && ((k * p) == m1) ) {
    e944:	e59d400c 	ldr	r4, [sp, #12]
    e948:	e1510004 	cmp	r1, r4
    e94c:	e3a03000 	mov	r3, #0	; 0x0
    e950:	e59dc004 	ldr	ip, [sp, #4]
    e954:	8a000016 	bhi	e9b4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8d0>
    e958:	0a000012 	beq	e9a8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8c4>
    e95c:	e3510000 	cmp	r1, #0	; 0x0
    e960:	e3a02000 	mov	r2, #0	; 0x0
    e964:	1a00000d 	bne	e9a0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8bc>
    e968:	e3500801 	cmp	r0, #65536	; 0x10000
    e96c:	8a00000b 	bhi	e9a0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8bc>
    e970:	e0033002 	and	r3, r3, r2
    e974:	e3130001 	tst	r3, #1	; 0x1
    e978:	0affffe6 	beq	e918 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x834>
    e97c:	e0030c90 	mul	r3, r0, ip
    e980:	e0223991 	mla	r2, r1, r9, r3
    e984:	e0843990 	umull	r3, r4, r0, r9
    e988:	e1530005 	cmp	r3, r5
    e98c:	e0824004 	add	r4, r2, r4
    e990:	0a000009 	beq	e9bc <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8d8>
    e994:	e58d5050 	str	r5, [sp, #80]
    e998:	e58d6054 	str	r6, [sp, #84]
    e99c:	eaffffc3 	b	e8b0 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x7cc>
    e9a0:	e3a02001 	mov	r2, #1	; 0x1
    e9a4:	eafffff1 	b	e970 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x88c>
    e9a8:	e59de010 	ldr	lr, [sp, #16]
    e9ac:	e150000e 	cmp	r0, lr
    e9b0:	9affffe9 	bls	e95c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x878>
    e9b4:	e3a03001 	mov	r3, #1	; 0x1
    e9b8:	eaffffe7 	b	e95c <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x878>
    e9bc:	e1540006 	cmp	r4, r6
    e9c0:	1afffff3 	bne	e994 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x8b0>
    e9c4:	e1a03000 	mov	r3, r0
    e9c8:	e1a00001 	mov	r0, r1
    e9cc:	e1a05003 	mov	r5, r3
    e9d0:	e1a06000 	mov	r6, r0
    e9d4:	eaffffc7 	b	e8f8 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x814>
                break;
        }
        
        // and factors from the table - ensure m1 stays well larger than d1
        cont = ((m2 < m1) && (m1 > (d1 << 4)) && (m1 > 0x10000));
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    e9d8:	e59d4050 	ldr	r4, [sp, #80]
    e9dc:	e1540002 	cmp	r4, r2
    e9e0:	9affff86 	bls	e800 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x71c>
    e9e4:	e3a03001 	mov	r3, #1	; 0x1
    e9e8:	eaffff84 	b	e800 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x71c>
            upper = m1;
            rounding++;
            goto retry_rounding;
        }
        // likewise for d1 - each of the pair can be odd only once each
        if ( (d1 & 1) && (d1 == lower) && (d1 > 0x10000) && (rounding < 2) ) {
    e9ec:	e59d405c 	ldr	r4, [sp, #92]
    e9f0:	e59de024 	ldr	lr, [sp, #36]
    e9f4:	e154000e 	cmp	r4, lr
    e9f8:	03a03001 	moveq	r3, #1	; 0x1
    e9fc:	eafffed9 	b	e568 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x484>
            d2 <<= 1;
        }

        // and factors from the table - go too far, if anything
        int cont = (d2 < d1);
        for ( i = 0 ; cont && (i < (sizeof( primes )/sizeof( primes[0] ))); i++ ) {
    ea00:	e1550001 	cmp	r5, r1
    ea04:	9afffe8a 	bls	e434 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x350>
    ea08:	eaffff0a 	b	e638 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x554>
        // incremented once.
        if ( (m1 & 1) && (m1 == upper) && (m1 > 0x10000) && (rounding < 2) ) {
            CYG_ASSERT( 1 == m2, "m2 should be 1 to try rounding" );
            m1--;
            upper = m1;
            rounding++;
    ea0c:	e28d2050 	add	r2, sp, #80	; 0x50
    ea10:	e892000c 	ldm	r2, {r2, r3}
        // if, after all that, m1 odd and unchanged, and too large,
        // decrement it just the once and try again: then try it
        // incremented once.
        if ( (m1 & 1) && (m1 == upper) && (m1 > 0x10000) && (rounding < 2) ) {
            CYG_ASSERT( 1 == m2, "m2 should be 1 to try rounding" );
            m1--;
    ea14:	e3e00000 	mvn	r0, #0	; 0x0
            upper = m1;
            rounding++;
    ea18:	e0922000 	adds	r2, r2, r0
        // if, after all that, m1 odd and unchanged, and too large,
        // decrement it just the once and try again: then try it
        // incremented once.
        if ( (m1 & 1) && (m1 == upper) && (m1 > 0x10000) && (rounding < 2) ) {
            CYG_ASSERT( 1 == m2, "m2 should be 1 to try rounding" );
            m1--;
    ea1c:	e3e01000 	mvn	r1, #0	; 0x0
            upper = m1;
            rounding++;
    ea20:	e0a33001 	adc	r3, r3, r1
    ea24:	e28ee001 	add	lr, lr, #1	; 0x1
    ea28:	e58d2030 	str	r2, [sp, #48]
    ea2c:	e58d3034 	str	r3, [sp, #52]
    ea30:	e58de048 	str	lr, [sp, #72]
    ea34:	eafffdc5 	b	e150 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy+0x6c>
    ea38:	00013126 	.word	0x00013126

0000ea3c <_ZN9Cyg_Clock28get_other_to_clock_converterEyPNS_9converterE>:
}

// other to clocks is (other * ns_per * dividend / divisor)
void Cyg_Clock::get_other_to_clock_converter(
    cyg_uint64 ns_per_other_tick,
    struct converter *pcc )
    ea3c:	e92d4030 	push	{r4, r5, lr}
{
    construct_converter( pcc,
                         ns_per_other_tick, 1,
                         resolution.divisor, resolution.dividend );
    ea40:	e590c018 	ldr	ip, [r0, #24]
}

// other to clocks is (other * ns_per * dividend / divisor)
void Cyg_Clock::get_other_to_clock_converter(
    cyg_uint64 ns_per_other_tick,
    struct converter *pcc )
    ea44:	e24dd01c 	sub	sp, sp, #28	; 0x1c
{
    construct_converter( pcc,
                         ns_per_other_tick, 1,
                         resolution.divisor, resolution.dividend );
    ea48:	e590e014 	ldr	lr, [r0, #20]
    ea4c:	e3a01000 	mov	r1, #0	; 0x0
    ea50:	e3a04001 	mov	r4, #1	; 0x1
    ea54:	e3a05000 	mov	r5, #0	; 0x0
    ea58:	e59d0028 	ldr	r0, [sp, #40]
    ea5c:	e88d0030 	stm	sp, {r4, r5}
    ea60:	e58dc008 	str	ip, [sp, #8]
    ea64:	e58de010 	str	lr, [sp, #16]
    ea68:	e58d1014 	str	r1, [sp, #20]
    ea6c:	e58d100c 	str	r1, [sp, #12]
    ea70:	ebfffd9b 	bl	e0e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy>
}
    ea74:	e28dd01c 	add	sp, sp, #28	; 0x1c
    ea78:	e8bd8030 	pop	{r4, r5, pc}

0000ea7c <_ZN9Cyg_Clock28get_clock_to_other_converterEyPNS_9converterE>:

// clocks to other is (ticks * divisor / dividend / ns_per)
void Cyg_Clock::get_clock_to_other_converter(
    cyg_uint64 ns_per_other_tick,
    struct converter *pcc )
    ea7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
{
    construct_converter( pcc,
                         1, ns_per_other_tick,
                         resolution.dividend, resolution.divisor );
    ea80:	e590c014 	ldr	ip, [r0, #20]
}

// clocks to other is (ticks * divisor / dividend / ns_per)
void Cyg_Clock::get_clock_to_other_converter(
    cyg_uint64 ns_per_other_tick,
    struct converter *pcc )
    ea84:	e24dd01c 	sub	sp, sp, #28	; 0x1c
{
    construct_converter( pcc,
                         1, ns_per_other_tick,
                         resolution.dividend, resolution.divisor );
    ea88:	e590e018 	ldr	lr, [r0, #24]
    ea8c:	e3a01000 	mov	r1, #0	; 0x0
    ea90:	e88d000c 	stm	sp, {r2, r3}
    ea94:	e59d0020 	ldr	r0, [sp, #32]
    ea98:	e3a02001 	mov	r2, #1	; 0x1
    ea9c:	e3a03000 	mov	r3, #0	; 0x0
    eaa0:	e58dc008 	str	ip, [sp, #8]
    eaa4:	e58de010 	str	lr, [sp, #16]
    eaa8:	e58d1014 	str	r1, [sp, #20]
    eaac:	e58d100c 	str	r1, [sp, #12]
    eab0:	ebfffd8b 	bl	e0e4 <_ZL19construct_converterPN9Cyg_Clock9converterEyyyy>
}
    eab4:	e28dd01c 	add	sp, sp, #28	; 0x1c
    eab8:	e8bd8000 	pop	{pc}

0000eabc <_ZN9Cyg_AlarmC2EP11Cyg_CounterPFvPS_jEj>:

Cyg_Alarm::Cyg_Alarm(
        Cyg_Counter     *c,             // Attached to this counter
        cyg_alarm_fn    *a,             // Call-back function
        CYG_ADDRWORD    d               // Call-back data
        )
    eabc:	e92d0070 	push	{r4, r5, r6}
    eac0:	e1a0c000 	mov	ip, r0
    CYG_REPORT_FUNCTION();

    counter     = c;
    alarm       = a;
    data        = d;
    trigger     = 0;
    eac4:	e3a05000 	mov	r5, #0	; 0x0
    eac8:	e3a06000 	mov	r6, #0	; 0x0
    interval    = 0;
    enabled     = false;
    eacc:	e3a04000 	mov	r4, #0	; 0x0
    ead0:	e5804028 	str	r4, [r0, #40]
        CYG_ADDRWORD    d               // Call-back data
        )
{
    CYG_REPORT_FUNCTION();

    counter     = c;
    ead4:	e5801008 	str	r1, [r0, #8]
    alarm       = a;
    ead8:	e580200c 	str	r2, [r0, #12]
    data        = d;
    eadc:	e5803010 	str	r3, [r0, #16]
    trigger     = 0;
    interval    = 0;
    eae0:	e5805020 	str	r5, [r0, #32]
    eae4:	e5806024 	str	r6, [r0, #36]
public:

    Cyg_DNode()
    {
        // Initialize pointers to point here
        next = prev = this;
    eae8:	e58c0004 	str	r0, [ip, #4]
    eaec:	e58c0000 	str	r0, [ip]
    CYG_REPORT_FUNCTION();

    counter     = c;
    alarm       = a;
    data        = d;
    trigger     = 0;
    eaf0:	e5805018 	str	r5, [r0, #24]
    eaf4:	e580601c 	str	r6, [r0, #28]
    interval    = 0;
    enabled     = false;

}
    eaf8:	e8bd0070 	pop	{r4, r5, r6}
    eafc:	e12fff1e 	bx	lr

0000eb00 <_ZN9Cyg_AlarmC1EP11Cyg_CounterPFvPS_jEj>:

Cyg_Alarm::Cyg_Alarm(
        Cyg_Counter     *c,             // Attached to this counter
        cyg_alarm_fn    *a,             // Call-back function
        CYG_ADDRWORD    d               // Call-back data
        )
    eb00:	e92d0070 	push	{r4, r5, r6}
    eb04:	e1a0c000 	mov	ip, r0
    CYG_REPORT_FUNCTION();

    counter     = c;
    alarm       = a;
    data        = d;
    trigger     = 0;
    eb08:	e3a05000 	mov	r5, #0	; 0x0
    eb0c:	e3a06000 	mov	r6, #0	; 0x0
    interval    = 0;
    enabled     = false;
    eb10:	e3a04000 	mov	r4, #0	; 0x0
    eb14:	e5804028 	str	r4, [r0, #40]
        CYG_ADDRWORD    d               // Call-back data
        )
{
    CYG_REPORT_FUNCTION();

    counter     = c;
    eb18:	e5801008 	str	r1, [r0, #8]
    alarm       = a;
    eb1c:	e580200c 	str	r2, [r0, #12]
    data        = d;
    eb20:	e5803010 	str	r3, [r0, #16]
    trigger     = 0;
    interval    = 0;
    eb24:	e5805020 	str	r5, [r0, #32]
    eb28:	e5806024 	str	r6, [r0, #36]
    eb2c:	e58c0004 	str	r0, [ip, #4]
    eb30:	e58c0000 	str	r0, [ip]
    CYG_REPORT_FUNCTION();

    counter     = c;
    alarm       = a;
    data        = d;
    trigger     = 0;
    eb34:	e5805018 	str	r5, [r0, #24]
    eb38:	e580601c 	str	r6, [r0, #28]
    interval    = 0;
    enabled     = false;

}
    eb3c:	e8bd0070 	pop	{r4, r5, r6}
    eb40:	e12fff1e 	bx	lr

0000eb44 <_ZN9Cyg_AlarmC2Ev>:

Cyg_Alarm::Cyg_Alarm(){}
    eb44:	e1a03000 	mov	r3, r0
    eb48:	e5830000 	str	r0, [r3]
    eb4c:	e5830004 	str	r0, [r3, #4]
    eb50:	e12fff1e 	bx	lr

0000eb54 <_ZN9Cyg_AlarmC1Ev>:
    eb54:	e1a03000 	mov	r3, r0
    eb58:	e5830000 	str	r0, [r3]
    eb5c:	e5830004 	str	r0, [r3, #4]
    eb60:	e12fff1e 	bx	lr

0000eb64 <_ZN9Cyg_Alarm11synchronizeEv>:
// -------------------------------------------------------------------------
// Synchronize with a past alarm stream that had been disabled,
// bring past times into synch, and the like.

void
Cyg_Alarm::synchronize( void )
    eb64:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
{
    if( interval != 0 ) {
    eb68:	e2805020 	add	r5, r0, #32	; 0x20
    eb6c:	e8950060 	ldm	r5, {r5, r6}
    eb70:	e1953006 	orrs	r3, r5, r6
// -------------------------------------------------------------------------
// Synchronize with a past alarm stream that had been disabled,
// bring past times into synch, and the like.

void
Cyg_Alarm::synchronize( void )
    eb74:	e24dd004 	sub	sp, sp, #4	; 0x4
    eb78:	e1a07000 	mov	r7, r0
{
    if( interval != 0 ) {
    eb7c:	0a000019 	beq	ebe8 <_ZN9Cyg_Alarm11synchronizeEv+0x84>
        // than preserving the original intervals. That behaviour can
        // always be obtained by using initialize() rather than
        // enable(), while the current behaviour would be more
        // difficult to achieve that way.
        cyg_tick_count d;
        d = counter->current_value() + interval - trigger;
    eb80:	e5903008 	ldr	r3, [r0, #8]
    eb84:	e2830008 	add	r0, r3, #8	; 0x8
    eb88:	e8900003 	ldm	r0, {r0, r1}
    eb8c:	e2878018 	add	r8, r7, #24	; 0x18
    eb90:	e8980300 	ldm	r8, {r8, r9}
    eb94:	e0900005 	adds	r0, r0, r5
    eb98:	e0a11006 	adc	r1, r1, r6
    eb9c:	e0500008 	subs	r0, r0, r8
    eba0:	e0c11009 	sbc	r1, r1, r9
        if ( d > interval ) {
    eba4:	e1510006 	cmp	r1, r6
    eba8:	9a000010 	bls	ebf0 <_ZN9Cyg_Alarm11synchronizeEv+0x8c>
            // then trigger was in the past, so resynchronize
            trigger += interval * ((d - 1) / interval );
    ebac:	e3e03000 	mvn	r3, #0	; 0x0
    ebb0:	e0900003 	adds	r0, r0, r3
    ebb4:	e3e04000 	mvn	r4, #0	; 0x0
    ebb8:	e0a11004 	adc	r1, r1, r4
    ebbc:	e1a02005 	mov	r2, r5
    ebc0:	e1a03006 	mov	r3, r6
    ebc4:	eb000c97 	bl	11e28 <__aeabi_uldivmod>
    ebc8:	e00c0690 	mul	ip, r0, r6
    ebcc:	e0843590 	umull	r3, r4, r0, r5
    ebd0:	e022c195 	mla	r2, r5, r1, ip
    ebd4:	e0933008 	adds	r3, r3, r8
    ebd8:	e0824004 	add	r4, r2, r4
    ebdc:	e0a44009 	adc	r4, r4, r9
    ebe0:	e5873018 	str	r3, [r7, #24]
    ebe4:	e587401c 	str	r4, [r7, #28]
        }
        // otherwise, we were just set up, so no worries.
    }
}
    ebe8:	e28dd004 	add	sp, sp, #4	; 0x4
    ebec:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        // always be obtained by using initialize() rather than
        // enable(), while the current behaviour would be more
        // difficult to achieve that way.
        cyg_tick_count d;
        d = counter->current_value() + interval - trigger;
        if ( d > interval ) {
    ebf0:	1afffffc 	bne	ebe8 <_ZN9Cyg_Alarm11synchronizeEv+0x84>
    ebf4:	e1500005 	cmp	r0, r5
    ebf8:	9afffffa 	bls	ebe8 <_ZN9Cyg_Alarm11synchronizeEv+0x84>
    ebfc:	eaffffea 	b	ebac <_ZN9Cyg_Alarm11synchronizeEv+0x48>

0000ec00 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm>:
}

// -------------------------------------------------------------------------
// Add an alarm to this counter

void Cyg_Counter::add_alarm( Cyg_Alarm *alarm )
    ec00:	e92d4070 	push	{r4, r5, r6, lr}
    ec04:	e1a05001 	mov	r5, r1
    ec08:	e1a06000 	mov	r6, r0
    // this alarm sensibly.
    alarm->enabled = true;

    // Check here for an alarm that triggers now or in the past and
    // call its alarm function immediately. 
    if( alarm->trigger <= counter )
    ec0c:	e595301c 	ldr	r3, [r5, #28]
    ec10:	e2800008 	add	r0, r0, #8	; 0x8
    ec14:	e8900003 	ldm	r0, {r0, r1}
    CYG_ASSERTCLASS( alarm, "Bad alarm passed" );
    CYG_ASSERT( Cyg_Scheduler::get_sched_lock() > 0, "Scheduler not locked");
    
    // set this now to allow an immediate handler call to manipulate
    // this alarm sensibly.
    alarm->enabled = true;
    ec18:	e3a02001 	mov	r2, #1	; 0x1

    // Check here for an alarm that triggers now or in the past and
    // call its alarm function immediately. 
    if( alarm->trigger <= counter )
    ec1c:	e1530001 	cmp	r3, r1
    CYG_ASSERTCLASS( alarm, "Bad alarm passed" );
    CYG_ASSERT( Cyg_Scheduler::get_sched_lock() > 0, "Scheduler not locked");
    
    // set this now to allow an immediate handler call to manipulate
    // this alarm sensibly.
    alarm->enabled = true;
    ec20:	e5852028 	str	r2, [r5, #40]

    // Check here for an alarm that triggers now or in the past and
    // call its alarm function immediately. 
    if( alarm->trigger <= counter )
    ec24:	8a000013 	bhi	ec78 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm+0x78>
    ec28:	0a00001f 	beq	ecac <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm+0xac>

        // call alarm function. Note that this is being
        // called here before the add_alarm has returned.
        // Note that this function may disable the alarm.
        
        alarm->alarm(alarm, alarm->data);
    ec2c:	e5951010 	ldr	r1, [r5, #16]
    ec30:	e1a00005 	mov	r0, r5
    ec34:	e1a0e00f 	mov	lr, pc
    ec38:	e595f00c 	ldr	pc, [r5, #12]

        // Note that this extra check on alarm->enabled is in case the
        // handler function disables this alarm!
        if( alarm->interval != 0 && alarm->enabled )
    ec3c:	e2851020 	add	r1, r5, #32	; 0x20
    ec40:	e8910006 	ldm	r1, {r1, r2}
    ec44:	e1913002 	orrs	r3, r1, r2
    ec48:	0a000014 	beq	eca0 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm+0xa0>
    ec4c:	e5953028 	ldr	r3, [r5, #40]
    ec50:	e3530000 	cmp	r3, #0	; 0x0
    ec54:	0a000011 	beq	eca0 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm+0xa0>
        {
            // The alarm has a retrigger interval.
            // Reset the trigger interval and drop
            // through to queue it.
            alarm->trigger += alarm->interval;
    ec58:	e2853018 	add	r3, r5, #24	; 0x18
    ec5c:	e8930018 	ldm	r3, {r3, r4}
    ec60:	e0933001 	adds	r3, r3, r1
    ec64:	e0a44002 	adc	r4, r4, r2
    ec68:	e5853018 	str	r3, [r5, #24]
    ec6c:	e585401c 	str	r4, [r5, #28]
            // ensure the next alarm time is in our future, and in phase
            // with the original time requested.
            alarm->synchronize();
    ec70:	e1a00005 	mov	r0, r5
    ec74:	ebffffba 	bl	eb64 <_ZN9Cyg_Alarm11synchronizeEv>


    // Add a node at the tail of the list
    void add_tail( Cyg_DNode *node )
    {
        if( head == NULL )
    ec78:	e5961000 	ldr	r1, [r6]
    ec7c:	e3510000 	cmp	r1, #0	; 0x0
    // so that it becomes this nodes predecessor in
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
    ec80:	15913004 	ldrne	r3, [r1, #4]
    ec84:	15853004 	strne	r3, [r5, #4]
        prev->next = node;
    ec88:	15912004 	ldrne	r2, [r1, #4]
    // Insert a node into the list before this one,
    // so that it becomes this nodes predecessor in
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
    ec8c:	15851000 	strne	r1, [r5]

    // Add a node at the tail of the list
    void add_tail( Cyg_DNode *node )
    {
        if( head == NULL )
            head = node;
    ec90:	05865000 	streq	r5, [r6]
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
        prev->next = node;
        prev = node;
    ec94:	15815004 	strne	r5, [r1, #4]
    // the list.
    void insert( Cyg_DNode *node )
    {
        node->next = this;
        node->prev = prev;
        prev->next = node;
    ec98:	15825000 	strne	r5, [r2]
    ec9c:	e8bd8070 	pop	{r4, r5, r6, pc}
        }
        else
        {
            // The alarm is all done with, disable it
            // unlock and return.
            alarm->enabled = false;
    eca0:	e3a03000 	mov	r3, #0	; 0x0
    eca4:	e5853028 	str	r3, [r5, #40]
    eca8:	e8bd8070 	pop	{r4, r5, r6, pc}
    // this alarm sensibly.
    alarm->enabled = true;

    // Check here for an alarm that triggers now or in the past and
    // call its alarm function immediately. 
    if( alarm->trigger <= counter )
    ecac:	e5953018 	ldr	r3, [r5, #24]
    ecb0:	e1530000 	cmp	r3, r0
    ecb4:	8affffef 	bhi	ec78 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm+0x78>
    ecb8:	eaffffdb 	b	ec2c <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm+0x2c>

0000ecbc <_ZN17Cyg_RealTimeClock3isrEjj>:
cyg_uint32 clock_dsr_start = 0;
#endif

// -------------------------------------------------------------------------

cyg_uint32 Cyg_RealTimeClock::isr(cyg_vector vector, CYG_ADDRWORD data)
    ecbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    }
#endif

    CYG_INSTRUMENT_CLOCK( ISR, 0, 0);

    HAL_CLOCK_RESET( CYGNUM_HAL_INTERRUPT_RTC, CYGNUM_KERNEL_COUNTERS_RTC_PERIOD );
    ecc0:	e3a01809 	mov	r1, #589824	; 0x90000
cyg_uint32 clock_dsr_start = 0;
#endif

// -------------------------------------------------------------------------

cyg_uint32 Cyg_RealTimeClock::isr(cyg_vector vector, CYG_ADDRWORD data)
    ecc4:	e24dd004 	sub	sp, sp, #4	; 0x4
    }
#endif

    CYG_INSTRUMENT_CLOCK( ISR, 0, 0);

    HAL_CLOCK_RESET( CYGNUM_HAL_INTERRUPT_RTC, CYGNUM_KERNEL_COUNTERS_RTC_PERIOD );
    ecc8:	e3a00004 	mov	r0, #4	; 0x4
    eccc:	ebfffb77 	bl	dab0 <hal_clock_reset>

    Cyg_Interrupt::acknowledge_interrupt(CYGNUM_HAL_INTERRUPT_RTC);
    ecd0:	e3a00004 	mov	r0, #4	; 0x4
    ecd4:	ebffd8df 	bl	5058 <_ZN13Cyg_Interrupt21acknowledge_interruptEj>

#if defined(CYGVAR_KERNEL_COUNTERS_CLOCK_DSR_LATENCY)
    HAL_CLOCK_READ(&clock_dsr_start);
#endif    
    return Cyg_Interrupt::CALL_DSR|Cyg_Interrupt::HANDLED;
}
    ecd8:	e3a00003 	mov	r0, #3	; 0x3
    ecdc:	e28dd004 	add	sp, sp, #4	; 0x4
    ece0:	e8bd8000 	pop	{pc}

0000ece4 <_ZN17Cyg_RealTimeClockC1Ev>:

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );

// -------------------------------------------------------------------------

Cyg_RealTimeClock::Cyg_RealTimeClock()
    ece4:	e92d4070 	push	{r4, r5, r6, lr}
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ece8:	e59f3088 	ldr	r3, [pc, #136]	; ed78 <_ZN17Cyg_RealTimeClockC1Ev+0x94>
    ecec:	e593c000 	ldr	ip, [r3]

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );

// -------------------------------------------------------------------------

Cyg_RealTimeClock::Cyg_RealTimeClock()
    ecf0:	e1a05000 	mov	r5, r0
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    ecf4:	e3a04000 	mov	r4, #0	; 0x0

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ecf8:	e5930004 	ldr	r0, [r3, #4]
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    ecfc:	e3a03000 	mov	r3, #0	; 0x0
    ed00:	e5853008 	str	r3, [r5, #8]
    ed04:	e585400c 	str	r4, [r5, #12]
    cyg_resolution      res
    )
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    ed08:	e585c014 	str	ip, [r5, #20]

public:

    Cyg_CList()
    {
        head = NULL;
    ed0c:	e3a01000 	mov	r1, #0	; 0x0

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ed10:	e59fc064 	ldr	ip, [pc, #100]	; ed7c <_ZN17Cyg_RealTimeClockC1Ev+0x98>
    ed14:	e285601c 	add	r6, r5, #28	; 0x1c
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    increment = incr;
    ed18:	e3a02001 	mov	r2, #1	; 0x1

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ed1c:	e59f405c 	ldr	r4, [pc, #92]	; ed80 <_ZN17Cyg_RealTimeClockC1Ev+0x9c>

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );

// -------------------------------------------------------------------------

Cyg_RealTimeClock::Cyg_RealTimeClock()
    ed20:	e24dd008 	sub	sp, sp, #8	; 0x8
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ed24:	e1a03005 	mov	r3, r5
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    increment = incr;
    ed28:	e5852010 	str	r2, [r5, #16]
    cyg_resolution      res
    )
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    ed2c:	e5850018 	str	r0, [r5, #24]

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ed30:	e1a02001 	mov	r2, r1
    ed34:	e5851000 	str	r1, [r5]
    ed38:	e1a00006 	mov	r0, r6
    ed3c:	e2811004 	add	r1, r1, #4	; 0x4
    ed40:	e58dc000 	str	ip, [sp]
    ed44:	e58d4004 	str	r4, [sp, #4]
    ed48:	ebffd7d6 	bl	4ca8 <_ZN13Cyg_InterruptC1EjijPFjjjEPFvjjjE>
{
    CYG_REPORT_FUNCTION();

    HAL_CLOCK_INITIALIZE( CYGNUM_KERNEL_COUNTERS_RTC_PERIOD );
    ed4c:	e3a00809 	mov	r0, #589824	; 0x90000
    ed50:	ebfffb49 	bl	da7c <hal_clock_initialize>
    
    interrupt.attach();
    ed54:	e1a00006 	mov	r0, r6
    ed58:	ebffd8dd 	bl	50d4 <_ZN13Cyg_Interrupt6attachEv>

    interrupt.unmask_interrupt(CYGNUM_HAL_INTERRUPT_RTC);
    ed5c:	e3a00004 	mov	r0, #4	; 0x4
    ed60:	ebffd8be 	bl	5060 <_ZN13Cyg_Interrupt16unmask_interruptEj>

    Cyg_Clock::real_time_clock = this;
    ed64:	e59f3018 	ldr	r3, [pc, #24]	; ed84 <_ZN17Cyg_RealTimeClockC1Ev+0xa0>
}
    ed68:	e1a00005 	mov	r0, r5
    
    interrupt.attach();

    interrupt.unmask_interrupt(CYGNUM_HAL_INTERRUPT_RTC);

    Cyg_Clock::real_time_clock = this;
    ed6c:	e5835000 	str	r5, [r3]
}
    ed70:	e28dd008 	add	sp, sp, #8	; 0x8
    ed74:	e8bd8070 	pop	{r4, r5, r6, pc}
    ed78:	400007ec 	.word	0x400007ec
    ed7c:	0000ecbc 	.word	0x0000ecbc
    ed80:	0000f0d0 	.word	0x0000f0d0
    ed84:	400046bc 	.word	0x400046bc

0000ed88 <_Z41__static_initialization_and_destruction_0ii>:

    CYG_INSTRUMENT_CLOCK( TICK_END,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
    
}
    ed88:	e3500001 	cmp	r0, #1	; 0x1
    ed8c:	e92d4010 	push	{r4, lr}
    ed90:	e1a04000 	mov	r4, r0
    ed94:	0a00001b 	beq	ee08 <_Z41__static_initialization_and_destruction_0ii+0x80>

Cyg_Clock::cyg_resolution rtc_resolution = CYGNUM_KERNEL_COUNTERS_RTC_RESOLUTION;

//Cyg_RealTimeClock Cyg_RealTimeClock::rtc __attribute__((init_priority (1)));

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );
    ed98:	e3500000 	cmp	r0, #0	; 0x0
    ed9c:	18bd8010 	popne	{r4, pc}
    eda0:	e3a03dda 	mov	r3, #13952	; 0x3680
    eda4:	e2833030 	add	r3, r3, #48	; 0x30
    eda8:	e1510003 	cmp	r1, r3
    edac:	18bd8010 	popne	{r4, pc}

#ifdef CYGVAR_KERNEL_COUNTERS_CLOCK

class Cyg_RealTimeClock
    : public Cyg_Clock
{
    edb0:	e59f006c 	ldr	r0, [pc, #108]	; ee24 <_Z41__static_initialization_and_destruction_0ii+0x9c>
    edb4:	ebffd7db 	bl	4d28 <_ZN13Cyg_InterruptD1Ev>
    edb8:	e59fe068 	ldr	lr, [pc, #104]	; ee28 <_Z41__static_initialization_and_destruction_0ii+0xa0>
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    edbc:	e59e1000 	ldr	r1, [lr]
    edc0:	e3510000 	cmp	r1, #0	; 0x0
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    edc4:	e1a00004 	mov	r0, r4
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    edc8:	e1a0400e 	mov	r4, lr
    edcc:	0a00000c 	beq	ee04 <_Z41__static_initialization_and_destruction_0ii+0x7c>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    edd0:	e591c000 	ldr	ip, [r1]
            if( next == node )
    edd4:	e15c0001 	cmp	ip, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    edd8:	15913004 	ldrne	r3, [r1, #4]
    eddc:	158c3004 	strne	r3, [ip, #4]
        prev->next = next;
    ede0:	15912004 	ldrne	r2, [r1, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    ede4:	05840000 	streq	r0, [r4]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    ede8:	1582c000 	strne	ip, [r2]
        next = prev = this;
    edec:	15811004 	strne	r1, [r1, #4]
    edf0:	15811000 	strne	r1, [r1]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    edf4:	1584c000 	strne	ip, [r4]
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    edf8:	e59e1000 	ldr	r1, [lr]
    edfc:	e3510000 	cmp	r1, #0	; 0x0
    ee00:	1afffff2 	bne	edd0 <_Z41__static_initialization_and_destruction_0ii+0x48>
    ee04:	e8bd8010 	pop	{r4, pc}

    CYG_INSTRUMENT_CLOCK( TICK_END,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
    
}
    ee08:	e3a03dda 	mov	r3, #13952	; 0x3680
    ee0c:	e2833030 	add	r3, r3, #48	; 0x30
    ee10:	e1510003 	cmp	r1, r3
    ee14:	18bd8010 	popne	{r4, pc}

Cyg_Clock::cyg_resolution rtc_resolution = CYGNUM_KERNEL_COUNTERS_RTC_RESOLUTION;

//Cyg_RealTimeClock Cyg_RealTimeClock::rtc __attribute__((init_priority (1)));

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );
    ee18:	e59f0008 	ldr	r0, [pc, #8]	; ee28 <_Z41__static_initialization_and_destruction_0ii+0xa0>

    CYG_INSTRUMENT_CLOCK( TICK_END,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
    
}
    ee1c:	e8bd4010 	pop	{r4, lr}

Cyg_Clock::cyg_resolution rtc_resolution = CYGNUM_KERNEL_COUNTERS_RTC_RESOLUTION;

//Cyg_RealTimeClock Cyg_RealTimeClock::rtc __attribute__((init_priority (1)));

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );
    ee20:	eaffffaf 	b	ece4 <_ZN17Cyg_RealTimeClockC1Ev>
    ee24:	400046dc 	.word	0x400046dc
    ee28:	400046c0 	.word	0x400046c0

0000ee2c <_GLOBAL__D.14000__ZN9Cyg_Clock15real_time_clockE>:

    CYG_INSTRUMENT_CLOCK( TICK_END,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
    
}
    ee2c:	e3a01dda 	mov	r1, #13952	; 0x3680
    ee30:	e2811030 	add	r1, r1, #48	; 0x30
    ee34:	e3a00000 	mov	r0, #0	; 0x0
    ee38:	eaffffd2 	b	ed88 <_Z41__static_initialization_and_destruction_0ii>

0000ee3c <_GLOBAL__I.14000__ZN9Cyg_Clock15real_time_clockE>:
    ee3c:	e3a01dda 	mov	r1, #13952	; 0x3680
    ee40:	e2811030 	add	r1, r1, #48	; 0x30
    ee44:	e3a00001 	mov	r0, #1	; 0x1
    ee48:	eaffffce 	b	ed88 <_Z41__static_initialization_and_destruction_0ii>

0000ee4c <_ZN17Cyg_RealTimeClockC2Ev>:

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );

// -------------------------------------------------------------------------

Cyg_RealTimeClock::Cyg_RealTimeClock()
    ee4c:	e92d4070 	push	{r4, r5, r6, lr}
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ee50:	e59f3088 	ldr	r3, [pc, #136]	; eee0 <_ZN17Cyg_RealTimeClockC2Ev+0x94>
    ee54:	e593c000 	ldr	ip, [r3]

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );

// -------------------------------------------------------------------------

Cyg_RealTimeClock::Cyg_RealTimeClock()
    ee58:	e1a05000 	mov	r5, r0
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    ee5c:	e3a04000 	mov	r4, #0	; 0x0

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ee60:	e5930004 	ldr	r0, [r3, #4]
    cyg_uint32      incr
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    ee64:	e3a03000 	mov	r3, #0	; 0x0
    ee68:	e5853008 	str	r3, [r5, #8]
    ee6c:	e585400c 	str	r4, [r5, #12]
    cyg_resolution      res
    )
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    ee70:	e585c014 	str	ip, [r5, #20]

public:

    Cyg_CList()
    {
        head = NULL;
    ee74:	e3a01000 	mov	r1, #0	; 0x0

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ee78:	e59fc064 	ldr	ip, [pc, #100]	; eee4 <_ZN17Cyg_RealTimeClockC2Ev+0x98>
    ee7c:	e285601c 	add	r6, r5, #28	; 0x1c
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    increment = incr;
    ee80:	e3a02001 	mov	r2, #1	; 0x1

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ee84:	e59f405c 	ldr	r4, [pc, #92]	; eee8 <_ZN17Cyg_RealTimeClockC2Ev+0x9c>

Cyg_RealTimeClock Cyg_RealTimeClock::rtc CYG_INIT_PRIORITY( CLOCK );

// -------------------------------------------------------------------------

Cyg_RealTimeClock::Cyg_RealTimeClock()
    ee88:	e24dd008 	sub	sp, sp, #8	; 0x8
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ee8c:	e1a03005 	mov	r3, r5
    )
{
    CYG_REPORT_FUNCTION();

    counter = 0;
    increment = incr;
    ee90:	e5852010 	str	r2, [r5, #16]
    cyg_resolution      res
    )
{
    CYG_REPORT_FUNCTION();

    resolution = res;
    ee94:	e5850018 	str	r0, [r5, #24]

Cyg_RealTimeClock::Cyg_RealTimeClock()
    : Cyg_Clock(rtc_resolution),
      interrupt(CYGNUM_HAL_INTERRUPT_RTC,
                CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY,
                (CYG_ADDRWORD)this, isr, dsr)
    ee98:	e1a02001 	mov	r2, r1
    ee9c:	e5851000 	str	r1, [r5]
    eea0:	e1a00006 	mov	r0, r6
    eea4:	e2811004 	add	r1, r1, #4	; 0x4
    eea8:	e58dc000 	str	ip, [sp]
    eeac:	e58d4004 	str	r4, [sp, #4]
    eeb0:	ebffd77c 	bl	4ca8 <_ZN13Cyg_InterruptC1EjijPFjjjEPFvjjjE>
{
    CYG_REPORT_FUNCTION();

    HAL_CLOCK_INITIALIZE( CYGNUM_KERNEL_COUNTERS_RTC_PERIOD );
    eeb4:	e3a00809 	mov	r0, #589824	; 0x90000
    eeb8:	ebfffaef 	bl	da7c <hal_clock_initialize>
    
    interrupt.attach();
    eebc:	e1a00006 	mov	r0, r6
    eec0:	ebffd883 	bl	50d4 <_ZN13Cyg_Interrupt6attachEv>

    interrupt.unmask_interrupt(CYGNUM_HAL_INTERRUPT_RTC);
    eec4:	e3a00004 	mov	r0, #4	; 0x4
    eec8:	ebffd864 	bl	5060 <_ZN13Cyg_Interrupt16unmask_interruptEj>

    Cyg_Clock::real_time_clock = this;
    eecc:	e59f3018 	ldr	r3, [pc, #24]	; eeec <_ZN17Cyg_RealTimeClockC2Ev+0xa0>
}
    eed0:	e1a00005 	mov	r0, r5
    
    interrupt.attach();

    interrupt.unmask_interrupt(CYGNUM_HAL_INTERRUPT_RTC);

    Cyg_Clock::real_time_clock = this;
    eed4:	e5835000 	str	r5, [r3]
}
    eed8:	e28dd008 	add	sp, sp, #8	; 0x8
    eedc:	e8bd8070 	pop	{r4, r5, r6, pc}
    eee0:	400007ec 	.word	0x400007ec
    eee4:	0000ecbc 	.word	0x0000ecbc
    eee8:	0000f0d0 	.word	0x0000f0d0
    eeec:	400046bc 	.word	0x400046bc

0000eef0 <_ZN9Cyg_Alarm10initializeEyy>:
// Initialize Alarm and enable

void Cyg_Alarm::initialize(                
    cyg_tick_count    t,                // Absolute trigger time
    cyg_tick_count    i                 // Relative retrigger interval
    )
    eef0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    eef4:	e1a05000 	mov	r5, r0
    eef8:	e1a06002 	mov	r6, r2
    eefc:	e1a07003 	mov	r7, r3
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    ef00:	e59f8060 	ldr	r8, [pc, #96]	; ef68 <_ZN9Cyg_Alarm10initializeEyy+0x78>
    ef04:	e5983000 	ldr	r3, [r8]
    ef08:	e2833001 	add	r3, r3, #1	; 0x1
    ef0c:	e5883000 	str	r3, [r8]

    Cyg_Scheduler::lock();
    
    // If already enabled, remove from counter
    
    if( enabled ) counter->rem_alarm(this);
    ef10:	e5903028 	ldr	r3, [r0, #40]
    ef14:	e3530000 	cmp	r3, #0	; 0x0
    ef18:	15900008 	ldrne	r0, [r0, #8]
    ef1c:	11a01005 	movne	r1, r5
    ef20:	1bfffc0d 	blne	df5c <_ZN11Cyg_Counter9rem_alarmEP9Cyg_Alarm>
                          ((cyg_uint32 *)&t)[1] );
    CYG_INSTRUMENT_ALARM( INTERVAL,
                          ((cyg_uint32 *)&i)[0],
                          ((cyg_uint32 *)&i)[1] );
 
    trigger = t;
    ef24:	e5856018 	str	r6, [r5, #24]
    ef28:	e585701c 	str	r7, [r5, #28]
    interval = i;
    ef2c:	e28d3018 	add	r3, sp, #24	; 0x18
    ef30:	e8930018 	ldm	r3, {r3, r4}

    counter->add_alarm(this);
    ef34:	e1a01005 	mov	r1, r5
    CYG_INSTRUMENT_ALARM( INTERVAL,
                          ((cyg_uint32 *)&i)[0],
                          ((cyg_uint32 *)&i)[1] );
 
    trigger = t;
    interval = i;
    ef38:	e5853020 	str	r3, [r5, #32]
    ef3c:	e5854024 	str	r4, [r5, #36]

    counter->add_alarm(this);
    ef40:	e5950008 	ldr	r0, [r5, #8]
    ef44:	ebffff2d 	bl	ec00 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    ef48:	e5983000 	ldr	r3, [r8]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    ef4c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    ef50:	159f3010 	ldrne	r3, [pc, #16]	; ef68 <_ZN9Cyg_Alarm10initializeEyy+0x78>
    ef54:	15830000 	strne	r0, [r3]
    ef58:	0a000000 	beq	ef60 <_ZN9Cyg_Alarm10initializeEyy+0x70>

    Cyg_Scheduler::unlock();    
}
    ef5c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ef60:	ebffdaad 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    ef64:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ef68:	400007c8 	.word	0x400007c8

0000ef6c <_ZN11Cyg_Counter4tickEj>:
#endif

// -------------------------------------------------------------------------
// Counter tick function

void Cyg_Counter::tick( cyg_uint32 ticks )
    ef6c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}

    // Increment the counter in a loop so we process
    // each tick separately. This is easier than trying
    // to cope with a range of increments.
    
    while( ticks-- )
    ef70:	e2518000 	subs	r8, r1, #0	; 0x0
#endif

// -------------------------------------------------------------------------
// Counter tick function

void Cyg_Counter::tick( cyg_uint32 ticks )
    ef74:	e1a07000 	mov	r7, r0

    // Increment the counter in a loop so we process
    // each tick separately. This is easier than trying
    // to cope with a range of increments.
    
    while( ticks-- )
    ef78:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
    ef7c:	e59f6148 	ldr	r6, [pc, #328]	; f0cc <_ZN11Cyg_Counter4tickEj+0x160>
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    ef80:	e3a09000 	mov	r9, #0	; 0x0
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    ef84:	e1a0a006 	mov	sl, r6
    ef88:	ea000001 	b	ef94 <_ZN11Cyg_Counter4tickEj+0x28>
    ef8c:	e2588001 	subs	r8, r8, #1	; 0x1
    ef90:	0a000015 	beq	efec <_ZN11Cyg_Counter4tickEj+0x80>
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    ef94:	e5963000 	ldr	r3, [r6]
    ef98:	e2833001 	add	r3, r3, #1	; 0x1
    ef9c:	e5863000 	str	r3, [r6]
    {
        Cyg_Scheduler::lock();

        // increment the counter, note that it is
        // allowed to wrap.
        counter += increment;
    efa0:	e5973010 	ldr	r3, [r7, #16]
    efa4:	e2871008 	add	r1, r7, #8	; 0x8
    efa8:	e8910006 	ldm	r1, {r1, r2}
    efac:	e3a04000 	mov	r4, #0	; 0x0
    efb0:	e0933001 	adds	r3, r3, r1
    efb4:	e0a44002 	adc	r4, r4, r2
    efb8:	e5873008 	str	r3, [r7, #8]
    efbc:	e587400c 	str	r4, [r7, #12]
    {
        head = NULL;
    };

    // Accessor and test functions
    Cyg_DNode *get_head() { return head; };
    efc0:	e597c000 	ldr	ip, [r7]

        cyg_bool rescan = true;

        while( rescan )
        {
            Cyg_DNode_T<Cyg_Alarm> *node = alarm_list_ptr->get_head();
    efc4:	e1a0500c 	mov	r5, ip

            rescan = false;
            
            while( node != NULL )
    efc8:	e3550000 	cmp	r5, #0	; 0x0
    efcc:	1a000007 	bne	eff0 <_ZN11Cyg_Counter4tickEj+0x84>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    efd0:	e5963000 	ldr	r3, [r6]
    efd4:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    efd8:	158a0000 	strne	r0, [sl]
    efdc:	1affffea 	bne	ef8c <_ZN11Cyg_Counter4tickEj+0x20>
    efe0:	ebffda8d 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>

    // Increment the counter in a loop so we process
    // each tick separately. This is easier than trying
    // to cope with a range of increments.
    
    while( ticks-- )
    efe4:	e2588001 	subs	r8, r8, #1	; 0x1
    efe8:	1affffe9 	bne	ef94 <_ZN11Cyg_Counter4tickEj+0x28>
    efec:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                Cyg_Alarm *alarm = CYG_CLASSFROMBASE( Cyg_Alarm, Cyg_DNode, node );
                Cyg_DNode_T<Cyg_Alarm> *next = alarm->get_next();

                CYG_ASSERTCLASS(alarm, "Bad alarm in counter list" );

                if( alarm->trigger <= counter )
    eff0:	e2871008 	add	r1, r7, #8	; 0x8
    eff4:	e8910006 	ldm	r1, {r1, r2}
    eff8:	e595301c 	ldr	r3, [r5, #28]
    effc:	e1530002 	cmp	r3, r2
        // Initialize pointers to point here
        next = prev = this;
    };

    // Accessor and test functions
    Cyg_DNode *get_next() { return next; };
    f000:	e5950000 	ldr	r0, [r5]
    f004:	8a000015 	bhi	f060 <_ZN11Cyg_Counter4tickEj+0xf4>
    f008:	0a000011 	beq	f054 <_ZN11Cyg_Counter4tickEj+0xe8>
    
    // General removal. Deals with what happend if this is only
    // object on list, or is the head.
    void remove( Cyg_DNode *node )
    {
        if( node == head )
    f00c:	e155000c 	cmp	r5, ip
    f010:	0a000022 	beq	f0a0 <_ZN11Cyg_Counter4tickEj+0x134>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    f014:	e5953004 	ldr	r3, [r5, #4]
    f018:	e5803004 	str	r3, [r0, #4]
        prev->next = next;
    f01c:	e895000c 	ldm	r5, {r2, r3}
        next = prev = this;
    f020:	e5855004 	str	r5, [r5, #4]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    f024:	e5832000 	str	r2, [r3]
        next = prev = this;
    f028:	e5855000 	str	r5, [r5]
                {
                    alarm_list_ptr->remove(alarm);

                    if( alarm->interval != 0 )
    f02c:	e2851020 	add	r1, r5, #32	; 0x20
    f030:	e8910006 	ldm	r1, {r1, r2}
    f034:	e1913002 	orrs	r3, r1, r2
                        // Reset the trigger time and requeue
                        // the alarm.
                        alarm->trigger += alarm->interval;
                        add_alarm( alarm );
                    }
                    else alarm->enabled = false;
    f038:	05853028 	streq	r3, [r5, #40]

                if( alarm->trigger <= counter )
                {
                    alarm_list_ptr->remove(alarm);

                    if( alarm->interval != 0 )
    f03c:	1a00000d 	bne	f078 <_ZN11Cyg_Counter4tickEj+0x10c>
                    else alarm->enabled = false;

                    CYG_INSTRUMENT_ALARM( CALL, this, alarm );
                
                    // Call alarm function
                    alarm->alarm(alarm, alarm->data);
    f040:	e1a00005 	mov	r0, r5
    f044:	e5951010 	ldr	r1, [r5, #16]
    f048:	e1a0e00f 	mov	lr, pc
    f04c:	e595f00c 	ldr	pc, [r5, #12]
    f050:	eaffffda 	b	efc0 <_ZN11Cyg_Counter4tickEj+0x54>
                Cyg_Alarm *alarm = CYG_CLASSFROMBASE( Cyg_Alarm, Cyg_DNode, node );
                Cyg_DNode_T<Cyg_Alarm> *next = alarm->get_next();

                CYG_ASSERTCLASS(alarm, "Bad alarm in counter list" );

                if( alarm->trigger <= counter )
    f054:	e5953018 	ldr	r3, [r5, #24]
    f058:	e1530001 	cmp	r3, r1
    f05c:	9affffea 	bls	f00c <_ZN11Cyg_Counter4tickEj+0xa0>

                // If the next node is the head of the list, then we have
                // looped all the way around. The node == next test
                // catches the case where we only had one element to start
                // with.
                if( next == alarm_list_ptr->get_head() || node == next )
    f060:	e15c0000 	cmp	ip, r0
    f064:	0affffd9 	beq	efd0 <_ZN11Cyg_Counter4tickEj+0x64>
    f068:	e1550000 	cmp	r5, r0
    f06c:	0affffd7 	beq	efd0 <_ZN11Cyg_Counter4tickEj+0x64>
    f070:	e1a05000 	mov	r5, r0
    f074:	eaffffd3 	b	efc8 <_ZN11Cyg_Counter4tickEj+0x5c>
                    if( alarm->interval != 0 )
                    {
                        // The alarm has a retrigger interval.
                        // Reset the trigger time and requeue
                        // the alarm.
                        alarm->trigger += alarm->interval;
    f078:	e2853018 	add	r3, r5, #24	; 0x18
    f07c:	e8930018 	ldm	r3, {r3, r4}
    f080:	e0933001 	adds	r3, r3, r1
    f084:	e0a44002 	adc	r4, r4, r2
    f088:	e5853018 	str	r3, [r5, #24]
    f08c:	e585401c 	str	r4, [r5, #28]
                        add_alarm( alarm );
    f090:	e1a00007 	mov	r0, r7
    f094:	e1a01005 	mov	r1, r5
    f098:	ebfffed8 	bl	ec00 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm>
    f09c:	eaffffe7 	b	f040 <_ZN11Cyg_Counter4tickEj+0xd4>
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
    f0a0:	e1550000 	cmp	r5, r0

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    f0a4:	15953004 	ldrne	r3, [r5, #4]
    f0a8:	15803004 	strne	r3, [r0, #4]
        prev->next = next;
    f0ac:	15952000 	ldrne	r2, [r5]
    f0b0:	15953004 	ldrne	r3, [r5, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    f0b4:	05879000 	streq	r9, [r7]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    f0b8:	15832000 	strne	r2, [r3]
        next = prev = this;
    f0bc:	15855004 	strne	r5, [r5, #4]
    f0c0:	15855000 	strne	r5, [r5]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    f0c4:	15870000 	strne	r0, [r7]
    f0c8:	eaffffd7 	b	f02c <_ZN11Cyg_Counter4tickEj+0xc0>
    f0cc:	400007c8 	.word	0x400007c8

0000f0d0 <_ZN17Cyg_RealTimeClock3dsrEjjj>:
    return Cyg_Interrupt::CALL_DSR|Cyg_Interrupt::HANDLED;
}

// -------------------------------------------------------------------------

void Cyg_RealTimeClock::dsr(cyg_vector vector, cyg_ucount32 count, CYG_ADDRWORD data)
    f0d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)

    CYG_INSTRUMENT_CLOCK( TICK_START,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
                          
    rtc->tick( count );
    f0d4:	e1a00002 	mov	r0, r2
    return Cyg_Interrupt::CALL_DSR|Cyg_Interrupt::HANDLED;
}

// -------------------------------------------------------------------------

void Cyg_RealTimeClock::dsr(cyg_vector vector, cyg_ucount32 count, CYG_ADDRWORD data)
    f0d8:	e24dd004 	sub	sp, sp, #4	; 0x4

    CYG_INSTRUMENT_CLOCK( TICK_START,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
                          
    rtc->tick( count );
    f0dc:	ebffffa2 	bl	ef6c <_ZN11Cyg_Counter4tickEj>
#if    0 == CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES

    // If timeslicing is enabled, call the scheduler to
    // handle it. But not if we have unique priorities.
    
    Cyg_Scheduler::scheduler.timeslice();
    f0e0:	e59f0008 	ldr	r0, [pc, #8]	; f0f0 <_ZN17Cyg_RealTimeClock3dsrEjjj+0x20>

    CYG_INSTRUMENT_CLOCK( TICK_END,
                          rtc->current_value_lo(),
                          rtc->current_value_hi());
    
}
    f0e4:	e28dd004 	add	sp, sp, #4	; 0x4
    f0e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
#if    0 == CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES

    // If timeslicing is enabled, call the scheduler to
    // handle it. But not if we have unique priorities.
    
    Cyg_Scheduler::scheduler.timeslice();
    f0ec:	eaffd8cc 	b	5424 <_ZN28Cyg_Scheduler_Implementation9timesliceEv>
    f0f0:	40002540 	.word	0x40002540

0000f0f4 <_ZN9Cyg_Alarm9get_timesEPyS0_>:
// Get the current time values from the alarm

void Cyg_Alarm::get_times(
        cyg_tick_count  *t,      // Next trigger time
        cyg_tick_count  *i       // Current interval
        )
    f0f4:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f0f8:	e59fc048 	ldr	ip, [pc, #72]	; f148 <_ZN9Cyg_Alarm9get_timesEPyS0_+0x54>
    f0fc:	e59c3000 	ldr	r3, [ip]
    f100:	e2833001 	add	r3, r3, #1	; 0x1
    f104:	e58c3000 	str	r3, [ip]
{
    // Lock the scheduler while we do this to avoid
    // race conditions.
    Cyg_Scheduler::lock();

    if( t != NULL ) *t = trigger;
    f108:	e3510000 	cmp	r1, #0	; 0x0
    f10c:	12803018 	addne	r3, r0, #24	; 0x18
    f110:	18930018 	ldmne	r3, {r3, r4}
    f114:	18810018 	stmne	r1, {r3, r4}
    if( i != NULL ) *i = interval;
    f118:	e3520000 	cmp	r2, #0	; 0x0
    f11c:	12803020 	addne	r3, r0, #32	; 0x20
    f120:	18930018 	ldmne	r3, {r3, r4}
    f124:	18820018 	stmne	r2, {r3, r4}
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f128:	e59c3000 	ldr	r3, [ip]
    f12c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f130:	159f3010 	ldrne	r3, [pc, #16]	; f148 <_ZN9Cyg_Alarm9get_timesEPyS0_+0x54>
    f134:	15830000 	strne	r0, [r3]
    f138:	0a000000 	beq	f140 <_ZN9Cyg_Alarm9get_timesEPyS0_+0x4c>
    
    Cyg_Scheduler::unlock();
}
    f13c:	e8bd8010 	pop	{r4, pc}
    f140:	ebffda35 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f144:	e8bd8010 	pop	{r4, pc}
    f148:	400007c8 	.word	0x400007c8

0000f14c <_ZN9Cyg_Alarm7disableEv>:
}

// -------------------------------------------------------------------------
// Ensure alarm disabled

void Cyg_Alarm::disable()
    f14c:	e92d4010 	push	{r4, lr}
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f150:	e59f403c 	ldr	r4, [pc, #60]	; f194 <_ZN9Cyg_Alarm7disableEv+0x48>
    f154:	e5943000 	ldr	r3, [r4]
    f158:	e2833001 	add	r3, r3, #1	; 0x1
    f15c:	e5843000 	str	r3, [r4]
{
    Cyg_Scheduler::lock();

    if( enabled ) counter->rem_alarm(this);
    f160:	e5903028 	ldr	r3, [r0, #40]
    f164:	e3530000 	cmp	r3, #0	; 0x0
    f168:	11a01000 	movne	r1, r0
    f16c:	15900008 	ldrne	r0, [r0, #8]
    f170:	1bfffb79 	blne	df5c <_ZN11Cyg_Counter9rem_alarmEP9Cyg_Alarm>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f174:	e5943000 	ldr	r3, [r4]
    f178:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f17c:	159f3010 	ldrne	r3, [pc, #16]	; f194 <_ZN9Cyg_Alarm7disableEv+0x48>
    f180:	15830000 	strne	r0, [r3]
    f184:	0a000000 	beq	f18c <_ZN9Cyg_Alarm7disableEv+0x40>

    Cyg_Scheduler::unlock();
}
    f188:	e8bd8010 	pop	{r4, pc}
    f18c:	ebffda22 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f190:	e8bd8010 	pop	{r4, pc}
    f194:	400007c8 	.word	0x400007c8

0000f198 <_ZN9Cyg_AlarmD1Ev>:
Cyg_Alarm::Cyg_Alarm(){}

// -------------------------------------------------------------------------
// Destructor

Cyg_Alarm::~Cyg_Alarm()
    f198:	e92d4010 	push	{r4, lr}
    f19c:	e1a04000 	mov	r4, r0
{
    CYG_REPORT_FUNCTION();

    disable();
    f1a0:	ebffffe9 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    };
    
    ~Cyg_DNode()
    {
        // If this node is still linked, unlink it.
        if( next != this )
    f1a4:	e5941000 	ldr	r1, [r4]
    f1a8:	e1540001 	cmp	r4, r1
    f1ac:	0a000005 	beq	f1c8 <_ZN9Cyg_AlarmD1Ev+0x30>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    f1b0:	e5943004 	ldr	r3, [r4, #4]
    f1b4:	e5813004 	str	r3, [r1, #4]
        prev->next = next;
    f1b8:	e5942004 	ldr	r2, [r4, #4]
        next = prev = this;
    f1bc:	e5844004 	str	r4, [r4, #4]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    f1c0:	e5821000 	str	r1, [r2]
        next = prev = this;
    f1c4:	e5844000 	str	r4, [r4]
}
    f1c8:	e1a00004 	mov	r0, r4
    f1cc:	e8bd8010 	pop	{r4, pc}

0000f1d0 <_ZN9Cyg_AlarmD2Ev>:
Cyg_Alarm::Cyg_Alarm(){}

// -------------------------------------------------------------------------
// Destructor

Cyg_Alarm::~Cyg_Alarm()
    f1d0:	e92d4010 	push	{r4, lr}
    f1d4:	e1a04000 	mov	r4, r0
{
    CYG_REPORT_FUNCTION();

    disable();
    f1d8:	ebffffdb 	bl	f14c <_ZN9Cyg_Alarm7disableEv>
    };
    
    ~Cyg_DNode()
    {
        // If this node is still linked, unlink it.
        if( next != this )
    f1dc:	e5941000 	ldr	r1, [r4]
    f1e0:	e1540001 	cmp	r4, r1
    f1e4:	0a000005 	beq	f200 <_ZN9Cyg_AlarmD2Ev+0x30>

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    f1e8:	e5943004 	ldr	r3, [r4, #4]
    f1ec:	e5813004 	str	r3, [r1, #4]
        prev->next = next;
    f1f0:	e5942004 	ldr	r2, [r4, #4]
        next = prev = this;
    f1f4:	e5844004 	str	r4, [r4, #4]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    f1f8:	e5821000 	str	r1, [r2]
        next = prev = this;
    f1fc:	e5844000 	str	r4, [r4]
}
    f200:	e1a00004 	mov	r0, r4
    f204:	e8bd8010 	pop	{r4, pc}

0000f208 <_ZN9Cyg_Alarm6enableEv>:
}

// -------------------------------------------------------------------------
// Ensure alarm enabled

void Cyg_Alarm::enable()
    f208:	e92d4030 	push	{r4, r5, lr}
    f20c:	e1a04000 	mov	r4, r0
    f210:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f214:	e59f5050 	ldr	r5, [pc, #80]	; f26c <_ZN9Cyg_Alarm6enableEv+0x64>
    f218:	e5953000 	ldr	r3, [r5]
    f21c:	e2833001 	add	r3, r3, #1	; 0x1
    f220:	e5853000 	str	r3, [r5]
{
    Cyg_Scheduler::lock();
    
    if( !enabled )
    f224:	e5903028 	ldr	r3, [r0, #40]
    f228:	e3530000 	cmp	r3, #0	; 0x0
    f22c:	1a000005 	bne	f248 <_ZN9Cyg_Alarm6enableEv+0x40>
    {
        // ensure the alarm time is in our future:
        synchronize();
    f230:	ebfffe4b 	bl	eb64 <_ZN9Cyg_Alarm11synchronizeEv>
        enabled = true;
    f234:	e3a03001 	mov	r3, #1	; 0x1
    f238:	e5843028 	str	r3, [r4, #40]
        counter->add_alarm(this);
    f23c:	e1a01004 	mov	r1, r4
    f240:	e5940008 	ldr	r0, [r4, #8]
    f244:	ebfffe6d 	bl	ec00 <_ZN11Cyg_Counter9add_alarmEP9Cyg_Alarm>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f248:	e5953000 	ldr	r3, [r5]
    f24c:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f250:	159f3014 	ldrne	r3, [pc, #20]	; f26c <_ZN9Cyg_Alarm6enableEv+0x64>
    f254:	15830000 	strne	r0, [r3]
    f258:	0a000001 	beq	f264 <_ZN9Cyg_Alarm6enableEv+0x5c>
    }

    Cyg_Scheduler::unlock();    
}
    f25c:	e28dd004 	add	sp, sp, #4	; 0x4
    f260:	e8bd8030 	pop	{r4, r5, pc}
    f264:	ebffd9ec 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f268:	eafffffb 	b	f25c <_ZN9Cyg_Alarm6enableEv+0x54>
    f26c:	400007c8 	.word	0x400007c8

0000f270 <free>:
    return data_ptr;
} // malloc()


void
free( void *ptr )
    f270:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    CYG_REPORT_FUNCNAME( "free");
    
    CYG_REPORT_FUNCARG1XV( ptr );

    // if null pointer, do nothing as per spec
    if ( NULL==ptr )
    f274:	e3500000 	cmp	r0, #0	; 0x0
    return data_ptr;
} // malloc()


void
free( void *ptr )
    f278:	e24dd00c 	sub	sp, sp, #12	; 0xc
    CYG_REPORT_FUNCNAME( "free");
    
    CYG_REPORT_FUNCARG1XV( ptr );

    // if null pointer, do nothing as per spec
    if ( NULL==ptr )
    f27c:	0a00003c 	beq	f374 <free+0x104>
        return;

    CYG_CHECK_DATA_PTR( ptr, "Pointer to free isn't even valid!" );

    // get pool to free it
    freeret = POOL.free( (cyg_uint8 *) ptr );
    f280:	e59f30fc 	ldr	r3, [pc, #252]	; f384 <free+0x114>
    f284:	e5937000 	ldr	r7, [r3]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f288:	e59f20f8 	ldr	r2, [pc, #248]	; f388 <free+0x118>
    f28c:	e5923000 	ldr	r3, [r2]
    f290:	e2833001 	add	r3, r3, #1	; 0x1
    f294:	e5823000 	str	r3, [r2]
    CYG_REPORT_FUNCTION();
    // Prevent preemption
    Cyg_Scheduler::lock();
    CYG_ASSERTCLASS( this, "Bad this pointer");
    
    cyg_int32 ret = pool.free( p, size );
    f298:	e3a02000 	mov	r2, #0	; 0x0
    f29c:	e1a01000 	mov	r1, r0
    f2a0:	e1a00007 	mov	r0, r7
    f2a4:	eb000585 	bl	108c0 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi>

    // anyone waiting?
    if ( !(queue.empty()) ) {
    f2a8:	e5973410 	ldr	r3, [r7, #1040]
    f2ac:	e3530000 	cmp	r3, #0	; 0x0
    f2b0:	0a000029 	beq	f35c <free+0xec>

public:

    Cyg_CList()
    {
        head = NULL;
    f2b4:	e3a03000 	mov	r3, #0	; 0x0
    f2b8:	e28da008 	add	sl, sp, #8	; 0x8
    f2bc:	e52a3004 	str	r3, [sl, #-4]!

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    f2c0:	e1a0b003 	mov	fp, r3

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    f2c4:	e2878e41 	add	r8, r7, #1040	; 0x410
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    f2c8:	e3a09007 	mov	r9, #7	; 0x7
    f2cc:	ea000006 	b	f2ec <free+0x7c>

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    f2d0:	e5c4b080 	strb	fp, [r4, #128]
    wake_reason = reason;
    f2d4:	e5c49081 	strb	r9, [r4, #129]

            cyg_uint8 *mem;
            if ( NULL != (mem = pool.try_alloc( p->size )) ) {
                // success!  awaken the thread
                thread->set_wake_reason( Cyg_Thread::DONE );
                thread->wake();
    f2d8:	ebffd3cb 	bl	420c <_ZN10Cyg_Thread4wakeEv>
        thread->wake();
        // return the successful value to it
        p->addr = mem;
#else
        Cyg_ThreadQueue holding;
        do {
    f2dc:	e5973410 	ldr	r3, [r7, #1040]
    f2e0:	e3530000 	cmp	r3, #0	; 0x0
            if ( NULL != (mem = pool.try_alloc( p->size )) ) {
                // success!  awaken the thread
                thread->set_wake_reason( Cyg_Thread::DONE );
                thread->wake();
                // return the successful value to it
                p->addr = mem;
    f2e4:	e5865004 	str	r5, [r6, #4]
        thread->wake();
        // return the successful value to it
        p->addr = mem;
#else
        Cyg_ThreadQueue holding;
        do {
    f2e8:	0a00000f 	beq	f32c <free+0xbc>

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    f2ec:	e1a00008 	mov	r0, r8
    f2f0:	ebffd870 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
            thread = queue.dequeue();
            p = (Mempolt2WaitInfo *)(thread->get_wait_info());
    f2f4:	e5906048 	ldr	r6, [r0, #72]
    f2f8:	e1a04000 	mov	r4, r0
            CYG_ASSERT( NULL == p->addr, "Thread already awoken?" );

            cyg_uint8 *mem;
            if ( NULL != (mem = pool.try_alloc( p->size )) ) {
    f2fc:	e5961000 	ldr	r1, [r6]
    f300:	e1a00007 	mov	r0, r7
    f304:	eb00041f 	bl	10388 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi>
    f308:	e2505000 	subs	r5, r0, #0	; 0x0
                // success!  awaken the thread
                thread->set_wake_reason( Cyg_Thread::DONE );
                thread->wake();
    f30c:	e1a00004 	mov	r0, r4
            thread = queue.dequeue();
            p = (Mempolt2WaitInfo *)(thread->get_wait_info());
            CYG_ASSERT( NULL == p->addr, "Thread already awoken?" );

            cyg_uint8 *mem;
            if ( NULL != (mem = pool.try_alloc( p->size )) ) {
    f310:	1affffee 	bne	f2d0 <free+0x60>
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    f314:	e1a01004 	mov	r1, r4
    f318:	e1a0000a 	mov	r0, sl
    f31c:	ebffd855 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
        thread->wake();
        // return the successful value to it
        p->addr = mem;
#else
        Cyg_ThreadQueue holding;
        do {
    f320:	e5973410 	ldr	r3, [r7, #1040]
    f324:	e3530000 	cmp	r3, #0	; 0x0
    f328:	1affffef 	bne	f2ec <free+0x7c>
            }
        } while ( !(queue.empty()) );
            
        // Now re-queue the unaffected threads back into the pool queue
        // (no pun intended)
        while ( !(holding.empty()) ) {
    f32c:	e59d3004 	ldr	r3, [sp, #4]
    f330:	e3530000 	cmp	r3, #0	; 0x0
    f334:	0a000008 	beq	f35c <free+0xec>
    f338:	e28d4004 	add	r4, sp, #4	; 0x4

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    f33c:	e1a00004 	mov	r0, r4
    f340:	ebffd85c 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
    f344:	e1a01000 	mov	r1, r0
// Inlines for Cyg_ThreadQueue class


inline void Cyg_ThreadQueue::enqueue(Cyg_Thread *thread)
{
    Cyg_ThreadQueue_Implementation::enqueue(thread);
    f348:	e1a00008 	mov	r0, r8
    f34c:	ebffd849 	bl	5478 <_ZN30Cyg_ThreadQueue_Implementation7enqueueEP10Cyg_Thread>
    f350:	e59d3004 	ldr	r3, [sp, #4]
    f354:	e3530000 	cmp	r3, #0	; 0x0
    f358:	1afffff7 	bne	f33c <free+0xcc>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f35c:	e59f2024 	ldr	r2, [pc, #36]	; f388 <free+0x118>
    f360:	e5923000 	ldr	r3, [r2]
    f364:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f368:	159f3018 	ldrne	r3, [pc, #24]	; f388 <free+0x118>
    f36c:	15830000 	strne	r0, [r3]
    f370:	0a000001 	beq	f37c <free+0x10c>

    CYG_ASSERT( freeret , "Couldn't free!" );

    CYG_REPORT_RETURN();

} // free()
    f374:	e28dd00c 	add	sp, sp, #12	; 0xc
    f378:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f37c:	ebffd9a6 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    else set_sched_lock(__lock);

    HAL_REORDER_BARRIER();
    f380:	eafffffb 	b	f374 <free+0x104>
    f384:	400007f4 	.word	0x400007f4
    f388:	400007c8 	.word	0x400007c8

0000f38c <malloc>:
#endif

// FUNCTIONS

void *
malloc( size_t size )
    f38c:	e92d4030 	push	{r4, r5, lr}
        return NULL;
    } // if
#endif

    // ask the pool for the data
    data_ptr = POOL.try_alloc( size );
    f390:	e59f3044 	ldr	r3, [pc, #68]	; f3dc <malloc+0x50>
#endif

// FUNCTIONS

void *
malloc( size_t size )
    f394:	e1a01000 	mov	r1, r0
    f398:	e24dd004 	sub	sp, sp, #4	; 0x4
        return NULL;
    } // if
#endif

    // ask the pool for the data
    data_ptr = POOL.try_alloc( size );
    f39c:	e5930000 	ldr	r0, [r3]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f3a0:	e59f4038 	ldr	r4, [pc, #56]	; f3e0 <malloc+0x54>
    f3a4:	e5943000 	ldr	r3, [r4]
    f3a8:	e2833001 	add	r3, r3, #1	; 0x1
    f3ac:	e5843000 	str	r3, [r4]
        
    // Prevent preemption
    Cyg_Scheduler::lock();
    CYG_ASSERTCLASS( this, "Bad this pointer");
    
    cyg_uint8 *ret = pool.try_alloc( size );
    f3b0:	eb0003f4 	bl	10388 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi>
    f3b4:	e1a05000 	mov	r5, r0
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f3b8:	e5943000 	ldr	r3, [r4]
    
    HAL_REORDER_BARRIER();
    
    cyg_ucount32 __lock = get_sched_lock() - 1;
    
    if( __lock == 0 ) unlock_inner(0);
    f3bc:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f3c0:	15840000 	strne	r0, [r4]
    f3c4:	0a000002 	beq	f3d4 <malloc+0x48>
    } // if

    CYG_REPORT_RETVAL( data_ptr );

    return data_ptr;
} // malloc()
    f3c8:	e1a00005 	mov	r0, r5
    f3cc:	e28dd004 	add	sp, sp, #4	; 0x4
    f3d0:	e8bd8030 	pop	{r4, r5, pc}
    f3d4:	ebffd990 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f3d8:	eafffffa 	b	f3c8 <malloc+0x3c>
    f3dc:	400007f4 	.word	0x400007f4
    f3e0:	400007c8 	.word	0x400007c8

0000f3e4 <calloc>:

} // free()


void *
calloc( size_t nmemb, size_t size )
    f3e4:	e92d4030 	push	{r4, r5, lr}

    CYG_REPORT_FUNCNAMETYPE( "calloc", "returning pointer %08x" );
    
    CYG_REPORT_FUNCARG2DV( nmemb, size );

    realsize = nmemb * size;
    f3e8:	e0040190 	mul	r4, r0, r1

} // free()


void *
calloc( size_t nmemb, size_t size )
    f3ec:	e24dd004 	sub	sp, sp, #4	; 0x4
    
    CYG_REPORT_FUNCARG2DV( nmemb, size );

    realsize = nmemb * size;

    data_ptr = malloc( realsize );
    f3f0:	e1a00004 	mov	r0, r4
    f3f4:	ebffffe4 	bl	f38c <malloc>

    // Fill with 0's if non-NULL
    if ( data_ptr != NULL )
    f3f8:	e2505000 	subs	r5, r0, #0	; 0x0
        memset( data_ptr, 0, realsize );
    f3fc:	11a02004 	movne	r2, r4
    f400:	13a01000 	movne	r1, #0	; 0x0
    f404:	1b00035f 	blne	10188 <_memset>

    CYG_REPORT_RETVAL( data_ptr );
    return data_ptr;
} // calloc()
    f408:	e1a00005 	mov	r0, r5
    f40c:	e28dd004 	add	sp, sp, #4	; 0x4
    f410:	e8bd8030 	pop	{r4, r5, pc}

0000f414 <mallinfo>:


externC struct mallinfo
mallinfo( void )
{
    struct mallinfo ret = { 0 }; // initialize to all zeros
    f414:	e3a01000 	mov	r1, #0	; 0x0
    f418:	e1a03000 	mov	r3, r0
    f41c:	e4831004 	str	r1, [r3], #4
    f420:	e2833004 	add	r3, r3, #4	; 0x4
    f424:	e4831004 	str	r1, [r3], #4
    f428:	e4831004 	str	r1, [r3], #4
    f42c:	e4831004 	str	r1, [r3], #4
    f430:	e4831004 	str	r1, [r3], #4
    f434:	e4831004 	str	r1, [r3], #4
    f438:	e4831004 	str	r1, [r3], #4
    return newptr;
} // realloc()


externC struct mallinfo
mallinfo( void )
    f43c:	e92d4030 	push	{r4, r5, lr}
{
    struct mallinfo ret = { 0 }; // initialize to all zeros
    f440:	e4831004 	str	r1, [r3], #4
    f444:	e4831004 	str	r1, [r3], #4
    return newptr;
} // realloc()


externC struct mallinfo
mallinfo( void )
    f448:	e24dd034 	sub	sp, sp, #52	; 0x34
{
    struct mallinfo ret = { 0 }; // initialize to all zeros
    f44c:	e5831000 	str	r1, [r3]

    POOL.get_status( CYG_MEMPOOL_STAT_ARENASIZE|
                     CYG_MEMPOOL_STAT_FREEBLOCKS|
                     CYG_MEMPOOL_STAT_TOTALALLOCATED|
                     CYG_MEMPOOL_STAT_TOTALFREE|
                     CYG_MEMPOOL_STAT_MAXFREE, stat );
    f450:	e59f30b4 	ldr	r3, [pc, #180]	; f50c <mallinfo+0xf8>
        blocksize       = -1;
        maxfree         = -1;
        waiting         = -1;
        origbase        = (const cyg_uint8 *)-1;
        origsize        = -1;
        maxoverhead     = -1;
    f454:	e3e0c000 	mvn	ip, #0	; 0x0

    cyg_int8    maxoverhead;    

    void
    init() {
        arenabase       = (const cyg_uint8 *)-1;
    f458:	e28d2030 	add	r2, sp, #48	; 0x30
    return newptr;
} // realloc()


externC struct mallinfo
mallinfo( void )
    f45c:	e1a05000 	mov	r5, r0
    // defined in common.hxx
    void
    get_status( cyg_mempool_status_flag_t flags, Cyg_Mempool_Status &status ) {
        // set to 0 - if there's anything really waiting, it will be set to
        // 1 later
        status.waiting = 0;
    f460:	e5cd1020 	strb	r1, [sp, #32]
    f464:	e522c02c 	str	ip, [r2, #-44]!
{
    struct mallinfo ret = { 0 }; // initialize to all zeros
    f468:	e5801004 	str	r1, [r0, #4]
        totalallocated  = -1;
        totalfree       = -1;
        blocksize       = -1;
        maxfree         = -1;
        waiting         = -1;
        origbase        = (const cyg_uint8 *)-1;
    f46c:	e58dc024 	str	ip, [sp, #36]

    POOL.get_status( CYG_MEMPOOL_STAT_ARENASIZE|
                     CYG_MEMPOOL_STAT_FREEBLOCKS|
                     CYG_MEMPOOL_STAT_TOTALALLOCATED|
                     CYG_MEMPOOL_STAT_TOTALFREE|
                     CYG_MEMPOOL_STAT_MAXFREE, stat );
    f470:	e5930000 	ldr	r0, [r3]
        origsize        = -1;
        maxoverhead     = -1;
    f474:	e5cdc02c 	strb	ip, [sp, #44]
        totalfree       = -1;
        blocksize       = -1;
        maxfree         = -1;
        waiting         = -1;
        origbase        = (const cyg_uint8 *)-1;
        origsize        = -1;
    f478:	e58dc028 	str	ip, [sp, #40]
        arenasize       = -1;
        freeblocks      = -1;
        totalallocated  = -1;
        totalfree       = -1;
        blocksize       = -1;
        maxfree         = -1;
    f47c:	e58dc01c 	str	ip, [sp, #28]
        arenabase       = (const cyg_uint8 *)-1;
        arenasize       = -1;
        freeblocks      = -1;
        totalallocated  = -1;
        totalfree       = -1;
        blocksize       = -1;
    f480:	e58dc018 	str	ip, [sp, #24]
    init() {
        arenabase       = (const cyg_uint8 *)-1;
        arenasize       = -1;
        freeblocks      = -1;
        totalallocated  = -1;
        totalfree       = -1;
    f484:	e58dc014 	str	ip, [sp, #20]
    void
    init() {
        arenabase       = (const cyg_uint8 *)-1;
        arenasize       = -1;
        freeblocks      = -1;
        totalallocated  = -1;
    f488:	e58dc010 	str	ip, [sp, #16]

    void
    init() {
        arenabase       = (const cyg_uint8 *)-1;
        arenasize       = -1;
        freeblocks      = -1;
    f48c:	e58dc00c 	str	ip, [sp, #12]
    cyg_int8    maxoverhead;    

    void
    init() {
        arenabase       = (const cyg_uint8 *)-1;
        arenasize       = -1;
    f490:	e58dc008 	str	ip, [sp, #8]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f494:	e59f4074 	ldr	r4, [pc, #116]	; f510 <mallinfo+0xfc>
    f498:	e5943000 	ldr	r3, [r4]
    f49c:	e2833001 	add	r3, r3, #1	; 0x1
    f4a0:	e5843000 	str	r3, [r4]
    CYG_ASSERTCLASS( this, "Bad this pointer");
    
    if (0 != (flags & CYG_MEMPOOL_STAT_WAITING)) {
        status.waiting = (0 == queue.empty());
    }
    pool.get_status(flags, status);
    f4a4:	e281105e 	add	r1, r1, #94	; 0x5e
    f4a8:	eb00059c 	bl	10b20 <_ZN35Cyg_Mempool_dlmalloc_Implementation10get_statusEtR18Cyg_Mempool_Status>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f4ac:	e5943000 	ldr	r3, [r4]
    f4b0:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f4b4:	15840000 	strne	r0, [r4]
    f4b8:	0a000011 	beq	f504 <mallinfo+0xf0>

    if ( stat.arenasize > 0 )
    f4bc:	e59d3008 	ldr	r3, [sp, #8]
    f4c0:	e3530000 	cmp	r3, #0	; 0x0
        ret.arena = stat.arenasize;
    f4c4:	c5853000 	strgt	r3, [r5]
    
    if ( stat.freeblocks > 0 )
    f4c8:	e59d300c 	ldr	r3, [sp, #12]
    f4cc:	e3530000 	cmp	r3, #0	; 0x0
        ret.ordblks = stat.freeblocks;
    f4d0:	c5853004 	strgt	r3, [r5, #4]

    if ( stat.totalallocated > 0 )
    f4d4:	e59d3010 	ldr	r3, [sp, #16]
    f4d8:	e3530000 	cmp	r3, #0	; 0x0
        ret.uordblks = stat.totalallocated;
    f4dc:	c585301c 	strgt	r3, [r5, #28]
    
    if ( stat.totalfree > 0 )
    f4e0:	e59d3014 	ldr	r3, [sp, #20]
    f4e4:	e3530000 	cmp	r3, #0	; 0x0
        ret.fordblks = stat.totalfree;
    f4e8:	c5853020 	strgt	r3, [r5, #32]

    if ( stat.maxfree > 0 )
    f4ec:	e59d301c 	ldr	r3, [sp, #28]
    f4f0:	e3530000 	cmp	r3, #0	; 0x0
        ret.maxfree = stat.maxfree;
    f4f4:	c5853028 	strgt	r3, [r5, #40]

    CYG_REPORT_RETURN();
    return ret;
} // mallinfo()
    f4f8:	e1a00005 	mov	r0, r5
    f4fc:	e28dd034 	add	sp, sp, #52	; 0x34
    f500:	e8bd8030 	pop	{r4, r5, pc}
    f504:	ebffd944 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f508:	eaffffeb 	b	f4bc <mallinfo+0xa8>
    f50c:	400007f4 	.word	0x400007f4
    f510:	400007c8 	.word	0x400007c8

0000f514 <realloc>:
    return data_ptr;
} // calloc()


externC void *
realloc( void *ptr, size_t size )
    f514:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    CYG_REPORT_FUNCNAMETYPE( "realloc", "returning pointer %08x" );

    CYG_REPORT_FUNCARG2( "ptr=%08x, size=%d", ptr, size );

    // if pointer is NULL, we must malloc it
    if ( ptr == NULL ) {
    f518:	e2507000 	subs	r7, r0, #0	; 0x0
    return data_ptr;
} // calloc()


externC void *
realloc( void *ptr, size_t size )
    f51c:	e24dd00c 	sub	sp, sp, #12	; 0xc
    f520:	e1a06001 	mov	r6, r1
    CYG_REPORT_FUNCNAMETYPE( "realloc", "returning pointer %08x" );

    CYG_REPORT_FUNCARG2( "ptr=%08x, size=%d", ptr, size );

    // if pointer is NULL, we must malloc it
    if ( ptr == NULL ) {
    f524:	0a000024 	beq	f5bc <realloc+0xa8>
    } // if

    CYG_CHECK_DATA_PTR( ptr, "realloc() passed a bogus pointer!" );

    // if size is 0, we must free it
    if (size == 0) {
    f528:	e3510000 	cmp	r1, #0	; 0x0
    f52c:	0a000025 	beq	f5c8 <realloc+0xb4>
    } // if
        
    void *newptr;

    // otherwise try to resize allocation
    newptr = POOL.resize_alloc( (cyg_uint8 *)ptr, size, &oldsize );
    f530:	e59f309c 	ldr	r3, [pc, #156]	; f5d4 <realloc+0xc0>
    f534:	e5930000 	ldr	r0, [r3]
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f538:	e59f5098 	ldr	r5, [pc, #152]	; f5d8 <realloc+0xc4>
    f53c:	e5953000 	ldr	r3, [r5]
    f540:	e2833001 	add	r3, r3, #1	; 0x1
    f544:	e5853000 	str	r3, [r5]
        
    // Prevent preemption
    Cyg_Scheduler::lock();
    CYG_ASSERTCLASS( this, "Bad this pointer");
    
    cyg_uint8 *ret = pool.resize_alloc( alloc_ptr, newsize, oldsize );
    f548:	e1a01007 	mov	r1, r7
    f54c:	e1a02006 	mov	r2, r6
    f550:	e28d3004 	add	r3, sp, #4	; 0x4
    f554:	eb0005a6 	bl	10bf4 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi>
    f558:	e1a04000 	mov	r4, r0
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f55c:	e5953000 	ldr	r3, [r5]
    f560:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f564:	15850000 	strne	r0, [r5]
    f568:	0a000004 	beq	f580 <realloc+0x6c>

    if ( NULL == newptr ) {
    f56c:	e3540000 	cmp	r4, #0	; 0x0
    f570:	0a000004 	beq	f588 <realloc+0x74>
        CYG_ASSERT( oldsize != 0,
                    "resize_alloc() couldn't determine allocation size!" );

        newptr = malloc( size );
        
        if ( NULL != newptr ) {
    f574:	e1a00004 	mov	r0, r4
        }
    }
    
    CYG_REPORT_RETVAL( newptr );
    return newptr;
} // realloc()
    f578:	e28dd00c 	add	sp, sp, #12	; 0xc
    f57c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    f580:	ebffd925 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f584:	eafffff8 	b	f56c <realloc+0x58>
        // just have to allocate new space instead, and later copy it
        
        CYG_ASSERT( oldsize != 0,
                    "resize_alloc() couldn't determine allocation size!" );

        newptr = malloc( size );
    f588:	e1a00006 	mov	r0, r6
    f58c:	ebffff7e 	bl	f38c <malloc>
        
        if ( NULL != newptr ) {
    f590:	e2505000 	subs	r5, r0, #0	; 0x0
    f594:	0afffff6 	beq	f574 <realloc+0x60>
            memcpy( newptr, ptr, size < (size_t) oldsize ? size
                    : (size_t) oldsize );
    f598:	e59d2004 	ldr	r2, [sp, #4]
    f59c:	e1a01007 	mov	r1, r7
    f5a0:	e1560002 	cmp	r6, r2
    f5a4:	31a02006 	movcc	r2, r6
    f5a8:	ebfff9ef 	bl	dd6c <_memcpy>
            free( ptr );
    f5ac:	e1a00007 	mov	r0, r7
    f5b0:	ebffff2e 	bl	f270 <free>
    f5b4:	e1a00005 	mov	r0, r5
    f5b8:	eaffffee 	b	f578 <realloc+0x64>

    CYG_REPORT_FUNCARG2( "ptr=%08x, size=%d", ptr, size );

    // if pointer is NULL, we must malloc it
    if ( ptr == NULL ) {
        ptr = malloc( size );
    f5bc:	e1a00001 	mov	r0, r1
    f5c0:	ebffff71 	bl	f38c <malloc>
    f5c4:	eaffffeb 	b	f578 <realloc+0x64>

    CYG_CHECK_DATA_PTR( ptr, "realloc() passed a bogus pointer!" );

    // if size is 0, we must free it
    if (size == 0) {
        free(ptr);
    f5c8:	ebffff28 	bl	f270 <free>
    f5cc:	e1a00006 	mov	r0, r6
    f5d0:	eaffffe8 	b	f578 <realloc+0x64>
    f5d4:	400007f4 	.word	0x400007f4
    f5d8:	400007c8 	.word	0x400007c8

0000f5dc <_Z41__static_initialization_and_destruction_0ii>:
#endif

Cyg_Mempool_dlmalloc *cygmem_memalloc_heaps[ 2 ] = { 
    &cygmem_pool_heap1,
    NULL
};
    f5dc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    f5e0:	e3500001 	cmp	r0, #1	; 0x1
    f5e4:	e24dd004 	sub	sp, sp, #4	; 0x4
    f5e8:	0a000007 	beq	f60c <_Z41__static_initialization_and_destruction_0ii+0x30>
    HAL_MEM_REAL_REGION_TOP( (cyg_uint8 *)CYGMEM_SECTION_heap1 + CYGMEM_SECTION_heap1_SIZE ) - (cyg_uint8 *)CYGMEM_SECTION_heap1 ) 
        ;

#else

Cyg_Mempool_dlmalloc CYGBLD_ATTRIB_INIT_BEFORE(CYG_INIT_MEMALLOC) cygmem_pool_heap1 ( (cyg_uint8 *)CYGMEM_SECTION_heap1 , CYGMEM_SECTION_heap1_SIZE ) ;
    f5ec:	e3500000 	cmp	r0, #0	; 0x0
    f5f0:	1a000003 	bne	f604 <_Z41__static_initialization_and_destruction_0ii+0x28>
    f5f4:	e3a03c4d 	mov	r3, #19712	; 0x4d00
    f5f8:	e28330bc 	add	r3, r3, #188	; 0xbc
    f5fc:	e1510003 	cmp	r1, r3
    f600:	0a00000f 	beq	f644 <_Z41__static_initialization_and_destruction_0ii+0x68>
#endif

Cyg_Mempool_dlmalloc *cygmem_memalloc_heaps[ 2 ] = { 
    &cygmem_pool_heap1,
    NULL
};
    f604:	e28dd004 	add	sp, sp, #4	; 0x4
    f608:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    f60c:	e3a03c4d 	mov	r3, #19712	; 0x4d00
    f610:	e28330bc 	add	r3, r3, #188	; 0xbc
    f614:	e1510003 	cmp	r1, r3
    f618:	1afffff9 	bne	f604 <_Z41__static_initialization_and_destruction_0ii+0x28>
template <class T>
Cyg_Mempolt2<T>::Cyg_Mempolt2(
    cyg_uint8 *base,
    cyg_int32 size,
    CYG_ADDRWORD arg_thru)              // Constructor
    : pool( base, size, arg_thru )
    f61c:	e59f10d0 	ldr	r1, [pc, #208]	; f6f4 <_Z41__static_initialization_and_destruction_0ii+0x118>
    f620:	e59f40d0 	ldr	r4, [pc, #208]	; f6f8 <_Z41__static_initialization_and_destruction_0ii+0x11c>
    f624:	e2612101 	rsb	r2, r1, #1073741824	; 0x40000000
    f628:	e3a03000 	mov	r3, #0	; 0x0
    f62c:	e2822801 	add	r2, r2, #65536	; 0x10000
    f630:	e1a00004 	mov	r0, r4
    f634:	eb000331 	bl	10300 <_ZN35Cyg_Mempool_dlmalloc_ImplementationC1EPhij>
    f638:	e3a03000 	mov	r3, #0	; 0x0
    f63c:	e5843410 	str	r3, [r4, #1040]
    f640:	eaffffef 	b	f604 <_Z41__static_initialization_and_destruction_0ii+0x28>
    
    // Increment the scheduler lock, possibly taking it from zero to
    // one.
    static void inc_sched_lock()
    {
        sched_lock++;
    f644:	e59f70b0 	ldr	r7, [pc, #176]	; f6fc <_Z41__static_initialization_and_destruction_0ii+0x120>
    f648:	e5973000 	ldr	r3, [r7]
    f64c:	e2833001 	add	r3, r3, #1	; 0x1
    f650:	e5873000 	str	r3, [r7]
Cyg_Mempolt2<T>::~Cyg_Mempolt2()  // destructor
{
    // Prevent preemption
    Cyg_Scheduler::lock();
            
    while ( ! queue.empty() ) {
    f654:	e59f609c 	ldr	r6, [pc, #156]	; f6f8 <_Z41__static_initialization_and_destruction_0ii+0x11c>
    f658:	e5963410 	ldr	r3, [r6, #1040]
    f65c:	e3530000 	cmp	r3, #0	; 0x0
    f660:	0a000009 	beq	f68c <_Z41__static_initialization_and_destruction_0ii+0xb0>

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    f664:	e1a05000 	mov	r5, r0
    wake_reason = reason;
    f668:	e3a04005 	mov	r4, #5	; 0x5

// -------------------------------------------------------------------------

inline Cyg_Thread *Cyg_ThreadQueue::dequeue()
{
    return Cyg_ThreadQueue_Implementation::dequeue();
    f66c:	e59f008c 	ldr	r0, [pc, #140]	; f700 <_Z41__static_initialization_and_destruction_0ii+0x124>
    f670:	ebffd790 	bl	54b8 <_ZN30Cyg_ThreadQueue_Implementation7dequeueEv>
// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    wake_reason = reason;
    f674:	e5c04081 	strb	r4, [r0, #129]

// -------------------------------------------------------------------------

inline void Cyg_Thread::set_wake_reason( cyg_reason reason )
{
    sleep_reason = NONE;
    f678:	e5c05080 	strb	r5, [r0, #128]
        Cyg_Thread *thread = queue.dequeue();
        thread->set_wake_reason( Cyg_Thread::DESTRUCT );
        thread->wake();
    f67c:	ebffd2e2 	bl	420c <_ZN10Cyg_Thread4wakeEv>
Cyg_Mempolt2<T>::~Cyg_Mempolt2()  // destructor
{
    // Prevent preemption
    Cyg_Scheduler::lock();
            
    while ( ! queue.empty() ) {
    f680:	e5963410 	ldr	r3, [r6, #1040]
    f684:	e3530000 	cmp	r3, #0	; 0x0
    f688:	1afffff7 	bne	f66c <_Z41__static_initialization_and_destruction_0ii+0x90>
        sched_lock = new_lock;
    };

    static cyg_ucount32 get_sched_lock()
    {
        return sched_lock;
    f68c:	e5973000 	ldr	r3, [r7]
    f690:	e2530001 	subs	r0, r3, #1	; 0x1
    // lock and the new value must be non-zero.
    static void set_sched_lock(cyg_uint32 new_lock)
    {
        CYG_ASSERT( new_lock > 0, "New scheduler lock value == 0");
        CYG_ASSERT( sched_lock > 0, "Scheduler lock == 0");
        sched_lock = new_lock;
    f694:	159f3060 	ldrne	r3, [pc, #96]	; f6fc <_Z41__static_initialization_and_destruction_0ii+0x120>
    f698:	15830000 	strne	r0, [r3]
    f69c:	0a000012 	beq	f6ec <_Z41__static_initialization_and_destruction_0ii+0x110>
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    f6a0:	e5961410 	ldr	r1, [r6, #1040]
    f6a4:	e3510000 	cmp	r1, #0	; 0x0
    f6a8:	e59fc048 	ldr	ip, [pc, #72]	; f6f8 <_Z41__static_initialization_and_destruction_0ii+0x11c>
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    f6ac:	e3a04000 	mov	r4, #0	; 0x0
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    f6b0:	0affffd3 	beq	f604 <_Z41__static_initialization_and_destruction_0ii+0x28>
    {
        Cyg_DNode *node = head;
        if( node != NULL )
        {
            // There is a node available
            Cyg_DNode *next = node->next;
    f6b4:	e5910000 	ldr	r0, [r1]
            if( next == node )
    f6b8:	e1500001 	cmp	r0, r1

    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
    f6bc:	15913004 	ldrne	r3, [r1, #4]
    f6c0:	15803004 	strne	r3, [r0, #4]
        prev->next = next;
    f6c4:	15912004 	ldrne	r2, [r1, #4]
            // There is a node available
            Cyg_DNode *next = node->next;
            if( next == node )
            {
                // Only node on list
                head = NULL;
    f6c8:	058c4410 	streq	r4, [ip, #1040]
    // Unlink this node from it's list. It is safe to apply this to an
    // already unlinked node.
    void unlink()
    {
        next->prev = prev;
        prev->next = next;
    f6cc:	15820000 	strne	r0, [r2]
        next = prev = this;
    f6d0:	15811004 	strne	r1, [r1, #4]
    f6d4:	15811000 	strne	r1, [r1]
            }
            else
            {
                // remove head node and move head to next.
                node->unlink();
                head = next;
    f6d8:	158c0410 	strne	r0, [ip, #1040]
        else list_node->insert( node );
    };
    
    ~Cyg_CList()
    {
        while( head != NULL )
    f6dc:	e5961410 	ldr	r1, [r6, #1040]
    f6e0:	e3510000 	cmp	r1, #0	; 0x0
    f6e4:	1afffff2 	bne	f6b4 <_Z41__static_initialization_and_destruction_0ii+0xd8>
    f6e8:	eaffffc5 	b	f604 <_Z41__static_initialization_and_destruction_0ii+0x28>
    f6ec:	ebffd8ca 	bl	5a1c <_ZN13Cyg_Scheduler12unlock_innerEj>
    f6f0:	eaffffea 	b	f6a0 <_Z41__static_initialization_and_destruction_0ii+0xc4>
    f6f4:	40004c58 	.word	0x40004c58
    f6f8:	400046f8 	.word	0x400046f8
    f6fc:	400007c8 	.word	0x400007c8
    f700:	40004b08 	.word	0x40004b08

0000f704 <_GLOBAL__D.19900_cygmem_pool_heap1>:
    f704:	e3a01c4d 	mov	r1, #19712	; 0x4d00
    f708:	e28110bc 	add	r1, r1, #188	; 0xbc
    f70c:	e3a00000 	mov	r0, #0	; 0x0
    f710:	eaffffb1 	b	f5dc <_Z41__static_initialization_and_destruction_0ii>

0000f714 <_GLOBAL__I.19900_cygmem_pool_heap1>:
    f714:	e3a01c4d 	mov	r1, #19712	; 0x4d00
    f718:	e28110bc 	add	r1, r1, #188	; 0xbc
    f71c:	e3a00001 	mov	r0, #1	; 0x1
    f720:	eaffffad 	b	f5dc <_Z41__static_initialization_and_destruction_0ii>

0000f724 <cyg_libc_invoke_main>:
#endif

// FUNCTIONS

externC void
cyg_libc_invoke_main( CYG_ADDRWORD )
    f724:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    // finish invoking constructors that weren't called by default
    cyg_hal_invoke_constructors();
#endif

    // argv[argc] must be NULL according to the ISO C standard 5.1.2.2.1
    char *temp_argv[] = CYGDAT_LIBC_ARGUMENTS ; 
    f728:	e59f2018 	ldr	r2, [pc, #24]	; f748 <cyg_libc_invoke_main+0x24>
    f72c:	e8920003 	ldm	r2, {r0, r1}
#endif

// FUNCTIONS

externC void
cyg_libc_invoke_main( CYG_ADDRWORD )
    f730:	e24dd00c 	sub	sp, sp, #12	; 0xc
    // finish invoking constructors that weren't called by default
    cyg_hal_invoke_constructors();
#endif

    // argv[argc] must be NULL according to the ISO C standard 5.1.2.2.1
    char *temp_argv[] = CYGDAT_LIBC_ARGUMENTS ; 
    f734:	e88d0003 	stm	sp, {r0, r1}
    int rc;
    
    rc = main( (sizeof(temp_argv)/sizeof(char *)) - 1, &temp_argv[0] );
    f738:	e1a0100d 	mov	r1, sp
    f73c:	e3a00001 	mov	r0, #1	; 0x1
    f740:	ebffc39f 	bl	5c4 <main>
#ifdef CYGINT_ISO_PTHREAD_IMPL
    // It is up to pthread_exit() to call exit() if needed
    pthread_exit( (void *)rc );
    CYG_FAIL( "pthread_exit() returned!!!" );
#else
    exit(rc);
    f744:	eb000611 	bl	10f90 <exit>
    f748:	00013188 	.word	0x00013188

0000f74c <cyg_libc_stdio_flush_all_but>:

// FUNCTIONS

// flush all but one stream
externC Cyg_ErrNo
cyg_libc_stdio_flush_all_but( Cyg_StdioStream *not_this_stream )
    f74c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
    cyg_bool files_flushed[FOPEN_MAX] = { false }; // sets all to 0
    f750:	e3a03000 	mov	r3, #0	; 0x0

// FUNCTIONS

// flush all but one stream
externC Cyg_ErrNo
cyg_libc_stdio_flush_all_but( Cyg_StdioStream *not_this_stream )
    f754:	e24dd02c 	sub	sp, sp, #44	; 0x2c
{
    cyg_bool files_flushed[FOPEN_MAX] = { false }; // sets all to 0
    f758:	e58d3008 	str	r3, [sp, #8]
    f75c:	e58d300c 	str	r3, [sp, #12]
    f760:	e58d3010 	str	r3, [sp, #16]
    f764:	e58d3014 	str	r3, [sp, #20]
    f768:	e58d3018 	str	r3, [sp, #24]
    f76c:	e58d301c 	str	r3, [sp, #28]
    f770:	e58d3020 	str	r3, [sp, #32]
    f774:	e58d3024 	str	r3, [sp, #36]
    f778:	e58d3004 	str	r3, [sp, #4]
Cyg_libc_stdio_files::get_file_stream( fd_t fd )
{
    CYG_PRECONDITION( (fd < FOPEN_MAX),
                  "Attempt to open larger file descriptor than FOPEN_MAX!" );

    return files[fd];
    f77c:	e59fb140 	ldr	fp, [pc, #320]	; f8c4 <cyg_libc_stdio_flush_all_but+0x178>
    f780:	e1a0a003 	mov	sl, r3

// FUNCTIONS

// flush all but one stream
externC Cyg_ErrNo
cyg_libc_stdio_flush_all_but( Cyg_StdioStream *not_this_stream )
    f784:	e1a09000 	mov	r9, r0
{
    cyg_bool files_flushed[FOPEN_MAX] = { false }; // sets all to 0
    f788:	e1a07003 	mov	r7, r3
    f78c:	e1a04003 	mov	r4, r3
    Cyg_StdioStream *stream;

    do {
        loop_again = false;

        for (i=0; (i<FOPEN_MAX) && !err; i++) {
    f790:	e2743001 	rsbs	r3, r4, #1	; 0x1
    f794:	33a03000 	movcc	r3, #0	; 0x0
    f798:	e3570007 	cmp	r7, #7	; 0x7
    f79c:	83a02000 	movhi	r2, #0	; 0x0
    f7a0:	92032001 	andls	r2, r3, #1	; 0x1
    f7a4:	e3520000 	cmp	r2, #0	; 0x0
    f7a8:	0a000033 	beq	f87c <cyg_libc_stdio_flush_all_but+0x130>
            if (files_flushed[i] == false) {
    f7ac:	e1a08107 	lsl	r8, r7, #2
    f7b0:	e28d2028 	add	r2, sp, #40	; 0x28
    f7b4:	e0825008 	add	r5, r2, r8
    f7b8:	e5156020 	ldr	r6, [r5, #-32]
    f7bc:	e3560000 	cmp	r6, #0	; 0x0
    f7c0:	13a04000 	movne	r4, #0	; 0x0
    f7c4:	1a000024 	bne	f85c <cyg_libc_stdio_flush_all_but+0x110>

inline cyg_bool
Cyg_libc_stdio_files::lock(void)
{
# ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return files_lock.lock();
    f7c8:	e59f00f8 	ldr	r0, [pc, #248]	; f8c8 <cyg_libc_stdio_flush_all_but+0x17c>
    f7cc:	ebffdde0 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
                // Don't let the files table change e.g. by closing the file.
                if ( !Cyg_libc_stdio_files::lock() ) {
    f7d0:	e3500000 	cmp	r0, #0	; 0x0
    f7d4:	0a000036 	beq	f8b4 <cyg_libc_stdio_flush_all_but+0x168>
Cyg_libc_stdio_files::get_file_stream( fd_t fd )
{
    CYG_PRECONDITION( (fd < FOPEN_MAX),
                  "Attempt to open larger file descriptor than FOPEN_MAX!" );

    return files[fd];
    f7d8:	e79b4107 	ldr	r4, [fp, r7, lsl #2]
                    err = EINTR;
                    break;
                }
                stream = Cyg_libc_stdio_files::get_file_stream(i);
                
                if ((stream == NULL) || (stream == not_this_stream)) {
    f7dc:	e1590004 	cmp	r9, r4
    f7e0:	13540000 	cmpne	r4, #0	; 0x0
                    // if it isn't a valid stream, set its entry in the
                    // list of files flushed since we don't want to
                    // flush it
                    // Ditto if its the one we're meant to miss
                    
                    files_flushed[i] = true;
    f7e4:	03a03001 	moveq	r3, #1	; 0x1
                    err = EINTR;
                    break;
                }
                stream = Cyg_libc_stdio_files::get_file_stream(i);
                
                if ((stream == NULL) || (stream == not_this_stream)) {
    f7e8:	13a00000 	movne	r0, #0	; 0x0
    f7ec:	03a00001 	moveq	r0, #1	; 0x1
                    // if it isn't a valid stream, set its entry in the
                    // list of files flushed since we don't want to
                    // flush it
                    // Ditto if its the one we're meant to miss
                    
                    files_flushed[i] = true;
    f7f0:	05053020 	streq	r3, [r5, #-32]
    f7f4:	01a04006 	moveq	r4, r6
                    err = EINTR;
                    break;
                }
                stream = Cyg_libc_stdio_files::get_file_stream(i);
                
                if ((stream == NULL) || (stream == not_this_stream)) {
    f7f8:	0a000015 	beq	f854 <cyg_libc_stdio_flush_all_but+0x108>
                } // if
                else {
                    // valid stream
#ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
                    // only buffers which we've written to need flushing
                    if ( !stream->flags.last_buffer_op_was_read)
    f7fc:	e5d43028 	ldrb	r3, [r4, #40]
    f800:	e1b033a3 	lsrs	r3, r3, #7
    f804:	11a04000 	movne	r4, r0
    f808:	1a000011 	bne	f854 <cyg_libc_stdio_flush_all_but+0x108>
                        // everything is flushed that can be flushed.
                        // The second time through we should just wait
                        // in case some other lowerpri thread has locked the
                        // stream, otherwise we will spin needlessly and
                        // never let the lower pri thread run!
                        if ( (looped && stream->lock_me()) || 
    f80c:	e59d2004 	ldr	r2, [sp, #4]
    f810:	e3520000 	cmp	r2, #0	; 0x0
    f814:	02845030 	addeq	r5, r4, #48	; 0x30
    f818:	0a00001d 	beq	f894 <cyg_libc_stdio_flush_all_but+0x148>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    f81c:	e2845030 	add	r5, r4, #48	; 0x30
    f820:	e1a00005 	mov	r0, r5
    f824:	ebffddca 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
    f828:	e3500000 	cmp	r0, #0	; 0x0
    f82c:	0a000018 	beq	f894 <cyg_libc_stdio_flush_all_but+0x148>
                             stream->trylock_me() ) {
                            err = stream->flush_output_unlocked();
    f830:	e1a00004 	mov	r0, r4
    f834:	ebffe052 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>
    f838:	e1a04000 	mov	r4, r0
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    f83c:	e1a00005 	mov	r0, r5
    f840:	ebffdebb 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
                            stream->unlock_me();
                            files_flushed[i] = true;
    f844:	e28d2028 	add	r2, sp, #40	; 0x28
    f848:	e0823008 	add	r3, r2, r8
    f84c:	e3a02001 	mov	r2, #1	; 0x1
    f850:	e5032020 	str	r2, [r3, #-32]

inline void
Cyg_libc_stdio_files::unlock(void)
{
# ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    files_lock.unlock();
    f854:	e59f006c 	ldr	r0, [pc, #108]	; f8c8 <cyg_libc_stdio_flush_all_but+0x17c>
    f858:	ebffdeb5 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    Cyg_StdioStream *stream;

    do {
        loop_again = false;

        for (i=0; (i<FOPEN_MAX) && !err; i++) {
    f85c:	e2743001 	rsbs	r3, r4, #1	; 0x1
    f860:	33a03000 	movcc	r3, #0	; 0x0
    f864:	e2877001 	add	r7, r7, #1	; 0x1
    f868:	e3570007 	cmp	r7, #7	; 0x7
    f86c:	83a02000 	movhi	r2, #0	; 0x0
    f870:	92032001 	andls	r2, r3, #1	; 0x1
    f874:	e3520000 	cmp	r2, #0	; 0x0
    f878:	1affffcb 	bne	f7ac <cyg_libc_stdio_flush_all_but+0x60>
    cyg_bool loop_again, looped = false;
    cyg_ucount32 i;
    Cyg_ErrNo err=ENOERR;
    Cyg_StdioStream *stream;

    do {
    f87c:	e113000a 	tst	r3, sl
    f880:	0a00000c 	beq	f8b8 <cyg_libc_stdio_flush_all_but+0x16c>
    f884:	e1a0a002 	mov	sl, r2
    f888:	e1a07002 	mov	r7, r2
    f88c:	e1a04002 	mov	r4, r2
    f890:	eaffffbe 	b	f790 <cyg_libc_stdio_flush_all_but+0x44>
Cyg_StdioStream::trylock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.trylock();
    f894:	e1a00005 	mov	r0, r5
    f898:	ebffde0e 	bl	70d8 <_ZN9Cyg_Mutex7trylockEv>
                        // everything is flushed that can be flushed.
                        // The second time through we should just wait
                        // in case some other lowerpri thread has locked the
                        // stream, otherwise we will spin needlessly and
                        // never let the lower pri thread run!
                        if ( (looped && stream->lock_me()) || 
    f89c:	e3500000 	cmp	r0, #0	; 0x0
    f8a0:	03a0a001 	moveq	sl, #1	; 0x1
    f8a4:	01a04000 	moveq	r4, r0
    f8a8:	058da004 	streq	sl, [sp, #4]
    f8ac:	0affffe8 	beq	f854 <cyg_libc_stdio_flush_all_but+0x108>
    f8b0:	eaffffde 	b	f830 <cyg_libc_stdio_flush_all_but+0xe4>
    cyg_bool loop_again, looped = false;
    cyg_ucount32 i;
    Cyg_ErrNo err=ENOERR;
    Cyg_StdioStream *stream;

    do {
    f8b4:	e3a04004 	mov	r4, #4	; 0x4
        } // for
    } // do
    while(loop_again && !err);
    
    return err;
} // cyg_libc_stdio_flush_all_but()
    f8b8:	e1a00004 	mov	r0, r4
    f8bc:	e28dd02c 	add	sp, sp, #44	; 0x2c
    f8c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f8c4:	40004b94 	.word	0x40004b94
    f8c8:	40004bb4 	.word	0x40004bb4

0000f8cc <fflush>:

externC int
fflush( FILE *stream ) __THROW
    f8cc:	e92d4030 	push	{r4, r5, lr}
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;

    if (stream == NULL) {  // tells us to flush ALL streams
    f8d0:	e2504000 	subs	r4, r0, #0	; 0x0
    
    return err;
} // cyg_libc_stdio_flush_all_but()

externC int
fflush( FILE *stream ) __THROW
    f8d4:	e24dd004 	sub	sp, sp, #4	; 0x4
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;

    if (stream == NULL) {  // tells us to flush ALL streams
    f8d8:	0a000013 	beq	f92c <fflush+0x60>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    f8dc:	e2845030 	add	r5, r4, #48	; 0x30
    f8e0:	e1a00005 	mov	r0, r5
    f8e4:	ebffdd9a 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
{
    Cyg_ErrNo err;

    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
    if (!lock_me())
    f8e8:	e3500000 	cmp	r0, #0	; 0x0
    f8ec:	03a04009 	moveq	r4, #9	; 0x9
    f8f0:	1a000004 	bne	f908 <fflush+0x3c>
    else {
        err = real_stream->flush_output();
    } // else

    if (err) {
        errno = err;
    f8f4:	ebfff81d 	bl	d970 <cyg_error_get_errno_p>
    f8f8:	e5804000 	str	r4, [r0]
    f8fc:	e3e00000 	mvn	r0, #0	; 0x0
        return EOF;
    } // if

    return 0;

} // fflush()
    f900:	e28dd004 	add	sp, sp, #4	; 0x4
    f904:	e8bd8030 	pop	{r4, r5, pc}
        return EBADF;  // assume file is now invalid
    
    err = flush_output_unlocked();
    f908:	e1a00004 	mov	r0, r4
    f90c:	ebffe01c 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>
    f910:	e1a04000 	mov	r4, r0
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    f914:	e1a00005 	mov	r0, r5
    f918:	ebffde85 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    } // if
    else {
        err = real_stream->flush_output();
    } // else

    if (err) {
    f91c:	e3540000 	cmp	r4, #0	; 0x0
    f920:	01a00004 	moveq	r0, r4
    f924:	0afffff5 	beq	f900 <fflush+0x34>
    f928:	eafffff1 	b	f8f4 <fflush+0x28>
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;

    if (stream == NULL) {  // tells us to flush ALL streams
        err = cyg_libc_stdio_flush_all_but(NULL);
    f92c:	ebffff86 	bl	f74c <cyg_libc_stdio_flush_all_but>
    f930:	e1a04000 	mov	r4, r0
    f934:	eafffff8 	b	f91c <fflush+0x50>

0000f938 <setvbuf>:

// FUNCTIONS


externC int
setvbuf( FILE *stream, char *buf, int mode, size_t size ) __THROW
    f938:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    f93c:	e2808030 	add	r8, r0, #48	; 0x30
    f940:	e1a05000 	mov	r5, r0
    f944:	e1a00008 	mov	r0, r8
    f948:	e1a07001 	mov	r7, r1
    f94c:	e1a06002 	mov	r6, r2
    f950:	e1a04003 	mov	r4, r3
    f954:	ebffdd7e 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>

    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    if ( !real_stream->lock_me() ) {
    f958:	e3500000 	cmp	r0, #0	; 0x0
    f95c:	1a000005 	bne	f978 <setvbuf+0x40>
        errno = EBADF;
    f960:	ebfff802 	bl	d970 <cyg_error_get_errno_p>
    f964:	e3a03009 	mov	r3, #9	; 0x9
    f968:	e5803000 	str	r3, [r0]
    f96c:	e1a04003 	mov	r4, r3
    errno = ENOSUPP;
    return ENOSUPP;

#endif // ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

} // setvbuf()
    f970:	e1a00004 	mov	r0, r4
    f974:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        return EBADF;
    } // if
#endif

    err = real_stream->io_buf.set_buffer( (cyg_ucount32) size, 
                                          (cyg_uint8 *) buf );
    f978:	e1a01004 	mov	r1, r4
    f97c:	e1a02007 	mov	r2, r7
    f980:	e2850010 	add	r0, r5, #16	; 0x10
    f984:	ebffe347 	bl	86a8 <_ZN21Cyg_StdioStreamBuffer10set_bufferEjPh>
    if (!err) {
    f988:	e2504000 	subs	r4, r0, #0	; 0x0
    f98c:	1a000006 	bne	f9ac <setvbuf+0x74>
        switch (mode) {
    f990:	e3760004 	cmn	r6, #4	; 0x4
    f994:	0a00001a 	beq	fa04 <setvbuf+0xcc>
    f998:	e3760002 	cmn	r6, #2	; 0x2
    f99c:	0a000011 	beq	f9e8 <setvbuf+0xb0>
    f9a0:	e3760008 	cmn	r6, #8	; 0x8
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    f9a4:	13a04016 	movne	r4, #22	; 0x16
    f9a8:	0a000005 	beq	f9c4 <setvbuf+0x8c>
    f9ac:	e1a00008 	mov	r0, r8
    f9b0:	ebffde5f 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    real_stream->unlock_me();
#endif
    
    if (err) {
        errno = err;
    f9b4:	ebfff7ed 	bl	d970 <cyg_error_get_errno_p>
    f9b8:	e5804000 	str	r4, [r0]
    errno = ENOSUPP;
    return ENOSUPP;

#endif // ifdef CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO

} // setvbuf()
    f9bc:	e1a00004 	mov	r0, r4
    f9c0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (!err) {
        switch (mode) {
        case _IONBF:
            CYG_ASSERT( (size == 0) && (buf == NULL),
                        "No buffering wanted but size/address specified!" );
            real_stream->flags.buffering = false;
    f9c4:	e5d53028 	ldrb	r3, [r5, #40]
    f9c8:	e3c33020 	bic	r3, r3, #32	; 0x20
    f9cc:	e5c53028 	strb	r3, [r5, #40]
            real_stream->flags.line_buffering = false;
    f9d0:	e5d52028 	ldrb	r2, [r5, #40]
    f9d4:	e3c22040 	bic	r2, r2, #64	; 0x40
    f9d8:	e5c52028 	strb	r2, [r5, #40]
    f9dc:	e1a00008 	mov	r0, r8
    f9e0:	ebffde53 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    f9e4:	eaffffe1 	b	f970 <setvbuf+0x38>
        case _IOLBF:
            real_stream->flags.buffering = true;
            real_stream->flags.line_buffering = true;
            break;
        case _IOFBF:
            real_stream->flags.buffering = true;
    f9e8:	e5d53028 	ldrb	r3, [r5, #40]
    f9ec:	e3833020 	orr	r3, r3, #32	; 0x20
    f9f0:	e5c53028 	strb	r3, [r5, #40]
            real_stream->flags.line_buffering = false;
    f9f4:	e5d52028 	ldrb	r2, [r5, #40]
    f9f8:	e3c22040 	bic	r2, r2, #64	; 0x40
    f9fc:	e5c52028 	strb	r2, [r5, #40]
    fa00:	eafffff5 	b	f9dc <setvbuf+0xa4>
                        "No buffering wanted but size/address specified!" );
            real_stream->flags.buffering = false;
            real_stream->flags.line_buffering = false;
            break;
        case _IOLBF:
            real_stream->flags.buffering = true;
    fa04:	e5d53028 	ldrb	r3, [r5, #40]
    fa08:	e3833020 	orr	r3, r3, #32	; 0x20
    fa0c:	e5c53028 	strb	r3, [r5, #40]
            real_stream->flags.line_buffering = true;
    fa10:	e5d52028 	ldrb	r2, [r5, #40]
    fa14:	e3822040 	orr	r2, r2, #64	; 0x40
    fa18:	e5c52028 	strb	r2, [r5, #40]
    fa1c:	eaffffee 	b	f9dc <setvbuf+0xa4>

0000fa20 <_Z41__static_initialization_and_destruction_0ii>:
static cyg_libc_dummy_stderr_init_class cyg_libc_dummy_stderr_init
                                             CYGBLD_ATTRIB_INIT_PRI(PRIO);

// and finally stderr itself
__externC Cyg_StdioStream * const stderr;
Cyg_StdioStream * const stderr=&cyg_libc_stdio_stderr;
    fa20:	e92d4070 	push	{r4, r5, r6, lr}
    fa24:	e3500001 	cmp	r0, #1	; 0x1
    fa28:	e24dd010 	sub	sp, sp, #16	; 0x10
    fa2c:	e1a06000 	mov	r6, r0
    fa30:	0a000007 	beq	fa54 <_Z41__static_initialization_and_destruction_0ii+0x34>
    }
};

// And here's an instance of the class just to make the code run
static cyg_libc_dummy_stderr_init_class cyg_libc_dummy_stderr_init
                                             CYGBLD_ATTRIB_INIT_PRI(PRIO);
    fa34:	e3500000 	cmp	r0, #0	; 0x0
    fa38:	1a000003 	bne	fa4c <_Z41__static_initialization_and_destruction_0ii+0x2c>
    fa3c:	e3a03cda 	mov	r3, #55808	; 0xda00
    fa40:	e28330c2 	add	r3, r3, #194	; 0xc2
    fa44:	e1510003 	cmp	r1, r3
    fa48:	0a000018 	beq	fab0 <_Z41__static_initialization_and_destruction_0ii+0x90>

// and finally stderr itself
__externC Cyg_StdioStream * const stderr;
Cyg_StdioStream * const stderr=&cyg_libc_stdio_stderr;
    fa4c:	e28dd010 	add	sp, sp, #16	; 0x10
    fa50:	e8bd8070 	pop	{r4, r5, r6, pc}
    fa54:	e3a03cda 	mov	r3, #55808	; 0xda00
    fa58:	e28330c2 	add	r3, r3, #194	; 0xc2
    fa5c:	e1510003 	cmp	r1, r3
    fa60:	1afffff9 	bne	fa4c <_Z41__static_initialization_and_destruction_0ii+0x2c>
Cyg_StdioStream
cyg_libc_stdio_stderr CYGBLD_ATTRIB_INIT_PRI(PRIO) = Cyg_StdioStream(
    Cyg_libc_stdio_find_filename(CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE,
                                 Cyg_StdioStream::CYG_STREAM_WRITE,
                                 false, false),
    Cyg_StdioStream::CYG_STREAM_WRITE, false, false, _IONBF, 0, NULL );
    fa64:	e3a02000 	mov	r2, #0	; 0x0
    fa68:	e1a03002 	mov	r3, r2
    fa6c:	e1a01000 	mov	r1, r0
    fa70:	e59f00b8 	ldr	r0, [pc, #184]	; fb30 <_Z41__static_initialization_and_destruction_0ii+0x110>
    fa74:	eb0000a8 	bl	fd1c <Cyg_libc_stdio_find_filename>
    fa78:	e59f50b4 	ldr	r5, [pc, #180]	; fb34 <_Z41__static_initialization_and_destruction_0ii+0x114>
    fa7c:	e3a04000 	mov	r4, #0	; 0x0
    fa80:	e1a01000 	mov	r1, r0
    fa84:	e1a03004 	mov	r3, r4
    fa88:	e3e0c007 	mvn	ip, #7	; 0x7
    fa8c:	e1a02006 	mov	r2, r6
    fa90:	e1a00005 	mov	r0, r5
    fa94:	e88d1010 	stm	sp, {r4, ip}
    fa98:	e58d4008 	str	r4, [sp, #8]
    fa9c:	e58d400c 	str	r4, [sp, #12]
    faa0:	ebffe292 	bl	84f0 <_ZN15Cyg_StdioStreamC1EPvNS_8OpenModeEiiijPh>
Cyg_libc_stdio_files::set_file_stream( fd_t fd, Cyg_StdioStream *stream )
{
    CYG_PRECONDITION( (fd < FOPEN_MAX),
                  "Attempt to set larger file descriptor than FOPEN_MAX!" );

    files[fd] = stream;
    faa4:	e59f308c 	ldr	r3, [pc, #140]	; fb38 <_Z41__static_initialization_and_destruction_0ii+0x118>
    faa8:	e5835008 	str	r5, [r3, #8]
    faac:	eaffffe6 	b	fa4c <_Z41__static_initialization_and_destruction_0ii+0x2c>
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    fab0:	e59f407c 	ldr	r4, [pc, #124]	; fb34 <_Z41__static_initialization_and_destruction_0ii+0x114>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    fab4:	e5943008 	ldr	r3, [r4, #8]
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    fab8:	e59f207c 	ldr	r2, [pc, #124]	; fb3c <_Z41__static_initialization_and_destruction_0ii+0x11c>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    fabc:	e3530000 	cmp	r3, #0	; 0x0
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    fac0:	e5842000 	str	r2, [r4]
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    fac4:	0a00000b 	beq	faf8 <_Z41__static_initialization_and_destruction_0ii+0xd8>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    fac8:	e2840030 	add	r0, r4, #48	; 0x30
    facc:	ebffdd20 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline Cyg_ErrNo
Cyg_StdioStream::close()
{
    Cyg_ErrNo err = ENOERR;
    
    if (!lock_me())
    fad0:	e3500000 	cmp	r0, #0	; 0x0
    fad4:	0a000007 	beq	faf8 <_Z41__static_initialization_and_destruction_0ii+0xd8>
        return EBADF;

    if( my_device != CYG_STDIO_HANDLE_NULL )
    fad8:	e5943008 	ldr	r3, [r4, #8]
    fadc:	e3530000 	cmp	r3, #0	; 0x0
    fae0:	0a000002 	beq	faf0 <_Z41__static_initialization_and_destruction_0ii+0xd0>
    {
        flush_output_unlocked();
    fae4:	e1a00004 	mov	r0, r4
    fae8:	ebffdfa5 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        err = cyg_stdio_close( my_device );
    
        if( err == ENOERR )
            my_device = CYG_STDIO_HANDLE_NULL;
    faec:	e5846008 	str	r6, [r4, #8]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    faf0:	e59f0048 	ldr	r0, [pc, #72]	; fb40 <_Z41__static_initialization_and_destruction_0ii+0x120>
    faf4:	ebffde0e 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        close();
    
#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0xbadbad;
#endif
} // Cyg_StdioStream destructor
    faf8:	e59f0040 	ldr	r0, [pc, #64]	; fb40 <_Z41__static_initialization_and_destruction_0ii+0x120>
    fafc:	ebffdcd4 	bl	6e54 <_ZN9Cyg_MutexD1Ev>

inline
Cyg_StdioStreamBuffer::~Cyg_StdioStreamBuffer()
{
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
    if ((buffer_bottom != NULL) && call_free)
    fb00:	e5940014 	ldr	r0, [r4, #20]
    fb04:	e3500000 	cmp	r0, #0	; 0x0
    fb08:	0a000003 	beq	fb1c <_Z41__static_initialization_and_destruction_0ii+0xfc>
    fb0c:	e59f3020 	ldr	r3, [pc, #32]	; fb34 <_Z41__static_initialization_and_destruction_0ii+0x114>
    fb10:	e5932010 	ldr	r2, [r3, #16]
    fb14:	e3520000 	cmp	r2, #0	; 0x0
    fb18:	1a000002 	bne	fb28 <_Z41__static_initialization_and_destruction_0ii+0x108>
    fb1c:	e59f3020 	ldr	r3, [pc, #32]	; fb44 <_Z41__static_initialization_and_destruction_0ii+0x124>
    fb20:	e5843000 	str	r3, [r4]
    fb24:	eaffffc8 	b	fa4c <_Z41__static_initialization_and_destruction_0ii+0x2c>
        free( buffer_bottom );
    fb28:	ebfffdd0 	bl	f270 <free>
    fb2c:	eafffffa 	b	fb1c <_Z41__static_initialization_and_destruction_0ii+0xfc>
    fb30:	00012954 	.word	0x00012954
    fb34:	40004b0c 	.word	0x40004b0c
    fb38:	40004b94 	.word	0x40004b94
    fb3c:	00012a78 	.word	0x00012a78
    fb40:	40004b3c 	.word	0x40004b3c
    fb44:	00012a90 	.word	0x00012a90

0000fb48 <_GLOBAL__D.56002_cyg_libc_stdio_stderr>:
static cyg_libc_dummy_stderr_init_class cyg_libc_dummy_stderr_init
                                             CYGBLD_ATTRIB_INIT_PRI(PRIO);

// and finally stderr itself
__externC Cyg_StdioStream * const stderr;
Cyg_StdioStream * const stderr=&cyg_libc_stdio_stderr;
    fb48:	e3a01cda 	mov	r1, #55808	; 0xda00
    fb4c:	e28110c2 	add	r1, r1, #194	; 0xc2
    fb50:	e3a00000 	mov	r0, #0	; 0x0
    fb54:	eaffffb1 	b	fa20 <_Z41__static_initialization_and_destruction_0ii>

0000fb58 <_GLOBAL__I.56002_cyg_libc_stdio_stderr>:
    fb58:	e3a01cda 	mov	r1, #55808	; 0xda00
    fb5c:	e28110c2 	add	r1, r1, #194	; 0xc2
    fb60:	e3a00001 	mov	r0, #1	; 0x1
    fb64:	eaffffad 	b	fa20 <_Z41__static_initialization_and_destruction_0ii>

0000fb68 <_Z41__static_initialization_and_destruction_0ii>:
static cyg_libc_dummy_stdin_init_class cyg_libc_dummy_stdin_init
                                         CYGBLD_ATTRIB_INIT_PRI(PRIO);

// and finally stdin itself
__externC Cyg_StdioStream * const stdin;
Cyg_StdioStream * const stdin=&cyg_libc_stdio_stdin;
    fb68:	e92d4070 	push	{r4, r5, r6, lr}
    fb6c:	e3500001 	cmp	r0, #1	; 0x1
    fb70:	e24dd010 	sub	sp, sp, #16	; 0x10
    fb74:	e1a04000 	mov	r4, r0
    fb78:	0a000007 	beq	fb9c <_Z41__static_initialization_and_destruction_0ii+0x34>
    }
};

// And here's an instance of the class just to make the code run
static cyg_libc_dummy_stdin_init_class cyg_libc_dummy_stdin_init
                                         CYGBLD_ATTRIB_INIT_PRI(PRIO);
    fb7c:	e3500000 	cmp	r0, #0	; 0x0
    fb80:	1a000003 	bne	fb94 <_Z41__static_initialization_and_destruction_0ii+0x2c>
    fb84:	e3a03cda 	mov	r3, #55808	; 0xda00
    fb88:	e28330c0 	add	r3, r3, #192	; 0xc0
    fb8c:	e1510003 	cmp	r1, r3
    fb90:	0a00001a 	beq	fc00 <_Z41__static_initialization_and_destruction_0ii+0x98>

// and finally stdin itself
__externC Cyg_StdioStream * const stdin;
Cyg_StdioStream * const stdin=&cyg_libc_stdio_stdin;
    fb94:	e28dd010 	add	sp, sp, #16	; 0x10
    fb98:	e8bd8070 	pop	{r4, r5, r6, pc}
    fb9c:	e3a03cda 	mov	r3, #55808	; 0xda00
    fba0:	e28330c0 	add	r3, r3, #192	; 0xc0
    fba4:	e1510003 	cmp	r1, r3
    fba8:	1afffff9 	bne	fb94 <_Z41__static_initialization_and_destruction_0ii+0x2c>

Cyg_StdioStream
cyg_libc_stdio_stdin CYGBLD_ATTRIB_INIT_PRI(PRIO) = Cyg_StdioStream( 
    Cyg_libc_stdio_find_filename(CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE,
                                 Cyg_StdioStream::CYG_STREAM_READ, false, false),
    Cyg_StdioStream::CYG_STREAM_READ, false, false, _IOLBF );
    fbac:	e3a01000 	mov	r1, #0	; 0x0
    fbb0:	e1a02001 	mov	r2, r1
    fbb4:	e1a03001 	mov	r3, r1
    fbb8:	e59f00c0 	ldr	r0, [pc, #192]	; fc80 <_Z41__static_initialization_and_destruction_0ii+0x118>
    fbbc:	eb000056 	bl	fd1c <Cyg_libc_stdio_find_filename>
    fbc0:	e59f60bc 	ldr	r6, [pc, #188]	; fc84 <_Z41__static_initialization_and_destruction_0ii+0x11c>
    fbc4:	e3a05000 	mov	r5, #0	; 0x0
    fbc8:	e1a01000 	mov	r1, r0
    fbcc:	e1a03005 	mov	r3, r5
    fbd0:	e3e0c003 	mvn	ip, #3	; 0x3
    fbd4:	e1a02005 	mov	r2, r5
    fbd8:	e1a00006 	mov	r0, r6
    fbdc:	e28440ff 	add	r4, r4, #255	; 0xff
    fbe0:	e58dc004 	str	ip, [sp, #4]
    fbe4:	e58d4008 	str	r4, [sp, #8]
    fbe8:	e58d5000 	str	r5, [sp]
    fbec:	e58d500c 	str	r5, [sp, #12]
    fbf0:	ebffe23e 	bl	84f0 <_ZN15Cyg_StdioStreamC1EPvNS_8OpenModeEiiijPh>
    fbf4:	e59f308c 	ldr	r3, [pc, #140]	; fc88 <_Z41__static_initialization_and_destruction_0ii+0x120>
    fbf8:	e5836000 	str	r6, [r3]
    fbfc:	eaffffe4 	b	fb94 <_Z41__static_initialization_and_destruction_0ii+0x2c>
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    fc00:	e59f507c 	ldr	r5, [pc, #124]	; fc84 <_Z41__static_initialization_and_destruction_0ii+0x11c>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    fc04:	e5953008 	ldr	r3, [r5, #8]
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    fc08:	e59f207c 	ldr	r2, [pc, #124]	; fc8c <_Z41__static_initialization_and_destruction_0ii+0x124>
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    fc0c:	e3530000 	cmp	r3, #0	; 0x0
    
    return err;
} // close()

inline
Cyg_StdioStream::~Cyg_StdioStream()
    fc10:	e5852000 	str	r2, [r5]
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );

    // Close the device if it has not already been closed.
    if( my_device != CYG_STDIO_HANDLE_NULL )
    fc14:	0a00000b 	beq	fc48 <_Z41__static_initialization_and_destruction_0ii+0xe0>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    fc18:	e2850030 	add	r0, r5, #48	; 0x30
    fc1c:	ebffdccc 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
inline Cyg_ErrNo
Cyg_StdioStream::close()
{
    Cyg_ErrNo err = ENOERR;
    
    if (!lock_me())
    fc20:	e3500000 	cmp	r0, #0	; 0x0
    fc24:	0a000007 	beq	fc48 <_Z41__static_initialization_and_destruction_0ii+0xe0>
        return EBADF;

    if( my_device != CYG_STDIO_HANDLE_NULL )
    fc28:	e5953008 	ldr	r3, [r5, #8]
    fc2c:	e3530000 	cmp	r3, #0	; 0x0
    fc30:	0a000002 	beq	fc40 <_Z41__static_initialization_and_destruction_0ii+0xd8>
    {
        flush_output_unlocked();
    fc34:	e1a00005 	mov	r0, r5
    fc38:	ebffdf51 	bl	7984 <_ZN15Cyg_StdioStream21flush_output_unlockedEv>

        err = cyg_stdio_close( my_device );
    
        if( err == ENOERR )
            my_device = CYG_STDIO_HANDLE_NULL;
    fc3c:	e5854008 	str	r4, [r5, #8]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    fc40:	e59f0048 	ldr	r0, [pc, #72]	; fc90 <_Z41__static_initialization_and_destruction_0ii+0x128>
    fc44:	ebffddba 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        close();
    
#ifdef CYGDBG_USE_ASSERTS
    magic_validity_word = 0xbadbad;
#endif
} // Cyg_StdioStream destructor
    fc48:	e59f0040 	ldr	r0, [pc, #64]	; fc90 <_Z41__static_initialization_and_destruction_0ii+0x128>
    fc4c:	ebffdc80 	bl	6e54 <_ZN9Cyg_MutexD1Ev>

inline
Cyg_StdioStreamBuffer::~Cyg_StdioStreamBuffer()
{
#ifdef CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
    if ((buffer_bottom != NULL) && call_free)
    fc50:	e5950014 	ldr	r0, [r5, #20]
    fc54:	e3500000 	cmp	r0, #0	; 0x0
    fc58:	0a000003 	beq	fc6c <_Z41__static_initialization_and_destruction_0ii+0x104>
    fc5c:	e59f3020 	ldr	r3, [pc, #32]	; fc84 <_Z41__static_initialization_and_destruction_0ii+0x11c>
    fc60:	e5932010 	ldr	r2, [r3, #16]
    fc64:	e3520000 	cmp	r2, #0	; 0x0
    fc68:	1a000002 	bne	fc78 <_Z41__static_initialization_and_destruction_0ii+0x110>
    fc6c:	e59f3020 	ldr	r3, [pc, #32]	; fc94 <_Z41__static_initialization_and_destruction_0ii+0x12c>
    fc70:	e5853000 	str	r3, [r5]
    fc74:	eaffffc6 	b	fb94 <_Z41__static_initialization_and_destruction_0ii+0x2c>
        free( buffer_bottom );
    fc78:	ebfffd7c 	bl	f270 <free>
    fc7c:	eafffffa 	b	fc6c <_Z41__static_initialization_and_destruction_0ii+0x104>
    fc80:	00012954 	.word	0x00012954
    fc84:	40004b50 	.word	0x40004b50
    fc88:	40004b94 	.word	0x40004b94
    fc8c:	00012a78 	.word	0x00012a78
    fc90:	40004b80 	.word	0x40004b80
    fc94:	00012a90 	.word	0x00012a90

0000fc98 <_GLOBAL__D.56000_cyg_libc_stdio_stdin>:
static cyg_libc_dummy_stdin_init_class cyg_libc_dummy_stdin_init
                                         CYGBLD_ATTRIB_INIT_PRI(PRIO);

// and finally stdin itself
__externC Cyg_StdioStream * const stdin;
Cyg_StdioStream * const stdin=&cyg_libc_stdio_stdin;
    fc98:	e3a01cda 	mov	r1, #55808	; 0xda00
    fc9c:	e28110c0 	add	r1, r1, #192	; 0xc0
    fca0:	e3a00000 	mov	r0, #0	; 0x0
    fca4:	eaffffaf 	b	fb68 <_Z41__static_initialization_and_destruction_0ii>

0000fca8 <_GLOBAL__I.56000_cyg_libc_stdio_stdin>:
    fca8:	e3a01cda 	mov	r1, #55808	; 0xda00
    fcac:	e28110c0 	add	r1, r1, #192	; 0xc0
    fcb0:	e3a00001 	mov	r0, #1	; 0x1
    fcb4:	eaffffab 	b	fb68 <_Z41__static_initialization_and_destruction_0ii>

0000fcb8 <_Z41__static_initialization_and_destruction_0ii>:

Cyg_StdioStream *Cyg_libc_stdio_files::files[FOPEN_MAX] = { NULL };

# ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
Cyg_Mutex Cyg_libc_stdio_files::files_lock 
    CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_LIBC);
    fcb8:	e3500001 	cmp	r0, #1	; 0x1
    fcbc:	0a000007 	beq	fce0 <_Z41__static_initialization_and_destruction_0ii+0x28>
    fcc0:	e3500000 	cmp	r0, #0	; 0x0
    fcc4:	112fff1e 	bxne	lr
    fcc8:	e3a03cda 	mov	r3, #55808	; 0xda00
    fccc:	e28330c0 	add	r3, r3, #192	; 0xc0
    fcd0:	e1510003 	cmp	r1, r3
    fcd4:	112fff1e 	bxne	lr
    fcd8:	e59f0018 	ldr	r0, [pc, #24]	; fcf8 <_Z41__static_initialization_and_destruction_0ii+0x40>
    fcdc:	eaffdc5c 	b	6e54 <_ZN9Cyg_MutexD1Ev>
    fce0:	e3a03cda 	mov	r3, #55808	; 0xda00
    fce4:	e28330c0 	add	r3, r3, #192	; 0xc0
    fce8:	e1510003 	cmp	r1, r3
    fcec:	112fff1e 	bxne	lr
    fcf0:	e59f0000 	ldr	r0, [pc, #0]	; fcf8 <_Z41__static_initialization_and_destruction_0ii+0x40>
    fcf4:	eaffdc2f 	b	6db8 <_ZN9Cyg_MutexC1Ev>
    fcf8:	40004bb4 	.word	0x40004bb4

0000fcfc <_GLOBAL__D.56000__ZN20Cyg_libc_stdio_files5filesE>:
    fcfc:	e3a01cda 	mov	r1, #55808	; 0xda00
    fd00:	e28110c0 	add	r1, r1, #192	; 0xc0
    fd04:	e3a00000 	mov	r0, #0	; 0x0
    fd08:	eaffffea 	b	fcb8 <_Z41__static_initialization_and_destruction_0ii>

0000fd0c <_GLOBAL__I.56000__ZN20Cyg_libc_stdio_files5filesE>:
    fd0c:	e3a01cda 	mov	r1, #55808	; 0xda00
    fd10:	e28110c0 	add	r1, r1, #192	; 0xc0
    fd14:	e3a00001 	mov	r0, #1	; 0x1
    fd18:	eaffffe6 	b	fcb8 <_Z41__static_initialization_and_destruction_0ii>

0000fd1c <Cyg_libc_stdio_find_filename>:

cyg_stdio_handle_t
Cyg_libc_stdio_find_filename( const char *filename,
                              const Cyg_StdioStream::OpenMode rw,
                              const cyg_bool binary,
                              const cyg_bool append )
    fd1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    fd20:	e24dd00c 	sub	sp, sp, #12	; 0xc
{
    cyg_stdio_handle_t dev = CYG_STDIO_HANDLE_NULL;
    fd24:	e28d1008 	add	r1, sp, #8	; 0x8
    fd28:	e3a03000 	mov	r3, #0	; 0x0
    fd2c:	e5213004 	str	r3, [r1, #-4]!
                                 const Cyg_StdioStream::OpenMode rw,
                                 const cyg_bool binary,
                                 const cyg_bool append,
                                 cyg_stdio_handle_t *dev)
{
    return cyg_io_lookup( filename, dev );
    fd30:	ebffc78d 	bl	1b6c <cyg_io_lookup>

    cyg_stdio_open(filename, rw, binary, append, &dev);
    
    return dev;
} // Cyg_libc_stdio_find_filename()
    fd34:	e59d0004 	ldr	r0, [sp, #4]
    fd38:	e28dd00c 	add	sp, sp, #12	; 0xc
    fd3c:	e8bd8000 	pop	{pc}

0000fd40 <ungetc>:
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;
    cyg_uint8 real_c;
    
    if (c == EOF)
    fd40:	e3700001 	cmn	r0, #1	; 0x1


// FUNCTIONS

externC int
ungetc( int c, FILE *stream ) __THROW
    fd44:	e92d4070 	push	{r4, r5, r6, lr}
    fd48:	e1a05000 	mov	r5, r0
    fd4c:	e1a04001 	mov	r4, r1
{
    Cyg_StdioStream *real_stream = (Cyg_StdioStream *)stream;
    Cyg_ErrNo err;
    cyg_uint8 real_c;
    
    if (c == EOF)
    fd50:	0a000019 	beq	fdbc <ungetc+0x7c>
Cyg_StdioStream::lock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    return stream_lock.lock();
    fd54:	e2816030 	add	r6, r1, #48	; 0x30
    fd58:	e1a00006 	mov	r0, r6
    fd5c:	ebffdc7c 	bl	6f54 <_ZN9Cyg_Mutex4lockEv>
Cyg_StdioStream::unread_byte( cyg_uint8 c )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGFUN_LIBC_STDIO_ungetc
    if (!lock_me())
    fd60:	e3500000 	cmp	r0, #0	; 0x0
        errno = err;
        return EOF;
    } // if
    
    
    return (int)real_c;
    fd64:	03a04009 	moveq	r4, #9	; 0x9
    fd68:	1a000003 	bne	fd7c <ungetc+0x3c>

    err = real_stream->unread_byte( real_c );

    if (err)
    {
        errno = err;
    fd6c:	ebfff6ff 	bl	d970 <cyg_error_get_errno_p>
    fd70:	e5804000 	str	r4, [r0]
    fd74:	e3e00000 	mvn	r0, #0	; 0x0
    } // if
    
    
    return (int)real_c;

} // ungetc()
    fd78:	e8bd8070 	pop	{r4, r5, r6, pc}
        return EBADF;  // assume file is now invalid

    if (flags.unread_char_buf_in_use) {
    fd7c:	e5d43028 	ldrb	r3, [r4, #40]
    fd80:	e3130010 	tst	r3, #16	; 0x10
    fd84:	1a00000e 	bne	fdc4 <ungetc+0x84>
        unlock_me();
        return ENOMEM;
    } // if

    flags.unread_char_buf_in_use = true;
    fd88:	e3833010 	orr	r3, r3, #16	; 0x10
    fd8c:	e5c43028 	strb	r3, [r4, #40]
    unread_char_buf = c;

    // can't be at EOF any more
    flags.at_eof = false;

    if (position)    // position is always 0 for certain devices
    fd90:	e594202c 	ldr	r2, [r4, #44]

    flags.unread_char_buf_in_use = true;
    unread_char_buf = c;

    // can't be at EOF any more
    flags.at_eof = false;
    fd94:	e5d43028 	ldrb	r3, [r4, #40]

    if (position)    // position is always 0 for certain devices
    fd98:	e3520000 	cmp	r2, #0	; 0x0

    flags.unread_char_buf_in_use = true;
    unread_char_buf = c;

    // can't be at EOF any more
    flags.at_eof = false;
    fd9c:	e3c33001 	bic	r3, r3, #1	; 0x1
    cyg_uint8 real_c;
    
    if (c == EOF)
        return EOF;

    real_c = (cyg_uint8) c;
    fda0:	e20550ff 	and	r5, r5, #255	; 0xff
    fda4:	e5c43028 	strb	r3, [r4, #40]

    if (position)    // position is always 0 for certain devices
        --position;
    fda8:	12423001 	subne	r3, r2, #1	; 0x1
        unlock_me();
        return ENOMEM;
    } // if

    flags.unread_char_buf_in_use = true;
    unread_char_buf = c;
    fdac:	e5c4500c 	strb	r5, [r4, #12]

    // can't be at EOF any more
    flags.at_eof = false;

    if (position)    // position is always 0 for certain devices
        --position;
    fdb0:	1584302c 	strne	r3, [r4, #44]
Cyg_StdioStream::unlock_me( void )
{
    CYG_ASSERTCLASS( this, "Stream object is not a valid stream!" );
    
#ifdef CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
    stream_lock.unlock();
    fdb4:	e1a00006 	mov	r0, r6
    fdb8:	ebffdd5d 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
        errno = err;
        return EOF;
    } // if
    
    
    return (int)real_c;
    fdbc:	e1a00005 	mov	r0, r5
    fdc0:	e8bd8070 	pop	{r4, r5, r6, pc}
    fdc4:	e1a00006 	mov	r0, r6
    fdc8:	ebffdd59 	bl	7334 <_ZN9Cyg_Mutex6unlockEv>
    fdcc:	e3a0400c 	mov	r4, #12	; 0xc
    fdd0:	eaffffe5 	b	fd6c <ungetc+0x2c>

0000fdd4 <cyg_hal_plf_serial_putc>:
                     CYGARC_HAL_LPC2XXX_REG_UxFCR_TX_FIFO_RESET);
}

void
cyg_hal_plf_serial_putc(void *__ch_data, char c)
{
    fdd4:	e5900000 	ldr	r0, [r0]
    fdd8:	e2802014 	add	r2, r0, #20	; 0x14
    cyg_uint8* base = ((channel_data_t*)__ch_data)->base;
    cyg_uint8 stat;
    CYGARC_HAL_SAVE_GP();

    do {
        HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    fddc:	e5923000 	ldr	r3, [r2]
    } while ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_THRE) == 0);
    fde0:	e3130020 	tst	r3, #32	; 0x20
    fde4:	0afffffc 	beq	fddc <cyg_hal_plf_serial_putc+0x8>

    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxTHR, c);
    fde8:	e5801000 	str	r1, [r0]

    CYGARC_HAL_RESTORE_GP();
}
    fdec:	e12fff1e 	bx	lr

0000fdf0 <cyg_hal_plf_serial_getc>:
    return true;
}

cyg_uint8
cyg_hal_plf_serial_getc(void* __ch_data)
{
    fdf0:	e5900000 	ldr	r0, [r0]
    fdf4:	e2802014 	add	r2, r0, #20	; 0x14
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint8 stat;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    fdf8:	e5923000 	ldr	r3, [r2]
    if ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_RDR) == 0)
    fdfc:	e3130001 	tst	r3, #1	; 0x1
    fe00:	0afffffc 	beq	fdf8 <cyg_hal_plf_serial_getc+0x8>
        return false;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxRBR, *ch);
    fe04:	e5900000 	ldr	r0, [r0]
    fe08:	e20000ff 	and	r0, r0, #255	; 0xff

    while(!cyg_hal_plf_serial_getc_nonblock(__ch_data, &ch));

    CYGARC_HAL_RESTORE_GP();
    return ch;
}
    fe0c:	e12fff1e 	bx	lr

0000fe10 <cyg_hal_plf_serial_write>:

static void
cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf, 
                         cyg_uint32 __len)
{
    fe10:	e92d0030 	push	{r4, r5}
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe14:	e2525000 	subs	r5, r2, #0	; 0x0
}

static void
cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf, 
                         cyg_uint32 __len)
{
    fe18:	e1a04001 	mov	r4, r1
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe1c:	0a00000a 	beq	fe4c <cyg_hal_plf_serial_write+0x3c>
    fe20:	e5900000 	ldr	r0, [r0]
    fe24:	e3a02000 	mov	r2, #0	; 0x0
        cyg_hal_plf_serial_putc(__ch_data, *__buf++);
    fe28:	e280c014 	add	ip, r0, #20	; 0x14
    fe2c:	e7d41002 	ldrb	r1, [r4, r2]
    cyg_uint8* base = ((channel_data_t*)__ch_data)->base;
    cyg_uint8 stat;
    CYGARC_HAL_SAVE_GP();

    do {
        HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    fe30:	e59c3000 	ldr	r3, [ip]
    } while ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_THRE) == 0);
    fe34:	e3130020 	tst	r3, #32	; 0x20
    fe38:	0afffffc 	beq	fe30 <cyg_hal_plf_serial_write+0x20>

    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxTHR, c);
    fe3c:	e2822001 	add	r2, r2, #1	; 0x1
cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf, 
                         cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe40:	e1550002 	cmp	r5, r2

    do {
        HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    } while ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_THRE) == 0);

    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxTHR, c);
    fe44:	e5801000 	str	r1, [r0]
cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf, 
                         cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe48:	1afffff7 	bne	fe2c <cyg_hal_plf_serial_write+0x1c>
        cyg_hal_plf_serial_putc(__ch_data, *__buf++);

    CYGARC_HAL_RESTORE_GP();
}
    fe4c:	e8bd0030 	pop	{r4, r5}
    fe50:	e12fff1e 	bx	lr

0000fe54 <cyg_hal_plf_serial_read>:

static void
cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf, cyg_uint32 __len)
{
    fe54:	e92d0030 	push	{r4, r5}
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe58:	e2525000 	subs	r5, r2, #0	; 0x0
    CYGARC_HAL_RESTORE_GP();
}

static void
cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf, cyg_uint32 __len)
{
    fe5c:	e1a04000 	mov	r4, r0
    fe60:	e1a00001 	mov	r0, r1
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe64:	0a00000a 	beq	fe94 <cyg_hal_plf_serial_read+0x40>
    fe68:	e3a02000 	mov	r2, #0	; 0x0
    fe6c:	e5941000 	ldr	r1, [r4]
    fe70:	e281c014 	add	ip, r1, #20	; 0x14
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint8 stat;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    fe74:	e59c3000 	ldr	r3, [ip]
    if ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_RDR) == 0)
    fe78:	e3130001 	tst	r3, #1	; 0x1
    fe7c:	0afffffc 	beq	fe74 <cyg_hal_plf_serial_read+0x20>
        return false;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxRBR, *ch);
    fe80:	e5913000 	ldr	r3, [r1]
cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf, cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
        *__buf++ = cyg_hal_plf_serial_getc(__ch_data);
    fe84:	e7c03002 	strb	r3, [r0, r2]
    fe88:	e2822001 	add	r2, r2, #1	; 0x1
static void
cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf, cyg_uint32 __len)
{
    CYGARC_HAL_SAVE_GP();

    while(__len-- > 0)
    fe8c:	e1550002 	cmp	r5, r2
    fe90:	1afffff5 	bne	fe6c <cyg_hal_plf_serial_read+0x18>
        *__buf++ = cyg_hal_plf_serial_getc(__ch_data);

    CYGARC_HAL_RESTORE_GP();
}
    fe94:	e8bd0030 	pop	{r4, r5}
    fe98:	e12fff1e 	bx	lr

0000fe9c <cyg_hal_plf_serial_getc_timeout>:

cyg_bool
cyg_hal_plf_serial_getc_timeout(void* __ch_data, cyg_uint8* ch)
{
    fe9c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint8 stat;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    fea0:	e5902000 	ldr	r2, [r0]
    fea4:	e5923014 	ldr	r3, [r2, #20]
    if ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_RDR) == 0)
    fea8:	e3130001 	tst	r3, #1	; 0x1
    CYGARC_HAL_RESTORE_GP();
}

cyg_bool
cyg_hal_plf_serial_getc_timeout(void* __ch_data, cyg_uint8* ch)
{
    feac:	e24dd004 	sub	sp, sp, #4	; 0x4
    feb0:	e1a05000 	mov	r5, r0
    feb4:	e1a07001 	mov	r7, r1
    int delay_count;
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_bool res;
    CYGARC_HAL_SAVE_GP();

    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
    feb8:	e5903004 	ldr	r3, [r0, #4]
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint8 stat;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    if ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_RDR) == 0)
    febc:	1a000011 	bne	ff08 <cyg_hal_plf_serial_getc_timeout+0x6c>
    int delay_count;
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_bool res;
    CYGARC_HAL_SAVE_GP();

    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
    fec0:	e1a02183 	lsl	r2, r3, #3
    fec4:	e1a03083 	lsl	r3, r3, #1

    for(;;) {
        res = cyg_hal_plf_serial_getc_nonblock(__ch_data, ch);
        if (res || 0 == delay_count--)
    fec8:	e0933002 	adds	r3, r3, r2
    fecc:	11a04003 	movne	r4, r3
    fed0:	159f6044 	ldrne	r6, [pc, #68]	; ff1c <cyg_hal_plf_serial_getc_timeout+0x80>
    fed4:	0a000009 	beq	ff00 <cyg_hal_plf_serial_getc_timeout+0x64>
#define CYGACC_CALL_IF_CONSOLE_INTERRUPT_FLAG_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_CONSOLE_INTERRUPT_FLAG]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_DELAY_US(_u_) \
 CYGACC_CALL_VV1(__call_if_delay_us_t*, CYGNUM_CALL_IF_DELAY_US, (_u_))
__call_voidVV1(CYGNUM_CALL_IF_DELAY_US, __call_if_delay_us_t, void, cyg_int32)
    fed8:	e5963048 	ldr	r3, [r6, #72]
    fedc:	e3a00064 	mov	r0, #100	; 0x64
    fee0:	e1a0e00f 	mov	lr, pc
    fee4:	e12fff13 	bx	r3
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint8 stat;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    fee8:	e5952000 	ldr	r2, [r5]
    feec:	e5923014 	ldr	r3, [r2, #20]
    if ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_RDR) == 0)
    fef0:	e3130001 	tst	r3, #1	; 0x1
    fef4:	1a000003 	bne	ff08 <cyg_hal_plf_serial_getc_timeout+0x6c>

    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps

    for(;;) {
        res = cyg_hal_plf_serial_getc_nonblock(__ch_data, ch);
        if (res || 0 == delay_count--)
    fef8:	e2544001 	subs	r4, r4, #1	; 0x1
    fefc:	1afffff5 	bne	fed8 <cyg_hal_plf_serial_getc_timeout+0x3c>
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint8 stat;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLSR, stat);
    if ((stat & CYGARC_HAL_LPC2XXX_REG_UxLSR_RDR) == 0)
    ff00:	e3a00000 	mov	r0, #0	; 0x0
    ff04:	ea000002 	b	ff14 <cyg_hal_plf_serial_getc_timeout+0x78>
        return false;

    HAL_READ_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxRBR, *ch);
    ff08:	e5923000 	ldr	r3, [r2]
    ff0c:	e5c73000 	strb	r3, [r7]
    ff10:	e3a00001 	mov	r0, #1	; 0x1
        CYGACC_CALL_IF_DELAY_US(100);
    }

    CYGARC_HAL_RESTORE_GP();
    return res;
}
    ff14:	e28dd004 	add	sp, sp, #4	; 0x4
    ff18:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    ff1c:	40000430 	.word	0x40000430

0000ff20 <cyg_hal_plf_serial_init>:
      CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD}
};

void
cyg_hal_plf_serial_init(void)
{
    ff20:	e92d4070 	push	{r4, r5, r6, lr}
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    ff24:	e59f50bc 	ldr	r5, [pc, #188]	; ffe8 <cyg_hal_plf_serial_init+0xc8>
    ff28:	e3e00000 	mvn	r0, #0	; 0x0
    ff2c:	e5953034 	ldr	r3, [r5, #52]
    ff30:	e1a0e00f 	mov	lr, pc
    ff34:	e12fff13 	bx	r3
static void
cyg_hal_plf_serial_init_channel(void* __ch_data)
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    ff38:	e59f40ac 	ldr	r4, [pc, #172]	; ffec <cyg_hal_plf_serial_init+0xcc>
    ff3c:	e594100c 	ldr	r1, [r4, #12]
    ff40:	e1a06000 	mov	r6, r0
    ff44:	e1a01201 	lsl	r1, r1, #4
    ff48:	e3a008e1 	mov	r0, #14745600	; 0xe10000
    ff4c:	eb000498 	bl	111b4 <__aeabi_idiv>
    ff50:	e1a00800 	lsl	r0, r0, #16
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
    ff54:	e5941000 	ldr	r1, [r4]
static void
cyg_hal_plf_serial_init_channel(void* __ch_data)
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    ff58:	e1a02820 	lsr	r2, r0, #16
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);
    ff5c:	e20220ff 	and	r2, r2, #255	; 0xff
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    ff60:	e1a00c20 	lsr	r0, r0, #24
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
    ff64:	e3a03080 	mov	r3, #128	; 0x80
    ff68:	e581300c 	str	r3, [r1, #12]
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    ff6c:	e5810004 	str	r0, [r1, #4]
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);

    // 8-1-no parity.
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
    ff70:	e243307d 	sub	r3, r3, #125	; 0x7d
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);
    ff74:	e5812000 	str	r2, [r1]
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_WORD_LENGTH_8 |
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_STOP_1);

    // Reset and enable FIFO
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxFCR, 
    ff78:	e3a02007 	mov	r2, #7	; 0x7
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);

    // 8-1-no parity.
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
    ff7c:	e581300c 	str	r3, [r1, #12]
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_WORD_LENGTH_8 |
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_STOP_1);

    // Reset and enable FIFO
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxFCR, 
    ff80:	e5812008 	str	r2, [r1, #8]
    ff84:	e3a00000 	mov	r0, #0	; 0x0
    ff88:	e5953034 	ldr	r3, [r5, #52]
    ff8c:	e1a0e00f 	mov	lr, pc
    ff90:	e12fff13 	bx	r3
#define CYGACC_CALL_IF_KILL_VECTOR_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_KILL_VECTOR]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_CONSOLE_PROCS() \
 CYGACC_DATA_VV(__call_if_console_procs_t, CYGNUM_CALL_IF_CONSOLE_PROCS)
__data_VV(CYGNUM_CALL_IF_CONSOLE_PROCS, __call_if_console_procs_t)
    ff94:	e5951014 	ldr	r1, [r5, #20]

    // Set channel 0
    CYGACC_CALL_IF_SET_CONSOLE_COMM(0);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_CH_DATA_SET(*comm, &lpc2xxx_ser_channels[0]);
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
    ff98:	e59f3050 	ldr	r3, [pc, #80]	; fff0 <cyg_hal_plf_serial_init+0xd0>
    // Setup procs in the vector table

    // Set channel 0
    CYGACC_CALL_IF_SET_CONSOLE_COMM(0);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_CH_DATA_SET(*comm, &lpc2xxx_ser_channels[0]);
    ff9c:	e5814000 	str	r4, [r1]
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
    ffa0:	e59f204c 	ldr	r2, [pc, #76]	; fff4 <cyg_hal_plf_serial_init+0xd4>

    // Set channel 0
    CYGACC_CALL_IF_SET_CONSOLE_COMM(0);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_CH_DATA_SET(*comm, &lpc2xxx_ser_channels[0]);
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
    ffa4:	e5813004 	str	r3, [r1, #4]
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
    ffa8:	e59f3048 	ldr	r3, [pc, #72]	; fff8 <cyg_hal_plf_serial_init+0xd8>
    // Set channel 0
    CYGACC_CALL_IF_SET_CONSOLE_COMM(0);
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_CH_DATA_SET(*comm, &lpc2xxx_ser_channels[0]);
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
    ffac:	e5812008 	str	r2, [r1, #8]
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
    ffb0:	e581300c 	str	r3, [r1, #12]
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
    ffb4:	e59f2040 	ldr	r2, [pc, #64]	; fffc <cyg_hal_plf_serial_init+0xdc>
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
    ffb8:	e59f3040 	ldr	r3, [pc, #64]	; 10000 <cyg_hal_plf_serial_init+0xe0>
    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_CH_DATA_SET(*comm, &lpc2xxx_ser_channels[0]);
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
    ffbc:	e5812010 	str	r2, [r1, #16]
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
    ffc0:	e5813014 	str	r3, [r1, #20]
    CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_serial_isr);
    ffc4:	e59f2038 	ldr	r2, [pc, #56]	; 10004 <cyg_hal_plf_serial_init+0xe4>
    CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
    ffc8:	e59f3038 	ldr	r3, [pc, #56]	; 10008 <cyg_hal_plf_serial_init+0xe8>
    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
    CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_serial_isr);
    ffcc:	e5812018 	str	r2, [r1, #24]
    CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
    ffd0:	e581301c 	str	r3, [r1, #28]
#define CYGACC_CALL_IF_SET_DEBUG_COMM_SET(_x_) \
 hal_virtual_vector_table[CYGNUM_CALL_IF_SET_DEBUG_COMM]=(CYG_ADDRWORD)(_x_)

#define CYGACC_CALL_IF_SET_CONSOLE_COMM(_i_) \
 CYGACC_CALL_VV1(__call_if_set_console_comm_t*, CYGNUM_CALL_IF_SET_CONSOLE_COMM, (_i_))
__call_VV1(CYGNUM_CALL_IF_SET_CONSOLE_COMM, __call_if_set_console_comm_t, int, int)
    ffd4:	e1a00006 	mov	r0, r6
    ffd8:	e5953034 	ldr	r3, [r5, #52]
    ffdc:	e1a0e00f 	mov	lr, pc
    ffe0:	e12fff13 	bx	r3
    CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
#endif

    // Restore original console
    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
}
    ffe4:	e8bd8070 	pop	{r4, r5, r6, pc}
    ffe8:	40000430 	.word	0x40000430
    ffec:	400007fc 	.word	0x400007fc
    fff0:	0000fe10 	.word	0x0000fe10
    fff4:	0000fe54 	.word	0x0000fe54
    fff8:	0000fdd4 	.word	0x0000fdd4
    fffc:	0000fdf0 	.word	0x0000fdf0
   10000:	00010080 	.word	0x00010080
   10004:	00010010 	.word	0x00010010
   10008:	0000fe9c 	.word	0x0000fe9c

0001000c <hal_diag_led>:

void
hal_diag_led(int mask)
{
    hal_lpc2xxx_set_leds(mask);
   1000c:	eafff747 	b	dd30 <hal_lpc2xxx_set_leds>

00010010 <cyg_hal_plf_serial_isr>:
}

static int
cyg_hal_plf_serial_isr(void *__ch_data, int* __ctrlc, 
                       CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
{
   10010:	e92d4030 	push	{r4, r5, lr}
   10014:	e1a05000 	mov	r5, r0
    cyg_uint8 c;
    cyg_uint8 iir;
    
    CYGARC_HAL_SAVE_GP();

    *__ctrlc = 0;
   10018:	e3a00000 	mov	r0, #0	; 0x0
   1001c:	e5810000 	str	r0, [r1]

	HAL_READ_UINT32(chan->base + CYGARC_HAL_LPC2XXX_REG_UxIIR, iir);
   10020:	e5952000 	ldr	r2, [r5]
   10024:	e5923008 	ldr	r3, [r2, #8]
	
	if((iir & (CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR0 | CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR1 | 
   10028:	e2033007 	and	r3, r3, #7	; 0x7
   1002c:	e3530004 	cmp	r3, #4	; 0x4
}

static int
cyg_hal_plf_serial_isr(void *__ch_data, int* __ctrlc, 
                       CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
{
   10030:	e1a04001 	mov	r4, r1
   10034:	e24dd00c 	sub	sp, sp, #12	; 0xc

    *__ctrlc = 0;

	HAL_READ_UINT32(chan->base + CYGARC_HAL_LPC2XXX_REG_UxIIR, iir);
	
	if((iir & (CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR0 | CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR1 | 
   10038:	11a04000 	movne	r4, r0
   1003c:	0a000004 	beq	10054 <cyg_hal_plf_serial_isr+0x44>
        if( cyg_hal_is_break( &c , 1 ) ) *__ctrlc = 1;

        res = CYG_ISR_HANDLED;
    }

    HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
   10040:	e5950008 	ldr	r0, [r5, #8]
   10044:	ebfff6f3 	bl	dc18 <hal_interrupt_acknowledge>

    CYGARC_HAL_RESTORE_GP();
    return res;
}
   10048:	e1a00004 	mov	r0, r4
   1004c:	e28dd00c 	add	sp, sp, #12	; 0xc
   10050:	e8bd8030 	pop	{r4, r5, pc}
	if((iir & (CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR0 | CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR1 | 
		CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR2)) == CYGARC_HAL_LPC2XXX_REG_UxIIR_IIR2)
	{
		// Rx data available or character timeout
		// Read data in order to clear interrupt
        HAL_READ_UINT32(chan->base+CYGARC_HAL_LPC2XXX_REG_UxRBR, c);
   10054:	e5923000 	ldr	r3, [r2]
   10058:	e28d0008 	add	r0, sp, #8	; 0x8
   1005c:	e5603001 	strb	r3, [r0, #-1]!
        if( cyg_hal_is_break( &c , 1 ) ) *__ctrlc = 1;
   10060:	e3a01001 	mov	r1, #1	; 0x1
   10064:	ebffc68e 	bl	1aa4 <cyg_hal_is_break>
   10068:	e3500000 	cmp	r0, #0	; 0x0
   1006c:	13a03001 	movne	r3, #1	; 0x1
   10070:	15843000 	strne	r3, [r4]
   10074:	03a04001 	moveq	r4, #1	; 0x1
   10078:	11a04003 	movne	r4, r3
   1007c:	eaffffef 	b	10040 <cyg_hal_plf_serial_isr+0x30>

00010080 <cyg_hal_plf_serial_control>:
    return res;
}

static int
cyg_hal_plf_serial_control(void *__ch_data, __comm_control_cmd_t __func, ...)
{
   10080:	e92d000e 	push	{r1, r2, r3}
   10084:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   10088:	e5dd3014 	ldrb	r3, [sp, #20]
   1008c:	e1a05000 	mov	r5, r0
    static int irq_state = 0;
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = ((channel_data_t*)__ch_data)->base;
   10090:	e5907000 	ldr	r7, [r0]
    va_list ap;

    CYGARC_HAL_SAVE_GP();
    va_start(ap, __func);

    switch (__func) {
   10094:	e3530007 	cmp	r3, #7	; 0x7
   10098:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   1009c:	ea000019 	b	10108 <cyg_hal_plf_serial_control+0x88>
   100a0:	000100c0 	.word	0x000100c0
   100a4:	0001012c 	.word	0x0001012c
   100a8:	00010108 	.word	0x00010108
   100ac:	00010108 	.word	0x00010108
   100b0:	00010134 	.word	0x00010134
   100b4:	00010154 	.word	0x00010154
   100b8:	0001017c 	.word	0x0001017c
   100bc:	0001011c 	.word	0x0001011c
    case __COMMCTL_GETBAUD:
        ret = chan->baud_rate;
        break;
    case __COMMCTL_SETBAUD:
        chan->baud_rate = va_arg(ap, cyg_int32);
   100c0:	e59d1018 	ldr	r1, [sp, #24]
   100c4:	e580100c 	str	r1, [r0, #12]
static void
cyg_hal_plf_serial_init_channel(void* __ch_data)
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
   100c8:	e1a01201 	lsl	r1, r1, #4
   100cc:	e3a008e1 	mov	r0, #14745600	; 0xe10000
   100d0:	eb000437 	bl	111b4 <__aeabi_idiv>
   100d4:	e1a00800 	lsl	r0, r0, #16
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
   100d8:	e5951000 	ldr	r1, [r5]
static void
cyg_hal_plf_serial_init_channel(void* __ch_data)
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
   100dc:	e1a02820 	lsr	r2, r0, #16
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);
   100e0:	e20220ff 	and	r2, r2, #255	; 0xff
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
   100e4:	e3a03080 	mov	r3, #128	; 0x80
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
   100e8:	e1a00c20 	lsr	r0, r0, #24
{
    channel_data_t* chan = (channel_data_t*)__ch_data;
    cyg_uint8* base = chan->base;
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
   100ec:	e581300c 	str	r3, [r1, #12]
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
   100f0:	e5810004 	str	r0, [r1, #4]
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);

    // 8-1-no parity.
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
   100f4:	e243307d 	sub	r3, r3, #125	; 0x7d
    cyg_uint16 divider = CYG_HAL_ARM_LPC2XXX_BAUD_GENERATOR(chan->baud_rate);
    // Set baudrate
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);
   100f8:	e5812000 	str	r2, [r1]
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_WORD_LENGTH_8 |
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_STOP_1);

    // Reset and enable FIFO
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxFCR, 
   100fc:	e3a02007 	mov	r2, #7	; 0x7
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_DLAB);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLM, divider >> 8);
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxDLL, divider & 0xFF);

    // 8-1-no parity.
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxLCR, 
   10100:	e581300c 	str	r3, [r1, #12]
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_WORD_LENGTH_8 |
                     CYGARC_HAL_LPC2XXX_REG_UxLCR_STOP_1);

    // Reset and enable FIFO
    HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxFCR, 
   10104:	e5812008 	str	r2, [r1, #8]
   10108:	e3a06000 	mov	r6, #0	; 0x0
    }

    va_end(ap);
    CYGARC_HAL_RESTORE_GP();
    return ret;
}
   1010c:	e1a00006 	mov	r0, r6
   10110:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
   10114:	e28dd00c 	add	sp, sp, #12	; 0xc
   10118:	e12fff1e 	bx	lr
    case __COMMCTL_DBG_ISR_VECTOR:
        ret = chan->isr_vector;
        break;
    case __COMMCTL_SET_TIMEOUT:
        ret = chan->msec_timeout;
        chan->msec_timeout = va_arg(ap, cyg_uint32);
   1011c:	e59d3018 	ldr	r3, [sp, #24]
        break;
    case __COMMCTL_DBG_ISR_VECTOR:
        ret = chan->isr_vector;
        break;
    case __COMMCTL_SET_TIMEOUT:
        ret = chan->msec_timeout;
   10120:	e5906004 	ldr	r6, [r0, #4]
        chan->msec_timeout = va_arg(ap, cyg_uint32);
   10124:	e5803004 	str	r3, [r0, #4]
   10128:	eafffff7 	b	1010c <cyg_hal_plf_serial_control+0x8c>
    CYGARC_HAL_SAVE_GP();
    va_start(ap, __func);

    switch (__func) {
    case __COMMCTL_GETBAUD:
        ret = chan->baud_rate;
   1012c:	e590600c 	ldr	r6, [r0, #12]
   10130:	eafffff5 	b	1010c <cyg_hal_plf_serial_control+0x8c>
        HAL_INTERRUPT_UNMASK(chan->isr_vector);
        HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxIER, 
                         CYGARC_HAL_LPC2XXX_REG_UxIER_RXDATA_INT);
        break;
    case __COMMCTL_IRQ_DISABLE:
        ret = irq_state;
   10134:	e59f3048 	ldr	r3, [pc, #72]	; 10184 <cyg_hal_plf_serial_control+0x104>
        irq_state = 0;
   10138:	e3a04000 	mov	r4, #0	; 0x0
        HAL_INTERRUPT_MASK(chan->isr_vector);
   1013c:	e5900008 	ldr	r0, [r0, #8]
        HAL_INTERRUPT_UNMASK(chan->isr_vector);
        HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxIER, 
                         CYGARC_HAL_LPC2XXX_REG_UxIER_RXDATA_INT);
        break;
    case __COMMCTL_IRQ_DISABLE:
        ret = irq_state;
   10140:	e5936000 	ldr	r6, [r3]
        irq_state = 0;
   10144:	e5834000 	str	r4, [r3]
        HAL_INTERRUPT_MASK(chan->isr_vector);
   10148:	ebfff6a8 	bl	dbf0 <hal_interrupt_mask>
        HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxIER, 0);
   1014c:	e5874004 	str	r4, [r7, #4]
   10150:	eaffffed 	b	1010c <cyg_hal_plf_serial_control+0x8c>
        // Should we verify this value here?
        cyg_hal_plf_serial_init_channel(chan);
        ret = 0;
        break;
    case __COMMCTL_IRQ_ENABLE:
        irq_state = 1;
   10154:	e59f3028 	ldr	r3, [pc, #40]	; 10184 <cyg_hal_plf_serial_control+0x104>
   10158:	e3a04001 	mov	r4, #1	; 0x1
        HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
   1015c:	e5900008 	ldr	r0, [r0, #8]
        // Should we verify this value here?
        cyg_hal_plf_serial_init_channel(chan);
        ret = 0;
        break;
    case __COMMCTL_IRQ_ENABLE:
        irq_state = 1;
   10160:	e5834000 	str	r4, [r3]
        HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
   10164:	ebfff6ab 	bl	dc18 <hal_interrupt_acknowledge>
        HAL_INTERRUPT_UNMASK(chan->isr_vector);
   10168:	e5950008 	ldr	r0, [r5, #8]
   1016c:	ebfff6a4 	bl	dc04 <hal_interrupt_unmask>
        HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxIER, 
   10170:	e3a06000 	mov	r6, #0	; 0x0
   10174:	e5874004 	str	r4, [r7, #4]
   10178:	eaffffe3 	b	1010c <cyg_hal_plf_serial_control+0x8c>
        irq_state = 0;
        HAL_INTERRUPT_MASK(chan->isr_vector);
        HAL_WRITE_UINT32(base+CYGARC_HAL_LPC2XXX_REG_UxIER, 0);
        break;
    case __COMMCTL_DBG_ISR_VECTOR:
        ret = chan->isr_vector;
   1017c:	e5906008 	ldr	r6, [r0, #8]
   10180:	eaffffe1 	b	1010c <cyg_hal_plf_serial_control+0x8c>
   10184:	40004bc8 	.word	0x40004bc8

00010188 <_memset>:
        CYG_CHECK_DATA_PTR( s, "s is not a valid pointer!" );
        CYG_CHECK_DATA_PTR( (char *)s+n-1, "s+n-1 is not a valid address!" );
    }
#endif

    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (s))
   10188:	e3520003 	cmp	r2, #3	; 0x3

/* FUNCTIONS */

void *
_memset( void *s, int c, size_t n )
{
   1018c:	e92d0030 	push	{r4, r5}
   10190:	e1a04000 	mov	r4, r0
        CYG_CHECK_DATA_PTR( s, "s is not a valid pointer!" );
        CYG_CHECK_DATA_PTR( (char *)s+n-1, "s+n-1 is not a valid address!" );
    }
#endif

    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (s))
   10194:	9a00000a 	bls	101c4 <_memset+0x3c>
   10198:	e3100003 	tst	r0, #3	; 0x3
   1019c:	0a00000b 	beq	101d0 <_memset+0x48>
    {
        while (n-- != 0)
   101a0:	e20110ff 	and	r1, r1, #255	; 0xff
   101a4:	e3a03000 	mov	r3, #0	; 0x0
        {
            *char_ptr++ = (char) c;
   101a8:	e7c41003 	strb	r1, [r4, r3]
   101ac:	e2833001 	add	r3, r3, #1	; 0x1
    }
#endif

    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (s))
    {
        while (n-- != 0)
   101b0:	e1530002 	cmp	r3, r2
   101b4:	1afffffb 	bne	101a8 <_memset+0x20>
    CYG_REPORT_RETVAL( s );
#endif
    return s;
#endif /* not defined(CYGIMP_PREFER_SMALL_TO_FAST_MEMSET) ||
        * defined(__OPTIMIZE_SIZE__) */
} /* _memset() */
   101b8:	e1a00004 	mov	r0, r4
   101bc:	e8bd0030 	pop	{r4, r5}
   101c0:	e12fff1e 	bx	lr
    }
#endif

    if (n < sizeof(CYG_WORD) || CYG_STR_UNALIGNED (s))
    {
        while (n-- != 0)
   101c4:	e3520000 	cmp	r2, #0	; 0x0
   101c8:	1afffff4 	bne	101a0 <_memset+0x18>
   101cc:	eafffff9 	b	101b8 <_memset+0x30>
    aligned_addr = (CYG_WORD *)s;
    
    /* Store C into each char sized location in BUFFER so that
     * we can set large blocks quickly.
     */
    c &= 0xff;
   101d0:	e20150ff 	and	r5, r1, #255	; 0xff
        buffer = 0;
        for (count = 0; count < CYG_STR_OPT_LITTLEBLOCKSIZE; count++)
            buffer = (buffer << 8) | c;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE*4)
   101d4:	e352000f 	cmp	r2, #15	; 0xf
     * we can set large blocks quickly.
     */
    c &= 0xff;
    if (CYG_STR_OPT_LITTLEBLOCKSIZE == 4)
    {
        buffer = (c << 8) | c;
   101d8:	e1853405 	orr	r3, r5, r5, lsl #8
        buffer |= (buffer << 16);
   101dc:	e1831803 	orr	r1, r3, r3, lsl #16
        buffer = 0;
        for (count = 0; count < CYG_STR_OPT_LITTLEBLOCKSIZE; count++)
            buffer = (buffer << 8) | c;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE*4)
   101e0:	81a0c002 	movhi	ip, r2
   101e4:	81a03004 	movhi	r3, r4
   101e8:	9a00000e 	bls	10228 <_memset+0xa0>
    {
        *aligned_addr++ = buffer;
        *aligned_addr++ = buffer;
        *aligned_addr++ = buffer;
        *aligned_addr++ = buffer;
        n -= 4*CYG_STR_OPT_LITTLEBLOCKSIZE;
   101ec:	e24cc010 	sub	ip, ip, #16	; 0x10
        buffer = 0;
        for (count = 0; count < CYG_STR_OPT_LITTLEBLOCKSIZE; count++)
            buffer = (buffer << 8) | c;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE*4)
   101f0:	e35c000f 	cmp	ip, #15	; 0xf
    {
        *aligned_addr++ = buffer;
   101f4:	e5831000 	str	r1, [r3]
        *aligned_addr++ = buffer;
   101f8:	e5831004 	str	r1, [r3, #4]
        *aligned_addr++ = buffer;
   101fc:	e5831008 	str	r1, [r3, #8]
        *aligned_addr++ = buffer;
   10200:	e583100c 	str	r1, [r3, #12]

/* FUNCTIONS */

void *
_memset( void *s, int c, size_t n )
{
   10204:	e2833010 	add	r3, r3, #16	; 0x10
        buffer = 0;
        for (count = 0; count < CYG_STR_OPT_LITTLEBLOCKSIZE; count++)
            buffer = (buffer << 8) | c;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE*4)
   10208:	8afffff7 	bhi	101ec <_memset+0x64>

/* FUNCTIONS */

void *
_memset( void *s, int c, size_t n )
{
   1020c:	e2422010 	sub	r2, r2, #16	; 0x10
   10210:	e3c2300f 	bic	r3, r2, #15	; 0xf
   10214:	e202200f 	and	r2, r2, #15	; 0xf
   10218:	e2833010 	add	r3, r3, #16	; 0x10
        *aligned_addr++ = buffer;
        *aligned_addr++ = buffer;
        n -= 4*CYG_STR_OPT_LITTLEBLOCKSIZE;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
   1021c:	e3520003 	cmp	r2, #3	; 0x3

/* FUNCTIONS */

void *
_memset( void *s, int c, size_t n )
{
   10220:	e0840003 	add	r0, r4, r3
        *aligned_addr++ = buffer;
        *aligned_addr++ = buffer;
        n -= 4*CYG_STR_OPT_LITTLEBLOCKSIZE;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
   10224:	9a00000a 	bls	10254 <_memset+0xcc>
        buffer = 0;
        for (count = 0; count < CYG_STR_OPT_LITTLEBLOCKSIZE; count++)
            buffer = (buffer << 8) | c;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE*4)
   10228:	e3a0c000 	mov	ip, #0	; 0x0
        n -= 4*CYG_STR_OPT_LITTLEBLOCKSIZE;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
    {
        *aligned_addr++ = buffer;
   1022c:	e780100c 	str	r1, [r0, ip]
   10230:	e28cc004 	add	ip, ip, #4	; 0x4
        *aligned_addr++ = buffer;
        *aligned_addr++ = buffer;
        n -= 4*CYG_STR_OPT_LITTLEBLOCKSIZE;
    }
    
    while (n >= CYG_STR_OPT_LITTLEBLOCKSIZE)
   10234:	e06c3002 	rsb	r3, ip, r2
   10238:	e3530003 	cmp	r3, #3	; 0x3
   1023c:	8afffffa 	bhi	1022c <_memset+0xa4>

/* FUNCTIONS */

void *
_memset( void *s, int c, size_t n )
{
   10240:	e2422004 	sub	r2, r2, #4	; 0x4
   10244:	e3c23003 	bic	r3, r2, #3	; 0x3
   10248:	e2833004 	add	r3, r3, #4	; 0x4
   1024c:	e0800003 	add	r0, r0, r3
   10250:	e2022003 	and	r2, r2, #3	; 0x3
        n -= CYG_STR_OPT_LITTLEBLOCKSIZE;
    }
    
    /* Pick up the remainder with a bytewise loop. */
    unaligned_addr = (char*)aligned_addr;
    while (n)
   10254:	e3520000 	cmp	r2, #0	; 0x0
   10258:	0affffd6 	beq	101b8 <_memset+0x30>
   1025c:	e20510ff 	and	r1, r5, #255	; 0xff
   10260:	e3a03000 	mov	r3, #0	; 0x0
    {
        *unaligned_addr++ = (char)c;
   10264:	e7c01003 	strb	r1, [r0, r3]
   10268:	e2833001 	add	r3, r3, #1	; 0x1
        n -= CYG_STR_OPT_LITTLEBLOCKSIZE;
    }
    
    /* Pick up the remainder with a bytewise loop. */
    unaligned_addr = (char*)aligned_addr;
    while (n)
   1026c:	e1530002 	cmp	r3, r2
   10270:	1afffffb 	bne	10264 <_memset+0xdc>
   10274:	eaffffcf 	b	101b8 <_memset+0x30>

00010278 <_ZN35Cyg_Mempool_dlmalloc_ImplementationC2EPhij>:
    CYG_ADDRESS front_misalign;
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
   10278:	e3a03000 	mov	r3, #0	; 0x0

Cyg_Mempool_dlmalloc_Implementation::Cyg_Mempool_dlmalloc_Implementation(
                                            cyg_uint8 *base, cyg_int32 size,
                                            CYG_ADDRWORD /* argthru */ )
{
    arenabase = base;
   1027c:	e5801000 	str	r1, [r0]
    CYG_ADDRESS front_misalign;
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
   10280:	e580300c 	str	r3, [r0, #12]
   10284:	e5803008 	str	r3, [r0, #8]

//----------------------------------------------------------------------------

Cyg_Mempool_dlmalloc_Implementation::Cyg_Mempool_dlmalloc_Implementation(
                                            cyg_uint8 *base, cyg_int32 size,
                                            CYG_ADDRWORD /* argthru */ )
   10288:	e92d0030 	push	{r4, r5}
{
    arenabase = base;
    arenasize = size;
   1028c:	e5802004 	str	r2, [r0, #4]

//----------------------------------------------------------------------------

Cyg_Mempool_dlmalloc_Implementation::Cyg_Mempool_dlmalloc_Implementation(
                                            cyg_uint8 *base, cyg_int32 size,
                                            CYG_ADDRWORD /* argthru */ )
   10290:	e1a05002 	mov	r5, r2
   10294:	e1a04001 	mov	r4, r1
    CYG_ADDRESS front_misalign;
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
   10298:	e1a02003 	mov	r2, r3
   1029c:	e1a0c000 	mov	ip, r0
    for (i=0; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; i++) {
        av_[ i*2+2 ] = av_[ i*2+3 ] = bin_at(i);
   102a0:	e2823001 	add	r3, r2, #1	; 0x1
   102a4:	e1a02003 	mov	r2, r3
   102a8:	e1a03183 	lsl	r3, r3, #3
   102ac:	e0803003 	add	r3, r0, r3
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
    for (i=0; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; i++) {
   102b0:	e3520080 	cmp	r2, #128	; 0x80
        av_[ i*2+2 ] = av_[ i*2+3 ] = bin_at(i);
   102b4:	e58c3010 	str	r3, [ip, #16]
   102b8:	e58c3014 	str	r3, [ip, #20]
   102bc:	e28cc008 	add	ip, ip, #8	; 0x8
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
    for (i=0; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; i++) {
   102c0:	1afffff6 	bne	102a0 <_ZN35Cyg_Mempool_dlmalloc_ImplementationC2EPhij+0x28>
                  "not defined" );
#endif

    front_misalign = (CYG_ADDRESS)chunk2mem(base) & MALLOC_ALIGN_MASK;

    if ( front_misalign > 0 ) {
   102c4:	e2143007 	ands	r3, r4, #7	; 0x7
   102c8:	12631008 	rsbne	r1, r3, #8	; 0x8
   102cc:	01a01003 	moveq	r1, r3
   102d0:	12813010 	addne	r3, r1, #16	; 0x10
   102d4:	03a03010 	moveq	r3, #16	; 0x10
    } else {
        correction = 0;
    }

    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
   102d8:	e1550003 	cmp	r5, r3
        // help catch errors. Don't fail now.
        arenabase = NULL; 
    else {
        top = (mchunkptr)(base + correction);
        set_head(top, arenasize | PREV_INUSE);
   102dc:	25903004 	ldrcs	r3, [r0, #4]
    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
    else {
        top = (mchunkptr)(base + correction);
   102e0:	20842001 	addcs	r2, r4, r1
    }

    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
   102e4:	33a03000 	movcc	r3, #0	; 0x0
    else {
        top = (mchunkptr)(base + correction);
        set_head(top, arenasize | PREV_INUSE);
   102e8:	23833001 	orrcs	r3, r3, #1	; 0x1
    }

    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
   102ec:	35803000 	strcc	r3, [r0]
    else {
        top = (mchunkptr)(base + correction);
        set_head(top, arenasize | PREV_INUSE);
   102f0:	25823004 	strcs	r3, [r2, #4]
    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
    else {
        top = (mchunkptr)(base + correction);
   102f4:	25802010 	strcs	r2, [r0, #16]
        set_head(top, arenasize | PREV_INUSE);
    }
}
   102f8:	e8bd0030 	pop	{r4, r5}
   102fc:	e12fff1e 	bx	lr

00010300 <_ZN35Cyg_Mempool_dlmalloc_ImplementationC1EPhij>:
    CYG_ADDRESS front_misalign;
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
   10300:	e3a03000 	mov	r3, #0	; 0x0

Cyg_Mempool_dlmalloc_Implementation::Cyg_Mempool_dlmalloc_Implementation(
                                            cyg_uint8 *base, cyg_int32 size,
                                            CYG_ADDRWORD /* argthru */ )
{
    arenabase = base;
   10304:	e5801000 	str	r1, [r0]
    CYG_ADDRESS front_misalign;
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
   10308:	e580300c 	str	r3, [r0, #12]
   1030c:	e5803008 	str	r3, [r0, #8]

//----------------------------------------------------------------------------

Cyg_Mempool_dlmalloc_Implementation::Cyg_Mempool_dlmalloc_Implementation(
                                            cyg_uint8 *base, cyg_int32 size,
                                            CYG_ADDRWORD /* argthru */ )
   10310:	e92d0030 	push	{r4, r5}
{
    arenabase = base;
    arenasize = size;
   10314:	e5802004 	str	r2, [r0, #4]

//----------------------------------------------------------------------------

Cyg_Mempool_dlmalloc_Implementation::Cyg_Mempool_dlmalloc_Implementation(
                                            cyg_uint8 *base, cyg_int32 size,
                                            CYG_ADDRWORD /* argthru */ )
   10318:	e1a05002 	mov	r5, r2
   1031c:	e1a04001 	mov	r4, r1
    CYG_ADDRESS front_misalign;
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
   10320:	e1a02003 	mov	r2, r3
   10324:	e1a0c000 	mov	ip, r0
    for (i=0; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; i++) {
        av_[ i*2+2 ] = av_[ i*2+3 ] = bin_at(i);
   10328:	e2823001 	add	r3, r2, #1	; 0x1
   1032c:	e1a02003 	mov	r2, r3
   10330:	e1a03183 	lsl	r3, r3, #3
   10334:	e0803003 	add	r3, r0, r3
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
    for (i=0; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; i++) {
   10338:	e3520080 	cmp	r2, #128	; 0x80
        av_[ i*2+2 ] = av_[ i*2+3 ] = bin_at(i);
   1033c:	e58c3010 	str	r3, [ip, #16]
   10340:	e58c3014 	str	r3, [ip, #20]
   10344:	e28cc008 	add	ip, ip, #8	; 0x8
    cyg_int32 correction;

#ifdef CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE
    cyg_ucount16 i;
    av_[0] = av_[1] = 0;
    for (i=0; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; i++) {
   10348:	1afffff6 	bne	10328 <_ZN35Cyg_Mempool_dlmalloc_ImplementationC1EPhij+0x28>
                  "not defined" );
#endif

    front_misalign = (CYG_ADDRESS)chunk2mem(base) & MALLOC_ALIGN_MASK;

    if ( front_misalign > 0 ) {
   1034c:	e2143007 	ands	r3, r4, #7	; 0x7
   10350:	12631008 	rsbne	r1, r3, #8	; 0x8
   10354:	01a01003 	moveq	r1, r3
   10358:	12813010 	addne	r3, r1, #16	; 0x10
   1035c:	03a03010 	moveq	r3, #16	; 0x10
    } else {
        correction = 0;
    }

    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
   10360:	e1550003 	cmp	r5, r3
        // help catch errors. Don't fail now.
        arenabase = NULL; 
    else {
        top = (mchunkptr)(base + correction);
        set_head(top, arenasize | PREV_INUSE);
   10364:	25903004 	ldrcs	r3, [r0, #4]
    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
    else {
        top = (mchunkptr)(base + correction);
   10368:	20842001 	addcs	r2, r4, r1
    }

    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
   1036c:	33a03000 	movcc	r3, #0	; 0x0
    else {
        top = (mchunkptr)(base + correction);
        set_head(top, arenasize | PREV_INUSE);
   10370:	23833001 	orrcs	r3, r3, #1	; 0x1
    }

    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
   10374:	35803000 	strcc	r3, [r0]
    else {
        top = (mchunkptr)(base + correction);
        set_head(top, arenasize | PREV_INUSE);
   10378:	25823004 	strcs	r3, [r2, #4]
    // too small to be useful?
    if ( correction + 2*(unsigned)MALLOC_ALIGNMENT > (unsigned) size )
        // help catch errors. Don't fail now.
        arenabase = NULL; 
    else {
        top = (mchunkptr)(base + correction);
   1037c:	25802010 	strcs	r2, [r0, #16]
        set_head(top, arenasize | PREV_INUSE);
    }
}
   10380:	e8bd0030 	pop	{r4, r5}
   10384:	e12fff1e 	bx	lr

00010388 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi>:
      or the base of its memory arena.)

*/

cyg_uint8 *
Cyg_Mempool_dlmalloc_Implementation::try_alloc( cyg_int32 bytes )
   10388:	e92d0ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp}
  INTERNAL_SIZE_T nb;

  /*  Allow uninitialised (zero sized) heaps because they could exist as a
   *  quirk of the MLT setup where a dynamically sized heap is at the top of
   *  memory. */
  if (NULL==arenabase) return NULL;
   1038c:	e5903000 	ldr	r3, [r0]
   10390:	e3530000 	cmp	r3, #0	; 0x0
      or the base of its memory arena.)

*/

cyg_uint8 *
Cyg_Mempool_dlmalloc_Implementation::try_alloc( cyg_int32 bytes )
   10394:	e24dd008 	sub	sp, sp, #8	; 0x8
   10398:	e1a05000 	mov	r5, r0
  INTERNAL_SIZE_T nb;

  /*  Allow uninitialised (zero sized) heaps because they could exist as a
   *  quirk of the MLT setup where a dynamically sized heap is at the top of
   *  memory. */
  if (NULL==arenabase) return NULL;
   1039c:	1a000004 	bne	103b4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x2c>
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);
   103a0:	e3a05000 	mov	r5, #0	; 0x0

} // Cyg_Mempool_dlmalloc_Implementation::try_alloc()
   103a4:	e1a00005 	mov	r0, r5
   103a8:	e28dd008 	add	sp, sp, #8	; 0x8
   103ac:	e8bd0ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp}
   103b0:	e12fff1e 	bx	lr
  /*  Allow uninitialised (zero sized) heaps because they could exist as a
   *  quirk of the MLT setup where a dynamically sized heap is at the top of
   *  memory. */
  if (NULL==arenabase) return NULL;

  if ((long)bytes < 0) return 0;
   103b4:	e3510000 	cmp	r1, #0	; 0x0
   103b8:	bafffff8 	blt	103a0 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x18>

  nb = request2size(bytes);  /* padded request size; */
   103bc:	e281100b 	add	r1, r1, #11	; 0xb
   103c0:	e3510016 	cmp	r1, #22	; 0x16
   103c4:	d3a07010 	movle	r7, #16	; 0x10
   103c8:	d3a02002 	movle	r2, #2	; 0x2
   103cc:	d3a03004 	movle	r3, #4	; 0x4
   103d0:	da00004b 	ble	10504 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x17c>
   103d4:	e3c17007 	bic	r7, r1, #7	; 0x7

  MALLOC_LOCK;

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   103d8:	e3570f7e 	cmp	r7, #504	; 0x1f8
   103dc:	3a000046 	bcc	104fc <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x174>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   103e0:	e1b024a7 	lsrs	r2, r7, #9
   103e4:	01a021a7 	lsreq	r2, r7, #3
   103e8:	01a03082 	lsleq	r3, r2, #1
   103ec:	0a00001a 	beq	1045c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0xd4>
   103f0:	e3520004 	cmp	r2, #4	; 0x4
   103f4:	91a03327 	lsrls	r3, r7, #6
   103f8:	92832038 	addls	r2, r3, #56	; 0x38
   103fc:	91a03082 	lslls	r3, r2, #1
   10400:	9a000015 	bls	1045c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0xd4>
   10404:	e3520014 	cmp	r2, #20	; 0x14
   10408:	9282205b 	addls	r2, r2, #91	; 0x5b
   1040c:	91a03082 	lslls	r3, r2, #1
   10410:	9a000011 	bls	1045c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0xd4>
   10414:	e3520054 	cmp	r2, #84	; 0x54
   10418:	91a03627 	lsrls	r3, r7, #12
   1041c:	9283206e 	addls	r2, r3, #110	; 0x6e
   10420:	91a03082 	lslls	r3, r2, #1
   10424:	9a00000c 	bls	1045c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0xd4>
   10428:	e3520f55 	cmp	r2, #340	; 0x154
   1042c:	91a037a7 	lsrls	r3, r7, #15
   10430:	92832077 	addls	r2, r3, #119	; 0x77
   10434:	91a03082 	lslls	r3, r2, #1
   10438:	9a000007 	bls	1045c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0xd4>
   1043c:	e3a03e55 	mov	r3, #1360	; 0x550
   10440:	e2833004 	add	r3, r3, #4	; 0x4
   10444:	e1520003 	cmp	r2, r3
   10448:	91a03927 	lsrls	r3, r7, #18
   1044c:	9283207c 	addls	r2, r3, #124	; 0x7c
   10450:	83a0207e 	movhi	r2, #126	; 0x7e
   10454:	83a030fc 	movhi	r3, #252	; 0xfc
   10458:	91a03082 	lslls	r3, r2, #1
    bin = bin_at(idx);
   1045c:	e2833002 	add	r3, r3, #2	; 0x2
   10460:	e1a03103 	lsl	r3, r3, #2
   10464:	e0850003 	add	r0, r5, r3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   10468:	e590c00c 	ldr	ip, [r0, #12]
   1046c:	e150000c 	cmp	r0, ip
   10470:	1a000005 	bne	1048c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x104>
   10474:	ea00000a 	b	104a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x11c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   10478:	e3510000 	cmp	r1, #0	; 0x0
   1047c:	aa00003d 	bge	10578 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1f0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   10480:	e59cc00c 	ldr	ip, [ip, #12]
   10484:	e150000c 	cmp	r0, ip
   10488:	0a000005 	beq	104a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x11c>
    {
      victim_size = chunksize(victim);
   1048c:	e59c3004 	ldr	r3, [ip, #4]
   10490:	e3c33001 	bic	r3, r3, #1	; 0x1
      remainder_size = long_sub_size_t(victim_size, nb);
   10494:	e0671003 	rsb	r1, r7, r3
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   10498:	e351000f 	cmp	r1, #15	; 0xf
   1049c:	dafffff5 	ble	10478 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0xf0>
      {
        --idx; /* adjust to rescan below after checking last remainder */
   104a0:	e2422001 	sub	r2, r2, #1	; 0x1
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
   104a4:	e2829001 	add	r9, r2, #1	; 0x1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   104a8:	e285a010 	add	sl, r5, #16	; 0x10
   104ac:	e59ac008 	ldr	ip, [sl, #8]
   104b0:	e15a000c 	cmp	sl, ip
   104b4:	02850008 	addeq	r0, r5, #8	; 0x8
   104b8:	058d0004 	streq	r0, [sp, #4]
   104bc:	0a000067 	beq	10660 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x2d8>
  {
    victim_size = chunksize(victim);
   104c0:	e59c3004 	ldr	r3, [ip, #4]
   104c4:	e3c34001 	bic	r4, r3, #1	; 0x1
    remainder_size = long_sub_size_t(victim_size, nb);
   104c8:	e0670004 	rsb	r0, r7, r4

    if (remainder_size >= (long)MINSIZE) /* re-split */
   104cc:	e350000f 	cmp	r0, #15	; 0xf
   104d0:	ca00001d 	bgt	1054c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c4>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
   104d4:	e3500000 	cmp	r0, #0	; 0x0
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   104d8:	e58aa00c 	str	sl, [sl, #12]
   104dc:	e58aa008 	str	sl, [sl, #8]

    if (remainder_size >= 0)  /* exhaust */
   104e0:	ba000098 	blt	10748 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x3c0>
    {
      set_inuse_bit_at_offset(victim, victim_size);
   104e4:	e08c2004 	add	r2, ip, r4
   104e8:	e5923004 	ldr	r3, [r2, #4]
   104ec:	e3833001 	orr	r3, r3, #1	; 0x1
   104f0:	e5823004 	str	r3, [r2, #4]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
   104f4:	e28c5008 	add	r5, ip, #8	; 0x8
   104f8:	eaffffa9 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>

  MALLOC_LOCK;

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   104fc:	e1a021a7 	lsr	r2, r7, #3
   10500:	e1a03082 	lsl	r3, r2, #1
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   10504:	e2833002 	add	r3, r3, #2	; 0x2
   10508:	e1a03103 	lsl	r3, r3, #2
   1050c:	e0853003 	add	r3, r5, r3
    victim = last(q);
   10510:	e593c00c 	ldr	ip, [r3, #12]

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   10514:	e15c0003 	cmp	ip, r3
   10518:	0a000084 	beq	10730 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x3a8>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   1051c:	e59c3004 	ldr	r3, [ip, #4]
   10520:	e3c33001 	bic	r3, r3, #1	; 0x1
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
   10524:	e08c3003 	add	r3, ip, r3
   10528:	e5932004 	ldr	r2, [r3, #4]
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   1052c:	e59c000c 	ldr	r0, [ip, #12]
   10530:	e59c1008 	ldr	r1, [ip, #8]
      set_inuse_bit_at_offset(victim, victim_size);
   10534:	e3822001 	orr	r2, r2, #1	; 0x1
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   10538:	e5801008 	str	r1, [r0, #8]
      set_inuse_bit_at_offset(victim, victim_size);
   1053c:	e5832004 	str	r2, [r3, #4]
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   10540:	e581000c 	str	r0, [r1, #12]
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
   10544:	e28c5008 	add	r5, ip, #8	; 0x8
   10548:	eaffff95 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
   1054c:	e08c2007 	add	r2, ip, r7
      set_head(victim, nb | PREV_INUSE);
   10550:	e3873001 	orr	r3, r7, #1	; 0x1
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   10554:	e3801001 	orr	r1, r0, #1	; 0x1
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   10558:	e58c3004 	str	r3, [ip, #4]
      link_last_remainder(remainder);
   1055c:	e58a200c 	str	r2, [sl, #12]
   10560:	e58a2008 	str	r2, [sl, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
   10564:	e7820000 	str	r0, [r2, r0]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   10568:	e9820402 	stmib	r2, {r1, sl}

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
   1056c:	e582a00c 	str	sl, [r2, #12]
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
   10570:	e28c5008 	add	r5, ip, #8	; 0x8
   10574:	eaffff8a 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   10578:	e08c0003 	add	r0, ip, r3
   1057c:	e5903004 	ldr	r3, [r0, #4]
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   10580:	e59c100c 	ldr	r1, [ip, #12]
   10584:	e59c2008 	ldr	r2, [ip, #8]
        set_inuse_bit_at_offset(victim, victim_size);
   10588:	e3833001 	orr	r3, r3, #1	; 0x1
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   1058c:	e5812008 	str	r2, [r1, #8]
        set_inuse_bit_at_offset(victim, victim_size);
   10590:	e5803004 	str	r3, [r0, #4]
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   10594:	e582100c 	str	r1, [r2, #12]
        set_inuse_bit_at_offset(victim, victim_size);
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
        return chunk2mem(victim);
   10598:	e28c5008 	add	r5, ip, #8	; 0x8
   1059c:	eaffff80 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   105a0:	e1a014a4 	lsr	r1, r4, #9
   105a4:	e3510004 	cmp	r1, #4	; 0x4
   105a8:	91a03324 	lsrls	r3, r4, #6
   105ac:	92831038 	addls	r1, r3, #56	; 0x38
   105b0:	91a03081 	lslls	r3, r1, #1
   105b4:	9a000015 	bls	10610 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x288>
   105b8:	e3510014 	cmp	r1, #20	; 0x14
   105bc:	9281105b 	addls	r1, r1, #91	; 0x5b
   105c0:	91a03081 	lslls	r3, r1, #1
   105c4:	9a000011 	bls	10610 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x288>
   105c8:	e3510054 	cmp	r1, #84	; 0x54
   105cc:	91a03624 	lsrls	r3, r4, #12
   105d0:	9283106e 	addls	r1, r3, #110	; 0x6e
   105d4:	91a03081 	lslls	r3, r1, #1
   105d8:	9a00000c 	bls	10610 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x288>
   105dc:	e3510f55 	cmp	r1, #340	; 0x154
   105e0:	91a037a4 	lsrls	r3, r4, #15
   105e4:	92831077 	addls	r1, r3, #119	; 0x77
   105e8:	91a03081 	lslls	r3, r1, #1
   105ec:	9a000007 	bls	10610 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x288>
   105f0:	e3a03e55 	mov	r3, #1360	; 0x550
   105f4:	e2833004 	add	r3, r3, #4	; 0x4
   105f8:	e1510003 	cmp	r1, r3
   105fc:	91a03924 	lsrls	r3, r4, #18
   10600:	9283107c 	addls	r1, r3, #124	; 0x7c
   10604:	83a0107e 	movhi	r1, #126	; 0x7e
   10608:	83a030fc 	movhi	r3, #252	; 0xfc
   1060c:	91a03081 	lslls	r3, r1, #1
   10610:	e2833002 	add	r3, r3, #2	; 0x2
   10614:	e1a03103 	lsl	r3, r3, #2
   10618:	e0852003 	add	r2, r5, r3
   1061c:	e5920008 	ldr	r0, [r2, #8]
   10620:	e1500002 	cmp	r0, r2
   10624:	0a000096 	beq	10884 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x4fc>
   10628:	e5903004 	ldr	r3, [r0, #4]
   1062c:	e3c33001 	bic	r3, r3, #1	; 0x1
   10630:	e1540003 	cmp	r4, r3
   10634:	2a000002 	bcs	10644 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x2bc>
   10638:	e5900008 	ldr	r0, [r0, #8]
   1063c:	e1520000 	cmp	r2, r0
   10640:	1afffff8 	bne	10628 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x2a0>
   10644:	e2852008 	add	r2, r5, #8	; 0x8
   10648:	e590300c 	ldr	r3, [r0, #12]
   1064c:	e58d2004 	str	r2, [sp, #4]
   10650:	e58c300c 	str	r3, [ip, #12]
   10654:	e58c0008 	str	r0, [ip, #8]
   10658:	e580c00c 	str	ip, [r0, #12]
   1065c:	e583c008 	str	ip, [r3, #8]
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   10660:	e3a03001 	mov	r3, #1	; 0x1
   10664:	e1a02149 	asr	r2, r9, #2
   10668:	e1a01213 	lsl	r1, r3, r2
   1066c:	e59d3004 	ldr	r3, [sp, #4]
   10670:	e5938004 	ldr	r8, [r3, #4]
   10674:	e1510008 	cmp	r1, r8
   10678:	8a000063 	bhi	1080c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x484>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   1067c:	e1110008 	tst	r1, r8
   10680:	1a000008 	bne	106a8 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x320>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   10684:	e1a01081 	lsl	r1, r1, #1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   10688:	e3c93003 	bic	r3, r9, #3	; 0x3
      block <<= 1;
      while ((block & binblocks) == 0)
   1068c:	e1110008 	tst	r1, r8
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   10690:	e2839004 	add	r9, r3, #4	; 0x4
      block <<= 1;
      while ((block & binblocks) == 0)
   10694:	1a000003 	bne	106a8 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x320>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   10698:	e1a01081 	lsl	r1, r1, #1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   1069c:	e1110008 	tst	r1, r8
      {
        idx += BINBLOCKWIDTH;
   106a0:	e2899004 	add	r9, r9, #4	; 0x4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   106a4:	0afffffb 	beq	10698 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x310>
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   106a8:	e2893001 	add	r3, r9, #1	; 0x1
   106ac:	e1a03183 	lsl	r3, r3, #3
   106b0:	e0850003 	add	r0, r5, r3
   106b4:	e1a0b009 	mov	fp, r9
   106b8:	e1a02000 	mov	r2, r0
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   106bc:	e592600c 	ldr	r6, [r2, #12]
   106c0:	e1520006 	cmp	r2, r6
   106c4:	1a000005 	bne	106e0 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x358>
   106c8:	ea000032 	b	10798 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x410>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   106cc:	e3540000 	cmp	r4, #0	; 0x0
   106d0:	aa000035 	bge	107ac <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x424>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   106d4:	e596600c 	ldr	r6, [r6, #12]
   106d8:	e1520006 	cmp	r2, r6
   106dc:	0a00002d 	beq	10798 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x410>
        {
          victim_size = chunksize(victim);
   106e0:	e5963004 	ldr	r3, [r6, #4]
   106e4:	e3c33001 	bic	r3, r3, #1	; 0x1
          remainder_size = long_sub_size_t(victim_size, nb);
   106e8:	e0674003 	rsb	r4, r7, r3

          if (remainder_size >= (long)MINSIZE) /* split */
   106ec:	e354000f 	cmp	r4, #15	; 0xf
   106f0:	dafffff5 	ble	106cc <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x344>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   106f4:	e1a05006 	mov	r5, r6
   106f8:	e596c00c 	ldr	ip, [r6, #12]
   106fc:	e5b50008 	ldr	r0, [r5, #8]!
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   10700:	e0863007 	add	r3, r6, r7
            set_head(victim, nb | PREV_INUSE);
   10704:	e3871001 	orr	r1, r7, #1	; 0x1
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   10708:	e3842001 	orr	r2, r4, #1	; 0x1

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   1070c:	e58c0008 	str	r0, [ip, #8]
   10710:	e580c00c 	str	ip, [r0, #12]
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   10714:	e5861004 	str	r1, [r6, #4]
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
   10718:	e58a3008 	str	r3, [sl, #8]
   1071c:	e58a300c 	str	r3, [sl, #12]
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
   10720:	e7834004 	str	r4, [r3, r4]
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   10724:	e9830404 	stmib	r3, {r2, sl}
          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
   10728:	e583a00c 	str	sl, [r3, #12]
   1072c:	eaffff1c 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
   10730:	e28c3008 	add	r3, ip, #8	; 0x8
      victim = last(q);
   10734:	e593c00c 	ldr	ip, [r3, #12]
    }
#endif
    if (victim != q)
   10738:	e153000c 	cmp	r3, ip
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   1073c:	02829002 	addeq	r9, r2, #2	; 0x2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   10740:	0affff58 	beq	104a8 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x120>
   10744:	eaffff74 	b	1051c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x194>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   10748:	e3540c02 	cmp	r4, #512	; 0x200
   1074c:	2affff93 	bcs	105a0 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x218>
   10750:	e2852008 	add	r2, r5, #8	; 0x8
   10754:	e5921004 	ldr	r1, [r2, #4]
   10758:	e1a031a4 	lsr	r3, r4, #3
   1075c:	e1a00143 	asr	r0, r3, #2
   10760:	e58d2004 	str	r2, [sp, #4]
   10764:	e3a02001 	mov	r2, #1	; 0x1
   10768:	e1811012 	orr	r1, r1, r2, lsl r0
   1076c:	e0833002 	add	r3, r3, r2
   10770:	e1a03183 	lsl	r3, r3, #3
   10774:	e0853003 	add	r3, r5, r3
   10778:	e5932008 	ldr	r2, [r3, #8]
   1077c:	e59d0004 	ldr	r0, [sp, #4]
   10780:	e58c300c 	str	r3, [ip, #12]
   10784:	e58c2008 	str	r2, [ip, #8]
   10788:	e5801004 	str	r1, [r0, #4]
   1078c:	e582c00c 	str	ip, [r2, #12]
   10790:	e583c008 	str	ip, [r3, #8]
   10794:	eaffffb1 	b	10660 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x2d8>
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);

      /* For each bin in this block ... */
      do
   10798:	e28bb001 	add	fp, fp, #1	; 0x1
   1079c:	e31b0003 	tst	fp, #3	; 0x3
   107a0:	0a00000b 	beq	107d4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x44c>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   107a4:	e2822008 	add	r2, r2, #8	; 0x8
   107a8:	eaffffc3 	b	106bc <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x334>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   107ac:	e0860003 	add	r0, r6, r3
   107b0:	e5903004 	ldr	r3, [r0, #4]
            unlink(victim, bck, fwd);
   107b4:	e1a05006 	mov	r5, r6
   107b8:	e596100c 	ldr	r1, [r6, #12]
   107bc:	e5b52008 	ldr	r2, [r5, #8]!
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   107c0:	e3833001 	orr	r3, r3, #1	; 0x1
   107c4:	e5803004 	str	r3, [r0, #4]
            unlink(victim, bck, fwd);
   107c8:	e5812008 	str	r2, [r1, #8]
   107cc:	e582100c 	str	r1, [r2, #12]
   107d0:	eafffef3 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   107d4:	e1a02009 	mov	r2, r9
   107d8:	e1a0c000 	mov	ip, r0

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   107dc:	e3120003 	tst	r2, #3	; 0x3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   107e0:	e1a0000c 	mov	r0, ip
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   107e4:	e2422001 	sub	r2, r2, #1	; 0x1

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   107e8:	0a00002f 	beq	108ac <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x524>
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
   107ec:	e410c008 	ldr	ip, [r0], #-8
   107f0:	e15c0000 	cmp	ip, r0
   107f4:	0afffff8 	beq	107dc <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x454>
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   107f8:	e1a01081 	lsl	r1, r1, #1
   107fc:	e1510008 	cmp	r1, r8
   10800:	8a000001 	bhi	1080c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x484>
   10804:	e3510000 	cmp	r1, #0	; 0x0
   10808:	1a000014 	bne	10860 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x4d8>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   1080c:	e59d2004 	ldr	r2, [sp, #4]
   10810:	e5920008 	ldr	r0, [r2, #8]
   10814:	e5902004 	ldr	r2, [r0, #4]
   10818:	e3c22001 	bic	r2, r2, #1	; 0x1
   1081c:	e0671002 	rsb	r1, r7, r2
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   10820:	e351000f 	cmp	r1, #15	; 0xf
   10824:	c3a03000 	movgt	r3, #0	; 0x0
   10828:	d3a03001 	movle	r3, #1	; 0x1
   1082c:	e1570002 	cmp	r7, r2
   10830:	83833001 	orrhi	r3, r3, #1	; 0x1
   10834:	e3530000 	cmp	r3, #0	; 0x0
   10838:	1afffed8 	bne	103a0 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x18>
      CYG_MEMALLOC_FAIL(bytes);
      return NULL; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   1083c:	e3872001 	orr	r2, r7, #1	; 0x1
   10840:	e5802004 	str	r2, [r0, #4]
  top = chunk_at_offset(victim, nb);
   10844:	e59d2004 	ldr	r2, [sp, #4]
   10848:	e0803007 	add	r3, r0, r7
  set_head(top, remainder_size | PREV_INUSE);
   1084c:	e3811001 	orr	r1, r1, #1	; 0x1
   10850:	e5831004 	str	r1, [r3, #4]
      return NULL; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   10854:	e5823008 	str	r3, [r2, #8]
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);
   10858:	e2805008 	add	r5, r0, #8	; 0x8
   1085c:	eafffed0 	b	103a4 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x1c>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   10860:	e1110008 	tst	r1, r8
   10864:	11a0900b 	movne	r9, fp
   10868:	1affff8e 	bne	106a8 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x320>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   1086c:	e1a01081 	lsl	r1, r1, #1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   10870:	e1110008 	tst	r1, r8
        {
          idx += BINBLOCKWIDTH;
   10874:	e28bb004 	add	fp, fp, #4	; 0x4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   10878:	0afffffb 	beq	1086c <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x4e4>
   1087c:	e1a0900b 	mov	r9, fp
   10880:	eaffff88 	b	106a8 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x320>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   10884:	e2852008 	add	r2, r5, #8	; 0x8
   10888:	e5923004 	ldr	r3, [r2, #4]
   1088c:	e58d2004 	str	r2, [sp, #4]
   10890:	e1a01141 	asr	r1, r1, #2
   10894:	e3a02001 	mov	r2, #1	; 0x1
   10898:	e1833112 	orr	r3, r3, r2, lsl r1
   1089c:	e59d2004 	ldr	r2, [sp, #4]
   108a0:	e5823004 	str	r3, [r2, #4]
   108a4:	e1a03000 	mov	r3, r0
   108a8:	eaffff68 	b	10650 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x2c8>

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
   108ac:	e1e03001 	mvn	r3, r1
   108b0:	e59d0004 	ldr	r0, [sp, #4]
   108b4:	e0088003 	and	r8, r8, r3
   108b8:	e5808004 	str	r8, [r0, #4]
   108bc:	eaffffcd 	b	107f8 <_ZN35Cyg_Mempool_dlmalloc_Implementation9try_allocEi+0x470>

000108c0 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == NULL)                              /* free(NULL) has no effect */
   108c0:	e3510000 	cmp	r1, #0	; 0x0
          placed in corresponding bins. (This includes the case of
          consolidating with the current `last_remainder').
*/

cyg_bool
Cyg_Mempool_dlmalloc_Implementation::free( cyg_uint8 *mem, cyg_int32 )
   108c4:	e92d01f0 	push	{r4, r5, r6, r7, r8}
   108c8:	e1a07000 	mov	r7, r0
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == NULL)                              /* free(NULL) has no effect */
   108cc:	01a00001 	moveq	r0, r1
   108d0:	0a00004e 	beq	10a10 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x150>
    return false;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   108d4:	e2415008 	sub	r5, r1, #8	; 0x8
  hd = p->size;
   108d8:	e5950004 	ldr	r0, [r5, #4]
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   108dc:	e2878008 	add	r8, r7, #8	; 0x8
  p = mem2chunk(mem);
  hd = p->size;

  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   108e0:	e3c04001 	bic	r4, r0, #1	; 0x1
  next = chunk_at_offset(p, sz);
   108e4:	e085c004 	add	ip, r5, r4
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   108e8:	e5983008 	ldr	r3, [r8, #8]

  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   108ec:	e59c2004 	ldr	r2, [ip, #4]
  
  if (next == top)                            /* merge with top */
   108f0:	e153000c 	cmp	r3, ip

  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   108f4:	e3c26001 	bic	r6, r2, #1	; 0x1
  
  if (next == top)                            /* merge with top */
   108f8:	0a000072 	beq	10ac8 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x208>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   108fc:	e2100001 	ands	r0, r0, #1	; 0x1
    top = p;
    MALLOC_UNLOCK;
    return true;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   10900:	e58c6004 	str	r6, [ip, #4]

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   10904:	13a01000 	movne	r1, #0	; 0x0
   10908:	0a000042 	beq	10a18 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x158>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   1090c:	e08c3006 	add	r3, ip, r6
   10910:	e5932004 	ldr	r2, [r3, #4]
   10914:	e3120001 	tst	r2, #1	; 0x1
   10918:	1a000006 	bne	10938 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x78>
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   1091c:	e3510000 	cmp	r1, #0	; 0x0
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   10920:	e0844006 	add	r4, r4, r6
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   10924:	159c2008 	ldrne	r2, [ip, #8]
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   10928:	0a00004a 	beq	10a58 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x198>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   1092c:	e59c300c 	ldr	r3, [ip, #12]
   10930:	e5832008 	str	r2, [r3, #8]
   10934:	e582300c 	str	r3, [r2, #12]
  }


  set_head(p, sz | PREV_INUSE);
   10938:	e3843001 	orr	r3, r4, #1	; 0x1
  set_foot(p, sz);
  if (!islr)
   1093c:	e3510000 	cmp	r1, #0	; 0x0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   10940:	e5853004 	str	r3, [r5, #4]
  set_foot(p, sz);
   10944:	e7854004 	str	r4, [r5, r4]
  if (!islr)
   10948:	1a00002f 	bne	10a0c <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x14c>
    frontlink(p, sz, idx, bck, fwd);  
   1094c:	e3540c02 	cmp	r4, #512	; 0x200
   10950:	3a00004d 	bcc	10a8c <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x1cc>
   10954:	e1a014a4 	lsr	r1, r4, #9
   10958:	e3510004 	cmp	r1, #4	; 0x4
   1095c:	91a03324 	lsrls	r3, r4, #6
   10960:	92831038 	addls	r1, r3, #56	; 0x38
   10964:	91a03081 	lslls	r3, r1, #1
   10968:	9a000015 	bls	109c4 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x104>
   1096c:	e3510014 	cmp	r1, #20	; 0x14
   10970:	9281105b 	addls	r1, r1, #91	; 0x5b
   10974:	91a03081 	lslls	r3, r1, #1
   10978:	9a000011 	bls	109c4 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x104>
   1097c:	e3510054 	cmp	r1, #84	; 0x54
   10980:	91a03624 	lsrls	r3, r4, #12
   10984:	9283106e 	addls	r1, r3, #110	; 0x6e
   10988:	91a03081 	lslls	r3, r1, #1
   1098c:	9a00000c 	bls	109c4 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x104>
   10990:	e3510f55 	cmp	r1, #340	; 0x154
   10994:	91a037a4 	lsrls	r3, r4, #15
   10998:	92831077 	addls	r1, r3, #119	; 0x77
   1099c:	91a03081 	lslls	r3, r1, #1
   109a0:	9a000007 	bls	109c4 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x104>
   109a4:	e3a03e55 	mov	r3, #1360	; 0x550
   109a8:	e2833004 	add	r3, r3, #4	; 0x4
   109ac:	e1510003 	cmp	r1, r3
   109b0:	91a03924 	lsrls	r3, r4, #18
   109b4:	9283107c 	addls	r1, r3, #124	; 0x7c
   109b8:	83a0107e 	movhi	r1, #126	; 0x7e
   109bc:	83a030fc 	movhi	r3, #252	; 0xfc
   109c0:	91a03081 	lslls	r3, r1, #1
   109c4:	e2833002 	add	r3, r3, #2	; 0x2
   109c8:	e1a03103 	lsl	r3, r3, #2
   109cc:	e0870003 	add	r0, r7, r3
   109d0:	e590c008 	ldr	ip, [r0, #8]
   109d4:	e15c0000 	cmp	ip, r0
   109d8:	0a000049 	beq	10b04 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x244>
   109dc:	e59c3004 	ldr	r3, [ip, #4]
   109e0:	e3c33001 	bic	r3, r3, #1	; 0x1
   109e4:	e1540003 	cmp	r4, r3
   109e8:	2a000002 	bcs	109f8 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x138>
   109ec:	e59cc008 	ldr	ip, [ip, #8]
   109f0:	e150000c 	cmp	r0, ip
   109f4:	1afffff8 	bne	109dc <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x11c>
   109f8:	e59c300c 	ldr	r3, [ip, #12]
   109fc:	e585300c 	str	r3, [r5, #12]
   10a00:	e585c008 	str	ip, [r5, #8]
   10a04:	e58c500c 	str	r5, [ip, #12]
   10a08:	e5835008 	str	r5, [r3, #8]
   10a0c:	e3a00001 	mov	r0, #1	; 0x1

  MALLOC_UNLOCK;

  return true;
} // Cyg_Mempool_dlmalloc_Implementation::free()
   10a10:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
   10a14:	e12fff1e 	bx	lr

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
   10a18:	e5112008 	ldr	r2, [r1, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
   10a1c:	e0625005 	rsb	r5, r2, r5
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   10a20:	e5951008 	ldr	r1, [r5, #8]
   10a24:	e2873010 	add	r3, r7, #16	; 0x10
   10a28:	e1510003 	cmp	r1, r3
      islr = 1;
    else
      unlink(p, bck, fwd);
   10a2c:	1595300c 	ldrne	r3, [r5, #12]
   10a30:	15831008 	strne	r1, [r3, #8]
   10a34:	1581300c 	strne	r3, [r1, #12]
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   10a38:	e08c3006 	add	r3, ip, r6

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;
   10a3c:	e0844002 	add	r4, r4, r2
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   10a40:	e5932004 	ldr	r2, [r3, #4]
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   10a44:	03a01001 	moveq	r1, #1	; 0x1
      islr = 1;
    else
      unlink(p, bck, fwd);
   10a48:	11a01000 	movne	r1, r0
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   10a4c:	e3120001 	tst	r2, #1	; 0x1
   10a50:	1affffb8 	bne	10938 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x78>
   10a54:	eaffffb0 	b	1091c <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x5c>
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   10a58:	e59c2008 	ldr	r2, [ip, #8]
   10a5c:	e2873010 	add	r3, r7, #16	; 0x10
   10a60:	e1520003 	cmp	r2, r3
   10a64:	1affffb0 	bne	1092c <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x6c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   10a68:	e3843001 	orr	r3, r4, #1	; 0x1
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   10a6c:	e582500c 	str	r5, [r2, #12]
   10a70:	e5825008 	str	r5, [r2, #8]
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   10a74:	e7854004 	str	r4, [r5, r4]
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   10a78:	e5853004 	str	r3, [r5, #4]
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   10a7c:	e5852008 	str	r2, [r5, #8]
   10a80:	e585200c 	str	r2, [r5, #12]
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   10a84:	e3a00001 	mov	r0, #1	; 0x1
   10a88:	eaffffe0 	b	10a10 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x150>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   10a8c:	e1a031a4 	lsr	r3, r4, #3
   10a90:	e5981004 	ldr	r1, [r8, #4]
   10a94:	e1a02143 	asr	r2, r3, #2
   10a98:	e3a00001 	mov	r0, #1	; 0x1
   10a9c:	e1811210 	orr	r1, r1, r0, lsl r2
   10aa0:	e0833000 	add	r3, r3, r0
   10aa4:	e1a03183 	lsl	r3, r3, #3
   10aa8:	e0873003 	add	r3, r7, r3
   10aac:	e5932008 	ldr	r2, [r3, #8]
   10ab0:	e585300c 	str	r3, [r5, #12]
   10ab4:	e5852008 	str	r2, [r5, #8]
   10ab8:	e5881004 	str	r1, [r8, #4]
   10abc:	e582500c 	str	r5, [r2, #12]
   10ac0:	e5835008 	str	r5, [r3, #8]
   10ac4:	eaffffd1 	b	10a10 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x150>
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   10ac8:	e3100001 	tst	r0, #1	; 0x1
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   10acc:	e086c004 	add	ip, r6, r4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   10ad0:	1a000006 	bne	10af0 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x230>
    {
      prevsz = p->prev_size;
   10ad4:	e5111008 	ldr	r1, [r1, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
   10ad8:	e0615005 	rsb	r5, r1, r5
      sz += prevsz;
      unlink(p, bck, fwd);
   10adc:	e595200c 	ldr	r2, [r5, #12]
   10ae0:	e5953008 	ldr	r3, [r5, #8]
   10ae4:	e5823008 	str	r3, [r2, #8]
   10ae8:	e583200c 	str	r2, [r3, #12]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
   10aec:	e08cc001 	add	ip, ip, r1
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   10af0:	e38c3001 	orr	r3, ip, #1	; 0x1
    top = p;
   10af4:	e5885008 	str	r5, [r8, #8]
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   10af8:	e5853004 	str	r3, [r5, #4]
    top = p;
   10afc:	e3a00001 	mov	r0, #1	; 0x1
   10b00:	eaffffc2 	b	10a10 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x150>


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   10b04:	e5983004 	ldr	r3, [r8, #4]
   10b08:	e1a01141 	asr	r1, r1, #2
   10b0c:	e3a02001 	mov	r2, #1	; 0x1
   10b10:	e1833112 	orr	r3, r3, r2, lsl r1
   10b14:	e5883004 	str	r3, [r8, #4]
   10b18:	e1a0300c 	mov	r3, ip
   10b1c:	eaffffb6 	b	109fc <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi+0x13c>

00010b20 <_ZN35Cyg_Mempool_dlmalloc_Implementation10get_statusEtR18Cyg_Mempool_Status>:
void
Cyg_Mempool_dlmalloc_Implementation::get_status( 
                                  cyg_mempool_status_flag_t flags,
                                  Cyg_Mempool_Status &status )
{
    if (0 != (flags&(CYG_MEMPOOL_STAT_FREEBLOCKS|CYG_MEMPOOL_STAT_TOTALFREE|
   10b20:	e311005c 	tst	r1, #92	; 0x5c
// flags is a bitmask of requested fields to fill in. The flags are
// defined in common.hxx
void
Cyg_Mempool_dlmalloc_Implementation::get_status( 
                                  cyg_mempool_status_flag_t flags,
                                  Cyg_Mempool_Status &status )
   10b24:	e92d01f0 	push	{r4, r5, r6, r7, r8}
   10b28:	e1a08001 	mov	r8, r1
   10b2c:	e1a06000 	mov	r6, r0
   10b30:	e1a07002 	mov	r7, r2
{
    if (0 != (flags&(CYG_MEMPOOL_STAT_FREEBLOCKS|CYG_MEMPOOL_STAT_TOTALFREE|
   10b34:	0a000024 	beq	10bcc <_ZN35Cyg_Mempool_dlmalloc_Implementation10get_statusEtR18Cyg_Mempool_Status+0xac>
        cyg_int32 maxfree;
#ifdef CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG
        mchunkptr q;
#endif
        
        INTERNAL_SIZE_T avail = chunksize(top);
   10b38:	e5903010 	ldr	r3, [r0, #16]
   10b3c:	e5932004 	ldr	r2, [r3, #4]
   10b40:	e3c20001 	bic	r0, r2, #1	; 0x1
        int   navail = ((long)(avail) >= (long)MINSIZE)? 1 : 0; 
   10b44:	e350000f 	cmp	r0, #15	; 0xf
   10b48:	d3a04000 	movle	r4, #0	; 0x0
   10b4c:	c3a04001 	movgt	r4, #1	; 0x1
   10b50:	e1a01000 	mov	r1, r0
   10b54:	e3a03001 	mov	r3, #1	; 0x1
        maxfree = avail;
        
        for (i = 1; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; ++i) {
            b = bin_at(i);
   10b58:	e2835001 	add	r5, r3, #1	; 0x1
   10b5c:	e1a03185 	lsl	r3, r5, #3
   10b60:	e0862003 	add	r2, r6, r3
            for (p = last(b); p != b; p = p->bk) {
   10b64:	e592c00c 	ldr	ip, [r2, #12]
   10b68:	e152000c 	cmp	r2, ip
   10b6c:	0a000008 	beq	10b94 <_ZN35Cyg_Mempool_dlmalloc_Implementation10get_statusEtR18Cyg_Mempool_Status+0x74>
                     (q < top) && inuse(q) && 
                         (long)(chunksize(q)) >= (long)MINSIZE; 
                     q = next_chunk(q))
                    check_inuse_chunk(q);
#endif
                chunksizep = chunksize(p);
   10b70:	e59c3004 	ldr	r3, [ip, #4]
        int   navail = ((long)(avail) >= (long)MINSIZE)? 1 : 0; 
        maxfree = avail;
        
        for (i = 1; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; ++i) {
            b = bin_at(i);
            for (p = last(b); p != b; p = p->bk) {
   10b74:	e59cc00c 	ldr	ip, [ip, #12]
                     (q < top) && inuse(q) && 
                         (long)(chunksize(q)) >= (long)MINSIZE; 
                     q = next_chunk(q))
                    check_inuse_chunk(q);
#endif
                chunksizep = chunksize(p);
   10b78:	e3c33001 	bic	r3, r3, #1	; 0x1
                avail += chunksizep;
   10b7c:	e1510003 	cmp	r1, r3
   10b80:	b1a01003 	movlt	r1, r3
        int   navail = ((long)(avail) >= (long)MINSIZE)? 1 : 0; 
        maxfree = avail;
        
        for (i = 1; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; ++i) {
            b = bin_at(i);
            for (p = last(b); p != b; p = p->bk) {
   10b84:	e152000c 	cmp	r2, ip
                         (long)(chunksize(q)) >= (long)MINSIZE; 
                     q = next_chunk(q))
                    check_inuse_chunk(q);
#endif
                chunksizep = chunksize(p);
                avail += chunksizep;
   10b88:	e0800003 	add	r0, r0, r3
                if ( chunksizep > maxfree )
                    maxfree = chunksizep;
                navail++;
   10b8c:	e2844001 	add	r4, r4, #1	; 0x1
        int   navail = ((long)(avail) >= (long)MINSIZE)? 1 : 0; 
        maxfree = avail;
        
        for (i = 1; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; ++i) {
            b = bin_at(i);
            for (p = last(b); p != b; p = p->bk) {
   10b90:	1afffff6 	bne	10b70 <_ZN35Cyg_Mempool_dlmalloc_Implementation10get_statusEtR18Cyg_Mempool_Status+0x50>
        
        INTERNAL_SIZE_T avail = chunksize(top);
        int   navail = ((long)(avail) >= (long)MINSIZE)? 1 : 0; 
        maxfree = avail;
        
        for (i = 1; i < CYGPRI_MEMALLOC_ALLOCATOR_DLMALLOC_NAV; ++i) {
   10b94:	e3550080 	cmp	r5, #128	; 0x80
   10b98:	e1a03005 	mov	r3, r5
   10b9c:	1affffed 	bne	10b58 <_ZN35Cyg_Mempool_dlmalloc_Implementation10get_statusEtR18Cyg_Mempool_Status+0x38>
                    maxfree = chunksizep;
                navail++;
            }
        }
    
        if ( 0 != (flags & CYG_MEMPOOL_STAT_TOTALALLOCATED) )
   10ba0:	e3180008 	tst	r8, #8	; 0x8
            status.totalallocated = arenasize - avail;
   10ba4:	15963004 	ldrne	r3, [r6, #4]
   10ba8:	10603003 	rsbne	r3, r0, r3
   10bac:	1587300c 	strne	r3, [r7, #12]
        // test flag first
        status.totalfree = (avail & ~(MALLOC_ALIGN_MASK)) - SIZE_SZ - MINSIZE;
        CYG_ASSERT( ((avail + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
                    >= MINSIZE, "free mem negative!" );
        status.freeblocks = navail;
        status.maxfree = (maxfree & ~(MALLOC_ALIGN_MASK)) - SIZE_SZ - MINSIZE;
   10bb0:	e3c12007 	bic	r2, r1, #7	; 0x7
    
        if ( 0 != (flags & CYG_MEMPOOL_STAT_TOTALALLOCATED) )
            status.totalallocated = arenasize - avail;
        // as quick or quicker to just set most of these, rather than
        // test flag first
        status.totalfree = (avail & ~(MALLOC_ALIGN_MASK)) - SIZE_SZ - MINSIZE;
   10bb4:	e3c03007 	bic	r3, r0, #7	; 0x7
   10bb8:	e2433014 	sub	r3, r3, #20	; 0x14
        CYG_ASSERT( ((avail + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
                    >= MINSIZE, "free mem negative!" );
        status.freeblocks = navail;
        status.maxfree = (maxfree & ~(MALLOC_ALIGN_MASK)) - SIZE_SZ - MINSIZE;
   10bbc:	e2422014 	sub	r2, r2, #20	; 0x14
    
        if ( 0 != (flags & CYG_MEMPOOL_STAT_TOTALALLOCATED) )
            status.totalallocated = arenasize - avail;
        // as quick or quicker to just set most of these, rather than
        // test flag first
        status.totalfree = (avail & ~(MALLOC_ALIGN_MASK)) - SIZE_SZ - MINSIZE;
   10bc0:	e5873010 	str	r3, [r7, #16]
        CYG_ASSERT( ((avail + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
                    >= MINSIZE, "free mem negative!" );
        status.freeblocks = navail;
   10bc4:	e5874008 	str	r4, [r7, #8]
        status.maxfree = (maxfree & ~(MALLOC_ALIGN_MASK)) - SIZE_SZ - MINSIZE;
   10bc8:	e5872018 	str	r2, [r7, #24]
    } // if

    // as quick or quicker to just set most of these, rather than
    // test flag first
    status.arenabase = status.origbase = arenabase;
    status.arenasize = status.origsize = arenasize;
   10bcc:	e5961004 	ldr	r1, [r6, #4]
                    "max free block size negative!" );
    } // if

    // as quick or quicker to just set most of these, rather than
    // test flag first
    status.arenabase = status.origbase = arenabase;
   10bd0:	e5962000 	ldr	r2, [r6]
    status.arenasize = status.origsize = arenasize;
    status.maxoverhead = MINSIZE + MALLOC_ALIGNMENT;
   10bd4:	e3a03018 	mov	r3, #24	; 0x18
   10bd8:	e5c73028 	strb	r3, [r7, #40]
                    "max free block size negative!" );
    } // if

    // as quick or quicker to just set most of these, rather than
    // test flag first
    status.arenabase = status.origbase = arenabase;
   10bdc:	e5872000 	str	r2, [r7]
    status.arenasize = status.origsize = arenasize;
   10be0:	e5871004 	str	r1, [r7, #4]
                    "max free block size negative!" );
    } // if

    // as quick or quicker to just set most of these, rather than
    // test flag first
    status.arenabase = status.origbase = arenabase;
   10be4:	e5872020 	str	r2, [r7, #32]
    status.arenasize = status.origsize = arenasize;
   10be8:	e5871024 	str	r1, [r7, #36]
    status.maxoverhead = MINSIZE + MALLOC_ALIGNMENT;

} // Cyg_Mempool_dlmalloc_Implementation::get_status()
   10bec:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
   10bf0:	e12fff1e 	bx	lr

00010bf4 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi>:
*/

cyg_uint8 *
Cyg_Mempool_dlmalloc_Implementation::resize_alloc( cyg_uint8 *oldmem,
                                                   cyg_int32 bytes,
                                                   cyg_int32 *poldsize )
   10bf4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  mchunkptr bck;                  /* misc temp for linking */
  mchunkptr fwd;                  /* misc temp for linking */

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   10bf8:	e2414008 	sub	r4, r1, #8	; 0x8
*/

cyg_uint8 *
Cyg_Mempool_dlmalloc_Implementation::resize_alloc( cyg_uint8 *oldmem,
                                                   cyg_int32 bytes,
                                                   cyg_int32 *poldsize )
   10bfc:	e1a08001 	mov	r8, r1
  mchunkptr fwd;                  /* misc temp for linking */

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   10c00:	e5941004 	ldr	r1, [r4, #4]

  if (NULL != poldsize)
   10c04:	e253c000 	subs	ip, r3, #0	; 0x0
  mchunkptr fwd;                  /* misc temp for linking */

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   10c08:	e3c11001 	bic	r1, r1, #1	; 0x1

  if (NULL != poldsize)
      *poldsize = oldsize - SIZE_SZ;
   10c0c:	12413004 	subne	r3, r1, #4	; 0x4

  nb = request2size(bytes);
   10c10:	e282200b 	add	r2, r2, #11	; 0xb

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);

  if (NULL != poldsize)
      *poldsize = oldsize - SIZE_SZ;
   10c14:	158c3000 	strne	r3, [ip]

  nb = request2size(bytes);
   10c18:	e3520016 	cmp	r2, #22	; 0x16
   10c1c:	d3a0a010 	movle	sl, #16	; 0x10
   10c20:	c3c2a007 	bicgt	sl, r2, #7	; 0x7
   10c24:	d1a0500a 	movle	r5, sl
   10c28:	c1a0500a 	movgt	r5, sl
*/

cyg_uint8 *
Cyg_Mempool_dlmalloc_Implementation::resize_alloc( cyg_uint8 *oldmem,
                                                   cyg_int32 bytes,
                                                   cyg_int32 *poldsize )
   10c2c:	e24dd00c 	sub	sp, sp, #12	; 0xc

  nb = request2size(bytes);

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   10c30:	e1510005 	cmp	r1, r5
*/

cyg_uint8 *
Cyg_Mempool_dlmalloc_Implementation::resize_alloc( cyg_uint8 *oldmem,
                                                   cyg_int32 bytes,
                                                   cyg_int32 *poldsize )
   10c34:	e58d0004 	str	r0, [sp, #4]

  nb = request2size(bytes);

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   10c38:	a1a07001 	movge	r7, r1
   10c3c:	aa000012 	bge	10c8c <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x98>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   10c40:	e59d3004 	ldr	r3, [sp, #4]
   10c44:	e283b008 	add	fp, r3, #8	; 0x8
   10c48:	e59b6008 	ldr	r6, [fp, #8]
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   10c4c:	e0840001 	add	r0, r4, r1
    if (next == top || !inuse(next)) 
   10c50:	e1560000 	cmp	r6, r0
   10c54:	0a00006f 	beq	10e18 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x224>
   10c58:	e5903004 	ldr	r3, [r0, #4]
   10c5c:	e3c3c001 	bic	ip, r3, #1	; 0x1
   10c60:	e080200c 	add	r2, r0, ip
   10c64:	e5923004 	ldr	r3, [r2, #4]
   10c68:	e3130001 	tst	r3, #1	; 0x1
   10c6c:	1a000025 	bne	10d08 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x114>
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   10c70:	e08c7001 	add	r7, ip, r1
   10c74:	e1570005 	cmp	r7, r5
   10c78:	ba000024 	blt	10d10 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x11c>
      { 
        unlink(next, bck, fwd);
   10c7c:	e2802008 	add	r2, r0, #8	; 0x8
   10c80:	e892000c 	ldm	r2, {r2, r3}
   10c84:	e5832008 	str	r2, [r3, #8]
   10c88:	e582300c 	str	r3, [r2, #12]
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   10c8c:	e06a0007 	rsb	r0, sl, r7

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   10c90:	e350000f 	cmp	r0, #15	; 0xf
   10c94:	8a00000b 	bhi	10cc8 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0xd4>
    /* let free() deal with it */
    Cyg_Mempool_dlmalloc_Implementation::free( chunk2mem(remainder) );
  }
  else
  {
    set_head_size(newp, newsize);
   10c98:	e5943004 	ldr	r3, [r4, #4]
   10c9c:	e2033001 	and	r3, r3, #1	; 0x1
   10ca0:	e1873003 	orr	r3, r7, r3
   10ca4:	e5843004 	str	r3, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
   10ca8:	e0842007 	add	r2, r4, r7
   10cac:	e5923004 	ldr	r3, [r2, #4]
   10cb0:	e3833001 	orr	r3, r3, #1	; 0x1
   10cb4:	e5823004 	str	r3, [r2, #4]
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);
   10cb8:	e2844008 	add	r4, r4, #8	; 0x8

} // Cyg_Mempool_dlmalloc_Implementation::resize_alloc()
   10cbc:	e1a00004 	mov	r0, r4
   10cc0:	e28dd00c 	add	sp, sp, #12	; 0xc
   10cc4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   10cc8:	e5943004 	ldr	r3, [r4, #4]
   10ccc:	e2033001 	and	r3, r3, #1	; 0x1

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   10cd0:	e084100a 	add	r1, r4, sl
    set_head_size(newp, nb);
   10cd4:	e18a3003 	orr	r3, sl, r3
    set_head(remainder, remainder_size | PREV_INUSE);
   10cd8:	e3802001 	orr	r2, r0, #1	; 0x1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   10cdc:	e5843004 	str	r3, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
   10ce0:	e5812004 	str	r2, [r1, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
   10ce4:	e0810000 	add	r0, r1, r0
   10ce8:	e5903004 	ldr	r3, [r0, #4]
   10cec:	e3833001 	orr	r3, r3, #1	; 0x1
   10cf0:	e5803004 	str	r3, [r0, #4]
    /* let free() deal with it */
    Cyg_Mempool_dlmalloc_Implementation::free( chunk2mem(remainder) );
   10cf4:	e2811008 	add	r1, r1, #8	; 0x8
   10cf8:	e59d0004 	ldr	r0, [sp, #4]
   10cfc:	e3a02000 	mov	r2, #0	; 0x0
   10d00:	ebfffeee 	bl	108c0 <_ZN35Cyg_Mempool_dlmalloc_Implementation4freeEPhi>
   10d04:	eaffffeb 	b	10cb8 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0xc4>
      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
        goto split;
   10d08:	e3a00000 	mov	r0, #0	; 0x0
   10d0c:	e1a0c000 	mov	ip, r0
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   10d10:	e5943004 	ldr	r3, [r4, #4]
   10d14:	e3130001 	tst	r3, #1	; 0x1
   10d18:	1a00003c 	bne	10e10 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x21c>
    {
      prev = prev_chunk(oldp);
   10d1c:	e5183008 	ldr	r3, [r8, #-8]
   10d20:	e0639004 	rsb	r9, r3, r4
      prevsize = chunksize(prev);
   10d24:	e5992004 	ldr	r2, [r9, #4]

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
   10d28:	e3500000 	cmp	r0, #0	; 0x0
    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
      prevsize = chunksize(prev);
   10d2c:	e3c22001 	bic	r2, r2, #1	; 0x1

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
   10d30:	0a000094 	beq	10f88 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x394>
      {
        /* into top */
        if (next == top)
   10d34:	e1500006 	cmp	r0, r6
   10d38:	0a00004d 	beq	10e74 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x280>
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   10d3c:	e0822001 	add	r2, r2, r1
   10d40:	e08c7002 	add	r7, ip, r2
   10d44:	e1570005 	cmp	r7, r5
   10d48:	b1a07002 	movlt	r7, r2
   10d4c:	aa000043 	bge	10e60 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x26c>
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   10d50:	e1570005 	cmp	r7, r5
   10d54:	ba00002d 	blt	10e10 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x21c>
      {
        unlink(prev, bck, fwd);
   10d58:	e1a00009 	mov	r0, r9
   10d5c:	e599200c 	ldr	r2, [r9, #12]
   10d60:	e5b03008 	ldr	r3, [r0, #8]!
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10d64:	e2415004 	sub	r5, r1, #4	; 0x4
   10d68:	e3550024 	cmp	r5, #36	; 0x24
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   10d6c:	e5823008 	str	r3, [r2, #8]
   10d70:	e583200c 	str	r2, [r3, #12]
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10d74:	8a000079 	bhi	10f60 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x36c>
   10d78:	e3550013 	cmp	r5, #19	; 0x13
   10d7c:	e1a04000 	mov	r4, r0
   10d80:	e1a0c008 	mov	ip, r8
   10d84:	9a000017 	bls	10de8 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x1f4>
   10d88:	e5983000 	ldr	r3, [r8]
   10d8c:	e5893008 	str	r3, [r9, #8]
   10d90:	e5982004 	ldr	r2, [r8, #4]
   10d94:	e2883004 	add	r3, r8, #4	; 0x4
   10d98:	e355001b 	cmp	r5, #27	; 0x1b
   10d9c:	e589200c 	str	r2, [r9, #12]
   10da0:	e2894010 	add	r4, r9, #16	; 0x10
   10da4:	e283c004 	add	ip, r3, #4	; 0x4
   10da8:	9a00000e 	bls	10de8 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x1f4>
   10dac:	e5933004 	ldr	r3, [r3, #4]
   10db0:	e5893010 	str	r3, [r9, #16]
   10db4:	e59c2004 	ldr	r2, [ip, #4]
   10db8:	e28c3004 	add	r3, ip, #4	; 0x4
   10dbc:	e3550024 	cmp	r5, #36	; 0x24
   10dc0:	e5892014 	str	r2, [r9, #20]
   10dc4:	e2894018 	add	r4, r9, #24	; 0x18
   10dc8:	e283c004 	add	ip, r3, #4	; 0x4
   10dcc:	1a000005 	bne	10de8 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x1f4>
   10dd0:	e5933004 	ldr	r3, [r3, #4]
   10dd4:	e5893018 	str	r3, [r9, #24]
   10dd8:	e59c2004 	ldr	r2, [ip, #4]
   10ddc:	e589201c 	str	r2, [r9, #28]
   10de0:	e28cc008 	add	ip, ip, #8	; 0x8
   10de4:	e2894020 	add	r4, r9, #32	; 0x20
   10de8:	e1a0000c 	mov	r0, ip
   10dec:	e4902004 	ldr	r2, [r0], #4
   10df0:	e1a01004 	mov	r1, r4
   10df4:	e4812004 	str	r2, [r1], #4
   10df8:	e59c3004 	ldr	r3, [ip, #4]
   10dfc:	e5843004 	str	r3, [r4, #4]
   10e00:	e5902004 	ldr	r2, [r0, #4]
   10e04:	e1a04009 	mov	r4, r9
   10e08:	e5812004 	str	r2, [r1, #4]
   10e0c:	eaffff9e 	b	10c8c <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x98>
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);
   10e10:	e3a04000 	mov	r4, #0	; 0x0
   10e14:	eaffffa8 	b	10cbc <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0xc8>
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);
   10e18:	e5963004 	ldr	r3, [r6, #4]
   10e1c:	e3c3c001 	bic	ip, r3, #1	; 0x1

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   10e20:	e08c2001 	add	r2, ip, r1
   10e24:	e28a3010 	add	r3, sl, #16	; 0x10
   10e28:	e1520003 	cmp	r2, r3
   10e2c:	b1a00006 	movlt	r0, r6
   10e30:	baffffb6 	blt	10d10 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x11c>
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
   10e34:	e06a3002 	rsb	r3, sl, r2
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   10e38:	e084100a 	add	r1, r4, sl
          set_head(top, (newsize - nb) | PREV_INUSE);
   10e3c:	e3833001 	orr	r3, r3, #1	; 0x1
   10e40:	e5813004 	str	r3, [r1, #4]
          set_head_size(oldp, nb);
   10e44:	e5942004 	ldr	r2, [r4, #4]
   10e48:	e2022001 	and	r2, r2, #1	; 0x1
   10e4c:	e18a2002 	orr	r2, sl, r2
   10e50:	e5842004 	str	r2, [r4, #4]
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   10e54:	e58b1008 	str	r1, [fp, #8]
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
	  MALLOC_UNLOCK;
          return chunk2mem(oldp);
   10e58:	e2844008 	add	r4, r4, #8	; 0x8
   10e5c:	eaffff96 	b	10cbc <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0xc8>
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   10e60:	e2802008 	add	r2, r0, #8	; 0x8
   10e64:	e892000c 	ldm	r2, {r2, r3}
   10e68:	e5832008 	str	r2, [r3, #8]
   10e6c:	e582300c 	str	r3, [r2, #12]
   10e70:	eaffffb8 	b	10d58 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x164>
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   10e74:	e0827001 	add	r7, r2, r1
   10e78:	e08c6007 	add	r6, ip, r7
   10e7c:	e28a3010 	add	r3, sl, #16	; 0x10
   10e80:	e1560003 	cmp	r6, r3
   10e84:	baffffb1 	blt	10d50 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x15c>
          {
            unlink(prev, bck, fwd);
   10e88:	e1a04009 	mov	r4, r9
   10e8c:	e599200c 	ldr	r2, [r9, #12]
   10e90:	e5b43008 	ldr	r3, [r4, #8]!
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10e94:	e2410004 	sub	r0, r1, #4	; 0x4
   10e98:	e3500024 	cmp	r0, #36	; 0x24
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   10e9c:	e5823008 	str	r3, [r2, #8]
   10ea0:	e583200c 	str	r2, [r3, #12]
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10ea4:	8a000032 	bhi	10f74 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x380>
   10ea8:	e3500013 	cmp	r0, #19	; 0x13
   10eac:	e1a0c008 	mov	ip, r8
   10eb0:	e1a05004 	mov	r5, r4
   10eb4:	9a000017 	bls	10f18 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x324>
   10eb8:	e5983000 	ldr	r3, [r8]
   10ebc:	e5893008 	str	r3, [r9, #8]
   10ec0:	e5982004 	ldr	r2, [r8, #4]
   10ec4:	e2883004 	add	r3, r8, #4	; 0x4
   10ec8:	e350001b 	cmp	r0, #27	; 0x1b
   10ecc:	e589200c 	str	r2, [r9, #12]
   10ed0:	e2895010 	add	r5, r9, #16	; 0x10
   10ed4:	e283c004 	add	ip, r3, #4	; 0x4
   10ed8:	9a00000e 	bls	10f18 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x324>
   10edc:	e5933004 	ldr	r3, [r3, #4]
   10ee0:	e5893010 	str	r3, [r9, #16]
   10ee4:	e59c2004 	ldr	r2, [ip, #4]
   10ee8:	e28c3004 	add	r3, ip, #4	; 0x4
   10eec:	e3500024 	cmp	r0, #36	; 0x24
   10ef0:	e5892014 	str	r2, [r9, #20]
   10ef4:	e2895018 	add	r5, r9, #24	; 0x18
   10ef8:	e283c004 	add	ip, r3, #4	; 0x4
   10efc:	1a000005 	bne	10f18 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x324>
   10f00:	e5933004 	ldr	r3, [r3, #4]
   10f04:	e5893018 	str	r3, [r9, #24]
   10f08:	e59c2004 	ldr	r2, [ip, #4]
   10f0c:	e589201c 	str	r2, [r9, #28]
   10f10:	e28cc008 	add	ip, ip, #8	; 0x8
   10f14:	e2895020 	add	r5, r9, #32	; 0x20
   10f18:	e1a0000c 	mov	r0, ip
   10f1c:	e4902004 	ldr	r2, [r0], #4
   10f20:	e1a01005 	mov	r1, r5
   10f24:	e4812004 	str	r2, [r1], #4
   10f28:	e59c3004 	ldr	r3, [ip, #4]
   10f2c:	e5853004 	str	r3, [r5, #4]
   10f30:	e5902004 	ldr	r2, [r0, #4]
   10f34:	e5812004 	str	r2, [r1, #4]
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
   10f38:	e06a3006 	rsb	r3, sl, r6
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   10f3c:	e089100a 	add	r1, r9, sl
            set_head(top, (newsize - nb) | PREV_INUSE);
   10f40:	e3833001 	orr	r3, r3, #1	; 0x1
   10f44:	e5813004 	str	r3, [r1, #4]
            set_head_size(newp, nb);
   10f48:	e5992004 	ldr	r2, [r9, #4]
   10f4c:	e2022001 	and	r2, r2, #1	; 0x1
   10f50:	e18a2002 	orr	r2, sl, r2
   10f54:	e5892004 	str	r2, [r9, #4]
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   10f58:	e58b1008 	str	r1, [fp, #8]
   10f5c:	eaffff56 	b	10cbc <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0xc8>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10f60:	e1a01008 	mov	r1, r8
   10f64:	e1a02005 	mov	r2, r5
   10f68:	eb00000e 	bl	10fa8 <__memmove>
   10f6c:	e1a04009 	mov	r4, r9
   10f70:	eaffff45 	b	10c8c <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x98>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10f74:	e1a02000 	mov	r2, r0
   10f78:	e1a01008 	mov	r1, r8
   10f7c:	e1a00004 	mov	r0, r4
   10f80:	eb000008 	bl	10fa8 <__memmove>
   10f84:	eaffffeb 	b	10f38 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x344>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   10f88:	e0827001 	add	r7, r2, r1
   10f8c:	eaffff6f 	b	10d50 <_ZN35Cyg_Mempool_dlmalloc_Implementation12resize_allocEPhiPi+0x15c>

00010f90 <exit>:
cyg_libc_invoke_atexit_handlers( void );

// FUNCTIONS

externC void
exit( int status )
   10f90:	e1a04000 	mov	r4, r0
    // and flush stdio buffers. Anything else is for _exit() 
    // within the implementation)

#ifdef CYGFUN_LIBC_ATEXIT
    // we start with the atexit handlers
    cyg_libc_invoke_atexit_handlers();
   10f94:	eb000022 	bl	11024 <cyg_libc_invoke_atexit_handlers>
#ifdef CYGSEM_LIBC_EXIT_CALLS_FFLUSH

    int rc;

    CYG_TRACE0( true, "Calling fflush( NULL )" );
    rc = fflush( NULL );
   10f98:	e3a00000 	mov	r0, #0	; 0x0
   10f9c:	ebfffa4a 	bl	f8cc <fflush>

    CYG_TRACE2( rc != 0, "fflush() returned non-zero. It returned %d and "
                "errno indicates the error: %s", rc, strerror(errno) );
#endif

    _exit( status );
   10fa0:	e1a00004 	mov	r0, r4
   10fa4:	eb00001c 	bl	1101c <_exit>

00010fa8 <__memmove>:
    {
        CYG_CHECK_DATA_PTR( s1, "s1 is not a valid pointer!" );
        CYG_CHECK_DATA_PTR( s2, "s2 is not a valid pointer!" );
    }

    if ((src < dst) && (dst < (src + n)))
   10fa8:	e1500001 	cmp	r0, r1
    CYGBLD_ATTRIB_WEAK_ALIAS(__memmove);

// FUNCTIONS

void *
__memmove( void *s1, const void *s2, size_t n )
   10fac:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
   10fb0:	e1a0c002 	mov	ip, r2
    {
        CYG_CHECK_DATA_PTR( s1, "s1 is not a valid pointer!" );
        CYG_CHECK_DATA_PTR( s2, "s2 is not a valid pointer!" );
    }

    if ((src < dst) && (dst < (src + n)))
   10fb4:	9a00000f 	bls	10ff8 <__memmove+0x50>
   10fb8:	e0814002 	add	r4, r1, r2
   10fbc:	e1500004 	cmp	r0, r4
   10fc0:	2a00000c 	bcs	10ff8 <__memmove+0x50>
    {
        // Have to copy backwards
        src += n;
        dst += n;
        while (n--)
   10fc4:	e3520000 	cmp	r2, #0	; 0x0
   10fc8:	0a000008 	beq	10ff0 <__memmove+0x48>
   10fcc:	e2623000 	rsb	r3, r2, #0	; 0x0

    if ((src < dst) && (dst < (src + n)))
    {
        // Have to copy backwards
        src += n;
        dst += n;
   10fd0:	e0802002 	add	r2, r0, r2
        while (n--)
        {
            *--dst = *--src;
   10fd4:	e0821003 	add	r1, r2, r3
   10fd8:	e0844003 	add	r4, r4, r3
    if ((src < dst) && (dst < (src + n)))
    {
        // Have to copy backwards
        src += n;
        dst += n;
        while (n--)
   10fdc:	e24c2001 	sub	r2, ip, #1	; 0x1
        {
            *--dst = *--src;
   10fe0:	e7d43002 	ldrb	r3, [r4, r2]
   10fe4:	e7c13002 	strb	r3, [r1, r2]
    if ((src < dst) && (dst < (src + n)))
    {
        // Have to copy backwards
        src += n;
        dst += n;
        while (n--)
   10fe8:	e2522001 	subs	r2, r2, #1	; 0x1
   10fec:	2afffffb 	bcs	10fe0 <__memmove+0x38>
    }

    CYG_REPORT_RETVAL( s1 );
    
    return s1;
} // __memmove()
   10ff0:	e8bd0010 	pop	{r4}
   10ff4:	e12fff1e 	bx	lr
            *--dst = *--src;
        }
    }
    else
    {
        while (n--)
   10ff8:	e35c0000 	cmp	ip, #0	; 0x0
    if ((src < dst) && (dst < (src + n)))
    {
        // Have to copy backwards
        src += n;
        dst += n;
        while (n--)
   10ffc:	13a02000 	movne	r2, #0	; 0x0
            *--dst = *--src;
        }
    }
    else
    {
        while (n--)
   11000:	0afffffa 	beq	10ff0 <__memmove+0x48>
        {
            *dst++ = *src++;
   11004:	e7d13002 	ldrb	r3, [r1, r2]
   11008:	e7c03002 	strb	r3, [r0, r2]
   1100c:	e2822001 	add	r2, r2, #1	; 0x1
            *--dst = *--src;
        }
    }
    else
    {
        while (n--)
   11010:	e15c0002 	cmp	ip, r2
   11014:	1afffffa 	bne	11004 <__memmove+0x5c>
   11018:	eafffff4 	b	10ff0 <__memmove+0x48>

0001101c <_exit>:
    for (;;)
        CYG_EMPTY_STATEMENT;

# else

    Cyg_Thread::exit();
   1101c:	ebffca92 	bl	3a6c <_ZN10Cyg_Thread4exitEv>
   11020:	eafffffe 	b	11020 <_exit+0x4>

00011024 <cyg_libc_invoke_atexit_handlers>:


// FUNCTIONS

externC void
cyg_libc_invoke_atexit_handlers( void )
   11024:	e92d4030 	push	{r4, r5, lr}
    CYG_REPORT_FUNCNAME( "cyg_libc_invoke_atexit_handlers");
    CYG_REPORT_FUNCARGVOID();
    
    cyg_ucount32 i;

    for (i=cyg_libc_atexit_handlers_count; i>0; --i) {
   11028:	e59f3038 	ldr	r3, [pc, #56]	; 11068 <cyg_libc_invoke_atexit_handlers+0x44>
   1102c:	e5934000 	ldr	r4, [r3]
   11030:	e3540000 	cmp	r4, #0	; 0x0


// FUNCTIONS

externC void
cyg_libc_invoke_atexit_handlers( void )
   11034:	e24dd004 	sub	sp, sp, #4	; 0x4
    CYG_REPORT_FUNCNAME( "cyg_libc_invoke_atexit_handlers");
    CYG_REPORT_FUNCARGVOID();
    
    cyg_ucount32 i;

    for (i=cyg_libc_atexit_handlers_count; i>0; --i) {
   11038:	0a000008 	beq	11060 <cyg_libc_invoke_atexit_handlers+0x3c>
   1103c:	e59f3028 	ldr	r3, [pc, #40]	; 1106c <cyg_libc_invoke_atexit_handlers+0x48>
   11040:	e1a02104 	lsl	r2, r4, #2
   11044:	e0835002 	add	r5, r3, r2
        CYG_CHECK_FUNC_PTR( cyg_libc_atexit_handlers[i-1],
                            "Function to call in atexit handler list "
                            "isn't valid! Even though it was when "
                            "entered!" );

        (*cyg_libc_atexit_handlers[i-1])();
   11048:	e2444001 	sub	r4, r4, #1	; 0x1
   1104c:	e5353004 	ldr	r3, [r5, #-4]!
   11050:	e1a0e00f 	mov	lr, pc
   11054:	e12fff13 	bx	r3
    CYG_REPORT_FUNCNAME( "cyg_libc_invoke_atexit_handlers");
    CYG_REPORT_FUNCARGVOID();
    
    cyg_ucount32 i;

    for (i=cyg_libc_atexit_handlers_count; i>0; --i) {
   11058:	e3540000 	cmp	r4, #0	; 0x0
   1105c:	1afffff9 	bne	11048 <cyg_libc_invoke_atexit_handlers+0x24>
        (*cyg_libc_atexit_handlers[i-1])();

    } // for
        
    CYG_REPORT_RETURN();
} // cyg_libc_invoke_atexit_handlers()
   11060:	e28dd004 	add	sp, sp, #4	; 0x4
   11064:	e8bd8030 	pop	{r4, r5, pc}
   11068:	40004bcc 	.word	0x40004bcc
   1106c:	40004bd0 	.word	0x40004bd0

00011070 <atexit>:

    CYG_CHECK_FUNC_PTR( func_to_register,
                       "atexit() not passed a valid function argument!" );

    // have we any slots left?
    if (cyg_libc_atexit_handlers_count >=
   11070:	e59fc020 	ldr	ip, [pc, #32]	; 11098 <atexit+0x28>
   11074:	e59c1000 	ldr	r1, [ip]
   11078:	e351001f 	cmp	r1, #31	; 0x1f
        CYG_REPORT_RETVAL( 1 ); 
        return 1; // failure
    } // if

    cyg_libc_atexit_handlers[cyg_libc_atexit_handlers_count++] =
        func_to_register;
   1107c:	959f3018 	ldrls	r3, [pc, #24]	; 1109c <atexit+0x2c>
   11080:	92812001 	addls	r2, r1, #1	; 0x1
   11084:	97830101 	strls	r0, [r3, r1, lsl #2]

    CYG_CHECK_FUNC_PTR( func_to_register,
                       "atexit() not passed a valid function argument!" );

    // have we any slots left?
    if (cyg_libc_atexit_handlers_count >=
   11088:	83a00001 	movhi	r0, #1	; 0x1
        CYG_REPORT_RETVAL( 1 ); 
        return 1; // failure
    } // if

    cyg_libc_atexit_handlers[cyg_libc_atexit_handlers_count++] =
        func_to_register;
   1108c:	958c2000 	strls	r2, [ip]
   11090:	93a00000 	movls	r0, #0	; 0x0

    CYG_REPORT_RETVAL(0);
    return 0;
} // atexit()
   11094:	e12fff1e 	bx	lr
   11098:	40004bcc 	.word	0x40004bcc
   1109c:	40004bd0 	.word	0x40004bd0

000110a0 <__aeabi_uidiv>:
   110a0:	e2512001 	subs	r2, r1, #1	; 0x1
   110a4:	012fff1e 	bxeq	lr
   110a8:	3a000036 	bcc	11188 <__aeabi_uidiv+0xe8>
   110ac:	e1500001 	cmp	r0, r1
   110b0:	9a000022 	bls	11140 <__aeabi_uidiv+0xa0>
   110b4:	e1110002 	tst	r1, r2
   110b8:	0a000023 	beq	1114c <__aeabi_uidiv+0xac>
   110bc:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   110c0:	01a01181 	lsleq	r1, r1, #3
   110c4:	03a03008 	moveq	r3, #8	; 0x8
   110c8:	13a03001 	movne	r3, #1	; 0x1
   110cc:	e3510201 	cmp	r1, #268435456	; 0x10000000
   110d0:	31510000 	cmpcc	r1, r0
   110d4:	31a01201 	lslcc	r1, r1, #4
   110d8:	31a03203 	lslcc	r3, r3, #4
   110dc:	3afffffa 	bcc	110cc <__aeabi_uidiv+0x2c>
   110e0:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   110e4:	31510000 	cmpcc	r1, r0
   110e8:	31a01081 	lslcc	r1, r1, #1
   110ec:	31a03083 	lslcc	r3, r3, #1
   110f0:	3afffffa 	bcc	110e0 <__aeabi_uidiv+0x40>
   110f4:	e3a02000 	mov	r2, #0	; 0x0
   110f8:	e1500001 	cmp	r0, r1
   110fc:	20400001 	subcs	r0, r0, r1
   11100:	21822003 	orrcs	r2, r2, r3
   11104:	e15000a1 	cmp	r0, r1, lsr #1
   11108:	204000a1 	subcs	r0, r0, r1, lsr #1
   1110c:	218220a3 	orrcs	r2, r2, r3, lsr #1
   11110:	e1500121 	cmp	r0, r1, lsr #2
   11114:	20400121 	subcs	r0, r0, r1, lsr #2
   11118:	21822123 	orrcs	r2, r2, r3, lsr #2
   1111c:	e15001a1 	cmp	r0, r1, lsr #3
   11120:	204001a1 	subcs	r0, r0, r1, lsr #3
   11124:	218221a3 	orrcs	r2, r2, r3, lsr #3
   11128:	e3500000 	cmp	r0, #0	; 0x0
   1112c:	11b03223 	lsrsne	r3, r3, #4
   11130:	11a01221 	lsrne	r1, r1, #4
   11134:	1affffef 	bne	110f8 <__aeabi_uidiv+0x58>
   11138:	e1a00002 	mov	r0, r2
   1113c:	e12fff1e 	bx	lr
   11140:	03a00001 	moveq	r0, #1	; 0x1
   11144:	13a00000 	movne	r0, #0	; 0x0
   11148:	e12fff1e 	bx	lr
   1114c:	e3510801 	cmp	r1, #65536	; 0x10000
   11150:	21a01821 	lsrcs	r1, r1, #16
   11154:	23a02010 	movcs	r2, #16	; 0x10
   11158:	33a02000 	movcc	r2, #0	; 0x0
   1115c:	e3510c01 	cmp	r1, #256	; 0x100
   11160:	21a01421 	lsrcs	r1, r1, #8
   11164:	22822008 	addcs	r2, r2, #8	; 0x8
   11168:	e3510010 	cmp	r1, #16	; 0x10
   1116c:	21a01221 	lsrcs	r1, r1, #4
   11170:	22822004 	addcs	r2, r2, #4	; 0x4
   11174:	e3510004 	cmp	r1, #4	; 0x4
   11178:	82822003 	addhi	r2, r2, #3	; 0x3
   1117c:	908220a1 	addls	r2, r2, r1, lsr #1
   11180:	e1a00230 	lsr	r0, r0, r2
   11184:	e12fff1e 	bx	lr
   11188:	e52de008 	str	lr, [sp, #-8]!
   1118c:	eb000059 	bl	112f8 <__aeabi_idiv0>
   11190:	e3a00000 	mov	r0, #0	; 0x0
   11194:	e49de008 	ldr	lr, [sp], #8
   11198:	e12fff1e 	bx	lr

0001119c <__aeabi_uidivmod>:
   1119c:	e92d4003 	push	{r0, r1, lr}
   111a0:	ebffffbe 	bl	110a0 <__aeabi_uidiv>
   111a4:	e8bd4006 	pop	{r1, r2, lr}
   111a8:	e0030092 	mul	r3, r2, r0
   111ac:	e0411003 	sub	r1, r1, r3
   111b0:	e12fff1e 	bx	lr

000111b4 <__aeabi_idiv>:
   111b4:	e3510000 	cmp	r1, #0	; 0x0
   111b8:	e020c001 	eor	ip, r0, r1
   111bc:	0a000042 	beq	112cc <__aeabi_idiv+0x118>
   111c0:	42611000 	rsbmi	r1, r1, #0	; 0x0
   111c4:	e2512001 	subs	r2, r1, #1	; 0x1
   111c8:	0a000027 	beq	1126c <__aeabi_idiv+0xb8>
   111cc:	e1b03000 	movs	r3, r0
   111d0:	42603000 	rsbmi	r3, r0, #0	; 0x0
   111d4:	e1530001 	cmp	r3, r1
   111d8:	9a000026 	bls	11278 <__aeabi_idiv+0xc4>
   111dc:	e1110002 	tst	r1, r2
   111e0:	0a000028 	beq	11288 <__aeabi_idiv+0xd4>
   111e4:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   111e8:	01a01181 	lsleq	r1, r1, #3
   111ec:	03a02008 	moveq	r2, #8	; 0x8
   111f0:	13a02001 	movne	r2, #1	; 0x1
   111f4:	e3510201 	cmp	r1, #268435456	; 0x10000000
   111f8:	31510003 	cmpcc	r1, r3
   111fc:	31a01201 	lslcc	r1, r1, #4
   11200:	31a02202 	lslcc	r2, r2, #4
   11204:	3afffffa 	bcc	111f4 <__aeabi_idiv+0x40>
   11208:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   1120c:	31510003 	cmpcc	r1, r3
   11210:	31a01081 	lslcc	r1, r1, #1
   11214:	31a02082 	lslcc	r2, r2, #1
   11218:	3afffffa 	bcc	11208 <__aeabi_idiv+0x54>
   1121c:	e3a00000 	mov	r0, #0	; 0x0
   11220:	e1530001 	cmp	r3, r1
   11224:	20433001 	subcs	r3, r3, r1
   11228:	21800002 	orrcs	r0, r0, r2
   1122c:	e15300a1 	cmp	r3, r1, lsr #1
   11230:	204330a1 	subcs	r3, r3, r1, lsr #1
   11234:	218000a2 	orrcs	r0, r0, r2, lsr #1
   11238:	e1530121 	cmp	r3, r1, lsr #2
   1123c:	20433121 	subcs	r3, r3, r1, lsr #2
   11240:	21800122 	orrcs	r0, r0, r2, lsr #2
   11244:	e15301a1 	cmp	r3, r1, lsr #3
   11248:	204331a1 	subcs	r3, r3, r1, lsr #3
   1124c:	218001a2 	orrcs	r0, r0, r2, lsr #3
   11250:	e3530000 	cmp	r3, #0	; 0x0
   11254:	11b02222 	lsrsne	r2, r2, #4
   11258:	11a01221 	lsrne	r1, r1, #4
   1125c:	1affffef 	bne	11220 <__aeabi_idiv+0x6c>
   11260:	e35c0000 	cmp	ip, #0	; 0x0
   11264:	42600000 	rsbmi	r0, r0, #0	; 0x0
   11268:	e12fff1e 	bx	lr
   1126c:	e13c0000 	teq	ip, r0
   11270:	42600000 	rsbmi	r0, r0, #0	; 0x0
   11274:	e12fff1e 	bx	lr
   11278:	33a00000 	movcc	r0, #0	; 0x0
   1127c:	01a00fcc 	asreq	r0, ip, #31
   11280:	03800001 	orreq	r0, r0, #1	; 0x1
   11284:	e12fff1e 	bx	lr
   11288:	e3510801 	cmp	r1, #65536	; 0x10000
   1128c:	21a01821 	lsrcs	r1, r1, #16
   11290:	23a02010 	movcs	r2, #16	; 0x10
   11294:	33a02000 	movcc	r2, #0	; 0x0
   11298:	e3510c01 	cmp	r1, #256	; 0x100
   1129c:	21a01421 	lsrcs	r1, r1, #8
   112a0:	22822008 	addcs	r2, r2, #8	; 0x8
   112a4:	e3510010 	cmp	r1, #16	; 0x10
   112a8:	21a01221 	lsrcs	r1, r1, #4
   112ac:	22822004 	addcs	r2, r2, #4	; 0x4
   112b0:	e3510004 	cmp	r1, #4	; 0x4
   112b4:	82822003 	addhi	r2, r2, #3	; 0x3
   112b8:	908220a1 	addls	r2, r2, r1, lsr #1
   112bc:	e35c0000 	cmp	ip, #0	; 0x0
   112c0:	e1a00233 	lsr	r0, r3, r2
   112c4:	42600000 	rsbmi	r0, r0, #0	; 0x0
   112c8:	e12fff1e 	bx	lr
   112cc:	e52de008 	str	lr, [sp, #-8]!
   112d0:	eb000008 	bl	112f8 <__aeabi_idiv0>
   112d4:	e3a00000 	mov	r0, #0	; 0x0
   112d8:	e49de008 	ldr	lr, [sp], #8
   112dc:	e12fff1e 	bx	lr

000112e0 <__aeabi_idivmod>:
   112e0:	e92d4003 	push	{r0, r1, lr}
   112e4:	ebffffb2 	bl	111b4 <__aeabi_idiv>
   112e8:	e8bd4006 	pop	{r1, r2, lr}
   112ec:	e0030092 	mul	r3, r2, r0
   112f0:	e0411003 	sub	r1, r1, r3
   112f4:	e12fff1e 	bx	lr

000112f8 <__aeabi_idiv0>:
   112f8:	e12fff1e 	bx	lr

000112fc <__aeabi_drsub>:
   112fc:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
   11300:	ea000000 	b	11308 <__adddf3>

00011304 <__aeabi_dsub>:
   11304:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

00011308 <__adddf3>:
   11308:	e92d4030 	push	{r4, r5, lr}
   1130c:	e1a04081 	lsl	r4, r1, #1
   11310:	e1a05083 	lsl	r5, r3, #1
   11314:	e1340005 	teq	r4, r5
   11318:	01300002 	teqeq	r0, r2
   1131c:	1194c000 	orrsne	ip, r4, r0
   11320:	1195c002 	orrsne	ip, r5, r2
   11324:	11f0cac4 	mvnsne	ip, r4, asr #21
   11328:	11f0cac5 	mvnsne	ip, r5, asr #21
   1132c:	0a00008c 	beq	11564 <__adddf3+0x25c>
   11330:	e1a04aa4 	lsr	r4, r4, #21
   11334:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
   11338:	b2655000 	rsblt	r5, r5, #0	; 0x0
   1133c:	da000006 	ble	1135c <__adddf3+0x54>
   11340:	e0844005 	add	r4, r4, r5
   11344:	e0202002 	eor	r2, r0, r2
   11348:	e0213003 	eor	r3, r1, r3
   1134c:	e0220000 	eor	r0, r2, r0
   11350:	e0231001 	eor	r1, r3, r1
   11354:	e0202002 	eor	r2, r0, r2
   11358:	e0213003 	eor	r3, r1, r3
   1135c:	e3550036 	cmp	r5, #54	; 0x36
   11360:	88bd4030 	pophi	{r4, r5, lr}
   11364:	812fff1e 	bxhi	lr
   11368:	e3110102 	tst	r1, #-2147483648	; 0x80000000
   1136c:	e1a01601 	lsl	r1, r1, #12
   11370:	e3a0c601 	mov	ip, #1048576	; 0x100000
   11374:	e18c1621 	orr	r1, ip, r1, lsr #12
   11378:	0a000001 	beq	11384 <__adddf3+0x7c>
   1137c:	e2700000 	rsbs	r0, r0, #0	; 0x0
   11380:	e2e11000 	rsc	r1, r1, #0	; 0x0
   11384:	e3130102 	tst	r3, #-2147483648	; 0x80000000
   11388:	e1a03603 	lsl	r3, r3, #12
   1138c:	e18c3623 	orr	r3, ip, r3, lsr #12
   11390:	0a000001 	beq	1139c <__adddf3+0x94>
   11394:	e2722000 	rsbs	r2, r2, #0	; 0x0
   11398:	e2e33000 	rsc	r3, r3, #0	; 0x0
   1139c:	e1340005 	teq	r4, r5
   113a0:	0a000069 	beq	1154c <__adddf3+0x244>
   113a4:	e2444001 	sub	r4, r4, #1	; 0x1
   113a8:	e275e020 	rsbs	lr, r5, #32	; 0x20
   113ac:	ba000005 	blt	113c8 <__adddf3+0xc0>
   113b0:	e1a0ce12 	lsl	ip, r2, lr
   113b4:	e0900532 	adds	r0, r0, r2, lsr r5
   113b8:	e2a11000 	adc	r1, r1, #0	; 0x0
   113bc:	e0900e13 	adds	r0, r0, r3, lsl lr
   113c0:	e0b11553 	adcs	r1, r1, r3, asr r5
   113c4:	ea000006 	b	113e4 <__adddf3+0xdc>
   113c8:	e2455020 	sub	r5, r5, #32	; 0x20
   113cc:	e28ee020 	add	lr, lr, #32	; 0x20
   113d0:	e3520001 	cmp	r2, #1	; 0x1
   113d4:	e1a0ce13 	lsl	ip, r3, lr
   113d8:	238cc002 	orrcs	ip, ip, #2	; 0x2
   113dc:	e0900553 	adds	r0, r0, r3, asr r5
   113e0:	e0b11fc3 	adcs	r1, r1, r3, asr #31
   113e4:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
   113e8:	5a000002 	bpl	113f8 <__adddf3+0xf0>
   113ec:	e27cc000 	rsbs	ip, ip, #0	; 0x0
   113f0:	e2f00000 	rscs	r0, r0, #0	; 0x0
   113f4:	e2e11000 	rsc	r1, r1, #0	; 0x0
   113f8:	e3510601 	cmp	r1, #1048576	; 0x100000
   113fc:	3a00000f 	bcc	11440 <__adddf3+0x138>
   11400:	e3510602 	cmp	r1, #2097152	; 0x200000
   11404:	3a000006 	bcc	11424 <__adddf3+0x11c>
   11408:	e1b010a1 	lsrs	r1, r1, #1
   1140c:	e1b00060 	rrxs	r0, r0
   11410:	e1a0c06c 	rrx	ip, ip
   11414:	e2844001 	add	r4, r4, #1	; 0x1
   11418:	e1a02a84 	lsl	r2, r4, #21
   1141c:	e3720501 	cmn	r2, #4194304	; 0x400000
   11420:	2a00006b 	bcs	115d4 <__adddf3+0x2cc>
   11424:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
   11428:	01b0c0a0 	lsrseq	ip, r0, #1
   1142c:	e2b00000 	adcs	r0, r0, #0	; 0x0
   11430:	e0a11a04 	adc	r1, r1, r4, lsl #20
   11434:	e1811005 	orr	r1, r1, r5
   11438:	e8bd4030 	pop	{r4, r5, lr}
   1143c:	e12fff1e 	bx	lr
   11440:	e1b0c08c 	lsls	ip, ip, #1
   11444:	e0b00000 	adcs	r0, r0, r0
   11448:	e0a11001 	adc	r1, r1, r1
   1144c:	e3110601 	tst	r1, #1048576	; 0x100000
   11450:	e2444001 	sub	r4, r4, #1	; 0x1
   11454:	1afffff2 	bne	11424 <__adddf3+0x11c>
   11458:	e3310000 	teq	r1, #0	; 0x0
   1145c:	13a03014 	movne	r3, #20	; 0x14
   11460:	03a03034 	moveq	r3, #52	; 0x34
   11464:	01a01000 	moveq	r1, r0
   11468:	03a00000 	moveq	r0, #0	; 0x0
   1146c:	e1a02001 	mov	r2, r1
   11470:	e3520801 	cmp	r2, #65536	; 0x10000
   11474:	21a02822 	lsrcs	r2, r2, #16
   11478:	22433010 	subcs	r3, r3, #16	; 0x10
   1147c:	e3520c01 	cmp	r2, #256	; 0x100
   11480:	21a02422 	lsrcs	r2, r2, #8
   11484:	22433008 	subcs	r3, r3, #8	; 0x8
   11488:	e3520010 	cmp	r2, #16	; 0x10
   1148c:	21a02222 	lsrcs	r2, r2, #4
   11490:	22433004 	subcs	r3, r3, #4	; 0x4
   11494:	e3520004 	cmp	r2, #4	; 0x4
   11498:	22433002 	subcs	r3, r3, #2	; 0x2
   1149c:	304330a2 	subcc	r3, r3, r2, lsr #1
   114a0:	e04331a2 	sub	r3, r3, r2, lsr #3
   114a4:	e2532020 	subs	r2, r3, #32	; 0x20
   114a8:	aa000007 	bge	114cc <__adddf3+0x1c4>
   114ac:	e292200c 	adds	r2, r2, #12	; 0xc
   114b0:	da000004 	ble	114c8 <__adddf3+0x1c0>
   114b4:	e282c014 	add	ip, r2, #20	; 0x14
   114b8:	e262200c 	rsb	r2, r2, #12	; 0xc
   114bc:	e1a00c11 	lsl	r0, r1, ip
   114c0:	e1a01231 	lsr	r1, r1, r2
   114c4:	ea000004 	b	114dc <__adddf3+0x1d4>
   114c8:	e2822014 	add	r2, r2, #20	; 0x14
   114cc:	d262c020 	rsble	ip, r2, #32	; 0x20
   114d0:	e1a01211 	lsl	r1, r1, r2
   114d4:	d1811c30 	orrle	r1, r1, r0, lsr ip
   114d8:	d1a00210 	lslle	r0, r0, r2
   114dc:	e0544003 	subs	r4, r4, r3
   114e0:	a0811a04 	addge	r1, r1, r4, lsl #20
   114e4:	a1811005 	orrge	r1, r1, r5
   114e8:	a8bd4030 	popge	{r4, r5, lr}
   114ec:	a12fff1e 	bxge	lr
   114f0:	e1e04004 	mvn	r4, r4
   114f4:	e254401f 	subs	r4, r4, #31	; 0x1f
   114f8:	aa00000f 	bge	1153c <__adddf3+0x234>
   114fc:	e294400c 	adds	r4, r4, #12	; 0xc
   11500:	ca000006 	bgt	11520 <__adddf3+0x218>
   11504:	e2844014 	add	r4, r4, #20	; 0x14
   11508:	e2642020 	rsb	r2, r4, #32	; 0x20
   1150c:	e1a00430 	lsr	r0, r0, r4
   11510:	e1800211 	orr	r0, r0, r1, lsl r2
   11514:	e1851431 	orr	r1, r5, r1, lsr r4
   11518:	e8bd4030 	pop	{r4, r5, lr}
   1151c:	e12fff1e 	bx	lr
   11520:	e264400c 	rsb	r4, r4, #12	; 0xc
   11524:	e2642020 	rsb	r2, r4, #32	; 0x20
   11528:	e1a00230 	lsr	r0, r0, r2
   1152c:	e1800411 	orr	r0, r0, r1, lsl r4
   11530:	e1a01005 	mov	r1, r5
   11534:	e8bd4030 	pop	{r4, r5, lr}
   11538:	e12fff1e 	bx	lr
   1153c:	e1a00431 	lsr	r0, r1, r4
   11540:	e1a01005 	mov	r1, r5
   11544:	e8bd4030 	pop	{r4, r5, lr}
   11548:	e12fff1e 	bx	lr
   1154c:	e3340000 	teq	r4, #0	; 0x0
   11550:	e2233601 	eor	r3, r3, #1048576	; 0x100000
   11554:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
   11558:	02844001 	addeq	r4, r4, #1	; 0x1
   1155c:	12455001 	subne	r5, r5, #1	; 0x1
   11560:	eaffff8f 	b	113a4 <__adddf3+0x9c>
   11564:	e1f0cac4 	mvns	ip, r4, asr #21
   11568:	11f0cac5 	mvnsne	ip, r5, asr #21
   1156c:	0a00001d 	beq	115e8 <__adddf3+0x2e0>
   11570:	e1340005 	teq	r4, r5
   11574:	01300002 	teqeq	r0, r2
   11578:	0a000004 	beq	11590 <__adddf3+0x288>
   1157c:	e194c000 	orrs	ip, r4, r0
   11580:	01a01003 	moveq	r1, r3
   11584:	01a00002 	moveq	r0, r2
   11588:	e8bd4030 	pop	{r4, r5, lr}
   1158c:	e12fff1e 	bx	lr
   11590:	e1310003 	teq	r1, r3
   11594:	13a01000 	movne	r1, #0	; 0x0
   11598:	13a00000 	movne	r0, #0	; 0x0
   1159c:	18bd4030 	popne	{r4, r5, lr}
   115a0:	112fff1e 	bxne	lr
   115a4:	e1b0caa4 	lsrs	ip, r4, #21
   115a8:	1a000004 	bne	115c0 <__adddf3+0x2b8>
   115ac:	e1b00080 	lsls	r0, r0, #1
   115b0:	e0b11001 	adcs	r1, r1, r1
   115b4:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
   115b8:	e8bd4030 	pop	{r4, r5, lr}
   115bc:	e12fff1e 	bx	lr
   115c0:	e2944501 	adds	r4, r4, #4194304	; 0x400000
   115c4:	32811601 	addcc	r1, r1, #1048576	; 0x100000
   115c8:	38bd4030 	popcc	{r4, r5, lr}
   115cc:	312fff1e 	bxcc	lr
   115d0:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
   115d4:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
   115d8:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
   115dc:	e3a00000 	mov	r0, #0	; 0x0
   115e0:	e8bd4030 	pop	{r4, r5, lr}
   115e4:	e12fff1e 	bx	lr
   115e8:	e1f0cac4 	mvns	ip, r4, asr #21
   115ec:	11a01003 	movne	r1, r3
   115f0:	11a00002 	movne	r0, r2
   115f4:	01f0cac5 	mvnseq	ip, r5, asr #21
   115f8:	11a03001 	movne	r3, r1
   115fc:	11a02000 	movne	r2, r0
   11600:	e1904601 	orrs	r4, r0, r1, lsl #12
   11604:	01925603 	orrseq	r5, r2, r3, lsl #12
   11608:	01310003 	teqeq	r1, r3
   1160c:	13811702 	orrne	r1, r1, #524288	; 0x80000
   11610:	e8bd4030 	pop	{r4, r5, lr}
   11614:	e12fff1e 	bx	lr

00011618 <__aeabi_ui2d>:
   11618:	e3300000 	teq	r0, #0	; 0x0
   1161c:	03a01000 	moveq	r1, #0	; 0x0
   11620:	012fff1e 	bxeq	lr
   11624:	e92d4030 	push	{r4, r5, lr}
   11628:	e3a04b01 	mov	r4, #1024	; 0x400
   1162c:	e2844032 	add	r4, r4, #50	; 0x32
   11630:	e3a05000 	mov	r5, #0	; 0x0
   11634:	e3a01000 	mov	r1, #0	; 0x0
   11638:	eaffff86 	b	11458 <__adddf3+0x150>

0001163c <__aeabi_i2d>:
   1163c:	e3300000 	teq	r0, #0	; 0x0
   11640:	03a01000 	moveq	r1, #0	; 0x0
   11644:	012fff1e 	bxeq	lr
   11648:	e92d4030 	push	{r4, r5, lr}
   1164c:	e3a04b01 	mov	r4, #1024	; 0x400
   11650:	e2844032 	add	r4, r4, #50	; 0x32
   11654:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
   11658:	42600000 	rsbmi	r0, r0, #0	; 0x0
   1165c:	e3a01000 	mov	r1, #0	; 0x0
   11660:	eaffff7c 	b	11458 <__adddf3+0x150>

00011664 <__aeabi_f2d>:
   11664:	e1b02080 	lsls	r2, r0, #1
   11668:	e1a011c2 	asr	r1, r2, #3
   1166c:	e1a01061 	rrx	r1, r1
   11670:	e1a00e02 	lsl	r0, r2, #28
   11674:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
   11678:	133304ff 	teqne	r3, #-16777216	; 0xff000000
   1167c:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
   11680:	112fff1e 	bxne	lr
   11684:	e3320000 	teq	r2, #0	; 0x0
   11688:	133304ff 	teqne	r3, #-16777216	; 0xff000000
   1168c:	012fff1e 	bxeq	lr
   11690:	e92d4030 	push	{r4, r5, lr}
   11694:	e3a04d0e 	mov	r4, #896	; 0x380
   11698:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
   1169c:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
   116a0:	eaffff6c 	b	11458 <__adddf3+0x150>

000116a4 <__aeabi_ul2d>:
   116a4:	e1902001 	orrs	r2, r0, r1
   116a8:	012fff1e 	bxeq	lr
   116ac:	e92d4030 	push	{r4, r5, lr}
   116b0:	e3a05000 	mov	r5, #0	; 0x0
   116b4:	ea000006 	b	116d4 <__aeabi_l2d+0x1c>

000116b8 <__aeabi_l2d>:
   116b8:	e1902001 	orrs	r2, r0, r1
   116bc:	012fff1e 	bxeq	lr
   116c0:	e92d4030 	push	{r4, r5, lr}
   116c4:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
   116c8:	5a000001 	bpl	116d4 <__aeabi_l2d+0x1c>
   116cc:	e2700000 	rsbs	r0, r0, #0	; 0x0
   116d0:	e2e11000 	rsc	r1, r1, #0	; 0x0
   116d4:	e3a04b01 	mov	r4, #1024	; 0x400
   116d8:	e2844032 	add	r4, r4, #50	; 0x32
   116dc:	e1b0cb21 	lsrs	ip, r1, #22
   116e0:	0affff44 	beq	113f8 <__adddf3+0xf0>
   116e4:	e3a02003 	mov	r2, #3	; 0x3
   116e8:	e1b0c1ac 	lsrs	ip, ip, #3
   116ec:	12822003 	addne	r2, r2, #3	; 0x3
   116f0:	e1b0c1ac 	lsrs	ip, ip, #3
   116f4:	12822003 	addne	r2, r2, #3	; 0x3
   116f8:	e08221ac 	add	r2, r2, ip, lsr #3
   116fc:	e2623020 	rsb	r3, r2, #32	; 0x20
   11700:	e1a0c310 	lsl	ip, r0, r3
   11704:	e1a00230 	lsr	r0, r0, r2
   11708:	e1800311 	orr	r0, r0, r1, lsl r3
   1170c:	e1a01231 	lsr	r1, r1, r2
   11710:	e0844002 	add	r4, r4, r2
   11714:	eaffff37 	b	113f8 <__adddf3+0xf0>

00011718 <__aeabi_dmul>:
   11718:	e92d4070 	push	{r4, r5, r6, lr}
   1171c:	e3a0c0ff 	mov	ip, #255	; 0xff
   11720:	e38ccc07 	orr	ip, ip, #1792	; 0x700
   11724:	e01c4a21 	ands	r4, ip, r1, lsr #20
   11728:	101c5a23 	andsne	r5, ip, r3, lsr #20
   1172c:	1134000c 	teqne	r4, ip
   11730:	1135000c 	teqne	r5, ip
   11734:	0b000075 	bleq	11910 <__aeabi_dmul+0x1f8>
   11738:	e0844005 	add	r4, r4, r5
   1173c:	e0216003 	eor	r6, r1, r3
   11740:	e1c11a8c 	bic	r1, r1, ip, lsl #21
   11744:	e1c33a8c 	bic	r3, r3, ip, lsl #21
   11748:	e1905601 	orrs	r5, r0, r1, lsl #12
   1174c:	11925603 	orrsne	r5, r2, r3, lsl #12
   11750:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   11754:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   11758:	0a00001d 	beq	117d4 <__aeabi_dmul+0xbc>
   1175c:	e08ec290 	umull	ip, lr, r0, r2
   11760:	e3a05000 	mov	r5, #0	; 0x0
   11764:	e0a5e291 	umlal	lr, r5, r1, r2
   11768:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
   1176c:	e0a5e390 	umlal	lr, r5, r0, r3
   11770:	e3a06000 	mov	r6, #0	; 0x0
   11774:	e0a65391 	umlal	r5, r6, r1, r3
   11778:	e33c0000 	teq	ip, #0	; 0x0
   1177c:	138ee001 	orrne	lr, lr, #1	; 0x1
   11780:	e24440ff 	sub	r4, r4, #255	; 0xff
   11784:	e3560c02 	cmp	r6, #512	; 0x200
   11788:	e2c44c03 	sbc	r4, r4, #768	; 0x300
   1178c:	2a000002 	bcs	1179c <__aeabi_dmul+0x84>
   11790:	e1b0e08e 	lsls	lr, lr, #1
   11794:	e0b55005 	adcs	r5, r5, r5
   11798:	e0a66006 	adc	r6, r6, r6
   1179c:	e1821586 	orr	r1, r2, r6, lsl #11
   117a0:	e1811aa5 	orr	r1, r1, r5, lsr #21
   117a4:	e1a00585 	lsl	r0, r5, #11
   117a8:	e1800aae 	orr	r0, r0, lr, lsr #21
   117ac:	e1a0e58e 	lsl	lr, lr, #11
   117b0:	e254c0fd 	subs	ip, r4, #253	; 0xfd
   117b4:	835c0c07 	cmphi	ip, #1792	; 0x700
   117b8:	8a000011 	bhi	11804 <__aeabi_dmul+0xec>
   117bc:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
   117c0:	01b0e0a0 	lsrseq	lr, r0, #1
   117c4:	e2b00000 	adcs	r0, r0, #0	; 0x0
   117c8:	e0a11a04 	adc	r1, r1, r4, lsl #20
   117cc:	e8bd4070 	pop	{r4, r5, r6, lr}
   117d0:	e12fff1e 	bx	lr
   117d4:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
   117d8:	e1861001 	orr	r1, r6, r1
   117dc:	e1800002 	orr	r0, r0, r2
   117e0:	e0211003 	eor	r1, r1, r3
   117e4:	e05440ac 	subs	r4, r4, ip, lsr #1
   117e8:	c074500c 	rsbsgt	r5, r4, ip
   117ec:	c1811a04 	orrgt	r1, r1, r4, lsl #20
   117f0:	c8bd4070 	popgt	{r4, r5, r6, lr}
   117f4:	c12fff1e 	bxgt	lr
   117f8:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   117fc:	e3a0e000 	mov	lr, #0	; 0x0
   11800:	e2544001 	subs	r4, r4, #1	; 0x1
   11804:	ca00005d 	bgt	11980 <__aeabi_dmul+0x268>
   11808:	e3740036 	cmn	r4, #54	; 0x36
   1180c:	d3a00000 	movle	r0, #0	; 0x0
   11810:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
   11814:	d8bd4070 	pople	{r4, r5, r6, lr}
   11818:	d12fff1e 	bxle	lr
   1181c:	e2644000 	rsb	r4, r4, #0	; 0x0
   11820:	e2544020 	subs	r4, r4, #32	; 0x20
   11824:	aa00001a 	bge	11894 <__aeabi_dmul+0x17c>
   11828:	e294400c 	adds	r4, r4, #12	; 0xc
   1182c:	ca00000c 	bgt	11864 <__aeabi_dmul+0x14c>
   11830:	e2844014 	add	r4, r4, #20	; 0x14
   11834:	e2645020 	rsb	r5, r4, #32	; 0x20
   11838:	e1a03510 	lsl	r3, r0, r5
   1183c:	e1a00430 	lsr	r0, r0, r4
   11840:	e1800511 	orr	r0, r0, r1, lsl r5
   11844:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
   11848:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
   1184c:	e0900fa3 	adds	r0, r0, r3, lsr #31
   11850:	e0a21431 	adc	r1, r2, r1, lsr r4
   11854:	e19ee083 	orrs	lr, lr, r3, lsl #1
   11858:	01c00fa3 	biceq	r0, r0, r3, lsr #31
   1185c:	e8bd4070 	pop	{r4, r5, r6, lr}
   11860:	e12fff1e 	bx	lr
   11864:	e264400c 	rsb	r4, r4, #12	; 0xc
   11868:	e2645020 	rsb	r5, r4, #32	; 0x20
   1186c:	e1a03410 	lsl	r3, r0, r4
   11870:	e1a00530 	lsr	r0, r0, r5
   11874:	e1800411 	orr	r0, r0, r1, lsl r4
   11878:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   1187c:	e0900fa3 	adds	r0, r0, r3, lsr #31
   11880:	e2a11000 	adc	r1, r1, #0	; 0x0
   11884:	e19ee083 	orrs	lr, lr, r3, lsl #1
   11888:	01c00fa3 	biceq	r0, r0, r3, lsr #31
   1188c:	e8bd4070 	pop	{r4, r5, r6, lr}
   11890:	e12fff1e 	bx	lr
   11894:	e2645020 	rsb	r5, r4, #32	; 0x20
   11898:	e18ee510 	orr	lr, lr, r0, lsl r5
   1189c:	e1a03430 	lsr	r3, r0, r4
   118a0:	e1833511 	orr	r3, r3, r1, lsl r5
   118a4:	e1a00431 	lsr	r0, r1, r4
   118a8:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   118ac:	e1c00431 	bic	r0, r0, r1, lsr r4
   118b0:	e0800fa3 	add	r0, r0, r3, lsr #31
   118b4:	e19ee083 	orrs	lr, lr, r3, lsl #1
   118b8:	01c00fa3 	biceq	r0, r0, r3, lsr #31
   118bc:	e8bd4070 	pop	{r4, r5, r6, lr}
   118c0:	e12fff1e 	bx	lr
   118c4:	e3340000 	teq	r4, #0	; 0x0
   118c8:	1a000008 	bne	118f0 <__aeabi_dmul+0x1d8>
   118cc:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
   118d0:	e1b00080 	lsls	r0, r0, #1
   118d4:	e0a11001 	adc	r1, r1, r1
   118d8:	e3110601 	tst	r1, #1048576	; 0x100000
   118dc:	02444001 	subeq	r4, r4, #1	; 0x1
   118e0:	0afffffa 	beq	118d0 <__aeabi_dmul+0x1b8>
   118e4:	e1811006 	orr	r1, r1, r6
   118e8:	e3350000 	teq	r5, #0	; 0x0
   118ec:	11a0f00e 	movne	pc, lr
   118f0:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
   118f4:	e1b02082 	lsls	r2, r2, #1
   118f8:	e0a33003 	adc	r3, r3, r3
   118fc:	e3130601 	tst	r3, #1048576	; 0x100000
   11900:	02455001 	subeq	r5, r5, #1	; 0x1
   11904:	0afffffa 	beq	118f4 <__aeabi_dmul+0x1dc>
   11908:	e1833006 	orr	r3, r3, r6
   1190c:	e1a0f00e 	mov	pc, lr
   11910:	e134000c 	teq	r4, ip
   11914:	e00c5a23 	and	r5, ip, r3, lsr #20
   11918:	1135000c 	teqne	r5, ip
   1191c:	0a000007 	beq	11940 <__aeabi_dmul+0x228>
   11920:	e1906081 	orrs	r6, r0, r1, lsl #1
   11924:	11926083 	orrsne	r6, r2, r3, lsl #1
   11928:	1affffe5 	bne	118c4 <__aeabi_dmul+0x1ac>
   1192c:	e0211003 	eor	r1, r1, r3
   11930:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   11934:	e3a00000 	mov	r0, #0	; 0x0
   11938:	e8bd4070 	pop	{r4, r5, r6, lr}
   1193c:	e12fff1e 	bx	lr
   11940:	e1906081 	orrs	r6, r0, r1, lsl #1
   11944:	01a00002 	moveq	r0, r2
   11948:	01a01003 	moveq	r1, r3
   1194c:	11926083 	orrsne	r6, r2, r3, lsl #1
   11950:	0a000010 	beq	11998 <__aeabi_dmul+0x280>
   11954:	e134000c 	teq	r4, ip
   11958:	1a000001 	bne	11964 <__aeabi_dmul+0x24c>
   1195c:	e1906601 	orrs	r6, r0, r1, lsl #12
   11960:	1a00000c 	bne	11998 <__aeabi_dmul+0x280>
   11964:	e135000c 	teq	r5, ip
   11968:	1a000003 	bne	1197c <__aeabi_dmul+0x264>
   1196c:	e1926603 	orrs	r6, r2, r3, lsl #12
   11970:	11a00002 	movne	r0, r2
   11974:	11a01003 	movne	r1, r3
   11978:	1a000006 	bne	11998 <__aeabi_dmul+0x280>
   1197c:	e0211003 	eor	r1, r1, r3
   11980:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   11984:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
   11988:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
   1198c:	e3a00000 	mov	r0, #0	; 0x0
   11990:	e8bd4070 	pop	{r4, r5, r6, lr}
   11994:	e12fff1e 	bx	lr
   11998:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
   1199c:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
   119a0:	e8bd4070 	pop	{r4, r5, r6, lr}
   119a4:	e12fff1e 	bx	lr

000119a8 <__aeabi_ddiv>:
   119a8:	e92d4070 	push	{r4, r5, r6, lr}
   119ac:	e3a0c0ff 	mov	ip, #255	; 0xff
   119b0:	e38ccc07 	orr	ip, ip, #1792	; 0x700
   119b4:	e01c4a21 	ands	r4, ip, r1, lsr #20
   119b8:	101c5a23 	andsne	r5, ip, r3, lsr #20
   119bc:	1134000c 	teqne	r4, ip
   119c0:	1135000c 	teqne	r5, ip
   119c4:	0b00005e 	bleq	11b44 <__aeabi_ddiv+0x19c>
   119c8:	e0444005 	sub	r4, r4, r5
   119cc:	e021e003 	eor	lr, r1, r3
   119d0:	e1925603 	orrs	r5, r2, r3, lsl #12
   119d4:	e1a01601 	lsl	r1, r1, #12
   119d8:	0a00004c 	beq	11b10 <__aeabi_ddiv+0x168>
   119dc:	e1a03603 	lsl	r3, r3, #12
   119e0:	e3a05201 	mov	r5, #268435456	; 0x10000000
   119e4:	e1853223 	orr	r3, r5, r3, lsr #4
   119e8:	e1833c22 	orr	r3, r3, r2, lsr #24
   119ec:	e1a02402 	lsl	r2, r2, #8
   119f0:	e1855221 	orr	r5, r5, r1, lsr #4
   119f4:	e1855c20 	orr	r5, r5, r0, lsr #24
   119f8:	e1a06400 	lsl	r6, r0, #8
   119fc:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000
   11a00:	e1550003 	cmp	r5, r3
   11a04:	01560002 	cmpeq	r6, r2
   11a08:	e2a440fd 	adc	r4, r4, #253	; 0xfd
   11a0c:	e2844c03 	add	r4, r4, #768	; 0x300
   11a10:	2a000001 	bcs	11a1c <__aeabi_ddiv+0x74>
   11a14:	e1b030a3 	lsrs	r3, r3, #1
   11a18:	e1a02062 	rrx	r2, r2
   11a1c:	e0566002 	subs	r6, r6, r2
   11a20:	e0c55003 	sbc	r5, r5, r3
   11a24:	e1b030a3 	lsrs	r3, r3, #1
   11a28:	e1a02062 	rrx	r2, r2
   11a2c:	e3a00601 	mov	r0, #1048576	; 0x100000
   11a30:	e3a0c702 	mov	ip, #524288	; 0x80000
   11a34:	e056e002 	subs	lr, r6, r2
   11a38:	e0d5e003 	sbcs	lr, r5, r3
   11a3c:	20466002 	subcs	r6, r6, r2
   11a40:	21a0500e 	movcs	r5, lr
   11a44:	2180000c 	orrcs	r0, r0, ip
   11a48:	e1b030a3 	lsrs	r3, r3, #1
   11a4c:	e1a02062 	rrx	r2, r2
   11a50:	e056e002 	subs	lr, r6, r2
   11a54:	e0d5e003 	sbcs	lr, r5, r3
   11a58:	20466002 	subcs	r6, r6, r2
   11a5c:	21a0500e 	movcs	r5, lr
   11a60:	218000ac 	orrcs	r0, r0, ip, lsr #1
   11a64:	e1b030a3 	lsrs	r3, r3, #1
   11a68:	e1a02062 	rrx	r2, r2
   11a6c:	e056e002 	subs	lr, r6, r2
   11a70:	e0d5e003 	sbcs	lr, r5, r3
   11a74:	20466002 	subcs	r6, r6, r2
   11a78:	21a0500e 	movcs	r5, lr
   11a7c:	2180012c 	orrcs	r0, r0, ip, lsr #2
   11a80:	e1b030a3 	lsrs	r3, r3, #1
   11a84:	e1a02062 	rrx	r2, r2
   11a88:	e056e002 	subs	lr, r6, r2
   11a8c:	e0d5e003 	sbcs	lr, r5, r3
   11a90:	20466002 	subcs	r6, r6, r2
   11a94:	21a0500e 	movcs	r5, lr
   11a98:	218001ac 	orrcs	r0, r0, ip, lsr #3
   11a9c:	e195e006 	orrs	lr, r5, r6
   11aa0:	0a00000d 	beq	11adc <__aeabi_ddiv+0x134>
   11aa4:	e1a05205 	lsl	r5, r5, #4
   11aa8:	e1855e26 	orr	r5, r5, r6, lsr #28
   11aac:	e1a06206 	lsl	r6, r6, #4
   11ab0:	e1a03183 	lsl	r3, r3, #3
   11ab4:	e1833ea2 	orr	r3, r3, r2, lsr #29
   11ab8:	e1a02182 	lsl	r2, r2, #3
   11abc:	e1b0c22c 	lsrs	ip, ip, #4
   11ac0:	1affffdb 	bne	11a34 <__aeabi_ddiv+0x8c>
   11ac4:	e3110601 	tst	r1, #1048576	; 0x100000
   11ac8:	1a000006 	bne	11ae8 <__aeabi_ddiv+0x140>
   11acc:	e1811000 	orr	r1, r1, r0
   11ad0:	e3a00000 	mov	r0, #0	; 0x0
   11ad4:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
   11ad8:	eaffffd5 	b	11a34 <__aeabi_ddiv+0x8c>
   11adc:	e3110601 	tst	r1, #1048576	; 0x100000
   11ae0:	01811000 	orreq	r1, r1, r0
   11ae4:	03a00000 	moveq	r0, #0	; 0x0
   11ae8:	e254c0fd 	subs	ip, r4, #253	; 0xfd
   11aec:	835c0c07 	cmphi	ip, #1792	; 0x700
   11af0:	8affff43 	bhi	11804 <__aeabi_dmul+0xec>
   11af4:	e055c003 	subs	ip, r5, r3
   11af8:	0056c002 	subseq	ip, r6, r2
   11afc:	01b0c0a0 	lsrseq	ip, r0, #1
   11b00:	e2b00000 	adcs	r0, r0, #0	; 0x0
   11b04:	e0a11a04 	adc	r1, r1, r4, lsl #20
   11b08:	e8bd4070 	pop	{r4, r5, r6, lr}
   11b0c:	e12fff1e 	bx	lr
   11b10:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
   11b14:	e18e1621 	orr	r1, lr, r1, lsr #12
   11b18:	e09440ac 	adds	r4, r4, ip, lsr #1
   11b1c:	c074500c 	rsbsgt	r5, r4, ip
   11b20:	c1811a04 	orrgt	r1, r1, r4, lsl #20
   11b24:	c8bd4070 	popgt	{r4, r5, r6, lr}
   11b28:	c12fff1e 	bxgt	lr
   11b2c:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   11b30:	e3a0e000 	mov	lr, #0	; 0x0
   11b34:	e2544001 	subs	r4, r4, #1	; 0x1
   11b38:	eaffff31 	b	11804 <__aeabi_dmul+0xec>
   11b3c:	e185e006 	orr	lr, r5, r6
   11b40:	eaffff2f 	b	11804 <__aeabi_dmul+0xec>
   11b44:	e00c5a23 	and	r5, ip, r3, lsr #20
   11b48:	e134000c 	teq	r4, ip
   11b4c:	0135000c 	teqeq	r5, ip
   11b50:	0affff90 	beq	11998 <__aeabi_dmul+0x280>
   11b54:	e134000c 	teq	r4, ip
   11b58:	1a000006 	bne	11b78 <__aeabi_ddiv+0x1d0>
   11b5c:	e1904601 	orrs	r4, r0, r1, lsl #12
   11b60:	1affff8c 	bne	11998 <__aeabi_dmul+0x280>
   11b64:	e135000c 	teq	r5, ip
   11b68:	1affff83 	bne	1197c <__aeabi_dmul+0x264>
   11b6c:	e1a00002 	mov	r0, r2
   11b70:	e1a01003 	mov	r1, r3
   11b74:	eaffff87 	b	11998 <__aeabi_dmul+0x280>
   11b78:	e135000c 	teq	r5, ip
   11b7c:	1a000004 	bne	11b94 <__aeabi_ddiv+0x1ec>
   11b80:	e1925603 	orrs	r5, r2, r3, lsl #12
   11b84:	0affff68 	beq	1192c <__aeabi_dmul+0x214>
   11b88:	e1a00002 	mov	r0, r2
   11b8c:	e1a01003 	mov	r1, r3
   11b90:	eaffff80 	b	11998 <__aeabi_dmul+0x280>
   11b94:	e1906081 	orrs	r6, r0, r1, lsl #1
   11b98:	11926083 	orrsne	r6, r2, r3, lsl #1
   11b9c:	1affff48 	bne	118c4 <__aeabi_dmul+0x1ac>
   11ba0:	e1904081 	orrs	r4, r0, r1, lsl #1
   11ba4:	1affff74 	bne	1197c <__aeabi_dmul+0x264>
   11ba8:	e1925083 	orrs	r5, r2, r3, lsl #1
   11bac:	1affff5e 	bne	1192c <__aeabi_dmul+0x214>
   11bb0:	eaffff78 	b	11998 <__aeabi_dmul+0x280>

00011bb4 <__gedf2>:
   11bb4:	e3e0c000 	mvn	ip, #0	; 0x0
   11bb8:	ea000002 	b	11bc8 <__cmpdf2+0x4>

00011bbc <__ledf2>:
   11bbc:	e3a0c001 	mov	ip, #1	; 0x1
   11bc0:	ea000000 	b	11bc8 <__cmpdf2+0x4>

00011bc4 <__cmpdf2>:
   11bc4:	e3a0c001 	mov	ip, #1	; 0x1
   11bc8:	e50dc004 	str	ip, [sp, #-4]
   11bcc:	e1a0c081 	lsl	ip, r1, #1
   11bd0:	e1f0cacc 	mvns	ip, ip, asr #21
   11bd4:	e1a0c083 	lsl	ip, r3, #1
   11bd8:	11f0cacc 	mvnsne	ip, ip, asr #21
   11bdc:	0a00000d 	beq	11c18 <__cmpdf2+0x54>
   11be0:	e190c081 	orrs	ip, r0, r1, lsl #1
   11be4:	0192c083 	orrseq	ip, r2, r3, lsl #1
   11be8:	11310003 	teqne	r1, r3
   11bec:	01300002 	teqeq	r0, r2
   11bf0:	03a00000 	moveq	r0, #0	; 0x0
   11bf4:	012fff1e 	bxeq	lr
   11bf8:	e3700000 	cmn	r0, #0	; 0x0
   11bfc:	e1310003 	teq	r1, r3
   11c00:	51510003 	cmppl	r1, r3
   11c04:	01500002 	cmpeq	r0, r2
   11c08:	21a00fc3 	asrcs	r0, r3, #31
   11c0c:	31e00fc3 	mvncc	r0, r3, asr #31
   11c10:	e3800001 	orr	r0, r0, #1	; 0x1
   11c14:	e12fff1e 	bx	lr
   11c18:	e1a0c081 	lsl	ip, r1, #1
   11c1c:	e1f0cacc 	mvns	ip, ip, asr #21
   11c20:	1a000001 	bne	11c2c <__cmpdf2+0x68>
   11c24:	e190c601 	orrs	ip, r0, r1, lsl #12
   11c28:	1a000004 	bne	11c40 <__cmpdf2+0x7c>
   11c2c:	e1a0c083 	lsl	ip, r3, #1
   11c30:	e1f0cacc 	mvns	ip, ip, asr #21
   11c34:	1affffe9 	bne	11be0 <__cmpdf2+0x1c>
   11c38:	e192c603 	orrs	ip, r2, r3, lsl #12
   11c3c:	0affffe7 	beq	11be0 <__cmpdf2+0x1c>
   11c40:	e51d0004 	ldr	r0, [sp, #-4]
   11c44:	e12fff1e 	bx	lr

00011c48 <__aeabi_cdrcmple>:
   11c48:	e1a0c000 	mov	ip, r0
   11c4c:	e1a00002 	mov	r0, r2
   11c50:	e1a0200c 	mov	r2, ip
   11c54:	e1a0c001 	mov	ip, r1
   11c58:	e1a01003 	mov	r1, r3
   11c5c:	e1a0300c 	mov	r3, ip
   11c60:	eaffffff 	b	11c64 <__aeabi_cdcmpeq>

00011c64 <__aeabi_cdcmpeq>:
   11c64:	e92d4001 	push	{r0, lr}
   11c68:	ebffffd5 	bl	11bc4 <__cmpdf2>
   11c6c:	e3500000 	cmp	r0, #0	; 0x0
   11c70:	43700000 	cmnmi	r0, #0	; 0x0
   11c74:	e8bd4001 	pop	{r0, lr}
   11c78:	e12fff1e 	bx	lr

00011c7c <__aeabi_dcmpeq>:
   11c7c:	e52de008 	str	lr, [sp, #-8]!
   11c80:	ebfffff7 	bl	11c64 <__aeabi_cdcmpeq>
   11c84:	03a00001 	moveq	r0, #1	; 0x1
   11c88:	13a00000 	movne	r0, #0	; 0x0
   11c8c:	e49de008 	ldr	lr, [sp], #8
   11c90:	e12fff1e 	bx	lr

00011c94 <__aeabi_dcmplt>:
   11c94:	e52de008 	str	lr, [sp, #-8]!
   11c98:	ebfffff1 	bl	11c64 <__aeabi_cdcmpeq>
   11c9c:	33a00001 	movcc	r0, #1	; 0x1
   11ca0:	23a00000 	movcs	r0, #0	; 0x0
   11ca4:	e49de008 	ldr	lr, [sp], #8
   11ca8:	e12fff1e 	bx	lr

00011cac <__aeabi_dcmple>:
   11cac:	e52de008 	str	lr, [sp, #-8]!
   11cb0:	ebffffeb 	bl	11c64 <__aeabi_cdcmpeq>
   11cb4:	93a00001 	movls	r0, #1	; 0x1
   11cb8:	83a00000 	movhi	r0, #0	; 0x0
   11cbc:	e49de008 	ldr	lr, [sp], #8
   11cc0:	e12fff1e 	bx	lr

00011cc4 <__aeabi_dcmpge>:
   11cc4:	e52de008 	str	lr, [sp, #-8]!
   11cc8:	ebffffde 	bl	11c48 <__aeabi_cdrcmple>
   11ccc:	93a00001 	movls	r0, #1	; 0x1
   11cd0:	83a00000 	movhi	r0, #0	; 0x0
   11cd4:	e49de008 	ldr	lr, [sp], #8
   11cd8:	e12fff1e 	bx	lr

00011cdc <__aeabi_dcmpgt>:
   11cdc:	e52de008 	str	lr, [sp, #-8]!
   11ce0:	ebffffd8 	bl	11c48 <__aeabi_cdrcmple>
   11ce4:	33a00001 	movcc	r0, #1	; 0x1
   11ce8:	23a00000 	movcs	r0, #0	; 0x0
   11cec:	e49de008 	ldr	lr, [sp], #8
   11cf0:	e12fff1e 	bx	lr

00011cf4 <__aeabi_dcmpun>:
   11cf4:	e1a0c081 	lsl	ip, r1, #1
   11cf8:	e1f0cacc 	mvns	ip, ip, asr #21
   11cfc:	1a000001 	bne	11d08 <__aeabi_dcmpun+0x14>
   11d00:	e190c601 	orrs	ip, r0, r1, lsl #12
   11d04:	1a000006 	bne	11d24 <__aeabi_dcmpun+0x30>
   11d08:	e1a0c083 	lsl	ip, r3, #1
   11d0c:	e1f0cacc 	mvns	ip, ip, asr #21
   11d10:	1a000001 	bne	11d1c <__aeabi_dcmpun+0x28>
   11d14:	e192c603 	orrs	ip, r2, r3, lsl #12
   11d18:	1a000001 	bne	11d24 <__aeabi_dcmpun+0x30>
   11d1c:	e3a00000 	mov	r0, #0	; 0x0
   11d20:	e12fff1e 	bx	lr
   11d24:	e3a00001 	mov	r0, #1	; 0x1
   11d28:	e12fff1e 	bx	lr

00011d2c <__aeabi_d2iz>:
   11d2c:	e1a02081 	lsl	r2, r1, #1
   11d30:	e2922602 	adds	r2, r2, #2097152	; 0x200000
   11d34:	2a00000c 	bcs	11d6c <__aeabi_d2iz+0x40>
   11d38:	5a000009 	bpl	11d64 <__aeabi_d2iz+0x38>
   11d3c:	e3e03e3e 	mvn	r3, #992	; 0x3e0
   11d40:	e0532ac2 	subs	r2, r3, r2, asr #21
   11d44:	9a00000a 	bls	11d74 <__aeabi_d2iz+0x48>
   11d48:	e1a03581 	lsl	r3, r1, #11
   11d4c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   11d50:	e1833aa0 	orr	r3, r3, r0, lsr #21
   11d54:	e3110102 	tst	r1, #-2147483648	; 0x80000000
   11d58:	e1a00233 	lsr	r0, r3, r2
   11d5c:	12600000 	rsbne	r0, r0, #0	; 0x0
   11d60:	e12fff1e 	bx	lr
   11d64:	e3a00000 	mov	r0, #0	; 0x0
   11d68:	e12fff1e 	bx	lr
   11d6c:	e1900601 	orrs	r0, r0, r1, lsl #12
   11d70:	1a000002 	bne	11d80 <__aeabi_d2iz+0x54>
   11d74:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
   11d78:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
   11d7c:	e12fff1e 	bx	lr
   11d80:	e3a00000 	mov	r0, #0	; 0x0
   11d84:	e12fff1e 	bx	lr

00011d88 <__aeabi_d2f>:
   11d88:	e1a02081 	lsl	r2, r1, #1
   11d8c:	e2523207 	subs	r3, r2, #1879048192	; 0x70000000
   11d90:	2253c602 	subscs	ip, r3, #2097152	; 0x200000
   11d94:	227cc57f 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   11d98:	9a000006 	bls	11db8 <__aeabi_d2f+0x30>
   11d9c:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
   11da0:	e1a02180 	lsl	r2, r0, #3
   11da4:	e18c0ea0 	orr	r0, ip, r0, lsr #29
   11da8:	e3520102 	cmp	r2, #-2147483648	; 0x80000000
   11dac:	e0a00103 	adc	r0, r0, r3, lsl #2
   11db0:	03c00001 	biceq	r0, r0, #1	; 0x1
   11db4:	e12fff1e 	bx	lr
   11db8:	e3110101 	tst	r1, #1073741824	; 0x40000000
   11dbc:	1a00000f 	bne	11e00 <__aeabi_d2f+0x78>
   11dc0:	e293262e 	adds	r2, r3, #48234496	; 0x2e00000
   11dc4:	b2010102 	andlt	r0, r1, #-2147483648	; 0x80000000
   11dc8:	b12fff1e 	bxlt	lr
   11dcc:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   11dd0:	e1a02aa2 	lsr	r2, r2, #21
   11dd4:	e2622018 	rsb	r2, r2, #24	; 0x18
   11dd8:	e262c020 	rsb	ip, r2, #32	; 0x20
   11ddc:	e1b03c10 	lsls	r3, r0, ip
   11de0:	e1a00230 	lsr	r0, r0, r2
   11de4:	13800001 	orrne	r0, r0, #1	; 0x1
   11de8:	e1a03581 	lsl	r3, r1, #11
   11dec:	e1a035a3 	lsr	r3, r3, #11
   11df0:	e1800c13 	orr	r0, r0, r3, lsl ip
   11df4:	e1a03233 	lsr	r3, r3, r2
   11df8:	e1a03083 	lsl	r3, r3, #1
   11dfc:	eaffffe6 	b	11d9c <__aeabi_d2f+0x14>
   11e00:	e1f03ac2 	mvns	r3, r2, asr #21
   11e04:	1a000003 	bne	11e18 <__aeabi_d2f+0x90>
   11e08:	e1903601 	orrs	r3, r0, r1, lsl #12
   11e0c:	13a0047f 	movne	r0, #2130706432	; 0x7f000000
   11e10:	13800503 	orrne	r0, r0, #12582912	; 0xc00000
   11e14:	112fff1e 	bxne	lr
   11e18:	e2010102 	and	r0, r1, #-2147483648	; 0x80000000
   11e1c:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
   11e20:	e3800502 	orr	r0, r0, #8388608	; 0x800000
   11e24:	e12fff1e 	bx	lr

00011e28 <__aeabi_uldivmod>:
   11e28:	e24dd008 	sub	sp, sp, #8	; 0x8
   11e2c:	e92d6000 	push	{sp, lr}
   11e30:	eb000003 	bl	11e44 <__gnu_uldivmod_helper>
   11e34:	e59de004 	ldr	lr, [sp, #4]
   11e38:	e28dd008 	add	sp, sp, #8	; 0x8
   11e3c:	e8bd000c 	pop	{r2, r3}
   11e40:	e12fff1e 	bx	lr

00011e44 <__gnu_uldivmod_helper>:
   11e44:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
   11e48:	e24dd004 	sub	sp, sp, #4	; 0x4
   11e4c:	e1a0a002 	mov	sl, r2
   11e50:	e1a08003 	mov	r8, r3
   11e54:	e1a05000 	mov	r5, r0
   11e58:	e1a06001 	mov	r6, r1
   11e5c:	eb000177 	bl	12440 <__udivdi3>
   11e60:	e0070890 	mul	r7, r0, r8
   11e64:	e0843a90 	umull	r3, r4, r0, sl
   11e68:	e022719a 	mla	r2, sl, r1, r7
   11e6c:	e0824004 	add	r4, r2, r4
   11e70:	e59d2020 	ldr	r2, [sp, #32]
   11e74:	e0555003 	subs	r5, r5, r3
   11e78:	e0c66004 	sbc	r6, r6, r4
   11e7c:	e8820060 	stm	r2, {r5, r6}
   11e80:	e28dd004 	add	sp, sp, #4	; 0x4
   11e84:	e8bd45f0 	pop	{r4, r5, r6, r7, r8, sl, lr}
   11e88:	e12fff1e 	bx	lr

00011e8c <__gnu_ldivmod_helper>:
   11e8c:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
   11e90:	e24dd004 	sub	sp, sp, #4	; 0x4
   11e94:	e1a0a002 	mov	sl, r2
   11e98:	e1a08003 	mov	r8, r3
   11e9c:	e1a05000 	mov	r5, r0
   11ea0:	e1a06001 	mov	r6, r1
   11ea4:	eb00000a 	bl	11ed4 <__divdi3>
   11ea8:	e0070890 	mul	r7, r0, r8
   11eac:	e0843a90 	umull	r3, r4, r0, sl
   11eb0:	e022719a 	mla	r2, sl, r1, r7
   11eb4:	e0824004 	add	r4, r2, r4
   11eb8:	e59d2020 	ldr	r2, [sp, #32]
   11ebc:	e0555003 	subs	r5, r5, r3
   11ec0:	e0c66004 	sbc	r6, r6, r4
   11ec4:	e8820060 	stm	r2, {r5, r6}
   11ec8:	e28dd004 	add	sp, sp, #4	; 0x4
   11ecc:	e8bd45f0 	pop	{r4, r5, r6, r7, r8, sl, lr}
   11ed0:	e12fff1e 	bx	lr

00011ed4 <__divdi3>:
   11ed4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ed8:	e3510000 	cmp	r1, #0	; 0x0
   11edc:	e1a04003 	mov	r4, r3
   11ee0:	e24dd014 	sub	sp, sp, #20	; 0x14
   11ee4:	e1a05000 	mov	r5, r0
   11ee8:	a3a00000 	movge	r0, #0	; 0x0
   11eec:	e1a06001 	mov	r6, r1
   11ef0:	e1a03002 	mov	r3, r2
   11ef4:	e1a01002 	mov	r1, r2
   11ef8:	a58d0000 	strge	r0, [sp]
   11efc:	e1a02004 	mov	r2, r4
   11f00:	ba0000d1 	blt	1224c <__divdi3+0x378>
   11f04:	e3540000 	cmp	r4, #0	; 0x0
   11f08:	ba0000d5 	blt	12264 <__divdi3+0x390>
   11f0c:	e2520000 	subs	r0, r2, #0	; 0x0
   11f10:	e1a03005 	mov	r3, r5
   11f14:	e1a09005 	mov	r9, r5
   11f18:	e1a05001 	mov	r5, r1
   11f1c:	1a00003c 	bne	12014 <__divdi3+0x140>
   11f20:	e1510006 	cmp	r1, r6
   11f24:	9a00004a 	bls	12054 <__divdi3+0x180>
   11f28:	e3510801 	cmp	r1, #65536	; 0x10000
   11f2c:	2a00012c 	bcs	123e4 <__divdi3+0x510>
   11f30:	e3510c01 	cmp	r1, #256	; 0x100
   11f34:	33a00020 	movcc	r0, #32	; 0x20
   11f38:	23a00018 	movcs	r0, #24	; 0x18
   11f3c:	33a03000 	movcc	r3, #0	; 0x0
   11f40:	23a03008 	movcs	r3, #8	; 0x8
   11f44:	e1a01335 	lsr	r1, r5, r3
   11f48:	e59f24ec 	ldr	r2, [pc, #1260]	; 1243c <__divdi3+0x568>
   11f4c:	e7d23001 	ldrb	r3, [r2, r1]
   11f50:	e0502003 	subs	r2, r0, r3
   11f54:	12623020 	rsbne	r3, r2, #32	; 0x20
   11f58:	11a03339 	lsrne	r3, r9, r3
   11f5c:	11a05215 	lslne	r5, r5, r2
   11f60:	11836216 	orrne	r6, r3, r6, lsl r2
   11f64:	e1a08825 	lsr	r8, r5, #16
   11f68:	e1a01008 	mov	r1, r8
   11f6c:	e1a00006 	mov	r0, r6
   11f70:	11a09219 	lslne	r9, r9, r2
   11f74:	ebfffc49 	bl	110a0 <__aeabi_uidiv>
   11f78:	e1a01008 	mov	r1, r8
   11f7c:	e1a0a000 	mov	sl, r0
   11f80:	e1a00006 	mov	r0, r6
   11f84:	ebfffc84 	bl	1119c <__aeabi_uidivmod>
   11f88:	e1a07805 	lsl	r7, r5, #16
   11f8c:	e1a07827 	lsr	r7, r7, #16
   11f90:	e0020a97 	mul	r2, r7, sl
   11f94:	e1a03829 	lsr	r3, r9, #16
   11f98:	e1834801 	orr	r4, r3, r1, lsl #16
   11f9c:	e1520004 	cmp	r2, r4
   11fa0:	9a000005 	bls	11fbc <__divdi3+0xe8>
   11fa4:	e0944005 	adds	r4, r4, r5
   11fa8:	e24aa001 	sub	sl, sl, #1	; 0x1
   11fac:	2a000002 	bcs	11fbc <__divdi3+0xe8>
   11fb0:	e1520004 	cmp	r2, r4
   11fb4:	824aa001 	subhi	sl, sl, #1	; 0x1
   11fb8:	80844005 	addhi	r4, r4, r5
   11fbc:	e0624004 	rsb	r4, r2, r4
   11fc0:	e1a01008 	mov	r1, r8
   11fc4:	e1a00004 	mov	r0, r4
   11fc8:	ebfffc34 	bl	110a0 <__aeabi_uidiv>
   11fcc:	e1a01008 	mov	r1, r8
   11fd0:	e1a06000 	mov	r6, r0
   11fd4:	e1a00004 	mov	r0, r4
   11fd8:	ebfffc6f 	bl	1119c <__aeabi_uidivmod>
   11fdc:	e0000697 	mul	r0, r7, r6
   11fe0:	e1a03809 	lsl	r3, r9, #16
   11fe4:	e1a03823 	lsr	r3, r3, #16
   11fe8:	e1832801 	orr	r2, r3, r1, lsl #16
   11fec:	e1500002 	cmp	r0, r2
   11ff0:	9a000004 	bls	12008 <__divdi3+0x134>
   11ff4:	e0923005 	adds	r3, r2, r5
   11ff8:	e2466001 	sub	r6, r6, #1	; 0x1
   11ffc:	2a000001 	bcs	12008 <__divdi3+0x134>
   12000:	e1500003 	cmp	r0, r3
   12004:	82466001 	subhi	r6, r6, #1	; 0x1
   12008:	e186080a 	orr	r0, r6, sl, lsl #16
   1200c:	e3a02000 	mov	r2, #0	; 0x0
   12010:	ea000003 	b	12024 <__divdi3+0x150>
   12014:	e1500006 	cmp	r0, r6
   12018:	9a000079 	bls	12204 <__divdi3+0x330>
   1201c:	e3a00000 	mov	r0, #0	; 0x0
   12020:	e1a02000 	mov	r2, r0
   12024:	e1a03000 	mov	r3, r0
   12028:	e59d0000 	ldr	r0, [sp]
   1202c:	e3500000 	cmp	r0, #0	; 0x0
   12030:	e1a04002 	mov	r4, r2
   12034:	0a000001 	beq	12040 <__divdi3+0x16c>
   12038:	e2733000 	rsbs	r3, r3, #0	; 0x0
   1203c:	e2e44000 	rsc	r4, r4, #0	; 0x0
   12040:	e1a01004 	mov	r1, r4
   12044:	e1a00003 	mov	r0, r3
   12048:	e28dd014 	add	sp, sp, #20	; 0x14
   1204c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12050:	e12fff1e 	bx	lr
   12054:	e3510000 	cmp	r1, #0	; 0x0
   12058:	1a000002 	bne	12068 <__divdi3+0x194>
   1205c:	e3a00001 	mov	r0, #1	; 0x1
   12060:	ebfffc0e 	bl	110a0 <__aeabi_uidiv>
   12064:	e1a05000 	mov	r5, r0
   12068:	e3550801 	cmp	r5, #65536	; 0x10000
   1206c:	3a000082 	bcc	1227c <__divdi3+0x3a8>
   12070:	e3550401 	cmp	r5, #16777216	; 0x1000000
   12074:	33a03010 	movcc	r3, #16	; 0x10
   12078:	23a03018 	movcs	r3, #24	; 0x18
   1207c:	23a00008 	movcs	r0, #8	; 0x8
   12080:	31a00003 	movcc	r0, r3
   12084:	e1a01335 	lsr	r1, r5, r3
   12088:	e59f23ac 	ldr	r2, [pc, #940]	; 1243c <__divdi3+0x568>
   1208c:	e7d23001 	ldrb	r3, [r2, r1]
   12090:	e050a003 	subs	sl, r0, r3
   12094:	01a08805 	lsleq	r8, r5, #16
   12098:	00654006 	rsbeq	r4, r5, r6
   1209c:	01a08828 	lsreq	r8, r8, #16
   120a0:	01a07825 	lsreq	r7, r5, #16
   120a4:	03a0b001 	moveq	fp, #1	; 0x1
   120a8:	0a00002d 	beq	12164 <__divdi3+0x290>
   120ac:	e26a3020 	rsb	r3, sl, #32	; 0x20
   120b0:	e1a04336 	lsr	r4, r6, r3
   120b4:	e1a03339 	lsr	r3, r9, r3
   120b8:	e1a05a15 	lsl	r5, r5, sl
   120bc:	e1833a16 	orr	r3, r3, r6, lsl sl
   120c0:	e1a07825 	lsr	r7, r5, #16
   120c4:	e1a01007 	mov	r1, r7
   120c8:	e1a00004 	mov	r0, r4
   120cc:	e58d3004 	str	r3, [sp, #4]
   120d0:	ebfffbf2 	bl	110a0 <__aeabi_uidiv>
   120d4:	e1a01007 	mov	r1, r7
   120d8:	e1a0b000 	mov	fp, r0
   120dc:	e1a00004 	mov	r0, r4
   120e0:	ebfffc2d 	bl	1119c <__aeabi_uidivmod>
   120e4:	e1a08805 	lsl	r8, r5, #16
   120e8:	e1a08828 	lsr	r8, r8, #16
   120ec:	e0020b98 	mul	r2, r8, fp
   120f0:	e59d0004 	ldr	r0, [sp, #4]
   120f4:	e1a03820 	lsr	r3, r0, #16
   120f8:	e1834801 	orr	r4, r3, r1, lsl #16
   120fc:	e1520004 	cmp	r2, r4
   12100:	9a000002 	bls	12110 <__divdi3+0x23c>
   12104:	e0944005 	adds	r4, r4, r5
   12108:	e24bb001 	sub	fp, fp, #1	; 0x1
   1210c:	3a0000c6 	bcc	1242c <__divdi3+0x558>
   12110:	e0624004 	rsb	r4, r2, r4
   12114:	e1a01007 	mov	r1, r7
   12118:	e1a00004 	mov	r0, r4
   1211c:	ebfffbdf 	bl	110a0 <__aeabi_uidiv>
   12120:	e1a01007 	mov	r1, r7
   12124:	e1a06000 	mov	r6, r0
   12128:	e1a00004 	mov	r0, r4
   1212c:	ebfffc1a 	bl	1119c <__aeabi_uidivmod>
   12130:	e0040698 	mul	r4, r8, r6
   12134:	e59d2004 	ldr	r2, [sp, #4]
   12138:	e1a03802 	lsl	r3, r2, #16
   1213c:	e1a03823 	lsr	r3, r3, #16
   12140:	e1830801 	orr	r0, r3, r1, lsl #16
   12144:	e1540000 	cmp	r4, r0
   12148:	9a000002 	bls	12158 <__divdi3+0x284>
   1214c:	e0900005 	adds	r0, r0, r5
   12150:	e2466001 	sub	r6, r6, #1	; 0x1
   12154:	3a0000b0 	bcc	1241c <__divdi3+0x548>
   12158:	e1a09a19 	lsl	r9, r9, sl
   1215c:	e0644000 	rsb	r4, r4, r0
   12160:	e186b80b 	orr	fp, r6, fp, lsl #16
   12164:	e1a01007 	mov	r1, r7
   12168:	e1a00004 	mov	r0, r4
   1216c:	ebfffbcb 	bl	110a0 <__aeabi_uidiv>
   12170:	e1a01007 	mov	r1, r7
   12174:	e1a0a000 	mov	sl, r0
   12178:	e1a00004 	mov	r0, r4
   1217c:	ebfffc06 	bl	1119c <__aeabi_uidivmod>
   12180:	e0020a98 	mul	r2, r8, sl
   12184:	e1a03829 	lsr	r3, r9, #16
   12188:	e1834801 	orr	r4, r3, r1, lsl #16
   1218c:	e1520004 	cmp	r2, r4
   12190:	9a000005 	bls	121ac <__divdi3+0x2d8>
   12194:	e0944005 	adds	r4, r4, r5
   12198:	e24aa001 	sub	sl, sl, #1	; 0x1
   1219c:	2a000002 	bcs	121ac <__divdi3+0x2d8>
   121a0:	e1520004 	cmp	r2, r4
   121a4:	824aa001 	subhi	sl, sl, #1	; 0x1
   121a8:	80844005 	addhi	r4, r4, r5
   121ac:	e0624004 	rsb	r4, r2, r4
   121b0:	e1a01007 	mov	r1, r7
   121b4:	e1a00004 	mov	r0, r4
   121b8:	ebfffbb8 	bl	110a0 <__aeabi_uidiv>
   121bc:	e1a01007 	mov	r1, r7
   121c0:	e1a06000 	mov	r6, r0
   121c4:	e1a00004 	mov	r0, r4
   121c8:	ebfffbf3 	bl	1119c <__aeabi_uidivmod>
   121cc:	e0000698 	mul	r0, r8, r6
   121d0:	e1a03809 	lsl	r3, r9, #16
   121d4:	e1a03823 	lsr	r3, r3, #16
   121d8:	e1832801 	orr	r2, r3, r1, lsl #16
   121dc:	e1500002 	cmp	r0, r2
   121e0:	9a000004 	bls	121f8 <__divdi3+0x324>
   121e4:	e0923005 	adds	r3, r2, r5
   121e8:	e2466001 	sub	r6, r6, #1	; 0x1
   121ec:	2a000001 	bcs	121f8 <__divdi3+0x324>
   121f0:	e1500003 	cmp	r0, r3
   121f4:	82466001 	subhi	r6, r6, #1	; 0x1
   121f8:	e186080a 	orr	r0, r6, sl, lsl #16
   121fc:	e1a0200b 	mov	r2, fp
   12200:	eaffff87 	b	12024 <__divdi3+0x150>
   12204:	e3500801 	cmp	r0, #65536	; 0x10000
   12208:	3a000021 	bcc	12294 <__divdi3+0x3c0>
   1220c:	e3500401 	cmp	r0, #16777216	; 0x1000000
   12210:	33a03010 	movcc	r3, #16	; 0x10
   12214:	23a03018 	movcs	r3, #24	; 0x18
   12218:	e1a01330 	lsr	r1, r0, r3
   1221c:	e59f2218 	ldr	r2, [pc, #536]	; 1243c <__divdi3+0x568>
   12220:	31a0c003 	movcc	ip, r3
   12224:	e7d23001 	ldrb	r3, [r2, r1]
   12228:	23a0c008 	movcs	ip, #8	; 0x8
   1222c:	e05ca003 	subs	sl, ip, r3
   12230:	1a000021 	bne	122bc <__divdi3+0x3e8>
   12234:	e1500006 	cmp	r0, r6
   12238:	21550009 	cmpcs	r5, r9
   1223c:	91a0200a 	movls	r2, sl
   12240:	93a00001 	movls	r0, #1	; 0x1
   12244:	9affff76 	bls	12024 <__divdi3+0x150>
   12248:	eaffff73 	b	1201c <__divdi3+0x148>
   1224c:	e2755000 	rsbs	r5, r5, #0	; 0x0
   12250:	e2e66000 	rsc	r6, r6, #0	; 0x0
   12254:	e3e00000 	mvn	r0, #0	; 0x0
   12258:	e3540000 	cmp	r4, #0	; 0x0
   1225c:	e58d0000 	str	r0, [sp]
   12260:	aaffff29 	bge	11f0c <__divdi3+0x38>
   12264:	e2731000 	rsbs	r1, r3, #0	; 0x0
   12268:	e2e42000 	rsc	r2, r4, #0	; 0x0
   1226c:	e59d3000 	ldr	r3, [sp]
   12270:	e1e03003 	mvn	r3, r3
   12274:	e58d3000 	str	r3, [sp]
   12278:	eaffff23 	b	11f0c <__divdi3+0x38>
   1227c:	e3550c01 	cmp	r5, #256	; 0x100
   12280:	33a00020 	movcc	r0, #32	; 0x20
   12284:	23a00018 	movcs	r0, #24	; 0x18
   12288:	33a03000 	movcc	r3, #0	; 0x0
   1228c:	23a03008 	movcs	r3, #8	; 0x8
   12290:	eaffff7b 	b	12084 <__divdi3+0x1b0>
   12294:	e3500c01 	cmp	r0, #256	; 0x100
   12298:	33a03000 	movcc	r3, #0	; 0x0
   1229c:	23a03008 	movcs	r3, #8	; 0x8
   122a0:	e1a01330 	lsr	r1, r0, r3
   122a4:	e59f2190 	ldr	r2, [pc, #400]	; 1243c <__divdi3+0x568>
   122a8:	e7d23001 	ldrb	r3, [r2, r1]
   122ac:	33a0c020 	movcc	ip, #32	; 0x20
   122b0:	23a0c018 	movcs	ip, #24	; 0x18
   122b4:	e05ca003 	subs	sl, ip, r3
   122b8:	0affffdd 	beq	12234 <__divdi3+0x360>
   122bc:	e26a2020 	rsb	r2, sl, #32	; 0x20
   122c0:	e1a03235 	lsr	r3, r5, r2
   122c4:	e1a04236 	lsr	r4, r6, r2
   122c8:	e1a02239 	lsr	r2, r9, r2
   122cc:	e1837a10 	orr	r7, r3, r0, lsl sl
   122d0:	e1822a16 	orr	r2, r2, r6, lsl sl
   122d4:	e1a08827 	lsr	r8, r7, #16
   122d8:	e1a01008 	mov	r1, r8
   122dc:	e1a00004 	mov	r0, r4
   122e0:	e58d200c 	str	r2, [sp, #12]
   122e4:	ebfffb6d 	bl	110a0 <__aeabi_uidiv>
   122e8:	e1a01008 	mov	r1, r8
   122ec:	e1a0b000 	mov	fp, r0
   122f0:	e1a00004 	mov	r0, r4
   122f4:	ebfffba8 	bl	1119c <__aeabi_uidivmod>
   122f8:	e1a05a15 	lsl	r5, r5, sl
   122fc:	e1a06807 	lsl	r6, r7, #16
   12300:	e1a06826 	lsr	r6, r6, #16
   12304:	e0020b96 	mul	r2, r6, fp
   12308:	e59d000c 	ldr	r0, [sp, #12]
   1230c:	e1a03820 	lsr	r3, r0, #16
   12310:	e1834801 	orr	r4, r3, r1, lsl #16
   12314:	e1520004 	cmp	r2, r4
   12318:	e58d5008 	str	r5, [sp, #8]
   1231c:	9a000002 	bls	1232c <__divdi3+0x458>
   12320:	e0944007 	adds	r4, r4, r7
   12324:	e24bb001 	sub	fp, fp, #1	; 0x1
   12328:	3a000037 	bcc	1240c <__divdi3+0x538>
   1232c:	e0624004 	rsb	r4, r2, r4
   12330:	e1a01008 	mov	r1, r8
   12334:	e1a00004 	mov	r0, r4
   12338:	ebfffb58 	bl	110a0 <__aeabi_uidiv>
   1233c:	e1a01008 	mov	r1, r8
   12340:	e1a05000 	mov	r5, r0
   12344:	e1a00004 	mov	r0, r4
   12348:	ebfffb93 	bl	1119c <__aeabi_uidivmod>
   1234c:	e0020596 	mul	r2, r6, r5
   12350:	e59d000c 	ldr	r0, [sp, #12]
   12354:	e1a03800 	lsl	r3, r0, #16
   12358:	e1a03823 	lsr	r3, r3, #16
   1235c:	e1830801 	orr	r0, r3, r1, lsl #16
   12360:	e1520000 	cmp	r2, r0
   12364:	9a000002 	bls	12374 <__divdi3+0x4a0>
   12368:	e0900007 	adds	r0, r0, r7
   1236c:	e2455001 	sub	r5, r5, #1	; 0x1
   12370:	3a000021 	bcc	123fc <__divdi3+0x528>
   12374:	e0622000 	rsb	r2, r2, r0
   12378:	e185080b 	orr	r0, r5, fp, lsl #16
   1237c:	e59d5008 	ldr	r5, [sp, #8]
   12380:	e1a0c820 	lsr	ip, r0, #16
   12384:	e1a03825 	lsr	r3, r5, #16
   12388:	e1c0e80c 	bic	lr, r0, ip, lsl #16
   1238c:	e1c54803 	bic	r4, r5, r3, lsl #16
   12390:	e001049e 	mul	r1, lr, r4
   12394:	e004049c 	mul	r4, ip, r4
   12398:	e00e0e93 	mul	lr, r3, lr
   1239c:	e003039c 	mul	r3, ip, r3
   123a0:	e094e00e 	adds	lr, r4, lr
   123a4:	22833801 	addcs	r3, r3, #65536	; 0x10000
   123a8:	e091180e 	adds	r1, r1, lr, lsl #16
   123ac:	e0a3382e 	adc	r3, r3, lr, lsr #16
   123b0:	e1520003 	cmp	r2, r3
   123b4:	3a000007 	bcc	123d8 <__divdi3+0x504>
   123b8:	13a03000 	movne	r3, #0	; 0x0
   123bc:	03a03001 	moveq	r3, #1	; 0x1
   123c0:	e1510a19 	cmp	r1, r9, lsl sl
   123c4:	93a03000 	movls	r3, #0	; 0x0
   123c8:	82033001 	andhi	r3, r3, #1	; 0x1
   123cc:	e3530000 	cmp	r3, #0	; 0x0
   123d0:	01a02003 	moveq	r2, r3
   123d4:	0affff12 	beq	12024 <__divdi3+0x150>
   123d8:	e2400001 	sub	r0, r0, #1	; 0x1
   123dc:	e3a02000 	mov	r2, #0	; 0x0
   123e0:	eaffff0f 	b	12024 <__divdi3+0x150>
   123e4:	e3510401 	cmp	r1, #16777216	; 0x1000000
   123e8:	33a03010 	movcc	r3, #16	; 0x10
   123ec:	23a03018 	movcs	r3, #24	; 0x18
   123f0:	23a00008 	movcs	r0, #8	; 0x8
   123f4:	31a00003 	movcc	r0, r3
   123f8:	eafffed1 	b	11f44 <__divdi3+0x70>
   123fc:	e1520000 	cmp	r2, r0
   12400:	80800007 	addhi	r0, r0, r7
   12404:	82455001 	subhi	r5, r5, #1	; 0x1
   12408:	eaffffd9 	b	12374 <__divdi3+0x4a0>
   1240c:	e1520004 	cmp	r2, r4
   12410:	824bb001 	subhi	fp, fp, #1	; 0x1
   12414:	80844007 	addhi	r4, r4, r7
   12418:	eaffffc3 	b	1232c <__divdi3+0x458>
   1241c:	e1540000 	cmp	r4, r0
   12420:	82466001 	subhi	r6, r6, #1	; 0x1
   12424:	80800005 	addhi	r0, r0, r5
   12428:	eaffff4a 	b	12158 <__divdi3+0x284>
   1242c:	e1520004 	cmp	r2, r4
   12430:	824bb001 	subhi	fp, fp, #1	; 0x1
   12434:	80844005 	addhi	r4, r4, r5
   12438:	eaffff34 	b	12110 <__divdi3+0x23c>
   1243c:	00013198 	.word	0x00013198

00012440 <__udivdi3>:
   12440:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12444:	e3530000 	cmp	r3, #0	; 0x0
   12448:	e1a06001 	mov	r6, r1
   1244c:	e24dd014 	sub	sp, sp, #20	; 0x14
   12450:	e1a0c003 	mov	ip, r3
   12454:	e1a01002 	mov	r1, r2
   12458:	e1a09000 	mov	r9, r0
   1245c:	e1a05002 	mov	r5, r2
   12460:	e1a04006 	mov	r4, r6
   12464:	1a00003c 	bne	1255c <__udivdi3+0x11c>
   12468:	e1520006 	cmp	r2, r6
   1246c:	9a000054 	bls	125c4 <__udivdi3+0x184>
   12470:	e3520801 	cmp	r2, #65536	; 0x10000
   12474:	3a000119 	bcc	128e0 <__udivdi3+0x4a0>
   12478:	e3520401 	cmp	r2, #16777216	; 0x1000000
   1247c:	33a03010 	movcc	r3, #16	; 0x10
   12480:	23a03018 	movcs	r3, #24	; 0x18
   12484:	23a00008 	movcs	r0, #8	; 0x8
   12488:	31a00003 	movcc	r0, r3
   1248c:	e1a01335 	lsr	r1, r5, r3
   12490:	e59f24a0 	ldr	r2, [pc, #1184]	; 12938 <__udivdi3+0x4f8>
   12494:	e7d23001 	ldrb	r3, [r2, r1]
   12498:	e0502003 	subs	r2, r0, r3
   1249c:	12623020 	rsbne	r3, r2, #32	; 0x20
   124a0:	11a03339 	lsrne	r3, r9, r3
   124a4:	11a05215 	lslne	r5, r5, r2
   124a8:	11834216 	orrne	r4, r3, r6, lsl r2
   124ac:	e1a08825 	lsr	r8, r5, #16
   124b0:	e1a01008 	mov	r1, r8
   124b4:	e1a00004 	mov	r0, r4
   124b8:	11a09219 	lslne	r9, r9, r2
   124bc:	ebfffaf7 	bl	110a0 <__aeabi_uidiv>
   124c0:	e1a01008 	mov	r1, r8
   124c4:	e1a0a000 	mov	sl, r0
   124c8:	e1a00004 	mov	r0, r4
   124cc:	ebfffb32 	bl	1119c <__aeabi_uidivmod>
   124d0:	e1a07805 	lsl	r7, r5, #16
   124d4:	e1a07827 	lsr	r7, r7, #16
   124d8:	e0020a97 	mul	r2, r7, sl
   124dc:	e1a03829 	lsr	r3, r9, #16
   124e0:	e1834801 	orr	r4, r3, r1, lsl #16
   124e4:	e1520004 	cmp	r2, r4
   124e8:	9a000005 	bls	12504 <__udivdi3+0xc4>
   124ec:	e0944005 	adds	r4, r4, r5
   124f0:	e24aa001 	sub	sl, sl, #1	; 0x1
   124f4:	2a000002 	bcs	12504 <__udivdi3+0xc4>
   124f8:	e1520004 	cmp	r2, r4
   124fc:	824aa001 	subhi	sl, sl, #1	; 0x1
   12500:	80844005 	addhi	r4, r4, r5
   12504:	e0624004 	rsb	r4, r2, r4
   12508:	e1a01008 	mov	r1, r8
   1250c:	e1a00004 	mov	r0, r4
   12510:	ebfffae2 	bl	110a0 <__aeabi_uidiv>
   12514:	e1a01008 	mov	r1, r8
   12518:	e1a06000 	mov	r6, r0
   1251c:	e1a00004 	mov	r0, r4
   12520:	ebfffb1d 	bl	1119c <__aeabi_uidivmod>
   12524:	e0020697 	mul	r2, r7, r6
   12528:	e1a03809 	lsl	r3, r9, #16
   1252c:	e1a03823 	lsr	r3, r3, #16
   12530:	e1830801 	orr	r0, r3, r1, lsl #16
   12534:	e1520000 	cmp	r2, r0
   12538:	9a000004 	bls	12550 <__udivdi3+0x110>
   1253c:	e0903005 	adds	r3, r0, r5
   12540:	e2466001 	sub	r6, r6, #1	; 0x1
   12544:	2a000001 	bcs	12550 <__udivdi3+0x110>
   12548:	e1520003 	cmp	r2, r3
   1254c:	82466001 	subhi	r6, r6, #1	; 0x1
   12550:	e186280a 	orr	r2, r6, sl, lsl #16
   12554:	e3a03000 	mov	r3, #0	; 0x0
   12558:	ea000014 	b	125b0 <__udivdi3+0x170>
   1255c:	e1530006 	cmp	r3, r6
   12560:	8a000010 	bhi	125a8 <__udivdi3+0x168>
   12564:	e3530801 	cmp	r3, #65536	; 0x10000
   12568:	3a000081 	bcc	12774 <__udivdi3+0x334>
   1256c:	e3530401 	cmp	r3, #16777216	; 0x1000000
   12570:	33a03010 	movcc	r3, #16	; 0x10
   12574:	23a03018 	movcs	r3, #24	; 0x18
   12578:	e1a0133c 	lsr	r1, ip, r3
   1257c:	e59f23b4 	ldr	r2, [pc, #948]	; 12938 <__udivdi3+0x4f8>
   12580:	31a00003 	movcc	r0, r3
   12584:	e7d23001 	ldrb	r3, [r2, r1]
   12588:	23a00008 	movcs	r0, #8	; 0x8
   1258c:	e050a003 	subs	sl, r0, r3
   12590:	1a000081 	bne	1279c <__udivdi3+0x35c>
   12594:	e15c0006 	cmp	ip, r6
   12598:	21550009 	cmpcs	r5, r9
   1259c:	91a0300a 	movls	r3, sl
   125a0:	93a02001 	movls	r2, #1	; 0x1
   125a4:	9a000001 	bls	125b0 <__udivdi3+0x170>
   125a8:	e3a02000 	mov	r2, #0	; 0x0
   125ac:	e1a03002 	mov	r3, r2
   125b0:	e1a00002 	mov	r0, r2
   125b4:	e1a01003 	mov	r1, r3
   125b8:	e28dd014 	add	sp, sp, #20	; 0x14
   125bc:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   125c0:	e12fff1e 	bx	lr
   125c4:	e3520000 	cmp	r2, #0	; 0x0
   125c8:	1a000002 	bne	125d8 <__udivdi3+0x198>
   125cc:	e3a00001 	mov	r0, #1	; 0x1
   125d0:	ebfffab2 	bl	110a0 <__aeabi_uidiv>
   125d4:	e1a05000 	mov	r5, r0
   125d8:	e3550801 	cmp	r5, #65536	; 0x10000
   125dc:	3a0000b9 	bcc	128c8 <__udivdi3+0x488>
   125e0:	e3550401 	cmp	r5, #16777216	; 0x1000000
   125e4:	33a03010 	movcc	r3, #16	; 0x10
   125e8:	23a03018 	movcs	r3, #24	; 0x18
   125ec:	23a00008 	movcs	r0, #8	; 0x8
   125f0:	31a00003 	movcc	r0, r3
   125f4:	e1a01335 	lsr	r1, r5, r3
   125f8:	e59f2338 	ldr	r2, [pc, #824]	; 12938 <__udivdi3+0x4f8>
   125fc:	e7d23001 	ldrb	r3, [r2, r1]
   12600:	e050a003 	subs	sl, r0, r3
   12604:	01a08805 	lsleq	r8, r5, #16
   12608:	00654006 	rsbeq	r4, r5, r6
   1260c:	01a08828 	lsreq	r8, r8, #16
   12610:	01a07825 	lsreq	r7, r5, #16
   12614:	03a0b001 	moveq	fp, #1	; 0x1
   12618:	0a00002d 	beq	126d4 <__udivdi3+0x294>
   1261c:	e26a3020 	rsb	r3, sl, #32	; 0x20
   12620:	e1a04336 	lsr	r4, r6, r3
   12624:	e1a03339 	lsr	r3, r9, r3
   12628:	e1a05a15 	lsl	r5, r5, sl
   1262c:	e1836a16 	orr	r6, r3, r6, lsl sl
   12630:	e1a07825 	lsr	r7, r5, #16
   12634:	e1a01007 	mov	r1, r7
   12638:	e1a00004 	mov	r0, r4
   1263c:	e58d6004 	str	r6, [sp, #4]
   12640:	ebfffa96 	bl	110a0 <__aeabi_uidiv>
   12644:	e1a01007 	mov	r1, r7
   12648:	e1a0b000 	mov	fp, r0
   1264c:	e1a00004 	mov	r0, r4
   12650:	ebfffad1 	bl	1119c <__aeabi_uidivmod>
   12654:	e1a08805 	lsl	r8, r5, #16
   12658:	e1a08828 	lsr	r8, r8, #16
   1265c:	e0020b98 	mul	r2, r8, fp
   12660:	e59d6004 	ldr	r6, [sp, #4]
   12664:	e1a03826 	lsr	r3, r6, #16
   12668:	e1834801 	orr	r4, r3, r1, lsl #16
   1266c:	e1520004 	cmp	r2, r4
   12670:	9a000002 	bls	12680 <__udivdi3+0x240>
   12674:	e0944005 	adds	r4, r4, r5
   12678:	e24bb001 	sub	fp, fp, #1	; 0x1
   1267c:	3a0000a9 	bcc	12928 <__udivdi3+0x4e8>
   12680:	e0624004 	rsb	r4, r2, r4
   12684:	e1a01007 	mov	r1, r7
   12688:	e1a00004 	mov	r0, r4
   1268c:	ebfffa83 	bl	110a0 <__aeabi_uidiv>
   12690:	e1a01007 	mov	r1, r7
   12694:	e1a06000 	mov	r6, r0
   12698:	e1a00004 	mov	r0, r4
   1269c:	ebfffabe 	bl	1119c <__aeabi_uidivmod>
   126a0:	e0040698 	mul	r4, r8, r6
   126a4:	e59d0004 	ldr	r0, [sp, #4]
   126a8:	e1a03800 	lsl	r3, r0, #16
   126ac:	e1a03823 	lsr	r3, r3, #16
   126b0:	e1830801 	orr	r0, r3, r1, lsl #16
   126b4:	e1540000 	cmp	r4, r0
   126b8:	9a000002 	bls	126c8 <__udivdi3+0x288>
   126bc:	e0900005 	adds	r0, r0, r5
   126c0:	e2466001 	sub	r6, r6, #1	; 0x1
   126c4:	3a000093 	bcc	12918 <__udivdi3+0x4d8>
   126c8:	e1a09a19 	lsl	r9, r9, sl
   126cc:	e0644000 	rsb	r4, r4, r0
   126d0:	e186b80b 	orr	fp, r6, fp, lsl #16
   126d4:	e1a01007 	mov	r1, r7
   126d8:	e1a00004 	mov	r0, r4
   126dc:	ebfffa6f 	bl	110a0 <__aeabi_uidiv>
   126e0:	e1a01007 	mov	r1, r7
   126e4:	e1a0a000 	mov	sl, r0
   126e8:	e1a00004 	mov	r0, r4
   126ec:	ebfffaaa 	bl	1119c <__aeabi_uidivmod>
   126f0:	e0020a98 	mul	r2, r8, sl
   126f4:	e1a03829 	lsr	r3, r9, #16
   126f8:	e1834801 	orr	r4, r3, r1, lsl #16
   126fc:	e1520004 	cmp	r2, r4
   12700:	9a000005 	bls	1271c <__udivdi3+0x2dc>
   12704:	e0944005 	adds	r4, r4, r5
   12708:	e24aa001 	sub	sl, sl, #1	; 0x1
   1270c:	2a000002 	bcs	1271c <__udivdi3+0x2dc>
   12710:	e1520004 	cmp	r2, r4
   12714:	824aa001 	subhi	sl, sl, #1	; 0x1
   12718:	80844005 	addhi	r4, r4, r5
   1271c:	e0624004 	rsb	r4, r2, r4
   12720:	e1a01007 	mov	r1, r7
   12724:	e1a00004 	mov	r0, r4
   12728:	ebfffa5c 	bl	110a0 <__aeabi_uidiv>
   1272c:	e1a01007 	mov	r1, r7
   12730:	e1a06000 	mov	r6, r0
   12734:	e1a00004 	mov	r0, r4
   12738:	ebfffa97 	bl	1119c <__aeabi_uidivmod>
   1273c:	e0020698 	mul	r2, r8, r6
   12740:	e1a03809 	lsl	r3, r9, #16
   12744:	e1a03823 	lsr	r3, r3, #16
   12748:	e1830801 	orr	r0, r3, r1, lsl #16
   1274c:	e1520000 	cmp	r2, r0
   12750:	9a000004 	bls	12768 <__udivdi3+0x328>
   12754:	e0903005 	adds	r3, r0, r5
   12758:	e2466001 	sub	r6, r6, #1	; 0x1
   1275c:	2a000001 	bcs	12768 <__udivdi3+0x328>
   12760:	e1520003 	cmp	r2, r3
   12764:	82466001 	subhi	r6, r6, #1	; 0x1
   12768:	e186280a 	orr	r2, r6, sl, lsl #16
   1276c:	e1a0300b 	mov	r3, fp
   12770:	eaffff8e 	b	125b0 <__udivdi3+0x170>
   12774:	e3530c01 	cmp	r3, #256	; 0x100
   12778:	33a03000 	movcc	r3, #0	; 0x0
   1277c:	23a03008 	movcs	r3, #8	; 0x8
   12780:	e1a0133c 	lsr	r1, ip, r3
   12784:	e59f21ac 	ldr	r2, [pc, #428]	; 12938 <__udivdi3+0x4f8>
   12788:	e7d23001 	ldrb	r3, [r2, r1]
   1278c:	33a00020 	movcc	r0, #32	; 0x20
   12790:	23a00018 	movcs	r0, #24	; 0x18
   12794:	e050a003 	subs	sl, r0, r3
   12798:	0affff7d 	beq	12594 <__udivdi3+0x154>
   1279c:	e26a2020 	rsb	r2, sl, #32	; 0x20
   127a0:	e1a03235 	lsr	r3, r5, r2
   127a4:	e1a04236 	lsr	r4, r6, r2
   127a8:	e1a02239 	lsr	r2, r9, r2
   127ac:	e1837a1c 	orr	r7, r3, ip, lsl sl
   127b0:	e1826a16 	orr	r6, r2, r6, lsl sl
   127b4:	e1a08827 	lsr	r8, r7, #16
   127b8:	e1a01008 	mov	r1, r8
   127bc:	e1a00004 	mov	r0, r4
   127c0:	e58d600c 	str	r6, [sp, #12]
   127c4:	ebfffa35 	bl	110a0 <__aeabi_uidiv>
   127c8:	e1a01008 	mov	r1, r8
   127cc:	e1a0b000 	mov	fp, r0
   127d0:	e1a00004 	mov	r0, r4
   127d4:	ebfffa70 	bl	1119c <__aeabi_uidivmod>
   127d8:	e1a05a15 	lsl	r5, r5, sl
   127dc:	e1a06807 	lsl	r6, r7, #16
   127e0:	e1a06826 	lsr	r6, r6, #16
   127e4:	e0020b96 	mul	r2, r6, fp
   127e8:	e59d000c 	ldr	r0, [sp, #12]
   127ec:	e1a03820 	lsr	r3, r0, #16
   127f0:	e1834801 	orr	r4, r3, r1, lsl #16
   127f4:	e1520004 	cmp	r2, r4
   127f8:	e58d5008 	str	r5, [sp, #8]
   127fc:	9a000002 	bls	1280c <__udivdi3+0x3cc>
   12800:	e0944007 	adds	r4, r4, r7
   12804:	e24bb001 	sub	fp, fp, #1	; 0x1
   12808:	3a00003e 	bcc	12908 <__udivdi3+0x4c8>
   1280c:	e0624004 	rsb	r4, r2, r4
   12810:	e1a01008 	mov	r1, r8
   12814:	e1a00004 	mov	r0, r4
   12818:	ebfffa20 	bl	110a0 <__aeabi_uidiv>
   1281c:	e1a01008 	mov	r1, r8
   12820:	e1a05000 	mov	r5, r0
   12824:	e1a00004 	mov	r0, r4
   12828:	ebfffa5b 	bl	1119c <__aeabi_uidivmod>
   1282c:	e0020596 	mul	r2, r6, r5
   12830:	e59d000c 	ldr	r0, [sp, #12]
   12834:	e1a03800 	lsl	r3, r0, #16
   12838:	e1a03823 	lsr	r3, r3, #16
   1283c:	e1830801 	orr	r0, r3, r1, lsl #16
   12840:	e1520000 	cmp	r2, r0
   12844:	9a000002 	bls	12854 <__udivdi3+0x414>
   12848:	e0900007 	adds	r0, r0, r7
   1284c:	e2455001 	sub	r5, r5, #1	; 0x1
   12850:	3a000028 	bcc	128f8 <__udivdi3+0x4b8>
   12854:	e0622000 	rsb	r2, r2, r0
   12858:	e185080b 	orr	r0, r5, fp, lsl #16
   1285c:	e59d5008 	ldr	r5, [sp, #8]
   12860:	e1a0c820 	lsr	ip, r0, #16
   12864:	e1a03825 	lsr	r3, r5, #16
   12868:	e1c0e80c 	bic	lr, r0, ip, lsl #16
   1286c:	e1c54803 	bic	r4, r5, r3, lsl #16
   12870:	e001049e 	mul	r1, lr, r4
   12874:	e004049c 	mul	r4, ip, r4
   12878:	e00e0e93 	mul	lr, r3, lr
   1287c:	e003039c 	mul	r3, ip, r3
   12880:	e094e00e 	adds	lr, r4, lr
   12884:	22833801 	addcs	r3, r3, #65536	; 0x10000
   12888:	e091180e 	adds	r1, r1, lr, lsl #16
   1288c:	e0a3382e 	adc	r3, r3, lr, lsr #16
   12890:	e1520003 	cmp	r2, r3
   12894:	3a000008 	bcc	128bc <__udivdi3+0x47c>
   12898:	13a03000 	movne	r3, #0	; 0x0
   1289c:	03a03001 	moveq	r3, #1	; 0x1
   128a0:	e1510a19 	cmp	r1, r9, lsl sl
   128a4:	93a01000 	movls	r1, #0	; 0x0
   128a8:	82031001 	andhi	r1, r3, #1	; 0x1
   128ac:	e3510000 	cmp	r1, #0	; 0x0
   128b0:	01a02000 	moveq	r2, r0
   128b4:	01a03001 	moveq	r3, r1
   128b8:	0affff3c 	beq	125b0 <__udivdi3+0x170>
   128bc:	e2402001 	sub	r2, r0, #1	; 0x1
   128c0:	e3a03000 	mov	r3, #0	; 0x0
   128c4:	eaffff39 	b	125b0 <__udivdi3+0x170>
   128c8:	e3550c01 	cmp	r5, #256	; 0x100
   128cc:	33a00020 	movcc	r0, #32	; 0x20
   128d0:	23a00018 	movcs	r0, #24	; 0x18
   128d4:	33a03000 	movcc	r3, #0	; 0x0
   128d8:	23a03008 	movcs	r3, #8	; 0x8
   128dc:	eaffff44 	b	125f4 <__udivdi3+0x1b4>
   128e0:	e3520c01 	cmp	r2, #256	; 0x100
   128e4:	33a00020 	movcc	r0, #32	; 0x20
   128e8:	23a00018 	movcs	r0, #24	; 0x18
   128ec:	33a03000 	movcc	r3, #0	; 0x0
   128f0:	23a03008 	movcs	r3, #8	; 0x8
   128f4:	eafffee4 	b	1248c <__udivdi3+0x4c>
   128f8:	e1520000 	cmp	r2, r0
   128fc:	80800007 	addhi	r0, r0, r7
   12900:	82455001 	subhi	r5, r5, #1	; 0x1
   12904:	eaffffd2 	b	12854 <__udivdi3+0x414>
   12908:	e1520004 	cmp	r2, r4
   1290c:	824bb001 	subhi	fp, fp, #1	; 0x1
   12910:	80844007 	addhi	r4, r4, r7
   12914:	eaffffbc 	b	1280c <__udivdi3+0x3cc>
   12918:	e1540000 	cmp	r4, r0
   1291c:	82466001 	subhi	r6, r6, #1	; 0x1
   12920:	80800005 	addhi	r0, r0, r5
   12924:	eaffff67 	b	126c8 <__udivdi3+0x288>
   12928:	e1520004 	cmp	r2, r4
   1292c:	824bb001 	subhi	fp, fp, #1	; 0x1
   12930:	80844005 	addhi	r4, r4, r5
   12934:	eaffff51 	b	12680 <__udivdi3+0x240>
   12938:	00013198 	.word	0x00013198
